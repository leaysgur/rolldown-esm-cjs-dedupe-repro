import { a as __toESM, i as __require, t as __commonJSMin } from "./chunk-BdzVc5A2.js";
import { i as format2, l as init_prettier } from "./prettier-CGhNvo7x.js";

//#region node_modules/prettier/plugins/babel.js
var require_babel = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	(function(f) {
		function e() {
			var i = f();
			return i.default || i;
		}
		if (typeof exports == "object" && typeof module == "object") module.exports = e();
		else if (typeof define == "function" && define.amd) define(e);
		else {
			var t = typeof globalThis < "u" ? globalThis : typeof global < "u" ? global : typeof self < "u" ? self : this || {};
			t.prettierPlugins = t.prettierPlugins || {}, t.prettierPlugins.babel = e();
		}
	})(function() {
		"use strict";
		var Re = Object.defineProperty;
		var Hs = Object.getOwnPropertyDescriptor;
		var Ws = Object.getOwnPropertyNames;
		var Js = Object.prototype.hasOwnProperty;
		var Ue = (a, t) => {
			for (var e in t) Re(a, e, {
				get: t[e],
				enumerable: !0
			});
		}, Gs = (a, t, e, s) => {
			if (t && typeof t == "object" || typeof t == "function") for (let i of Ws(t)) !Js.call(a, i) && i !== e && Re(a, i, {
				get: () => t[i],
				enumerable: !(s = Hs(t, i)) || s.enumerable
			});
			return a;
		};
		var Xs = (a) => Gs(Re({}, "__esModule", { value: !0 }), a);
		var ca = {};
		Ue(ca, { parsers: () => ha });
		var vt = {};
		Ue(vt, {
			__babel_estree: () => ta,
			__js_expression: () => Zr,
			__ts_expression: () => ea,
			__vue_event_binding: () => Yr,
			__vue_expression: () => Zr,
			__vue_ts_event_binding: () => Qr,
			__vue_ts_expression: () => ea,
			babel: () => Yr,
			"babel-flow": () => $s,
			"babel-ts": () => Qr
		});
		function Ys(a, t) {
			if (a == null) return {};
			var e = {};
			for (var s in a) if ({}.hasOwnProperty.call(a, s)) {
				if (t.indexOf(s) !== -1) continue;
				e[s] = a[s];
			}
			return e;
		}
		var R = class {
			line;
			column;
			index;
			constructor(t, e, s) {
				this.line = t, this.column = e, this.index = s;
			}
		}, Q = class {
			start;
			end;
			filename;
			identifierName;
			constructor(t, e) {
				this.start = t, this.end = e;
			}
		};
		function D(a, t) {
			let { line: e, column: s, index: i } = a;
			return new R(e, s + t, i + t);
		}
		var Mt = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED", Qs = {
			ImportMetaOutsideModule: {
				message: `import.meta may appear only with 'sourceType: "module"'`,
				code: Mt
			},
			ImportOutsideModule: {
				message: `'import' and 'export' may appear only with 'sourceType: "module"'`,
				code: Mt
			}
		}, Ot = {
			ArrayPattern: "array destructuring pattern",
			AssignmentExpression: "assignment expression",
			AssignmentPattern: "assignment expression",
			ArrowFunctionExpression: "arrow function expression",
			ConditionalExpression: "conditional expression",
			CatchClause: "catch clause",
			ForOfStatement: "for-of statement",
			ForInStatement: "for-in statement",
			ForStatement: "for-loop",
			FormalParameters: "function parameter list",
			Identifier: "identifier",
			ImportSpecifier: "import specifier",
			ImportDefaultSpecifier: "import default specifier",
			ImportNamespaceSpecifier: "import namespace specifier",
			ObjectPattern: "object destructuring pattern",
			ParenthesizedExpression: "parenthesized expression",
			RestElement: "rest element",
			UpdateExpression: {
				true: "prefix operation",
				false: "postfix operation"
			},
			VariableDeclarator: "variable declaration",
			YieldExpression: "yield expression"
		}, be = (a) => a.type === "UpdateExpression" ? Ot.UpdateExpression[`${a.prefix}`] : Ot[a.type], Zs = {
			AccessorIsGenerator: ({ kind: a }) => `A ${a}ter cannot be a generator.`,
			ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
			AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
			AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
			AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
			AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
			AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.",
			AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
			BadGetterArity: "A 'get' accessor must not have any formal parameters.",
			BadSetterArity: "A 'set' accessor must have exactly one formal parameter.",
			BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.",
			ConstructorClassField: "Classes may not have a field named 'constructor'.",
			ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
			ConstructorIsAccessor: "Class constructor may not be an accessor.",
			ConstructorIsAsync: "Constructor can't be an async function.",
			ConstructorIsGenerator: "Constructor can't be a generator.",
			DeclarationMissingInitializer: ({ kind: a }) => `Missing initializer in ${a} declaration.`,
			DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.",
			DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.",
			DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.",
			DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
			DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.",
			DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
			DecoratorStaticBlock: "Decorators can't be used with a static block.",
			DeferImportRequiresNamespace: "Only `import defer * as x from \"./module\"` is valid.",
			DeletePrivateField: "Deleting a private field is not allowed.",
			DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
			DuplicateConstructor: "Duplicate constructor in the same class.",
			DuplicateDefaultExport: "Only one default export allowed per module.",
			DuplicateExport: ({ exportName: a }) => `\`${a}\` has already been exported. Exported identifiers must be unique.`,
			DuplicateProto: "Redefinition of __proto__ property.",
			DuplicateRegExpFlags: "Duplicate regular expression flag.",
			ElementAfterRest: "Rest element must be last element.",
			EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
			ExportBindingIsString: ({ localName: a, exportName: t }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${a}' as '${t}' } from 'some-module'\`?`,
			ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
			ForInOfLoopInitializer: ({ type: a }) => `'${a === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`,
			ForInUsing: "For-in loop may not start with 'using' declaration.",
			ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
			ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
			GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
			IllegalBreakContinue: ({ type: a }) => `Unsyntactic ${a === "BreakStatement" ? "break" : "continue"}.`,
			IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
			IllegalReturn: "'return' outside of function.",
			ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedImportAssert` parser plugin to suppress this error.",
			ImportBindingIsString: ({ importName: a }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${a}" as foo }\`?`,
			ImportCallArity: "`import()` requires exactly one or two arguments.",
			ImportCallNotNewExpression: "Cannot use new with import(...).",
			ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
			ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.",
			ImportReflectionHasAssertion: "`import module x` cannot have assertions.",
			ImportReflectionNotBinding: "Only `import module x from \"./module\"` is valid.",
			IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
			InvalidBigIntLiteral: "Invalid BigIntLiteral.",
			InvalidCodePoint: "Code point out of bounds.",
			InvalidCoverDiscardElement: "'void' must be followed by an expression when not used in a binding position.",
			InvalidCoverInitializedName: "Invalid shorthand property initializer.",
			InvalidDecimal: "Invalid decimal.",
			InvalidDigit: ({ radix: a }) => `Expected number in radix ${a}.`,
			InvalidEscapeSequence: "Bad character escape sequence.",
			InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
			InvalidEscapedReservedWord: ({ reservedWord: a }) => `Escape sequence in keyword ${a}.`,
			InvalidIdentifier: ({ identifierName: a }) => `Invalid identifier ${a}.`,
			InvalidLhs: ({ ancestor: a }) => `Invalid left-hand side in ${be(a)}.`,
			InvalidLhsBinding: ({ ancestor: a }) => `Binding invalid left-hand side in ${be(a)}.`,
			InvalidLhsOptionalChaining: ({ ancestor: a }) => `Invalid optional chaining in the left-hand side of ${be(a)}.`,
			InvalidNumber: "Invalid number.",
			InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
			InvalidOrUnexpectedToken: ({ unexpected: a }) => `Unexpected character '${a}'.`,
			InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
			InvalidPrivateFieldResolution: ({ identifierName: a }) => `Private name #${a} is not defined.`,
			InvalidPropertyBindingPattern: "Binding member expression.",
			InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
			InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
			LabelRedeclaration: ({ labelName: a }) => `Label '${a}' is already declared.`,
			LetInLexicalBinding: "'let' is disallowed as a lexically bound name.",
			LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
			MalformedRegExpFlags: "Invalid regular expression flag.",
			MissingClassName: "A class name is required.",
			MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
			MissingSemicolon: "Missing semicolon.",
			MissingPlugin: ({ missingPlugin: a }) => `This experimental syntax requires enabling the parser plugin: ${a.map((t) => JSON.stringify(t)).join(", ")}.`,
			MissingOneOfPlugins: ({ missingPlugin: a }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${a.map((t) => JSON.stringify(t)).join(", ")}.`,
			MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
			MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
			ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
			ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
			ModuleAttributesWithDuplicateKeys: ({ key: a }) => `Duplicate key "${a}" is not allowed in module attributes.`,
			ModuleExportNameHasLoneSurrogate: ({ surrogateCharCode: a }) => `An export name cannot include a lone surrogate, found '\\u${a.toString(16)}'.`,
			ModuleExportUndefined: ({ localName: a }) => `Export '${a}' is not defined.`,
			MultipleDefaultsInSwitch: "Multiple default clauses.",
			NewlineAfterThrow: "Illegal newline after throw.",
			NoCatchOrFinally: "Missing catch or finally clause.",
			NumberIdentifier: "Identifier directly after number.",
			NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
			ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
			OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
			OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
			OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
			ParamDupe: "Argument name clash.",
			PatternHasAccessor: "Object pattern can't contain getter or setter.",
			PatternHasMethod: "Object pattern can't contain methods.",
			PrivateInExpectedIn: ({ identifierName: a }) => `Private names are only allowed in property accesses (\`obj.#${a}\`) or in \`in\` expressions (\`#${a} in obj\`).`,
			PrivateNameRedeclaration: ({ identifierName: a }) => `Duplicate private name #${a}.`,
			RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
			RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
			RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
			RecordNoProto: "'__proto__' is not allowed in Record expressions.",
			RestTrailingComma: "Unexpected trailing comma after rest element.",
			SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.",
			SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.",
			SourcePhaseImportRequiresDefault: "Only `import source x from \"./module\"` is valid.",
			StaticPrototype: "Classes may not have static property named prototype.",
			SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
			SuperPrivateField: "Private fields can't be accessed on super.",
			TrailingDecorator: "Decorators must be attached to a class element.",
			TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
			TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
			TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
			UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
			UnexpectedAwaitAfterPipelineBody: "Unexpected \"await\" after pipeline body; await must have parentheses in minimal proposal.",
			UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
			UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
			UnexpectedKeyword: ({ keyword: a }) => `Unexpected keyword '${a}'.`,
			UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
			UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
			UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
			UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
			UnexpectedPrivateField: "Unexpected private name.",
			UnexpectedReservedWord: ({ reservedWord: a }) => `Unexpected reserved word '${a}'.`,
			UnexpectedSuper: "'super' is only allowed in object methods and classes.",
			UnexpectedToken: ({ expected: a, unexpected: t }) => `Unexpected token${t ? ` '${t}'.` : ""}${a ? `, expected "${a}"` : ""}`,
			UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
			UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script` or in the bare case statement.",
			UnexpectedVoidPattern: "Unexpected void binding.",
			UnsupportedBind: "Binding should be performed on object property.",
			UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
			UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
			UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
			UnsupportedMetaProperty: ({ target: a, onlyValidPropertyName: t }) => `The only valid meta property for ${a} is ${a}.${t}.`,
			UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
			UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
			UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
			UnterminatedComment: "Unterminated comment.",
			UnterminatedRegExp: "Unterminated regular expression.",
			UnterminatedString: "Unterminated string constant.",
			UnterminatedTemplate: "Unterminated template.",
			UsingDeclarationExport: "Using declaration cannot be exported.",
			UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.",
			VarRedeclaration: ({ identifierName: a }) => `Identifier '${a}' has already been declared.`,
			VoidPatternCatchClauseParam: "A void binding can not be the catch clause parameter. Use `try { ... } catch { ... }` if you want to discard the caught error.",
			VoidPatternInitializer: "A void binding may not have an initializer.",
			YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
			YieldInParameter: "Yield expression is not allowed in formal parameters.",
			YieldNotInGeneratorFunction: "'yield' is only allowed within generator functions.",
			ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
		}, ei = {
			StrictDelete: "Deleting local variable in strict mode.",
			StrictEvalArguments: ({ referenceName: a }) => `Assigning to '${a}' in strict mode.`,
			StrictEvalArgumentsBinding: ({ bindingName: a }) => `Binding '${a}' in strict mode.`,
			StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
			StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
			StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
			StrictWith: "'with' in strict mode."
		}, ti = {
			ParseExpressionEmptyInput: "Unexpected parseExpression() input: The input is empty or contains only comments.",
			ParseExpressionExpectsEOF: ({ unexpected: a }) => `Unexpected parseExpression() input: The input should contain exactly one expression, but the first expression is followed by the unexpected character \`${String.fromCodePoint(a)}\`.`
		}, si = new Set([
			"ArrowFunctionExpression",
			"AssignmentExpression",
			"ConditionalExpression",
			"YieldExpression"
		]), ii = Object.assign({
			PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.",
			PipeTopicRequiresHackPipes: "Topic references are only supported when using the `\"proposal\": \"hack\"` version of the pipeline proposal.",
			PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
			PipeTopicUnconfiguredToken: ({ token: a }) => `Invalid topic token ${a}. In order to use ${a} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${a}" }.`,
			PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
			PipeUnparenthesizedBody: ({ type: a }) => `Hack-style pipe body cannot be an unparenthesized ${be({ type: a })}; please wrap it in parentheses.`
		}, {}), ri = ["message"];
		function Ft(a, t, e) {
			Object.defineProperty(a, t, {
				enumerable: !1,
				configurable: !0,
				value: e
			});
		}
		function ai({ toMessage: a, code: t, reasonCode: e, syntaxPlugin: s }) {
			let i = e === "MissingPlugin" || e === "MissingOneOfPlugins";
			return function r(n, o) {
				let h = /* @__PURE__ */ new SyntaxError();
				return h.code = t, h.reasonCode = e, h.loc = n, h.pos = n.index, h.syntaxPlugin = s, i && (h.missingPlugin = o.missingPlugin), Ft(h, "clone", function(u = {}) {
					let { line: f, column: d, index: x } = u.loc ?? n;
					return r(new R(f, d, x), Object.assign({}, o, u.details));
				}), Ft(h, "details", o), Object.defineProperty(h, "message", {
					configurable: !0,
					get() {
						let l = `${a(o)} (${n.line}:${n.column})`;
						return this.message = l, l;
					},
					set(l) {
						Object.defineProperty(this, "message", {
							value: l,
							writable: !0
						});
					}
				}), h;
			};
		}
		function F(a, t) {
			if (Array.isArray(a)) return (s) => F(s, a[0]);
			let e = {};
			for (let s of Object.keys(a)) {
				let i = a[s], r = typeof i == "string" ? { message: () => i } : typeof i == "function" ? { message: i } : i, { message: n } = r, o = Ys(r, ri), h = typeof n == "string" ? () => n : n;
				e[s] = ai(Object.assign({
					code: "BABEL_PARSER_SYNTAX_ERROR",
					reasonCode: s,
					toMessage: h
				}, t ? { syntaxPlugin: t } : {}, o));
			}
			return e;
		}
		var p = Object.assign({}, F(Qs), F(Zs), F(ei), F(ti), F`pipelineOperator`(ii));
		function ni() {
			return {
				sourceType: "script",
				sourceFilename: void 0,
				startIndex: 0,
				startColumn: 0,
				startLine: 1,
				allowAwaitOutsideFunction: !1,
				allowReturnOutsideFunction: !1,
				allowNewTargetOutsideFunction: !1,
				allowImportExportEverywhere: !1,
				allowSuperOutsideMethod: !1,
				allowUndeclaredExports: !1,
				allowYieldOutsideFunction: !1,
				plugins: [],
				strictMode: void 0,
				ranges: !1,
				tokens: !1,
				createImportExpressions: !0,
				createParenthesizedExpressions: !1,
				errorRecovery: !1,
				attachComment: !0,
				annexB: !0
			};
		}
		function oi(a) {
			let t = ni();
			if (a == null) return t;
			if (a.annexB != null && a.annexB !== !1) throw new Error("The `annexB` option can only be set to `false`.");
			for (let e of Object.keys(t)) a[e] != null && (t[e] = a[e]);
			if (t.startLine === 1) a.startIndex == null && t.startColumn > 0 ? t.startIndex = t.startColumn : a.startColumn == null && t.startIndex > 0 && (t.startColumn = t.startIndex);
			else if (a.startColumn == null || a.startIndex == null) throw new Error("With a `startLine > 1` you must also specify `startIndex` and `startColumn`.");
			if (t.sourceType === "commonjs") {
				if (a.allowAwaitOutsideFunction != null) throw new Error("The `allowAwaitOutsideFunction` option cannot be used with `sourceType: 'commonjs'`.");
				if (a.allowReturnOutsideFunction != null) throw new Error("`sourceType: 'commonjs'` implies `allowReturnOutsideFunction: true`, please remove the `allowReturnOutsideFunction` option or use `sourceType: 'script'`.");
				if (a.allowNewTargetOutsideFunction != null) throw new Error("`sourceType: 'commonjs'` implies `allowNewTargetOutsideFunction: true`, please remove the `allowNewTargetOutsideFunction` option or use `sourceType: 'script'`.");
			}
			return t;
		}
		var { defineProperty: hi } = Object, Bt = (a, t) => {
			a && hi(a, t, {
				enumerable: !1,
				value: a[t]
			});
		};
		function ne(a) {
			return Bt(a.loc.start, "index"), Bt(a.loc.end, "index"), a;
		}
		var ci = (a) => class extends a {
			parse() {
				let e = ne(super.parse());
				return this.optionFlags & 256 && (e.tokens = e.tokens.map(ne)), e;
			}
			parseRegExpLiteral({ pattern: e, flags: s }) {
				let i = null;
				try {
					i = new RegExp(e, s);
				} catch {}
				let r = this.estreeParseLiteral(i);
				return r.regex = {
					pattern: e,
					flags: s
				}, r;
			}
			parseBigIntLiteral(e) {
				let s;
				try {
					s = BigInt(e);
				} catch {
					s = null;
				}
				let i = this.estreeParseLiteral(s);
				return i.bigint = String(i.value || e), i;
			}
			parseDecimalLiteral(e) {
				let i = this.estreeParseLiteral(null);
				return i.decimal = String(i.value || e), i;
			}
			estreeParseLiteral(e) {
				return this.parseLiteral(e, "Literal");
			}
			parseStringLiteral(e) {
				return this.estreeParseLiteral(e);
			}
			parseNumericLiteral(e) {
				return this.estreeParseLiteral(e);
			}
			parseNullLiteral() {
				return this.estreeParseLiteral(null);
			}
			parseBooleanLiteral(e) {
				return this.estreeParseLiteral(e);
			}
			estreeParseChainExpression(e, s) {
				let i = this.startNodeAtNode(e);
				return i.expression = e, this.finishNodeAt(i, "ChainExpression", s);
			}
			directiveToStmt(e) {
				let s = e.value;
				delete e.value, this.castNodeTo(s, "Literal"), s.raw = s.extra.raw, s.value = s.extra.expressionValue;
				let i = this.castNodeTo(e, "ExpressionStatement");
				return i.expression = s, i.directive = s.extra.rawValue, delete s.extra, i;
			}
			fillOptionalPropertiesForTSESLint(e) {}
			cloneEstreeStringLiteral(e) {
				let { start: s, end: i, loc: r, range: n, raw: o, value: h } = e, l = Object.create(e.constructor.prototype);
				return l.type = "Literal", l.start = s, l.end = i, l.loc = r, l.range = n, l.raw = o, l.value = h, l;
			}
			initFunction(e, s) {
				super.initFunction(e, s), e.expression = !1;
			}
			checkDeclaration(e) {
				e != null && this.isObjectProperty(e) ? this.checkDeclaration(e.value) : super.checkDeclaration(e);
			}
			getObjectOrClassMethodParams(e) {
				return e.value.params;
			}
			isValidDirective(e) {
				return e.type === "ExpressionStatement" && e.expression.type === "Literal" && typeof e.expression.value == "string" && !e.expression.extra?.parenthesized;
			}
			parseBlockBody(e, s, i, r, n) {
				super.parseBlockBody(e, s, i, r, n);
				e.body = e.directives.map((h) => this.directiveToStmt(h)).concat(e.body), delete e.directives;
			}
			parsePrivateName() {
				let e = super.parsePrivateName();
				return this.convertPrivateNameToPrivateIdentifier(e);
			}
			convertPrivateNameToPrivateIdentifier(e) {
				let s = super.getPrivateNameSV(e);
				return delete e.id, e.name = s, this.castNodeTo(e, "PrivateIdentifier");
			}
			isPrivateName(e) {
				return e.type === "PrivateIdentifier";
			}
			getPrivateNameSV(e) {
				return e.name;
			}
			parseLiteral(e, s) {
				let i = super.parseLiteral(e, s);
				return i.raw = i.extra.raw, delete i.extra, i;
			}
			parseFunctionBody(e, s, i = !1) {
				super.parseFunctionBody(e, s, i), e.expression = e.body.type !== "BlockStatement";
			}
			parseMethod(e, s, i, r, n, o, h = !1) {
				let l = this.startNode();
				l.kind = e.kind, l = super.parseMethod(l, s, i, r, n, o, h), delete l.kind;
				let { typeParameters: u } = e;
				u && (delete e.typeParameters, l.typeParameters = u, this.resetStartLocationFromNode(l, u));
				return e.value = this.castNodeTo(l, this.hasPlugin("typescript") && !l.body ? "TSEmptyBodyFunctionExpression" : "FunctionExpression"), o === "ClassPrivateMethod" && (e.computed = !1), this.hasPlugin("typescript") && e.abstract ? (delete e.abstract, this.finishNode(e, "TSAbstractMethodDefinition")) : o === "ObjectMethod" ? (e.kind === "method" && (e.kind = "init"), e.shorthand = !1, this.finishNode(e, "Property")) : this.finishNode(e, "MethodDefinition");
			}
			nameIsConstructor(e) {
				return e.type === "Literal" ? e.value === "constructor" : super.nameIsConstructor(e);
			}
			parseClassProperty(...e) {
				let s = super.parseClassProperty(...e);
				return s.abstract && this.hasPlugin("typescript") ? (delete s.abstract, this.castNodeTo(s, "TSAbstractPropertyDefinition")) : this.castNodeTo(s, "PropertyDefinition"), s;
			}
			parseClassPrivateProperty(...e) {
				let s = super.parseClassPrivateProperty(...e);
				return s.abstract && this.hasPlugin("typescript") ? this.castNodeTo(s, "TSAbstractPropertyDefinition") : this.castNodeTo(s, "PropertyDefinition"), s.computed = !1, s;
			}
			parseClassAccessorProperty(e) {
				let s = super.parseClassAccessorProperty(e);
				return s.abstract && this.hasPlugin("typescript") ? (delete s.abstract, this.castNodeTo(s, "TSAbstractAccessorProperty")) : this.castNodeTo(s, "AccessorProperty"), s;
			}
			parseObjectProperty(e, s, i, r) {
				let n = super.parseObjectProperty(e, s, i, r);
				return n && (n.kind = "init", this.castNodeTo(n, "Property")), n;
			}
			finishObjectProperty(e) {
				return e.kind = "init", this.finishNode(e, "Property");
			}
			isValidLVal(e, s, i, r) {
				return e === "Property" ? "value" : super.isValidLVal(e, s, i, r);
			}
			isAssignable(e, s) {
				return e != null && this.isObjectProperty(e) ? this.isAssignable(e.value, s) : super.isAssignable(e, s);
			}
			toAssignable(e, s = !1) {
				if (e != null && this.isObjectProperty(e)) {
					let { key: i, value: r } = e;
					this.isPrivateName(i) && this.classScope.usePrivateName(this.getPrivateNameSV(i), i.loc.start), this.toAssignable(r, s);
				} else super.toAssignable(e, s);
			}
			toAssignableObjectExpressionProp(e, s, i) {
				e.type === "Property" && (e.kind === "get" || e.kind === "set") ? this.raise(p.PatternHasAccessor, e.key) : e.type === "Property" && e.method ? this.raise(p.PatternHasMethod, e.key) : super.toAssignableObjectExpressionProp(e, s, i);
			}
			finishCallExpression(e, s) {
				let i = super.finishCallExpression(e, s);
				return i.callee.type === "Import" ? (this.castNodeTo(i, "ImportExpression"), i.source = i.arguments[0], i.options = i.arguments[1] ?? null, delete i.arguments, delete i.callee) : i.type === "OptionalCallExpression" ? this.castNodeTo(i, "CallExpression") : i.optional = !1, i;
			}
			toReferencedArguments(e) {
				e.type !== "ImportExpression" && super.toReferencedArguments(e);
			}
			parseExport(e, s) {
				let i = this.state.lastTokStartLoc, r = super.parseExport(e, s);
				switch (r.type) {
					case "ExportAllDeclaration":
						r.exported = null;
						break;
					case "ExportNamedDeclaration": r.specifiers.length === 1 && r.specifiers[0].type === "ExportNamespaceSpecifier" && (this.castNodeTo(r, "ExportAllDeclaration"), r.exported = r.specifiers[0].exported, delete r.specifiers);
					case "ExportDefaultDeclaration":
						{
							let { declaration: n } = r;
							n?.type === "ClassDeclaration" && n.decorators?.length > 0 && n.start === r.start && this.resetStartLocation(r, i);
						}
						break;
				}
				return r;
			}
			stopParseSubscript(e, s) {
				let i = super.stopParseSubscript(e, s);
				return s.optionalChainMember ? this.estreeParseChainExpression(i, e.loc.end) : i;
			}
			parseMember(e, s, i, r, n) {
				let o = super.parseMember(e, s, i, r, n);
				return o.type === "OptionalMemberExpression" ? this.castNodeTo(o, "MemberExpression") : o.optional = !1, o;
			}
			isOptionalMemberExpression(e) {
				return e.type === "ChainExpression" ? e.expression.type === "MemberExpression" : super.isOptionalMemberExpression(e);
			}
			hasPropertyAsPrivateName(e) {
				return e.type === "ChainExpression" && (e = e.expression), super.hasPropertyAsPrivateName(e);
			}
			isObjectProperty(e) {
				return e.type === "Property" && e.kind === "init" && !e.method;
			}
			isObjectMethod(e) {
				return e.type === "Property" && (e.method || e.kind === "get" || e.kind === "set");
			}
			castNodeTo(e, s) {
				let i = super.castNodeTo(e, s);
				return this.fillOptionalPropertiesForTSESLint(i), i;
			}
			cloneIdentifier(e) {
				let s = super.cloneIdentifier(e);
				return this.fillOptionalPropertiesForTSESLint(s), s;
			}
			cloneStringLiteral(e) {
				return e.type === "Literal" ? this.cloneEstreeStringLiteral(e) : super.cloneStringLiteral(e);
			}
			finishNodeAt(e, s, i) {
				return ne(super.finishNodeAt(e, s, i));
			}
			finishNode(e, s) {
				let i = super.finishNode(e, s);
				return this.fillOptionalPropertiesForTSESLint(i), i;
			}
			resetStartLocation(e, s) {
				super.resetStartLocation(e, s), ne(e);
			}
			resetEndLocation(e, s = this.state.lastTokEndLoc) {
				super.resetEndLocation(e, s), ne(e);
			}
		}, W = class {
			constructor(t, e) {
				this.token = t, this.preserveSpace = !!e;
			}
			token;
			preserveSpace;
		}, E = {
			brace: new W("{"),
			j_oTag: new W("<tag"),
			j_cTag: new W("</tag"),
			j_expr: new W("<tag>...</tag>", !0)
		}, T = !0, m = !0, _e = !0, oe = !0, j = !0, li = !0, we = class {
			label;
			keyword;
			beforeExpr;
			startsExpr;
			rightAssociative;
			isLoop;
			isAssign;
			prefix;
			postfix;
			binop;
			constructor(t, e = {}) {
				this.label = t, this.keyword = e.keyword, this.beforeExpr = !!e.beforeExpr, this.startsExpr = !!e.startsExpr, this.rightAssociative = !!e.rightAssociative, this.isLoop = !!e.isLoop, this.isAssign = !!e.isAssign, this.prefix = !!e.prefix, this.postfix = !!e.postfix, this.binop = e.binop != null ? e.binop : null;
			}
		}, dt = /* @__PURE__ */ new Map();
		function S(a, t = {}) {
			t.keyword = a;
			let e = P(a, t);
			return dt.set(a, e), e;
		}
		function v(a, t) {
			return P(a, {
				beforeExpr: T,
				binop: t
			});
		}
		var pe = -1, mt = [], yt = [], xt = [], Pt = [], gt = [], Tt = [];
		function P(a, t = {}) {
			return ++pe, yt.push(a), xt.push(t.binop ?? -1), Pt.push(t.beforeExpr ?? !1), gt.push(t.startsExpr ?? !1), Tt.push(t.prefix ?? !1), mt.push(new we(a, t)), pe;
		}
		function b(a, t = {}) {
			return ++pe, dt.set(a, pe), yt.push(a), xt.push(t.binop ?? -1), Pt.push(t.beforeExpr ?? !1), gt.push(t.startsExpr ?? !1), Tt.push(t.prefix ?? !1), mt.push(new we("name", t)), pe;
		}
		var pi = {
			bracketL: P("[", {
				beforeExpr: T,
				startsExpr: m
			}),
			bracketHashL: P("#[", {
				beforeExpr: T,
				startsExpr: m
			}),
			bracketBarL: P("[|", {
				beforeExpr: T,
				startsExpr: m
			}),
			bracketR: P("]"),
			bracketBarR: P("|]"),
			braceL: P("{", {
				beforeExpr: T,
				startsExpr: m
			}),
			braceBarL: P("{|", {
				beforeExpr: T,
				startsExpr: m
			}),
			braceHashL: P("#{", {
				beforeExpr: T,
				startsExpr: m
			}),
			braceR: P("}"),
			braceBarR: P("|}"),
			parenL: P("(", {
				beforeExpr: T,
				startsExpr: m
			}),
			parenR: P(")"),
			comma: P(",", { beforeExpr: T }),
			semi: P(";", { beforeExpr: T }),
			colon: P(":", { beforeExpr: T }),
			doubleColon: P("::", { beforeExpr: T }),
			dot: P("."),
			question: P("?", { beforeExpr: T }),
			questionDot: P("?."),
			arrow: P("=>", { beforeExpr: T }),
			template: P("template"),
			ellipsis: P("...", { beforeExpr: T }),
			backQuote: P("`", { startsExpr: m }),
			dollarBraceL: P("${", {
				beforeExpr: T,
				startsExpr: m
			}),
			templateTail: P("...`", { startsExpr: m }),
			templateNonTail: P("...${", {
				beforeExpr: T,
				startsExpr: m
			}),
			at: P("@"),
			hash: P("#", { startsExpr: m }),
			interpreterDirective: P("#!..."),
			eq: P("=", {
				beforeExpr: T,
				isAssign: oe
			}),
			assign: P("_=", {
				beforeExpr: T,
				isAssign: oe
			}),
			slashAssign: P("_=", {
				beforeExpr: T,
				isAssign: oe
			}),
			xorAssign: P("_=", {
				beforeExpr: T,
				isAssign: oe
			}),
			moduloAssign: P("_=", {
				beforeExpr: T,
				isAssign: oe
			}),
			incDec: P("++/--", {
				prefix: j,
				postfix: li,
				startsExpr: m
			}),
			bang: P("!", {
				beforeExpr: T,
				prefix: j,
				startsExpr: m
			}),
			tilde: P("~", {
				beforeExpr: T,
				prefix: j,
				startsExpr: m
			}),
			doubleCaret: P("^^", { startsExpr: m }),
			doubleAt: P("@@", { startsExpr: m }),
			pipeline: v("|>", 0),
			nullishCoalescing: v("??", 1),
			logicalOR: v("||", 1),
			logicalAND: v("&&", 2),
			bitwiseOR: v("|", 3),
			bitwiseXOR: v("^", 4),
			bitwiseAND: v("&", 5),
			equality: v("==/!=/===/!==", 6),
			lt: v("</>/<=/>=", 7),
			gt: v("</>/<=/>=", 7),
			relational: v("</>/<=/>=", 7),
			bitShift: v("<</>>/>>>", 8),
			bitShiftL: v("<</>>/>>>", 8),
			bitShiftR: v("<</>>/>>>", 8),
			plusMin: P("+/-", {
				beforeExpr: T,
				binop: 9,
				prefix: j,
				startsExpr: m
			}),
			modulo: P("%", {
				binop: 10,
				startsExpr: m
			}),
			star: P("*", { binop: 10 }),
			slash: v("/", 10),
			exponent: P("**", {
				beforeExpr: T,
				binop: 11,
				rightAssociative: !0
			}),
			_in: S("in", {
				beforeExpr: T,
				binop: 7
			}),
			_instanceof: S("instanceof", {
				beforeExpr: T,
				binop: 7
			}),
			_break: S("break"),
			_case: S("case", { beforeExpr: T }),
			_catch: S("catch"),
			_continue: S("continue"),
			_debugger: S("debugger"),
			_default: S("default", { beforeExpr: T }),
			_else: S("else", { beforeExpr: T }),
			_finally: S("finally"),
			_function: S("function", { startsExpr: m }),
			_if: S("if"),
			_return: S("return", { beforeExpr: T }),
			_switch: S("switch"),
			_throw: S("throw", {
				beforeExpr: T,
				prefix: j,
				startsExpr: m
			}),
			_try: S("try"),
			_var: S("var"),
			_const: S("const"),
			_with: S("with"),
			_new: S("new", {
				beforeExpr: T,
				startsExpr: m
			}),
			_this: S("this", { startsExpr: m }),
			_super: S("super", { startsExpr: m }),
			_class: S("class", { startsExpr: m }),
			_extends: S("extends", { beforeExpr: T }),
			_export: S("export"),
			_import: S("import", { startsExpr: m }),
			_null: S("null", { startsExpr: m }),
			_true: S("true", { startsExpr: m }),
			_false: S("false", { startsExpr: m }),
			_typeof: S("typeof", {
				beforeExpr: T,
				prefix: j,
				startsExpr: m
			}),
			_void: S("void", {
				beforeExpr: T,
				prefix: j,
				startsExpr: m
			}),
			_delete: S("delete", {
				beforeExpr: T,
				prefix: j,
				startsExpr: m
			}),
			_do: S("do", {
				isLoop: _e,
				beforeExpr: T
			}),
			_for: S("for", { isLoop: _e }),
			_while: S("while", { isLoop: _e }),
			_as: b("as", { startsExpr: m }),
			_assert: b("assert", { startsExpr: m }),
			_async: b("async", { startsExpr: m }),
			_await: b("await", { startsExpr: m }),
			_defer: b("defer", { startsExpr: m }),
			_from: b("from", { startsExpr: m }),
			_get: b("get", { startsExpr: m }),
			_let: b("let", { startsExpr: m }),
			_meta: b("meta", { startsExpr: m }),
			_of: b("of", { startsExpr: m }),
			_sent: b("sent", { startsExpr: m }),
			_set: b("set", { startsExpr: m }),
			_source: b("source", { startsExpr: m }),
			_static: b("static", { startsExpr: m }),
			_using: b("using", { startsExpr: m }),
			_yield: b("yield", { startsExpr: m }),
			_asserts: b("asserts", { startsExpr: m }),
			_checks: b("checks", { startsExpr: m }),
			_exports: b("exports", { startsExpr: m }),
			_global: b("global", { startsExpr: m }),
			_implements: b("implements", { startsExpr: m }),
			_intrinsic: b("intrinsic", { startsExpr: m }),
			_infer: b("infer", { startsExpr: m }),
			_is: b("is", { startsExpr: m }),
			_mixins: b("mixins", { startsExpr: m }),
			_proto: b("proto", { startsExpr: m }),
			_require: b("require", { startsExpr: m }),
			_satisfies: b("satisfies", { startsExpr: m }),
			_keyof: b("keyof", { startsExpr: m }),
			_readonly: b("readonly", { startsExpr: m }),
			_unique: b("unique", { startsExpr: m }),
			_abstract: b("abstract", { startsExpr: m }),
			_declare: b("declare", { startsExpr: m }),
			_enum: b("enum", { startsExpr: m }),
			_module: b("module", { startsExpr: m }),
			_namespace: b("namespace", { startsExpr: m }),
			_interface: b("interface", { startsExpr: m }),
			_type: b("type", { startsExpr: m }),
			_opaque: b("opaque", { startsExpr: m }),
			name: P("name", { startsExpr: m }),
			placeholder: P("%%", { startsExpr: m }),
			string: P("string", { startsExpr: m }),
			num: P("num", { startsExpr: m }),
			bigint: P("bigint", { startsExpr: m }),
			decimal: P("decimal", { startsExpr: m }),
			regexp: P("regexp", { startsExpr: m }),
			privateName: P("#name", { startsExpr: m }),
			eof: P("eof"),
			jsxName: P("jsxName"),
			jsxText: P("jsxText", { beforeExpr: T }),
			jsxTagStart: P("jsxTagStart", { startsExpr: m }),
			jsxTagEnd: P("jsxTagEnd")
		};
		function w(a) {
			return a >= 93 && a <= 133;
		}
		function ui(a) {
			return a <= 92;
		}
		function O(a) {
			return a >= 58 && a <= 133;
		}
		function Gt(a) {
			return a >= 58 && a <= 137;
		}
		function fi(a) {
			return Pt[a];
		}
		function ce(a) {
			return gt[a];
		}
		function di(a) {
			return a >= 29 && a <= 33;
		}
		function Rt(a) {
			return a >= 129 && a <= 131;
		}
		function mi(a) {
			return a >= 90 && a <= 92;
		}
		function bt(a) {
			return a >= 58 && a <= 92;
		}
		function yi(a) {
			return a >= 39 && a <= 59;
		}
		function xi(a) {
			return a === 34;
		}
		function Pi(a) {
			return Tt[a];
		}
		function gi(a) {
			return a >= 121 && a <= 123;
		}
		function Ti(a) {
			return a >= 124 && a <= 130;
		}
		function z(a) {
			return yt[a];
		}
		function Ae(a) {
			return xt[a];
		}
		function bi(a) {
			return a === 57;
		}
		function Ke(a) {
			return a >= 24 && a <= 25;
		}
		function Xt(a) {
			return mt[a];
		}
		var At = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-࢏ࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚ౜ౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽ೜-ೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲊᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-Ƛ꟱-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ", Yt = "·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛ࢗ-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-᫝᫠-᫫ᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‌‍‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯・꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿･", Ai = new RegExp("[" + At + "]"), Si = new RegExp("[" + At + Yt + "]");
		At = Yt = null;
		var Qt = [
			0,
			11,
			2,
			25,
			2,
			18,
			2,
			1,
			2,
			14,
			3,
			13,
			35,
			122,
			70,
			52,
			268,
			28,
			4,
			48,
			48,
			31,
			14,
			29,
			6,
			37,
			11,
			29,
			3,
			35,
			5,
			7,
			2,
			4,
			43,
			157,
			19,
			35,
			5,
			35,
			5,
			39,
			9,
			51,
			13,
			10,
			2,
			14,
			2,
			6,
			2,
			1,
			2,
			10,
			2,
			14,
			2,
			6,
			2,
			1,
			4,
			51,
			13,
			310,
			10,
			21,
			11,
			7,
			25,
			5,
			2,
			41,
			2,
			8,
			70,
			5,
			3,
			0,
			2,
			43,
			2,
			1,
			4,
			0,
			3,
			22,
			11,
			22,
			10,
			30,
			66,
			18,
			2,
			1,
			11,
			21,
			11,
			25,
			7,
			25,
			39,
			55,
			7,
			1,
			65,
			0,
			16,
			3,
			2,
			2,
			2,
			28,
			43,
			28,
			4,
			28,
			36,
			7,
			2,
			27,
			28,
			53,
			11,
			21,
			11,
			18,
			14,
			17,
			111,
			72,
			56,
			50,
			14,
			50,
			14,
			35,
			39,
			27,
			10,
			22,
			251,
			41,
			7,
			1,
			17,
			5,
			57,
			28,
			11,
			0,
			9,
			21,
			43,
			17,
			47,
			20,
			28,
			22,
			13,
			52,
			58,
			1,
			3,
			0,
			14,
			44,
			33,
			24,
			27,
			35,
			30,
			0,
			3,
			0,
			9,
			34,
			4,
			0,
			13,
			47,
			15,
			3,
			22,
			0,
			2,
			0,
			36,
			17,
			2,
			24,
			20,
			1,
			64,
			6,
			2,
			0,
			2,
			3,
			2,
			14,
			2,
			9,
			8,
			46,
			39,
			7,
			3,
			1,
			3,
			21,
			2,
			6,
			2,
			1,
			2,
			4,
			4,
			0,
			19,
			0,
			13,
			4,
			31,
			9,
			2,
			0,
			3,
			0,
			2,
			37,
			2,
			0,
			26,
			0,
			2,
			0,
			45,
			52,
			19,
			3,
			21,
			2,
			31,
			47,
			21,
			1,
			2,
			0,
			185,
			46,
			42,
			3,
			37,
			47,
			21,
			0,
			60,
			42,
			14,
			0,
			72,
			26,
			38,
			6,
			186,
			43,
			117,
			63,
			32,
			7,
			3,
			0,
			3,
			7,
			2,
			1,
			2,
			23,
			16,
			0,
			2,
			0,
			95,
			7,
			3,
			38,
			17,
			0,
			2,
			0,
			29,
			0,
			11,
			39,
			8,
			0,
			22,
			0,
			12,
			45,
			20,
			0,
			19,
			72,
			200,
			32,
			32,
			8,
			2,
			36,
			18,
			0,
			50,
			29,
			113,
			6,
			2,
			1,
			2,
			37,
			22,
			0,
			26,
			5,
			2,
			1,
			2,
			31,
			15,
			0,
			24,
			43,
			261,
			18,
			16,
			0,
			2,
			12,
			2,
			33,
			125,
			0,
			80,
			921,
			103,
			110,
			18,
			195,
			2637,
			96,
			16,
			1071,
			18,
			5,
			26,
			3994,
			6,
			582,
			6842,
			29,
			1763,
			568,
			8,
			30,
			18,
			78,
			18,
			29,
			19,
			47,
			17,
			3,
			32,
			20,
			6,
			18,
			433,
			44,
			212,
			63,
			33,
			24,
			3,
			24,
			45,
			74,
			6,
			0,
			67,
			12,
			65,
			1,
			2,
			0,
			15,
			4,
			10,
			7381,
			42,
			31,
			98,
			114,
			8702,
			3,
			2,
			6,
			2,
			1,
			2,
			290,
			16,
			0,
			30,
			2,
			3,
			0,
			15,
			3,
			9,
			395,
			2309,
			106,
			6,
			12,
			4,
			8,
			8,
			9,
			5991,
			84,
			2,
			70,
			2,
			1,
			3,
			0,
			3,
			1,
			3,
			3,
			2,
			11,
			2,
			0,
			2,
			6,
			2,
			64,
			2,
			3,
			3,
			7,
			2,
			6,
			2,
			27,
			2,
			3,
			2,
			4,
			2,
			0,
			4,
			6,
			2,
			339,
			3,
			24,
			2,
			24,
			2,
			30,
			2,
			24,
			2,
			30,
			2,
			24,
			2,
			30,
			2,
			24,
			2,
			30,
			2,
			24,
			2,
			7,
			1845,
			30,
			7,
			5,
			262,
			61,
			147,
			44,
			11,
			6,
			17,
			0,
			322,
			29,
			19,
			43,
			485,
			27,
			229,
			29,
			3,
			0,
			208,
			30,
			2,
			2,
			2,
			1,
			2,
			6,
			3,
			4,
			10,
			1,
			225,
			6,
			2,
			3,
			2,
			1,
			2,
			14,
			2,
			196,
			60,
			67,
			8,
			0,
			1205,
			3,
			2,
			26,
			2,
			1,
			2,
			0,
			3,
			0,
			2,
			9,
			2,
			3,
			2,
			0,
			2,
			0,
			7,
			0,
			5,
			0,
			2,
			0,
			2,
			0,
			2,
			2,
			2,
			1,
			2,
			0,
			3,
			0,
			2,
			0,
			2,
			0,
			2,
			0,
			2,
			0,
			2,
			1,
			2,
			0,
			3,
			3,
			2,
			6,
			2,
			3,
			2,
			3,
			2,
			0,
			2,
			9,
			2,
			16,
			6,
			2,
			2,
			4,
			2,
			16,
			4421,
			42719,
			33,
			4381,
			3,
			5773,
			3,
			7472,
			16,
			621,
			2467,
			541,
			1507,
			4938,
			6,
			8489
		], wi = [
			509,
			0,
			227,
			0,
			150,
			4,
			294,
			9,
			1368,
			2,
			2,
			1,
			6,
			3,
			41,
			2,
			5,
			0,
			166,
			1,
			574,
			3,
			9,
			9,
			7,
			9,
			32,
			4,
			318,
			1,
			78,
			5,
			71,
			10,
			50,
			3,
			123,
			2,
			54,
			14,
			32,
			10,
			3,
			1,
			11,
			3,
			46,
			10,
			8,
			0,
			46,
			9,
			7,
			2,
			37,
			13,
			2,
			9,
			6,
			1,
			45,
			0,
			13,
			2,
			49,
			13,
			9,
			3,
			2,
			11,
			83,
			11,
			7,
			0,
			3,
			0,
			158,
			11,
			6,
			9,
			7,
			3,
			56,
			1,
			2,
			6,
			3,
			1,
			3,
			2,
			10,
			0,
			11,
			1,
			3,
			6,
			4,
			4,
			68,
			8,
			2,
			0,
			3,
			0,
			2,
			3,
			2,
			4,
			2,
			0,
			15,
			1,
			83,
			17,
			10,
			9,
			5,
			0,
			82,
			19,
			13,
			9,
			214,
			6,
			3,
			8,
			28,
			1,
			83,
			16,
			16,
			9,
			82,
			12,
			9,
			9,
			7,
			19,
			58,
			14,
			5,
			9,
			243,
			14,
			166,
			9,
			71,
			5,
			2,
			1,
			3,
			3,
			2,
			0,
			2,
			1,
			13,
			9,
			120,
			6,
			3,
			6,
			4,
			0,
			29,
			9,
			41,
			6,
			2,
			3,
			9,
			0,
			10,
			10,
			47,
			15,
			199,
			7,
			137,
			9,
			54,
			7,
			2,
			7,
			17,
			9,
			57,
			21,
			2,
			13,
			123,
			5,
			4,
			0,
			2,
			1,
			2,
			6,
			2,
			0,
			9,
			9,
			49,
			4,
			2,
			1,
			2,
			4,
			9,
			9,
			55,
			9,
			266,
			3,
			10,
			1,
			2,
			0,
			49,
			6,
			4,
			4,
			14,
			10,
			5350,
			0,
			7,
			14,
			11465,
			27,
			2343,
			9,
			87,
			9,
			39,
			4,
			60,
			6,
			26,
			9,
			535,
			9,
			470,
			0,
			2,
			54,
			8,
			3,
			82,
			0,
			12,
			1,
			19628,
			1,
			4178,
			9,
			519,
			45,
			3,
			22,
			543,
			4,
			4,
			5,
			9,
			7,
			3,
			6,
			31,
			3,
			149,
			2,
			1418,
			49,
			513,
			54,
			5,
			49,
			9,
			0,
			15,
			0,
			23,
			4,
			2,
			14,
			1361,
			6,
			2,
			16,
			3,
			6,
			2,
			1,
			2,
			4,
			101,
			0,
			161,
			6,
			10,
			9,
			357,
			0,
			62,
			13,
			499,
			13,
			245,
			1,
			2,
			9,
			233,
			0,
			3,
			0,
			8,
			1,
			6,
			0,
			475,
			6,
			110,
			6,
			6,
			9,
			4759,
			9,
			787719,
			239
		];
		function He(a, t) {
			let e = 65536;
			for (let s = 0, i = t.length; s < i; s += 2) {
				if (e += t[s], e > a) return !1;
				if (e += t[s + 1], e >= a) return !0;
			}
			return !1;
		}
		function B(a) {
			return a < 65 ? a === 36 : a <= 90 ? !0 : a < 97 ? a === 95 : a <= 122 ? !0 : a <= 65535 ? a >= 170 && Ai.test(String.fromCharCode(a)) : He(a, Qt);
		}
		function K(a) {
			return a < 48 ? a === 36 : a < 58 ? !0 : a < 65 ? !1 : a <= 90 ? !0 : a < 97 ? a === 95 : a <= 122 ? !0 : a <= 65535 ? a >= 170 && Si.test(String.fromCharCode(a)) : He(a, Qt) || He(a, wi);
		}
		var St = {
			keyword: [
				"break",
				"case",
				"catch",
				"continue",
				"debugger",
				"default",
				"do",
				"else",
				"finally",
				"for",
				"function",
				"if",
				"return",
				"switch",
				"throw",
				"try",
				"var",
				"const",
				"while",
				"with",
				"new",
				"this",
				"super",
				"class",
				"extends",
				"export",
				"import",
				"null",
				"true",
				"false",
				"in",
				"instanceof",
				"typeof",
				"void",
				"delete"
			],
			strict: [
				"implements",
				"interface",
				"let",
				"package",
				"private",
				"protected",
				"public",
				"static",
				"yield"
			],
			strictBind: ["eval", "arguments"]
		}, Ci = new Set(St.keyword), Ei = new Set(St.strict), Ii = new Set(St.strictBind);
		function Zt(a, t) {
			return t && a === "await" || a === "enum";
		}
		function es(a, t) {
			return Zt(a, t) || Ei.has(a);
		}
		function ts(a) {
			return Ii.has(a);
		}
		function ss(a, t) {
			return es(a, t) || ts(a);
		}
		function Ni(a) {
			return Ci.has(a);
		}
		function ki(a, t, e) {
			return a === 64 && t === 64 && B(e);
		}
		var vi = new Set([
			"break",
			"case",
			"catch",
			"continue",
			"debugger",
			"default",
			"do",
			"else",
			"finally",
			"for",
			"function",
			"if",
			"return",
			"switch",
			"throw",
			"try",
			"var",
			"const",
			"while",
			"with",
			"new",
			"this",
			"super",
			"class",
			"extends",
			"export",
			"import",
			"null",
			"true",
			"false",
			"in",
			"instanceof",
			"typeof",
			"void",
			"delete",
			"implements",
			"interface",
			"let",
			"package",
			"private",
			"protected",
			"public",
			"static",
			"yield",
			"eval",
			"arguments",
			"enum",
			"await"
		]);
		function Li(a) {
			return vi.has(a);
		}
		var ue = class {
			flags = 0;
			names = /* @__PURE__ */ new Map();
			firstLexicalName = "";
			constructor(t) {
				this.flags = t;
			}
		}, fe = class {
			parser;
			scopeStack = [];
			inModule;
			undefinedExports = /* @__PURE__ */ new Map();
			constructor(t, e) {
				this.parser = t, this.inModule = e;
			}
			get inTopLevel() {
				return (this.currentScope().flags & 1) > 0;
			}
			get inFunction() {
				return (this.currentVarScopeFlags() & 2) > 0;
			}
			get allowSuper() {
				return (this.currentThisScopeFlags() & 16) > 0;
			}
			get allowDirectSuper() {
				return (this.currentThisScopeFlags() & 32) > 0;
			}
			get allowNewTarget() {
				return (this.currentThisScopeFlags() & 512) > 0;
			}
			get inClass() {
				return (this.currentThisScopeFlags() & 64) > 0;
			}
			get inClassAndNotInNonArrowFunction() {
				let t = this.currentThisScopeFlags();
				return (t & 64) > 0 && (t & 2) === 0;
			}
			get inStaticBlock() {
				for (let t = this.scopeStack.length - 1;; t--) {
					let { flags: e } = this.scopeStack[t];
					if (e & 128) return !0;
					if (e & 1731) return !1;
				}
			}
			get inNonArrowFunction() {
				return (this.currentThisScopeFlags() & 2) > 0;
			}
			get inBareCaseStatement() {
				return (this.currentScope().flags & 256) > 0;
			}
			get treatFunctionsAsVar() {
				return this.treatFunctionsAsVarInScope(this.currentScope());
			}
			createScope(t) {
				return new ue(t);
			}
			enter(t) {
				this.scopeStack.push(this.createScope(t));
			}
			exit() {
				return this.scopeStack.pop().flags;
			}
			treatFunctionsAsVarInScope(t) {
				return !!(t.flags & 130 || !this.parser.inModule && t.flags & 1);
			}
			declareName(t, e, s) {
				let i = this.currentScope();
				if (e & 8 || e & 16) {
					this.checkRedeclarationInScope(i, t, e, s);
					let r = i.names.get(t) || 0;
					e & 16 ? r = r | 4 : (i.firstLexicalName || (i.firstLexicalName = t), r = r | 2), i.names.set(t, r), e & 8 && this.maybeExportDefined(i, t);
				} else if (e & 4) for (let r = this.scopeStack.length - 1; r >= 0 && (i = this.scopeStack[r], this.checkRedeclarationInScope(i, t, e, s), i.names.set(t, (i.names.get(t) || 0) | 1), this.maybeExportDefined(i, t), !(i.flags & 1667)); --r);
				this.parser.inModule && i.flags & 1 && this.undefinedExports.delete(t);
			}
			maybeExportDefined(t, e) {
				this.parser.inModule && t.flags & 1 && this.undefinedExports.delete(e);
			}
			checkRedeclarationInScope(t, e, s, i) {
				this.isRedeclaredInScope(t, e, s) && this.parser.raise(p.VarRedeclaration, i, { identifierName: e });
			}
			isRedeclaredInScope(t, e, s) {
				if (!(s & 1)) return !1;
				if (s & 8) return t.names.has(e);
				let i = t.names.get(e) || 0;
				return s & 16 ? (i & 2) > 0 || !this.treatFunctionsAsVarInScope(t) && (i & 1) > 0 : (i & 2) > 0 && !(t.flags & 8 && t.firstLexicalName === e) || !this.treatFunctionsAsVarInScope(t) && (i & 4) > 0;
			}
			checkLocalExport(t) {
				let { name: e } = t;
				this.scopeStack[0].names.has(e) || this.undefinedExports.set(e, t.loc.start);
			}
			currentScope() {
				return this.scopeStack[this.scopeStack.length - 1];
			}
			currentVarScopeFlags() {
				for (let t = this.scopeStack.length - 1;; t--) {
					let { flags: e } = this.scopeStack[t];
					if (e & 1667) return e;
				}
			}
			currentThisScopeFlags() {
				for (let t = this.scopeStack.length - 1;; t--) {
					let { flags: e } = this.scopeStack[t];
					if (e & 1731 && !(e & 4)) return e;
				}
			}
		}, We = class extends ue {
			declareFunctions = /* @__PURE__ */ new Set();
		}, Je = class extends fe {
			createScope(t) {
				return new We(t);
			}
			declareName(t, e, s) {
				let i = this.currentScope();
				if (e & 2048) {
					this.checkRedeclarationInScope(i, t, e, s), this.maybeExportDefined(i, t), i.declareFunctions.add(t);
					return;
				}
				super.declareName(t, e, s);
			}
			isRedeclaredInScope(t, e, s) {
				if (super.isRedeclaredInScope(t, e, s)) return !0;
				if (s & 2048 && !t.declareFunctions.has(e)) {
					let i = t.names.get(e);
					return (i & 4) > 0 || (i & 2) > 0;
				}
				return !1;
			}
			checkLocalExport(t) {
				this.scopeStack[0].declareFunctions.has(t.name) || super.checkLocalExport(t);
			}
		}, Di = new Set([
			"_",
			"any",
			"bool",
			"boolean",
			"empty",
			"extends",
			"false",
			"interface",
			"mixed",
			"null",
			"number",
			"static",
			"string",
			"true",
			"typeof",
			"void"
		]), g = F`flow`({
			AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
			AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.",
			AssignReservedType: ({ reservedType: a }) => `Cannot overwrite reserved type ${a}.`,
			DeclareClassElement: "The `declare` modifier can only appear on class fields.",
			DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
			DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
			EnumBooleanMemberNotInitialized: ({ memberName: a, enumName: t }) => `Boolean enum members need to be initialized. Use either \`${a} = true,\` or \`${a} = false,\` in enum \`${t}\`.`,
			EnumDuplicateMemberName: ({ memberName: a, enumName: t }) => `Enum member names need to be unique, but the name \`${a}\` has already been used before in enum \`${t}\`.`,
			EnumInconsistentMemberValues: ({ enumName: a }) => `Enum \`${a}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`,
			EnumInvalidExplicitType: ({ invalidEnumType: a, enumName: t }) => `Enum type \`${a}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${t}\`.`,
			EnumInvalidExplicitTypeUnknownSupplied: ({ enumName: a }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${a}\`.`,
			EnumInvalidMemberInitializerPrimaryType: ({ enumName: a, memberName: t, explicitType: e }) => `Enum \`${a}\` has type \`${e}\`, so the initializer of \`${t}\` needs to be a ${e} literal.`,
			EnumInvalidMemberInitializerSymbolType: ({ enumName: a, memberName: t }) => `Symbol enum members cannot be initialized. Use \`${t},\` in enum \`${a}\`.`,
			EnumInvalidMemberInitializerUnknownType: ({ enumName: a, memberName: t }) => `The enum member initializer for \`${t}\` needs to be a literal (either a boolean, number, or string) in enum \`${a}\`.`,
			EnumInvalidMemberName: ({ enumName: a, memberName: t, suggestion: e }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${t}\`, consider using \`${e}\`, in enum \`${a}\`.`,
			EnumNumberMemberNotInitialized: ({ enumName: a, memberName: t }) => `Number enum members need to be initialized, e.g. \`${t} = 1\` in enum \`${a}\`.`,
			EnumStringMemberInconsistentlyInitialized: ({ enumName: a }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${a}\`.`,
			GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
			ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.",
			ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.",
			InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
			InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
			InexactVariance: "Explicit inexact syntax cannot have variance.",
			InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
			MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
			NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
			NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
			PatternIsOptional: Object.assign({ message: "A binding pattern parameter cannot be optional in an implementation signature." }, {}),
			SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
			SpreadVariance: "Spread properties cannot have variance.",
			ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
			ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
			ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
			ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
			ThisParamNoDefault: "The `this` parameter may not have a default value.",
			TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
			TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
			UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
			UnexpectedReservedType: ({ reservedType: a }) => `Unexpected reserved type ${a}.`,
			UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
			UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
			UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
			UnexpectedSubtractionOperand: "Unexpected token, expected \"number\" or \"bigint\".",
			UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
			UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.",
			UnsupportedDeclareExportKind: ({ unsupportedExportKind: a, suggestion: t }) => `\`declare export ${a}\` is not supported. Use \`${t}\` instead.`,
			UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
			UnterminatedFlowComment: "Unterminated flow-comment."
		});
		function Mi(a) {
			return a.type === "DeclareExportAllDeclaration" || a.type === "DeclareExportDeclaration" && (!a.declaration || a.declaration.type !== "TypeAlias" && a.declaration.type !== "InterfaceDeclaration");
		}
		function Ut(a) {
			return a.importKind === "type" || a.importKind === "typeof";
		}
		var Oi = {
			const: "declare export var",
			let: "declare export var",
			type: "export type",
			interface: "export interface"
		};
		function Fi(a, t) {
			let e = [], s = [];
			for (let i = 0; i < a.length; i++) (t(a[i], i, a) ? e : s).push(a[i]);
			return [e, s];
		}
		var Bi = /\*?\s*@((?:no)?flow)\b/, Ri = (a) => class extends a {
			flowPragma = void 0;
			getScopeHandler() {
				return Je;
			}
			shouldParseTypes() {
				return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
			}
			finishToken(e, s) {
				e !== 134 && e !== 13 && e !== 28 && this.flowPragma === void 0 && (this.flowPragma = null), super.finishToken(e, s);
			}
			addComment(e) {
				if (this.flowPragma === void 0) {
					let s = Bi.exec(e.value);
					if (s) if (s[1] === "flow") this.flowPragma = "flow";
					else if (s[1] === "noflow") this.flowPragma = "noflow";
					else throw new Error("Unexpected flow pragma");
				}
				super.addComment(e);
			}
			flowParseTypeInitialiser(e) {
				let s = this.state.inType;
				this.state.inType = !0, this.expect(e || 14);
				let i = this.flowParseType();
				return this.state.inType = s, i;
			}
			flowParsePredicate() {
				let e = this.startNode(), s = this.state.startLoc;
				return this.next(), this.expectContextual(110), this.state.lastTokStartLoc.index > s.index + 1 && this.raise(g.UnexpectedSpaceBetweenModuloChecks, s), this.eat(10) ? (e.value = super.parseExpression(), this.expect(11), this.finishNode(e, "DeclaredPredicate")) : this.finishNode(e, "InferredPredicate");
			}
			flowParseTypeAndPredicateInitialiser() {
				let e = this.state.inType;
				this.state.inType = !0, this.expect(14);
				let s = null, i = null;
				return this.match(54) ? (this.state.inType = e, i = this.flowParsePredicate()) : (s = this.flowParseType(), this.state.inType = e, this.match(54) && (i = this.flowParsePredicate())), [s, i];
			}
			flowParseDeclareClass(e) {
				return this.next(), this.flowParseInterfaceish(e, !0), this.finishNode(e, "DeclareClass");
			}
			flowParseDeclareFunction(e) {
				this.next();
				let s = e.id = this.parseIdentifier(), i = this.startNode(), r = this.startNode();
				this.match(47) ? i.typeParameters = this.flowParseTypeParameterDeclaration() : i.typeParameters = null, this.expect(10);
				let n = this.flowParseFunctionTypeParams();
				return i.params = n.params, i.rest = n.rest, i.this = n._this, this.expect(11), [i.returnType, e.predicate] = this.flowParseTypeAndPredicateInitialiser(), r.typeAnnotation = this.finishNode(i, "FunctionTypeAnnotation"), s.typeAnnotation = this.finishNode(r, "TypeAnnotation"), this.resetEndLocation(s), this.semicolon(), this.scope.declareName(e.id.name, 2048, e.id.loc.start), this.finishNode(e, "DeclareFunction");
			}
			flowParseDeclare(e, s) {
				if (this.match(80)) return this.flowParseDeclareClass(e);
				if (this.match(68)) return this.flowParseDeclareFunction(e);
				if (this.match(74)) return this.flowParseDeclareVariable(e);
				if (this.eatContextual(127)) return this.match(16) ? this.flowParseDeclareModuleExports(e) : (s && this.raise(g.NestedDeclareModule, this.state.lastTokStartLoc), this.flowParseDeclareModule(e));
				if (this.isContextual(130)) return this.flowParseDeclareTypeAlias(e);
				if (this.isContextual(131)) return this.flowParseDeclareOpaqueType(e);
				if (this.isContextual(129)) return this.flowParseDeclareInterface(e);
				if (this.match(82)) return this.flowParseDeclareExportDeclaration(e, s);
				throw this.unexpected();
			}
			flowParseDeclareVariable(e) {
				return this.next(), e.id = this.flowParseTypeAnnotatableIdentifier(!0), this.scope.declareName(e.id.name, 5, e.id.loc.start), this.semicolon(), this.finishNode(e, "DeclareVariable");
			}
			flowParseDeclareModule(e) {
				this.scope.enter(0), this.match(134) ? e.id = super.parseExprAtom() : e.id = this.parseIdentifier();
				let s = e.body = this.startNode(), i = s.body = [];
				for (this.expect(5); !this.match(8);) {
					let o = this.startNode();
					this.match(83) ? (this.next(), !this.isContextual(130) && !this.match(87) && this.raise(g.InvalidNonTypeImportInDeclareModule, this.state.lastTokStartLoc), i.push(super.parseImport(o))) : (this.expectContextual(125, g.UnsupportedStatementInDeclareModule), i.push(this.flowParseDeclare(o, !0)));
				}
				this.scope.exit(), this.expect(8), this.finishNode(s, "BlockStatement");
				let r = null, n = !1;
				return i.forEach((o) => {
					Mi(o) ? (r === "CommonJS" && this.raise(g.AmbiguousDeclareModuleKind, o), r = "ES") : o.type === "DeclareModuleExports" && (n && this.raise(g.DuplicateDeclareModuleExports, o), r === "ES" && this.raise(g.AmbiguousDeclareModuleKind, o), r = "CommonJS", n = !0);
				}), e.kind = r || "CommonJS", this.finishNode(e, "DeclareModule");
			}
			flowParseDeclareExportDeclaration(e, s) {
				if (this.expect(82), this.eat(65)) return this.match(68) || this.match(80) ? e.declaration = this.flowParseDeclare(this.startNode()) : (e.declaration = this.flowParseType(), this.semicolon()), e.default = !0, this.finishNode(e, "DeclareExportDeclaration");
				if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !s) {
					let i = this.state.value;
					throw this.raise(g.UnsupportedDeclareExportKind, this.state.startLoc, {
						unsupportedExportKind: i,
						suggestion: Oi[i]
					});
				}
				if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(131)) return e.declaration = this.flowParseDeclare(this.startNode()), e.default = !1, this.finishNode(e, "DeclareExportDeclaration");
				if (this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131)) return e = this.parseExport(e, null), e.type === "ExportNamedDeclaration" ? (e.default = !1, delete e.exportKind, this.castNodeTo(e, "DeclareExportDeclaration")) : this.castNodeTo(e, "DeclareExportAllDeclaration");
				throw this.unexpected();
			}
			flowParseDeclareModuleExports(e) {
				return this.next(), this.expectContextual(111), e.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(e, "DeclareModuleExports");
			}
			flowParseDeclareTypeAlias(e) {
				this.next();
				let s = this.flowParseTypeAlias(e);
				return this.castNodeTo(s, "DeclareTypeAlias"), s;
			}
			flowParseDeclareOpaqueType(e) {
				this.next();
				let s = this.flowParseOpaqueType(e, !0);
				return this.castNodeTo(s, "DeclareOpaqueType"), s;
			}
			flowParseDeclareInterface(e) {
				return this.next(), this.flowParseInterfaceish(e, !1), this.finishNode(e, "DeclareInterface");
			}
			flowParseInterfaceish(e, s) {
				if (e.id = this.flowParseRestrictedIdentifier(!s, !0), this.scope.declareName(e.id.name, s ? 17 : 8201, e.id.loc.start), this.match(47) ? e.typeParameters = this.flowParseTypeParameterDeclaration() : e.typeParameters = null, e.extends = [], this.eat(81)) do
					e.extends.push(this.flowParseInterfaceExtends());
				while (!s && this.eat(12));
				if (s) {
					if (e.implements = [], e.mixins = [], this.eatContextual(117)) do
						e.mixins.push(this.flowParseInterfaceExtends());
					while (this.eat(12));
					if (this.eatContextual(113)) do
						e.implements.push(this.flowParseInterfaceExtends());
					while (this.eat(12));
				}
				e.body = this.flowParseObjectType({
					allowStatic: s,
					allowExact: !1,
					allowSpread: !1,
					allowProto: s,
					allowInexact: !1
				});
			}
			flowParseInterfaceExtends() {
				let e = this.startNode();
				return e.id = this.flowParseQualifiedTypeIdentifier(), this.match(47) ? e.typeParameters = this.flowParseTypeParameterInstantiation() : e.typeParameters = null, this.finishNode(e, "InterfaceExtends");
			}
			flowParseInterface(e) {
				return this.flowParseInterfaceish(e, !1), this.finishNode(e, "InterfaceDeclaration");
			}
			checkNotUnderscore(e) {
				e === "_" && this.raise(g.UnexpectedReservedUnderscore, this.state.startLoc);
			}
			checkReservedType(e, s, i) {
				Di.has(e) && this.raise(i ? g.AssignReservedType : g.UnexpectedReservedType, s, { reservedType: e });
			}
			flowParseRestrictedIdentifier(e, s) {
				return this.checkReservedType(this.state.value, this.state.startLoc, s), this.parseIdentifier(e);
			}
			flowParseTypeAlias(e) {
				return e.id = this.flowParseRestrictedIdentifier(!1, !0), this.scope.declareName(e.id.name, 8201, e.id.loc.start), this.match(47) ? e.typeParameters = this.flowParseTypeParameterDeclaration() : e.typeParameters = null, e.right = this.flowParseTypeInitialiser(29), this.semicolon(), this.finishNode(e, "TypeAlias");
			}
			flowParseOpaqueType(e, s) {
				return this.expectContextual(130), e.id = this.flowParseRestrictedIdentifier(!0, !0), this.scope.declareName(e.id.name, 8201, e.id.loc.start), this.match(47) ? e.typeParameters = this.flowParseTypeParameterDeclaration() : e.typeParameters = null, e.supertype = null, this.match(14) && (e.supertype = this.flowParseTypeInitialiser(14)), e.impltype = null, s || (e.impltype = this.flowParseTypeInitialiser(29)), this.semicolon(), this.finishNode(e, "OpaqueType");
			}
			flowParseTypeParameter(e = !1) {
				let s = this.state.startLoc, i = this.startNode(), r = this.flowParseVariance(), n = this.flowParseTypeAnnotatableIdentifier();
				return i.name = n.name, i.variance = r, i.bound = n.typeAnnotation, this.match(29) ? (this.eat(29), i.default = this.flowParseType()) : e && this.raise(g.MissingTypeParamDefault, s), this.finishNode(i, "TypeParameter");
			}
			flowParseTypeParameterDeclaration() {
				let e = this.state.inType, s = this.startNode();
				s.params = [], this.state.inType = !0, this.match(47) || this.match(143) ? this.next() : this.unexpected();
				let i = !1;
				do {
					let r = this.flowParseTypeParameter(i);
					s.params.push(r), r.default && (i = !0), this.match(48) || this.expect(12);
				} while (!this.match(48));
				return this.expect(48), this.state.inType = e, this.finishNode(s, "TypeParameterDeclaration");
			}
			flowInTopLevelContext(e) {
				if (this.curContext() !== E.brace) {
					let s = this.state.context;
					this.state.context = [s[0]];
					try {
						return e();
					} finally {
						this.state.context = s;
					}
				} else return e();
			}
			flowParseTypeParameterInstantiationInExpression() {
				if (this.reScan_lt() === 47) return this.flowParseTypeParameterInstantiation();
			}
			flowParseTypeParameterInstantiation() {
				let e = this.startNode(), s = this.state.inType;
				return this.state.inType = !0, e.params = [], this.flowInTopLevelContext(() => {
					this.expect(47);
					let i = this.state.noAnonFunctionType;
					for (this.state.noAnonFunctionType = !1; !this.match(48);) e.params.push(this.flowParseType()), this.match(48) || this.expect(12);
					this.state.noAnonFunctionType = i;
				}), this.state.inType = s, !this.state.inType && this.curContext() === E.brace && this.reScan_lt_gt(), this.expect(48), this.finishNode(e, "TypeParameterInstantiation");
			}
			flowParseTypeParameterInstantiationCallOrNew() {
				if (this.reScan_lt() !== 47) return null;
				let e = this.startNode(), s = this.state.inType;
				for (e.params = [], this.state.inType = !0, this.expect(47); !this.match(48);) e.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(48) || this.expect(12);
				return this.expect(48), this.state.inType = s, this.finishNode(e, "TypeParameterInstantiation");
			}
			flowParseInterfaceType() {
				let e = this.startNode();
				if (this.expectContextual(129), e.extends = [], this.eat(81)) do
					e.extends.push(this.flowParseInterfaceExtends());
				while (this.eat(12));
				return e.body = this.flowParseObjectType({
					allowStatic: !1,
					allowExact: !1,
					allowSpread: !1,
					allowProto: !1,
					allowInexact: !1
				}), this.finishNode(e, "InterfaceTypeAnnotation");
			}
			flowParseObjectPropertyKey() {
				return this.match(135) || this.match(134) ? super.parseExprAtom() : this.parseIdentifier(!0);
			}
			flowParseObjectTypeIndexer(e, s, i) {
				return e.static = s, this.lookahead().type === 14 ? (e.id = this.flowParseObjectPropertyKey(), e.key = this.flowParseTypeInitialiser()) : (e.id = null, e.key = this.flowParseType()), this.expect(3), e.value = this.flowParseTypeInitialiser(), e.variance = i, this.finishNode(e, "ObjectTypeIndexer");
			}
			flowParseObjectTypeInternalSlot(e, s) {
				return e.static = s, e.id = this.flowParseObjectPropertyKey(), this.expect(3), this.expect(3), this.match(47) || this.match(10) ? (e.method = !0, e.optional = !1, e.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e.loc.start))) : (e.method = !1, this.eat(17) && (e.optional = !0), e.value = this.flowParseTypeInitialiser()), this.finishNode(e, "ObjectTypeInternalSlot");
			}
			flowParseObjectTypeMethodish(e) {
				for (e.params = [], e.rest = null, e.typeParameters = null, e.this = null, this.match(47) && (e.typeParameters = this.flowParseTypeParameterDeclaration()), this.expect(10), this.match(78) && (e.this = this.flowParseFunctionTypeParam(!0), e.this.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21);) e.params.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
				return this.eat(21) && (e.rest = this.flowParseFunctionTypeParam(!1)), this.expect(11), e.returnType = this.flowParseTypeInitialiser(), this.finishNode(e, "FunctionTypeAnnotation");
			}
			flowParseObjectTypeCallProperty(e, s) {
				let i = this.startNode();
				return e.static = s, e.value = this.flowParseObjectTypeMethodish(i), this.finishNode(e, "ObjectTypeCallProperty");
			}
			flowParseObjectType({ allowStatic: e, allowExact: s, allowSpread: i, allowProto: r, allowInexact: n }) {
				let o = this.state.inType;
				this.state.inType = !0;
				let h = this.startNode();
				h.callProperties = [], h.properties = [], h.indexers = [], h.internalSlots = [];
				let l, u, f = !1;
				for (s && this.match(6) ? (this.expect(6), l = 9, u = !0) : (this.expect(5), l = 8, u = !1), h.exact = u; !this.match(l);) {
					let x = !1, A = null, k = null, N = this.startNode();
					if (r && this.isContextual(118)) {
						let I = this.lookahead();
						I.type !== 14 && I.type !== 17 && (this.next(), A = this.state.startLoc, e = !1);
					}
					if (e && this.isContextual(106)) {
						let I = this.lookahead();
						I.type !== 14 && I.type !== 17 && (this.next(), x = !0);
					}
					let C = this.flowParseVariance();
					if (this.eat(0)) A != null && this.unexpected(A), this.eat(0) ? (C && this.unexpected(C.loc.start), h.internalSlots.push(this.flowParseObjectTypeInternalSlot(N, x))) : h.indexers.push(this.flowParseObjectTypeIndexer(N, x, C));
					else if (this.match(10) || this.match(47)) A != null && this.unexpected(A), C && this.unexpected(C.loc.start), h.callProperties.push(this.flowParseObjectTypeCallProperty(N, x));
					else {
						let I = "init";
						if (this.isContextual(99) || this.isContextual(104)) Gt(this.lookahead().type) && (I = this.state.value, this.next());
						let Pe = this.flowParseObjectTypeProperty(N, x, A, C, I, i, n ?? !u);
						Pe === null ? (f = !0, k = this.state.lastTokStartLoc) : h.properties.push(Pe);
					}
					this.flowObjectTypeSemicolon(), k && !this.match(8) && !this.match(9) && this.raise(g.UnexpectedExplicitInexactInObject, k);
				}
				this.expect(l), i && (h.inexact = f);
				let d = this.finishNode(h, "ObjectTypeAnnotation");
				return this.state.inType = o, d;
			}
			flowParseObjectTypeProperty(e, s, i, r, n, o, h) {
				if (this.eat(21)) return this.match(12) || this.match(13) || this.match(8) || this.match(9) ? (o ? h || this.raise(g.InexactInsideExact, this.state.lastTokStartLoc) : this.raise(g.InexactInsideNonObject, this.state.lastTokStartLoc), r && this.raise(g.InexactVariance, r), null) : (o || this.raise(g.UnexpectedSpreadType, this.state.lastTokStartLoc), i != null && this.unexpected(i), r && this.raise(g.SpreadVariance, r), e.argument = this.flowParseType(), this.finishNode(e, "ObjectTypeSpreadProperty"));
				{
					e.key = this.flowParseObjectPropertyKey(), e.static = s, e.proto = i != null, e.kind = n;
					let l = !1;
					return this.match(47) || this.match(10) ? (e.method = !0, i != null && this.unexpected(i), r && this.unexpected(r.loc.start), e.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e.loc.start)), (n === "get" || n === "set") && this.flowCheckGetterSetterParams(e), !o && e.key.name === "constructor" && e.value.this && this.raise(g.ThisParamBannedInConstructor, e.value.this)) : (n !== "init" && this.unexpected(), e.method = !1, this.eat(17) && (l = !0), e.value = this.flowParseTypeInitialiser(), e.variance = r), e.optional = l, this.finishNode(e, "ObjectTypeProperty");
				}
			}
			flowCheckGetterSetterParams(e) {
				let s = e.kind === "get" ? 0 : 1, i = e.value.params.length + (e.value.rest ? 1 : 0);
				e.value.this && this.raise(e.kind === "get" ? g.GetterMayNotHaveThisParam : g.SetterMayNotHaveThisParam, e.value.this), i !== s && this.raise(e.kind === "get" ? p.BadGetterArity : p.BadSetterArity, e), e.kind === "set" && e.value.rest && this.raise(p.BadSetterRestParameter, e);
			}
			flowObjectTypeSemicolon() {
				!this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9) && this.unexpected();
			}
			flowParseQualifiedTypeIdentifier(e, s) {
				e ?? (e = this.state.startLoc);
				let i = s || this.flowParseRestrictedIdentifier(!0);
				for (; this.eat(16);) {
					let r = this.startNodeAt(e);
					r.qualification = i, r.id = this.flowParseRestrictedIdentifier(!0), i = this.finishNode(r, "QualifiedTypeIdentifier");
				}
				return i;
			}
			flowParseGenericType(e, s) {
				let i = this.startNodeAt(e);
				return i.typeParameters = null, i.id = this.flowParseQualifiedTypeIdentifier(e, s), this.match(47) && (i.typeParameters = this.flowParseTypeParameterInstantiation()), this.finishNode(i, "GenericTypeAnnotation");
			}
			flowParseTypeofType() {
				let e = this.startNode();
				return this.expect(87), e.argument = this.flowParsePrimaryType(), this.finishNode(e, "TypeofTypeAnnotation");
			}
			flowParseTupleType() {
				let e = this.startNode();
				for (e.types = [], this.expect(0); this.state.pos < this.length && !this.match(3) && (e.types.push(this.flowParseType()), !this.match(3));) this.expect(12);
				return this.expect(3), this.finishNode(e, "TupleTypeAnnotation");
			}
			flowParseFunctionTypeParam(e) {
				let s = null, i = !1, r = null, n = this.startNode(), o = this.lookahead(), h = this.state.type === 78;
				return o.type === 14 || o.type === 17 ? (h && !e && this.raise(g.ThisParamMustBeFirst, n), s = this.parseIdentifier(h), this.eat(17) && (i = !0, h && this.raise(g.ThisParamMayNotBeOptional, n)), r = this.flowParseTypeInitialiser()) : r = this.flowParseType(), n.name = s, n.optional = i, n.typeAnnotation = r, this.finishNode(n, "FunctionTypeParam");
			}
			reinterpretTypeAsFunctionTypeParam(e) {
				let s = this.startNodeAt(e.loc.start);
				return s.name = null, s.optional = !1, s.typeAnnotation = e, this.finishNode(s, "FunctionTypeParam");
			}
			flowParseFunctionTypeParams(e = []) {
				let s = null, i = null;
				for (this.match(78) && (i = this.flowParseFunctionTypeParam(!0), i.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21);) e.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
				return this.eat(21) && (s = this.flowParseFunctionTypeParam(!1)), {
					params: e,
					rest: s,
					_this: i
				};
			}
			flowIdentToTypeAnnotation(e, s, i) {
				switch (i.name) {
					case "any": return this.finishNode(s, "AnyTypeAnnotation");
					case "bool":
					case "boolean": return this.finishNode(s, "BooleanTypeAnnotation");
					case "mixed": return this.finishNode(s, "MixedTypeAnnotation");
					case "empty": return this.finishNode(s, "EmptyTypeAnnotation");
					case "number": return this.finishNode(s, "NumberTypeAnnotation");
					case "string": return this.finishNode(s, "StringTypeAnnotation");
					case "symbol": return this.finishNode(s, "SymbolTypeAnnotation");
					default: return this.checkNotUnderscore(i.name), this.flowParseGenericType(e, i);
				}
			}
			flowParsePrimaryType() {
				let e = this.state.startLoc, s = this.startNode(), i, r, n = !1, o = this.state.noAnonFunctionType;
				switch (this.state.type) {
					case 5: return this.flowParseObjectType({
						allowStatic: !1,
						allowExact: !1,
						allowSpread: !0,
						allowProto: !1,
						allowInexact: !0
					});
					case 6: return this.flowParseObjectType({
						allowStatic: !1,
						allowExact: !0,
						allowSpread: !0,
						allowProto: !1,
						allowInexact: !1
					});
					case 0: return this.state.noAnonFunctionType = !1, r = this.flowParseTupleType(), this.state.noAnonFunctionType = o, r;
					case 47: {
						let h = this.startNode();
						return h.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(10), i = this.flowParseFunctionTypeParams(), h.params = i.params, h.rest = i.rest, h.this = i._this, this.expect(11), this.expect(19), h.returnType = this.flowParseType(), this.finishNode(h, "FunctionTypeAnnotation");
					}
					case 10: {
						let h = this.startNode();
						if (this.next(), !this.match(11) && !this.match(21)) if (w(this.state.type) || this.match(78)) {
							let l = this.lookahead().type;
							n = l !== 17 && l !== 14;
						} else n = !0;
						if (n) {
							if (this.state.noAnonFunctionType = !1, r = this.flowParseType(), this.state.noAnonFunctionType = o, this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19)) return this.expect(11), r;
							this.eat(12);
						}
						return r ? i = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(r)]) : i = this.flowParseFunctionTypeParams(), h.params = i.params, h.rest = i.rest, h.this = i._this, this.expect(11), this.expect(19), h.returnType = this.flowParseType(), h.typeParameters = null, this.finishNode(h, "FunctionTypeAnnotation");
					}
					case 134: return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
					case 85:
					case 86: return s.value = this.match(85), this.next(), this.finishNode(s, "BooleanLiteralTypeAnnotation");
					case 53:
						if (this.state.value === "-") {
							if (this.next(), this.match(135)) return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", s);
							if (this.match(136)) return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", s);
							throw this.raise(g.UnexpectedSubtractionOperand, this.state.startLoc);
						}
						throw this.unexpected();
					case 135: return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
					case 136: return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
					case 88: return this.next(), this.finishNode(s, "VoidTypeAnnotation");
					case 84: return this.next(), this.finishNode(s, "NullLiteralTypeAnnotation");
					case 78: return this.next(), this.finishNode(s, "ThisTypeAnnotation");
					case 55: return this.next(), this.finishNode(s, "ExistsTypeAnnotation");
					case 87: return this.flowParseTypeofType();
					default: if (bt(this.state.type)) {
						let h = z(this.state.type);
						return this.next(), super.createIdentifier(s, h);
					} else if (w(this.state.type)) return this.isContextual(129) ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(e, s, this.parseIdentifier());
				}
				throw this.unexpected();
			}
			flowParsePostfixType() {
				let e = this.state.startLoc, s = this.flowParsePrimaryType(), i = !1;
				for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon();) {
					let r = this.startNodeAt(e), n = this.eat(18);
					i = i || n, this.expect(0), !n && this.match(3) ? (r.elementType = s, this.next(), s = this.finishNode(r, "ArrayTypeAnnotation")) : (r.objectType = s, r.indexType = this.flowParseType(), this.expect(3), i ? (r.optional = n, s = this.finishNode(r, "OptionalIndexedAccessType")) : s = this.finishNode(r, "IndexedAccessType"));
				}
				return s;
			}
			flowParsePrefixType() {
				let e = this.startNode();
				return this.eat(17) ? (e.typeAnnotation = this.flowParsePrefixType(), this.finishNode(e, "NullableTypeAnnotation")) : this.flowParsePostfixType();
			}
			flowParseAnonFunctionWithoutParens() {
				let e = this.flowParsePrefixType();
				if (!this.state.noAnonFunctionType && this.eat(19)) {
					let s = this.startNodeAt(e.loc.start);
					return s.params = [this.reinterpretTypeAsFunctionTypeParam(e)], s.rest = null, s.this = null, s.returnType = this.flowParseType(), s.typeParameters = null, this.finishNode(s, "FunctionTypeAnnotation");
				}
				return e;
			}
			flowParseIntersectionType() {
				let e = this.startNode();
				this.eat(45);
				let s = this.flowParseAnonFunctionWithoutParens();
				for (e.types = [s]; this.eat(45);) e.types.push(this.flowParseAnonFunctionWithoutParens());
				return e.types.length === 1 ? s : this.finishNode(e, "IntersectionTypeAnnotation");
			}
			flowParseUnionType() {
				let e = this.startNode();
				this.eat(43);
				let s = this.flowParseIntersectionType();
				for (e.types = [s]; this.eat(43);) e.types.push(this.flowParseIntersectionType());
				return e.types.length === 1 ? s : this.finishNode(e, "UnionTypeAnnotation");
			}
			flowParseType() {
				let e = this.state.inType;
				this.state.inType = !0;
				let s = this.flowParseUnionType();
				return this.state.inType = e, s;
			}
			flowParseTypeOrImplicitInstantiation() {
				if (this.state.type === 132 && this.state.value === "_") {
					let e = this.state.startLoc, s = this.parseIdentifier();
					return this.flowParseGenericType(e, s);
				} else return this.flowParseType();
			}
			flowParseTypeAnnotation() {
				let e = this.startNode();
				return e.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(e, "TypeAnnotation");
			}
			flowParseTypeAnnotatableIdentifier(e) {
				let s = e ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
				return this.match(14) && (s.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(s)), s;
			}
			typeCastToParameter(e) {
				return e.expression.typeAnnotation = e.typeAnnotation, this.resetEndLocation(e.expression, e.typeAnnotation.loc.end), e.expression;
			}
			flowParseVariance() {
				let e = null;
				return this.match(53) ? (e = this.startNode(), this.state.value === "+" ? e.kind = "plus" : e.kind = "minus", this.next(), this.finishNode(e, "Variance")) : e;
			}
			parseFunctionBody(e, s, i = !1) {
				if (s) {
					this.forwardNoArrowParamsConversionAt(e, () => super.parseFunctionBody(e, !0, i));
					return;
				}
				super.parseFunctionBody(e, !1, i);
			}
			parseFunctionBodyAndFinish(e, s, i = !1) {
				if (this.match(14)) {
					let r = this.startNode();
					[r.typeAnnotation, e.predicate] = this.flowParseTypeAndPredicateInitialiser(), e.returnType = r.typeAnnotation ? this.finishNode(r, "TypeAnnotation") : null;
				}
				return super.parseFunctionBodyAndFinish(e, s, i);
			}
			parseStatementLike(e) {
				if (this.state.strict && this.isContextual(129)) {
					if (O(this.lookahead().type)) {
						let r = this.startNode();
						return this.next(), this.flowParseInterface(r);
					}
				} else if (this.isContextual(126)) {
					let i = this.startNode();
					return this.next(), this.flowParseEnumDeclaration(i);
				}
				let s = super.parseStatementLike(e);
				return this.flowPragma === void 0 && !this.isValidDirective(s) && (this.flowPragma = null), s;
			}
			parseExpressionStatement(e, s, i) {
				if (s.type === "Identifier") {
					if (s.name === "declare") {
						if (this.match(80) || w(this.state.type) || this.match(68) || this.match(74) || this.match(82)) return this.flowParseDeclare(e);
					} else if (w(this.state.type)) {
						if (s.name === "interface") return this.flowParseInterface(e);
						if (s.name === "type") return this.flowParseTypeAlias(e);
						if (s.name === "opaque") return this.flowParseOpaqueType(e, !1);
					}
				}
				return super.parseExpressionStatement(e, s, i);
			}
			shouldParseExportDeclaration() {
				let { type: e } = this.state;
				return e === 126 || Rt(e) ? !this.state.containsEsc : super.shouldParseExportDeclaration();
			}
			isExportDefaultSpecifier() {
				let { type: e } = this.state;
				return e === 126 || Rt(e) ? this.state.containsEsc : super.isExportDefaultSpecifier();
			}
			parseExportDefaultExpression() {
				if (this.isContextual(126)) {
					let e = this.startNode();
					return this.next(), this.flowParseEnumDeclaration(e);
				}
				return super.parseExportDefaultExpression();
			}
			parseConditional(e, s, i) {
				if (!this.match(17)) return e;
				if (this.state.maybeInArrowParameters) {
					let d = this.lookaheadCharCode();
					if (d === 44 || d === 61 || d === 58 || d === 41) return this.setOptionalParametersError(i), e;
				}
				this.expect(17);
				let r = this.state.clone(), n = this.state.noArrowAt, o = this.startNodeAt(s), { consequent: h, failed: l } = this.tryParseConditionalConsequent(), [u, f] = this.getArrowLikeExpressions(h);
				if (l || f.length > 0) {
					let d = [...n];
					if (f.length > 0) {
						this.state = r, this.state.noArrowAt = d;
						for (let x = 0; x < f.length; x++) d.push(f[x].start);
						({consequent: h, failed: l} = this.tryParseConditionalConsequent()), [u, f] = this.getArrowLikeExpressions(h);
					}
					l && u.length > 1 && this.raise(g.AmbiguousConditionalArrow, r.startLoc), l && u.length === 1 && (this.state = r, d.push(u[0].start), this.state.noArrowAt = d, {consequent: h, failed: l} = this.tryParseConditionalConsequent());
				}
				return this.getArrowLikeExpressions(h, !0), this.state.noArrowAt = n, this.expect(14), o.test = e, o.consequent = h, o.alternate = this.forwardNoArrowParamsConversionAt(o, () => this.parseMaybeAssign(void 0, void 0)), this.finishNode(o, "ConditionalExpression");
			}
			tryParseConditionalConsequent() {
				this.state.noArrowParamsConversionAt.push(this.state.start);
				let e = this.parseMaybeAssignAllowIn(), s = !this.match(14);
				return this.state.noArrowParamsConversionAt.pop(), {
					consequent: e,
					failed: s
				};
			}
			getArrowLikeExpressions(e, s) {
				let i = [e], r = [];
				for (; i.length !== 0;) {
					let n = i.pop();
					n.type === "ArrowFunctionExpression" && n.body.type !== "BlockStatement" ? (n.typeParameters || !n.returnType ? this.finishArrowValidation(n) : r.push(n), i.push(n.body)) : n.type === "ConditionalExpression" && (i.push(n.consequent), i.push(n.alternate));
				}
				return s ? (r.forEach((n) => this.finishArrowValidation(n)), [r, []]) : Fi(r, (n) => n.params.every((o) => this.isAssignable(o, !0)));
			}
			finishArrowValidation(e) {
				this.toAssignableList(e.params, e.extra?.trailingCommaLoc, !1), this.scope.enter(518), super.checkParams(e, !1, !0), this.scope.exit();
			}
			forwardNoArrowParamsConversionAt(e, s) {
				let i;
				return this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(e.start)) ? (this.state.noArrowParamsConversionAt.push(this.state.start), i = s(), this.state.noArrowParamsConversionAt.pop()) : i = s(), i;
			}
			parseParenItem(e, s) {
				let i = super.parseParenItem(e, s);
				if (this.eat(17) && (i.optional = !0, this.resetEndLocation(e)), this.match(14)) {
					let r = this.startNodeAt(s);
					return r.expression = i, r.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(r, "TypeCastExpression");
				}
				return i;
			}
			assertModuleNodeAllowed(e) {
				e.type === "ImportDeclaration" && (e.importKind === "type" || e.importKind === "typeof") || e.type === "ExportNamedDeclaration" && e.exportKind === "type" || e.type === "ExportAllDeclaration" && e.exportKind === "type" || super.assertModuleNodeAllowed(e);
			}
			parseExportDeclaration(e) {
				if (this.isContextual(130)) {
					e.exportKind = "type";
					let s = this.startNode();
					return this.next(), this.match(5) ? (e.specifiers = this.parseExportSpecifiers(!0), super.parseExportFrom(e), null) : this.flowParseTypeAlias(s);
				} else if (this.isContextual(131)) {
					e.exportKind = "type";
					let s = this.startNode();
					return this.next(), this.flowParseOpaqueType(s, !1);
				} else if (this.isContextual(129)) {
					e.exportKind = "type";
					let s = this.startNode();
					return this.next(), this.flowParseInterface(s);
				} else if (this.isContextual(126)) {
					e.exportKind = "value";
					let s = this.startNode();
					return this.next(), this.flowParseEnumDeclaration(s);
				} else return super.parseExportDeclaration(e);
			}
			eatExportStar(e) {
				return super.eatExportStar(e) ? !0 : this.isContextual(130) && this.lookahead().type === 55 ? (e.exportKind = "type", this.next(), this.next(), !0) : !1;
			}
			maybeParseExportNamespaceSpecifier(e) {
				let { startLoc: s } = this.state, i = super.maybeParseExportNamespaceSpecifier(e);
				return i && e.exportKind === "type" && this.unexpected(s), i;
			}
			parseClassId(e, s, i) {
				super.parseClassId(e, s, i), this.match(47) && (e.typeParameters = this.flowParseTypeParameterDeclaration());
			}
			parseClassMember(e, s, i) {
				let { startLoc: r } = this.state;
				if (this.isContextual(125)) {
					if (super.parseClassMemberFromModifier(e, s)) return;
					s.declare = !0;
				}
				super.parseClassMember(e, s, i), s.declare && (s.type !== "ClassProperty" && s.type !== "ClassPrivateProperty" && s.type !== "PropertyDefinition" ? this.raise(g.DeclareClassElement, r) : s.value && this.raise(g.DeclareClassFieldInitializer, s.value));
			}
			isIterator(e) {
				return e === "iterator" || e === "asyncIterator";
			}
			readIterator() {
				let e = super.readWord1(), s = "@@" + e;
				(!this.isIterator(e) || !this.state.inType) && this.raise(p.InvalidIdentifier, this.state.curPosition(), { identifierName: s }), this.finishToken(132, s);
			}
			getTokenFromCode(e) {
				let s = this.input.charCodeAt(this.state.pos + 1);
				e === 123 && s === 124 ? this.finishOp(6, 2) : this.state.inType && (e === 62 || e === 60) ? this.finishOp(e === 62 ? 48 : 47, 1) : this.state.inType && e === 63 ? s === 46 ? this.finishOp(18, 2) : this.finishOp(17, 1) : ki(e, s, this.input.charCodeAt(this.state.pos + 2)) ? (this.state.pos += 2, this.readIterator()) : super.getTokenFromCode(e);
			}
			isAssignable(e, s) {
				return e.type === "TypeCastExpression" ? this.isAssignable(e.expression, s) : super.isAssignable(e, s);
			}
			toAssignable(e, s = !1) {
				!s && e.type === "AssignmentExpression" && e.left.type === "TypeCastExpression" && (e.left = this.typeCastToParameter(e.left)), super.toAssignable(e, s);
			}
			toAssignableList(e, s, i) {
				for (let r = 0; r < e.length; r++) {
					let n = e[r];
					n?.type === "TypeCastExpression" && (e[r] = this.typeCastToParameter(n));
				}
				super.toAssignableList(e, s, i);
			}
			toReferencedList(e, s) {
				for (let i = 0; i < e.length; i++) {
					let r = e[i];
					r && r.type === "TypeCastExpression" && !r.extra?.parenthesized && (e.length > 1 || !s) && this.raise(g.TypeCastInPattern, r.typeAnnotation);
				}
				return e;
			}
			parseArrayLike(e, s, i) {
				let r = super.parseArrayLike(e, s, i);
				return i != null && !this.state.maybeInArrowParameters && this.toReferencedList(r.elements), r;
			}
			isValidLVal(e, s, i, r) {
				return e === "TypeCastExpression" || super.isValidLVal(e, s, i, r);
			}
			parseClassProperty(e) {
				return this.match(14) && (e.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(e);
			}
			parseClassPrivateProperty(e) {
				return this.match(14) && (e.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(e);
			}
			isClassMethod() {
				return this.match(47) || super.isClassMethod();
			}
			isClassProperty() {
				return this.match(14) || super.isClassProperty();
			}
			isNonstaticConstructor(e) {
				return !this.match(14) && super.isNonstaticConstructor(e);
			}
			pushClassMethod(e, s, i, r, n, o) {
				if (s.variance && this.unexpected(s.variance.loc.start), delete s.variance, this.match(47) && (s.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassMethod(e, s, i, r, n, o), s.params && n) {
					let h = s.params;
					h.length > 0 && this.isThisParam(h[0]) && this.raise(g.ThisParamBannedInConstructor, s);
				} else if (s.type === "MethodDefinition" && n && s.value.params) {
					let h = s.value.params;
					h.length > 0 && this.isThisParam(h[0]) && this.raise(g.ThisParamBannedInConstructor, s);
				}
			}
			pushClassPrivateMethod(e, s, i, r) {
				s.variance && this.unexpected(s.variance.loc.start), delete s.variance, this.match(47) && (s.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassPrivateMethod(e, s, i, r);
			}
			parseClassSuper(e) {
				if (super.parseClassSuper(e), e.superClass && (this.match(47) || this.match(51)) && (e.superTypeArguments = this.flowParseTypeParameterInstantiationInExpression()), this.isContextual(113)) {
					this.next();
					let s = e.implements = [];
					do {
						let i = this.startNode();
						i.id = this.flowParseRestrictedIdentifier(!0), this.match(47) ? i.typeParameters = this.flowParseTypeParameterInstantiation() : i.typeParameters = null, s.push(this.finishNode(i, "ClassImplements"));
					} while (this.eat(12));
				}
			}
			checkGetterSetterParams(e) {
				super.checkGetterSetterParams(e);
				let s = this.getObjectOrClassMethodParams(e);
				if (s.length > 0) {
					let i = s[0];
					this.isThisParam(i) && e.kind === "get" ? this.raise(g.GetterMayNotHaveThisParam, i) : this.isThisParam(i) && this.raise(g.SetterMayNotHaveThisParam, i);
				}
			}
			parsePropertyNamePrefixOperator(e) {
				e.variance = this.flowParseVariance();
			}
			parseObjPropValue(e, s, i, r, n, o, h) {
				e.variance && this.unexpected(e.variance.loc.start), delete e.variance;
				let l;
				this.match(47) && !o && (l = this.flowParseTypeParameterDeclaration(), this.match(10) || this.unexpected());
				let u = super.parseObjPropValue(e, s, i, r, n, o, h);
				return l && ((u.value || u).typeParameters = l), u;
			}
			parseFunctionParamType(e) {
				return this.eat(17) && (e.type !== "Identifier" && this.raise(g.PatternIsOptional, e), this.isThisParam(e) && this.raise(g.ThisParamMayNotBeOptional, e), e.optional = !0), this.match(14) ? e.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(e) && this.raise(g.ThisParamAnnotationRequired, e), this.match(29) && this.isThisParam(e) && this.raise(g.ThisParamNoDefault, e), this.resetEndLocation(e), e;
			}
			parseMaybeDefault(e, s) {
				let i = super.parseMaybeDefault(e, s);
				return i.type === "AssignmentPattern" && i.typeAnnotation && i.right.start < i.typeAnnotation.start && this.raise(g.TypeBeforeInitializer, i.typeAnnotation), i;
			}
			checkImportReflection(e) {
				super.checkImportReflection(e), e.module && e.importKind !== "value" && this.raise(g.ImportReflectionHasImportType, e.specifiers[0].loc.start);
			}
			parseImportSpecifierLocal(e, s, i) {
				s.local = Ut(e) ? this.flowParseRestrictedIdentifier(!0, !0) : this.parseIdentifier(), e.specifiers.push(this.finishImportSpecifier(s, i));
			}
			isPotentialImportPhase(e) {
				if (super.isPotentialImportPhase(e)) return !0;
				if (this.isContextual(130)) {
					if (!e) return !0;
					let s = this.lookaheadCharCode();
					return s === 123 || s === 42;
				}
				return !e && this.isContextual(87);
			}
			applyImportPhase(e, s, i, r) {
				if (super.applyImportPhase(e, s, i, r), s) {
					if (!i && this.match(65)) return;
					e.exportKind = i === "type" ? i : "value";
				} else i === "type" && this.match(55) && this.unexpected(), e.importKind = i === "type" || i === "typeof" ? i : "value";
			}
			parseImportSpecifier(e, s, i, r, n) {
				let o = e.imported, h = null;
				o.type === "Identifier" && (o.name === "type" ? h = "type" : o.name === "typeof" && (h = "typeof"));
				let l = !1;
				if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
					let f = this.parseIdentifier(!0);
					h !== null && !O(this.state.type) ? (e.imported = f, e.importKind = h, e.local = this.cloneIdentifier(f)) : (e.imported = o, e.importKind = null, e.local = this.parseIdentifier());
				} else {
					if (h !== null && O(this.state.type)) e.imported = this.parseIdentifier(!0), e.importKind = h;
					else {
						if (s) throw this.raise(p.ImportBindingIsString, e, { importName: o.value });
						e.imported = o, e.importKind = null;
					}
					this.eatContextual(93) ? e.local = this.parseIdentifier() : (l = !0, e.local = this.cloneIdentifier(e.imported));
				}
				let u = Ut(e);
				return i && u && this.raise(g.ImportTypeShorthandOnlyInPureImport, e), (i || u) && this.checkReservedType(e.local.name, e.local.loc.start, !0), l && !i && !u && this.checkReservedWord(e.local.name, e.loc.start, !0, !0), this.finishImportSpecifier(e, "ImportSpecifier");
			}
			parseBindingAtom() {
				switch (this.state.type) {
					case 78: return this.parseIdentifier(!0);
					default: return super.parseBindingAtom();
				}
			}
			parseFunctionParams(e, s) {
				let i = e.kind;
				i !== "get" && i !== "set" && this.match(47) && (e.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(e, s);
			}
			parseVarId(e, s) {
				super.parseVarId(e, s), this.match(14) && (e.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(e.id));
			}
			parseAsyncArrowFromCallExpression(e, s) {
				if (this.match(14)) {
					let i = this.state.noAnonFunctionType;
					this.state.noAnonFunctionType = !0, e.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = i;
				}
				return super.parseAsyncArrowFromCallExpression(e, s);
			}
			shouldParseAsyncArrow() {
				return this.match(14) || super.shouldParseAsyncArrow();
			}
			parseMaybeAssign(e, s) {
				let i = null, r;
				if (this.hasPlugin("jsx") && (this.match(143) || this.match(47))) {
					if (i = this.state.clone(), r = this.tryParse(() => super.parseMaybeAssign(e, s), i), !r.error) return r.node;
					let { context: n } = this.state, o = n[n.length - 1];
					(o === E.j_oTag || o === E.j_expr) && n.pop();
				}
				if (r?.error || this.match(47)) {
					i = i || this.state.clone();
					let n, o = this.tryParse((l) => {
						n = this.flowParseTypeParameterDeclaration();
						let u = this.forwardNoArrowParamsConversionAt(n, () => {
							let d = super.parseMaybeAssign(e, s);
							return this.resetStartLocationFromNode(d, n), d;
						});
						u.extra?.parenthesized && l();
						let f = this.maybeUnwrapTypeCastExpression(u);
						return f.type !== "ArrowFunctionExpression" && l(), f.typeParameters = n, this.resetStartLocationFromNode(f, n), u;
					}, i), h = null;
					if (o.node && this.maybeUnwrapTypeCastExpression(o.node).type === "ArrowFunctionExpression") {
						if (!o.error && !o.aborted) return o.node.async && this.raise(g.UnexpectedTypeParameterBeforeAsyncArrowFunction, n), o.node;
						h = o.node;
					}
					if (r?.node) return this.state = r.failState, r.node;
					if (h) return this.state = o.failState, h;
					throw r?.thrown ? r.error : o.thrown ? o.error : this.raise(g.UnexpectedTokenAfterTypeParameter, n);
				}
				return super.parseMaybeAssign(e, s);
			}
			parseArrow(e) {
				if (this.match(14)) {
					let s = this.tryParse(() => {
						let i = this.state.noAnonFunctionType;
						this.state.noAnonFunctionType = !0;
						let r = this.startNode();
						return [r.typeAnnotation, e.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = i, this.canInsertSemicolon() && this.unexpected(), this.match(19) || this.unexpected(), r;
					});
					if (s.thrown) return null;
					s.error && (this.state = s.failState), e.returnType = s.node.typeAnnotation ? this.finishNode(s.node, "TypeAnnotation") : null;
				}
				return super.parseArrow(e);
			}
			shouldParseArrow(e) {
				return this.match(14) || super.shouldParseArrow(e);
			}
			setArrowFunctionParameters(e, s) {
				this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(e.start)) ? e.params = s : super.setArrowFunctionParameters(e, s);
			}
			checkParams(e, s, i, r = !0) {
				if (!(i && this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(e.start)))) {
					for (let n = 0; n < e.params.length; n++) this.isThisParam(e.params[n]) && n > 0 && this.raise(g.ThisParamMustBeFirst, e.params[n]);
					super.checkParams(e, s, i, r);
				}
			}
			parseParenAndDistinguishExpression(e) {
				return super.parseParenAndDistinguishExpression(e && !this.state.noArrowAt.includes(this.sourceToOffsetPos(this.state.start)));
			}
			parseSubscripts(e, s, i) {
				if (e.type === "Identifier" && e.name === "async" && this.state.noArrowAt.includes(s.index)) {
					this.next();
					let r = this.startNodeAt(s);
					r.callee = e, r.arguments = super.parseCallExpressionArguments(), e = this.finishNode(r, "CallExpression");
				} else if (e.type === "Identifier" && e.name === "async" && this.match(47)) {
					let r = this.state.clone(), n = this.tryParse((h) => this.parseAsyncArrowWithTypeParameters(s) || h(), r);
					if (!n.error && !n.aborted) return n.node;
					let o = this.tryParse(() => super.parseSubscripts(e, s, i), r);
					if (o.node && !o.error) return o.node;
					if (n.node) return this.state = n.failState, n.node;
					if (o.node) return this.state = o.failState, o.node;
					throw n.error || o.error;
				}
				return super.parseSubscripts(e, s, i);
			}
			parseSubscript(e, s, i, r) {
				if (this.match(18) && this.isLookaheadToken_lt()) {
					if (r.optionalChainMember = !0, i) return r.stop = !0, e;
					this.next();
					let n = this.startNodeAt(s);
					return n.callee = e, n.typeArguments = this.flowParseTypeParameterInstantiationInExpression(), this.expect(10), n.arguments = this.parseCallExpressionArguments(), n.optional = !0, this.finishCallExpression(n, !0);
				} else if (!i && this.shouldParseTypes() && (this.match(47) || this.match(51))) {
					let n = this.startNodeAt(s);
					n.callee = e;
					let o = this.tryParse(() => (n.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(10), n.arguments = super.parseCallExpressionArguments(), r.optionalChainMember && (n.optional = !1), this.finishCallExpression(n, r.optionalChainMember)));
					if (o.node) return o.error && (this.state = o.failState), o.node;
				}
				return super.parseSubscript(e, s, i, r);
			}
			parseNewCallee(e) {
				super.parseNewCallee(e);
				let s = null;
				this.shouldParseTypes() && this.match(47) && (s = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), e.typeArguments = s;
			}
			parseAsyncArrowWithTypeParameters(e) {
				let s = this.startNodeAt(e);
				if (this.parseFunctionParams(s, !1), !!this.parseArrow(s)) return super.parseArrowExpression(s, void 0, !0);
			}
			readToken_mult_modulo(e) {
				let s = this.input.charCodeAt(this.state.pos + 1);
				if (e === 42 && s === 47 && this.state.hasFlowComment) {
					this.state.hasFlowComment = !1, this.state.pos += 2, this.nextToken();
					return;
				}
				super.readToken_mult_modulo(e);
			}
			readToken_pipe_amp(e) {
				let s = this.input.charCodeAt(this.state.pos + 1);
				if (e === 124 && s === 125) {
					this.finishOp(9, 2);
					return;
				}
				super.readToken_pipe_amp(e);
			}
			parseTopLevel(e, s) {
				let i = super.parseTopLevel(e, s);
				return this.state.hasFlowComment && this.raise(g.UnterminatedFlowComment, this.state.curPosition()), i;
			}
			skipBlockComment() {
				if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
					if (this.state.hasFlowComment) throw this.raise(g.NestedFlowComment, this.state.startLoc);
					this.hasFlowCommentCompletion();
					let e = this.skipFlowComment();
					e && (this.state.pos += e, this.state.hasFlowComment = !0);
					return;
				}
				return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
			}
			skipFlowComment() {
				let { pos: e } = this.state, s = 2;
				for (; [32, 9].includes(this.input.charCodeAt(e + s));) s++;
				let i = this.input.charCodeAt(s + e), r = this.input.charCodeAt(s + e + 1);
				return i === 58 && r === 58 ? s + 2 : this.input.slice(s + e, s + e + 12) === "flow-include" ? s + 12 : i === 58 && r !== 58 ? s : !1;
			}
			hasFlowCommentCompletion() {
				if (this.input.indexOf("*/", this.state.pos) === -1) throw this.raise(p.UnterminatedComment, this.state.curPosition());
			}
			flowEnumErrorBooleanMemberNotInitialized(e, { enumName: s, memberName: i }) {
				this.raise(g.EnumBooleanMemberNotInitialized, e, {
					memberName: i,
					enumName: s
				});
			}
			flowEnumErrorInvalidMemberInitializer(e, s) {
				return this.raise(s.explicitType ? s.explicitType === "symbol" ? g.EnumInvalidMemberInitializerSymbolType : g.EnumInvalidMemberInitializerPrimaryType : g.EnumInvalidMemberInitializerUnknownType, e, s);
			}
			flowEnumErrorNumberMemberNotInitialized(e, s) {
				this.raise(g.EnumNumberMemberNotInitialized, e, s);
			}
			flowEnumErrorStringMemberInconsistentlyInitialized(e, s) {
				this.raise(g.EnumStringMemberInconsistentlyInitialized, e, s);
			}
			flowEnumMemberInit() {
				let e = this.state.startLoc, s = () => this.match(12) || this.match(8);
				switch (this.state.type) {
					case 135: {
						let i = this.parseNumericLiteral(this.state.value);
						return s() ? {
							type: "number",
							loc: i.loc.start,
							value: i
						} : {
							type: "invalid",
							loc: e
						};
					}
					case 134: {
						let i = this.parseStringLiteral(this.state.value);
						return s() ? {
							type: "string",
							loc: i.loc.start,
							value: i
						} : {
							type: "invalid",
							loc: e
						};
					}
					case 85:
					case 86: {
						let i = this.parseBooleanLiteral(this.match(85));
						return s() ? {
							type: "boolean",
							loc: i.loc.start,
							value: i
						} : {
							type: "invalid",
							loc: e
						};
					}
					default: return {
						type: "invalid",
						loc: e
					};
				}
			}
			flowEnumMemberRaw() {
				let e = this.state.startLoc;
				return {
					id: this.parseIdentifier(!0),
					init: this.eat(29) ? this.flowEnumMemberInit() : {
						type: "none",
						loc: e
					}
				};
			}
			flowEnumCheckExplicitTypeMismatch(e, s, i) {
				let { explicitType: r } = s;
				r !== null && r !== i && this.flowEnumErrorInvalidMemberInitializer(e, s);
			}
			flowEnumMembers({ enumName: e, explicitType: s }) {
				let i = /* @__PURE__ */ new Set(), r = {
					booleanMembers: [],
					numberMembers: [],
					stringMembers: [],
					defaultedMembers: []
				}, n = !1;
				for (; !this.match(8);) {
					if (this.eat(21)) {
						n = !0;
						break;
					}
					let o = this.startNode(), { id: h, init: l } = this.flowEnumMemberRaw(), u = h.name;
					if (u === "") continue;
					/^[a-z]/.test(u) && this.raise(g.EnumInvalidMemberName, h, {
						memberName: u,
						suggestion: u[0].toUpperCase() + u.slice(1),
						enumName: e
					}), i.has(u) && this.raise(g.EnumDuplicateMemberName, h, {
						memberName: u,
						enumName: e
					}), i.add(u);
					let f = {
						enumName: e,
						explicitType: s,
						memberName: u
					};
					switch (o.id = h, l.type) {
						case "boolean":
							this.flowEnumCheckExplicitTypeMismatch(l.loc, f, "boolean"), o.init = l.value, r.booleanMembers.push(this.finishNode(o, "EnumBooleanMember"));
							break;
						case "number":
							this.flowEnumCheckExplicitTypeMismatch(l.loc, f, "number"), o.init = l.value, r.numberMembers.push(this.finishNode(o, "EnumNumberMember"));
							break;
						case "string":
							this.flowEnumCheckExplicitTypeMismatch(l.loc, f, "string"), o.init = l.value, r.stringMembers.push(this.finishNode(o, "EnumStringMember"));
							break;
						case "invalid": throw this.flowEnumErrorInvalidMemberInitializer(l.loc, f);
						case "none": switch (s) {
							case "boolean":
								this.flowEnumErrorBooleanMemberNotInitialized(l.loc, f);
								break;
							case "number":
								this.flowEnumErrorNumberMemberNotInitialized(l.loc, f);
								break;
							default: r.defaultedMembers.push(this.finishNode(o, "EnumDefaultedMember"));
						}
					}
					this.match(8) || this.expect(12);
				}
				return {
					members: r,
					hasUnknownMembers: n
				};
			}
			flowEnumStringMembers(e, s, { enumName: i }) {
				if (e.length === 0) return s;
				if (s.length === 0) return e;
				if (s.length > e.length) {
					for (let r of e) this.flowEnumErrorStringMemberInconsistentlyInitialized(r, { enumName: i });
					return s;
				} else {
					for (let r of s) this.flowEnumErrorStringMemberInconsistentlyInitialized(r, { enumName: i });
					return e;
				}
			}
			flowEnumParseExplicitType({ enumName: e }) {
				if (!this.eatContextual(102)) return null;
				if (!w(this.state.type)) throw this.raise(g.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, { enumName: e });
				let { value: s } = this.state;
				return this.next(), s !== "boolean" && s !== "number" && s !== "string" && s !== "symbol" && this.raise(g.EnumInvalidExplicitType, this.state.startLoc, {
					enumName: e,
					invalidEnumType: s
				}), s;
			}
			flowEnumBody(e, s) {
				let i = s.name, r = s.loc.start, n = this.flowEnumParseExplicitType({ enumName: i });
				this.expect(5);
				let { members: o, hasUnknownMembers: h } = this.flowEnumMembers({
					enumName: i,
					explicitType: n
				});
				switch (e.hasUnknownMembers = h, n) {
					case "boolean": return e.explicitType = !0, e.members = o.booleanMembers, this.expect(8), this.finishNode(e, "EnumBooleanBody");
					case "number": return e.explicitType = !0, e.members = o.numberMembers, this.expect(8), this.finishNode(e, "EnumNumberBody");
					case "string": return e.explicitType = !0, e.members = this.flowEnumStringMembers(o.stringMembers, o.defaultedMembers, { enumName: i }), this.expect(8), this.finishNode(e, "EnumStringBody");
					case "symbol": return e.members = o.defaultedMembers, this.expect(8), this.finishNode(e, "EnumSymbolBody");
					default: {
						let l = () => (e.members = [], this.expect(8), this.finishNode(e, "EnumStringBody"));
						e.explicitType = !1;
						let u = o.booleanMembers.length, f = o.numberMembers.length, d = o.stringMembers.length, x = o.defaultedMembers.length;
						if (!u && !f && !d && !x) return l();
						if (!u && !f) return e.members = this.flowEnumStringMembers(o.stringMembers, o.defaultedMembers, { enumName: i }), this.expect(8), this.finishNode(e, "EnumStringBody");
						if (!f && !d && u >= x) {
							for (let A of o.defaultedMembers) this.flowEnumErrorBooleanMemberNotInitialized(A.loc.start, {
								enumName: i,
								memberName: A.id.name
							});
							return e.members = o.booleanMembers, this.expect(8), this.finishNode(e, "EnumBooleanBody");
						} else if (!u && !d && f >= x) {
							for (let A of o.defaultedMembers) this.flowEnumErrorNumberMemberNotInitialized(A.loc.start, {
								enumName: i,
								memberName: A.id.name
							});
							return e.members = o.numberMembers, this.expect(8), this.finishNode(e, "EnumNumberBody");
						} else return this.raise(g.EnumInconsistentMemberValues, r, { enumName: i }), l();
					}
				}
			}
			flowParseEnumDeclaration(e) {
				let s = this.parseIdentifier();
				return e.id = s, e.body = this.flowEnumBody(this.startNode(), s), this.finishNode(e, "EnumDeclaration");
			}
			jsxParseOpeningElementAfterName(e) {
				return this.shouldParseTypes() && (this.match(47) || this.match(51)) && (e.typeArguments = this.flowParseTypeParameterInstantiationInExpression()), super.jsxParseOpeningElementAfterName(e);
			}
			isLookaheadToken_lt() {
				let e = this.nextTokenStart();
				if (this.input.charCodeAt(e) === 60) {
					let s = this.input.charCodeAt(e + 1);
					return s !== 60 && s !== 61;
				}
				return !1;
			}
			reScan_lt_gt() {
				let { type: e } = this.state;
				e === 47 ? (this.state.pos -= 1, this.readToken_lt()) : e === 48 && (this.state.pos -= 1, this.readToken_gt());
			}
			reScan_lt() {
				let { type: e } = this.state;
				return e === 51 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : e;
			}
			maybeUnwrapTypeCastExpression(e) {
				return e.type === "TypeCastExpression" ? e.expression : e;
			}
		};
		var ge = new RegExp(/\r\n|[\r\n\u2028\u2029]/.source, "g");
		function G(a) {
			switch (a) {
				case 10:
				case 13:
				case 8232:
				case 8233: return !0;
				default: return !1;
			}
		}
		function _t(a, t, e) {
			for (let s = t; s < e; s++) if (G(a.charCodeAt(s))) return !0;
			return !1;
		}
		var je = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, Ve = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g;
		function _i(a) {
			switch (a) {
				case 9:
				case 11:
				case 12:
				case 32:
				case 160:
				case 5760:
				case 8192:
				case 8193:
				case 8194:
				case 8195:
				case 8196:
				case 8197:
				case 8198:
				case 8199:
				case 8200:
				case 8201:
				case 8202:
				case 8239:
				case 8287:
				case 12288:
				case 65279: return !0;
				default: return !1;
			}
		}
		var U = F`jsx`({
			AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
			MissingClosingTagElement: ({ openingTagName: a }) => `Expected corresponding JSX closing tag for <${a}>.`,
			MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
			UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
			UnexpectedToken: ({ unexpected: a, HTMLEntity: t }) => `Unexpected token \`${a}\`. Did you mean \`${t}\` or \`{'${a}'}\`?`,
			UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
			UnterminatedJsxContent: "Unterminated JSX contents.",
			UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
		});
		function V(a) {
			return a ? a.type === "JSXOpeningFragment" || a.type === "JSXClosingFragment" : !1;
		}
		function J(a) {
			if (a.type === "JSXIdentifier") return a.name;
			if (a.type === "JSXNamespacedName") return a.namespace.name + ":" + a.name.name;
			if (a.type === "JSXMemberExpression") return J(a.object) + "." + J(a.property);
			throw new Error("Node had unexpected type: " + a.type);
		}
		var ji = (a) => class extends a {
			jsxReadToken() {
				let e = "", s = this.state.pos;
				for (;;) {
					if (this.state.pos >= this.length) throw this.raise(U.UnterminatedJsxContent, this.state.startLoc);
					let i = this.input.charCodeAt(this.state.pos);
					switch (i) {
						case 60:
						case 123:
							if (this.state.pos === this.state.start) {
								i === 60 && this.state.canStartJSXElement ? (++this.state.pos, this.finishToken(143)) : super.getTokenFromCode(i);
								return;
							}
							e += this.input.slice(s, this.state.pos), this.finishToken(142, e);
							return;
						case 38:
							e += this.input.slice(s, this.state.pos), e += this.jsxReadEntity(), s = this.state.pos;
							break;
						case 62:
						case 125: this.raise(U.UnexpectedToken, this.state.curPosition(), {
							unexpected: this.input[this.state.pos],
							HTMLEntity: i === 125 ? "&rbrace;" : "&gt;"
						});
						default: G(i) ? (e += this.input.slice(s, this.state.pos), e += this.jsxReadNewLine(!0), s = this.state.pos) : ++this.state.pos;
					}
				}
			}
			jsxReadNewLine(e) {
				let s = this.input.charCodeAt(this.state.pos), i;
				return ++this.state.pos, s === 13 && this.input.charCodeAt(this.state.pos) === 10 ? (++this.state.pos, i = e ? `
` : `\r
`) : i = String.fromCharCode(s), ++this.state.curLine, this.state.lineStart = this.state.pos, i;
			}
			jsxReadString(e) {
				let s = "", i = ++this.state.pos;
				for (;;) {
					if (this.state.pos >= this.length) throw this.raise(p.UnterminatedString, this.state.startLoc);
					let r = this.input.charCodeAt(this.state.pos);
					if (r === e) break;
					r === 38 ? (s += this.input.slice(i, this.state.pos), s += this.jsxReadEntity(), i = this.state.pos) : G(r) ? (s += this.input.slice(i, this.state.pos), s += this.jsxReadNewLine(!1), i = this.state.pos) : ++this.state.pos;
				}
				s += this.input.slice(i, this.state.pos++), this.finishToken(134, s);
			}
			jsxReadEntity() {
				let e = ++this.state.pos;
				if (this.codePointAtPos(this.state.pos) === 35) {
					++this.state.pos;
					let s = 10;
					this.codePointAtPos(this.state.pos) === 120 && (s = 16, ++this.state.pos);
					let i = this.readInt(s, void 0, !1, "bail");
					if (i !== null && this.codePointAtPos(this.state.pos) === 59) return ++this.state.pos, String.fromCodePoint(i);
				} else {
					let s = 0, i = !1;
					for (; s++ < 10 && this.state.pos < this.length && !(i = this.codePointAtPos(this.state.pos) === 59);) ++this.state.pos;
					if (i) {
						this.input.slice(e, this.state.pos);
						if (++this.state.pos, void 0);
					}
				}
				return this.state.pos = e, "&";
			}
			jsxReadWord() {
				let e, s = this.state.pos;
				do
					e = this.input.charCodeAt(++this.state.pos);
				while (K(e) || e === 45);
				this.finishToken(141, this.input.slice(s, this.state.pos));
			}
			jsxParseIdentifier() {
				let e = this.startNode();
				return this.match(141) ? e.name = this.state.value : bt(this.state.type) ? e.name = z(this.state.type) : this.unexpected(), this.next(), this.finishNode(e, "JSXIdentifier");
			}
			jsxParseNamespacedName() {
				let e = this.state.startLoc, s = this.jsxParseIdentifier();
				if (!this.eat(14)) return s;
				let i = this.startNodeAt(e);
				return i.namespace = s, i.name = this.jsxParseIdentifier(), this.finishNode(i, "JSXNamespacedName");
			}
			jsxParseElementName() {
				let e = this.state.startLoc, s = this.jsxParseNamespacedName();
				if (s.type === "JSXNamespacedName") return s;
				for (; this.eat(16);) {
					let i = this.startNodeAt(e);
					i.object = s, i.property = this.jsxParseIdentifier(), s = this.finishNode(i, "JSXMemberExpression");
				}
				return s;
			}
			jsxParseAttributeValue() {
				let e;
				switch (this.state.type) {
					case 5: return e = this.startNode(), this.setContext(E.brace), this.next(), e = this.jsxParseExpressionContainer(e, E.j_oTag), e.expression.type === "JSXEmptyExpression" && this.raise(U.AttributeIsEmpty, e), e;
					case 143:
					case 134: return this.parseExprAtom();
					default: throw this.raise(U.UnsupportedJsxValue, this.state.startLoc);
				}
			}
			jsxParseEmptyExpression() {
				let e = this.startNodeAt(this.state.lastTokEndLoc);
				return this.finishNodeAt(e, "JSXEmptyExpression", this.state.startLoc);
			}
			jsxParseSpreadChild(e) {
				return this.next(), e.expression = this.parseExpression(), this.setContext(E.j_expr), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(e, "JSXSpreadChild");
			}
			jsxParseExpressionContainer(e, s) {
				if (this.match(8)) e.expression = this.jsxParseEmptyExpression();
				else {
					let i = this.parseExpression();
					i.type === "SequenceExpression" && !i.extra?.parenthesized && this.raise(U.UnexpectedSequenceExpression, i.expressions[1]), e.expression = i;
				}
				return this.setContext(s), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(e, "JSXExpressionContainer");
			}
			jsxParseAttribute() {
				let e = this.startNode();
				return this.match(5) ? (this.setContext(E.brace), this.next(), this.expect(21), e.argument = this.parseMaybeAssignAllowIn(), this.setContext(E.j_oTag), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(e, "JSXSpreadAttribute")) : (e.name = this.jsxParseNamespacedName(), e.value = this.eat(29) ? this.jsxParseAttributeValue() : null, this.finishNode(e, "JSXAttribute"));
			}
			jsxParseOpeningElementAt(e) {
				let s = this.startNodeAt(e);
				return this.eat(144) ? this.finishNode(s, "JSXOpeningFragment") : (s.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(s));
			}
			jsxParseOpeningElementAfterName(e) {
				let s = [];
				for (; !this.match(56) && !this.match(144);) s.push(this.jsxParseAttribute());
				return e.attributes = s, e.selfClosing = this.eat(56), this.expect(144), this.finishNode(e, "JSXOpeningElement");
			}
			jsxParseClosingElementAt(e) {
				let s = this.startNodeAt(e);
				return this.eat(144) ? this.finishNode(s, "JSXClosingFragment") : (s.name = this.jsxParseElementName(), this.expect(144), this.finishNode(s, "JSXClosingElement"));
			}
			jsxParseElementAt(e) {
				let s = this.startNodeAt(e), i = [], r = this.jsxParseOpeningElementAt(e), n = null;
				if (!r.selfClosing) {
					e: for (;;) switch (this.state.type) {
						case 143:
							if (e = this.state.startLoc, this.next(), this.eat(56)) {
								n = this.jsxParseClosingElementAt(e);
								break e;
							}
							i.push(this.jsxParseElementAt(e));
							break;
						case 142:
							i.push(this.parseLiteral(this.state.value, "JSXText"));
							break;
						case 5: {
							let o = this.startNode();
							this.setContext(E.brace), this.next(), this.match(21) ? i.push(this.jsxParseSpreadChild(o)) : i.push(this.jsxParseExpressionContainer(o, E.j_expr));
							break;
						}
						default: this.unexpected();
					}
					V(r) && !V(n) && n !== null ? this.raise(U.MissingClosingTagFragment, n) : !V(r) && V(n) ? this.raise(U.MissingClosingTagElement, n, { openingTagName: J(r.name) }) : !V(r) && !V(n) && J(n.name) !== J(r.name) && this.raise(U.MissingClosingTagElement, n, { openingTagName: J(r.name) });
				}
				if (V(r) ? (s.openingFragment = r, s.closingFragment = n) : (s.openingElement = r, s.closingElement = n), s.children = i, this.match(47)) throw this.raise(U.UnwrappedAdjacentJSXElements, this.state.startLoc);
				return V(r) ? this.finishNode(s, "JSXFragment") : this.finishNode(s, "JSXElement");
			}
			jsxParseElement() {
				let e = this.state.startLoc;
				return this.next(), this.jsxParseElementAt(e);
			}
			setContext(e) {
				let { context: s } = this.state;
				s[s.length - 1] = e;
			}
			parseExprAtom(e) {
				return this.match(143) ? this.jsxParseElement() : this.match(47) && this.input.charCodeAt(this.state.pos) !== 33 ? (this.replaceToken(143), this.jsxParseElement()) : super.parseExprAtom(e);
			}
			skipSpace() {
				this.curContext().preserveSpace || super.skipSpace();
			}
			getTokenFromCode(e) {
				let s = this.curContext();
				if (s === E.j_expr) {
					this.jsxReadToken();
					return;
				}
				if (s === E.j_oTag || s === E.j_cTag) {
					if (B(e)) {
						this.jsxReadWord();
						return;
					}
					if (e === 62) {
						++this.state.pos, this.finishToken(144);
						return;
					}
					if ((e === 34 || e === 39) && s === E.j_oTag) {
						this.jsxReadString(e);
						return;
					}
				}
				if (e === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
					++this.state.pos, this.finishToken(143);
					return;
				}
				super.getTokenFromCode(e);
			}
			updateContext(e) {
				let { context: s, type: i } = this.state;
				if (i === 56 && e === 143) s.splice(-2, 2, E.j_cTag), this.state.canStartJSXElement = !1;
				else if (i === 143) s.push(E.j_oTag);
				else if (i === 144) {
					let r = s[s.length - 1];
					r === E.j_oTag && e === 56 || r === E.j_cTag ? (s.pop(), this.state.canStartJSXElement = s[s.length - 1] === E.j_expr) : (this.setContext(E.j_expr), this.state.canStartJSXElement = !0);
				} else this.state.canStartJSXElement = fi(i);
			}
		}, Ge = class extends ue {
			tsNames = /* @__PURE__ */ new Map();
		}, Xe = class extends fe {
			importsStack = [];
			createScope(t) {
				return this.importsStack.push(/* @__PURE__ */ new Set()), new Ge(t);
			}
			enter(t) {
				t === 1024 && this.importsStack.push(/* @__PURE__ */ new Set()), super.enter(t);
			}
			exit() {
				let t = super.exit();
				return t === 1024 && this.importsStack.pop(), t;
			}
			hasImport(t, e) {
				let s = this.importsStack.length;
				if (this.importsStack[s - 1].has(t)) return !0;
				if (!e && s > 1) {
					for (let i = 0; i < s - 1; i++) if (this.importsStack[i].has(t)) return !0;
				}
				return !1;
			}
			declareName(t, e, s) {
				if (e & 4096) {
					this.hasImport(t, !0) && this.parser.raise(p.VarRedeclaration, s, { identifierName: t }), this.importsStack[this.importsStack.length - 1].add(t);
					return;
				}
				let i = this.currentScope(), r = i.tsNames.get(t) || 0;
				if (e & 1024) {
					this.maybeExportDefined(i, t), i.tsNames.set(t, r | 16);
					return;
				}
				super.declareName(t, e, s), e & 2 && (e & 1 || (this.checkRedeclarationInScope(i, t, e, s), this.maybeExportDefined(i, t)), r = r | 1), e & 256 && (r = r | 2), e & 512 && (r = r | 4), e & 128 && (r = r | 8), r && i.tsNames.set(t, r);
			}
			isRedeclaredInScope(t, e, s) {
				let i = t.tsNames.get(e);
				if ((i & 2) > 0) {
					if (s & 256) return !!(s & 512) !== (i & 4) > 0;
					return !0;
				}
				return s & 128 && (i & 8) > 0 ? t.names.get(e) & 2 ? !!(s & 1) : !1 : s & 2 && (i & 1) > 0 ? !0 : super.isRedeclaredInScope(t, e, s);
			}
			checkLocalExport(t) {
				let { name: e } = t;
				if (this.hasImport(e)) return;
				let s = this.scopeStack.length;
				for (let i = s - 1; i >= 0; i--) {
					let n = this.scopeStack[i].tsNames.get(e);
					if ((n & 1) > 0 || (n & 16) > 0) return;
				}
				super.checkLocalExport(t);
			}
		}, Ye = class {
			stacks = [];
			enter(t) {
				this.stacks.push(t);
			}
			exit() {
				this.stacks.pop();
			}
			currentFlags() {
				return this.stacks[this.stacks.length - 1];
			}
			get hasAwait() {
				return (this.currentFlags() & 2) > 0;
			}
			get hasYield() {
				return (this.currentFlags() & 1) > 0;
			}
			get hasReturn() {
				return (this.currentFlags() & 4) > 0;
			}
			get hasIn() {
				return (this.currentFlags() & 8) > 0;
			}
		};
		function Se(a, t) {
			return (a ? 2 : 0) | (t ? 1 : 0);
		}
		var Qe = class {
			sawUnambiguousESM = !1;
			ambiguousScriptDifferentAst = !1;
			sourceToOffsetPos(t) {
				return t + this.startIndex;
			}
			offsetToSourcePos(t) {
				return t - this.startIndex;
			}
			hasPlugin(t) {
				if (typeof t == "string") return this.plugins.has(t);
				{
					let [e, s] = t;
					if (!this.hasPlugin(e)) return !1;
					let i = this.plugins.get(e);
					for (let r of Object.keys(s)) if (i?.[r] !== s[r]) return !1;
					return !0;
				}
			}
			getPluginOption(t, e) {
				return this.plugins.get(t)?.[e];
			}
		};
		function is(a, t) {
			a.trailingComments === void 0 ? a.trailingComments = t : a.trailingComments.unshift(...t);
		}
		function Vi(a, t) {
			a.leadingComments === void 0 ? a.leadingComments = t : a.leadingComments.unshift(...t);
		}
		function X(a, t) {
			a.innerComments === void 0 ? a.innerComments = t : a.innerComments.unshift(...t);
		}
		function $(a, t, e) {
			let s = null, i = t.length;
			for (; s === null && i > 0;) s = t[--i];
			s === null || s.start > e.start ? X(a, e.comments) : is(s, e.comments);
		}
		var Ze = class extends Qe {
			addComment(t) {
				this.filename && (t.loc.filename = this.filename);
				let { commentsLen: e } = this.state;
				this.comments.length !== e && (this.comments.length = e), this.comments.push(t), this.state.commentsLen++;
			}
			processComment(t) {
				let { commentStack: e } = this.state, s = e.length;
				if (s === 0) return;
				let i = s - 1, r = e[i];
				r.start === t.end && (r.leadingNode = t, i--);
				let { start: n } = t;
				for (; i >= 0; i--) {
					let o = e[i], h = o.end;
					if (h > n) o.containingNode = t, this.finalizeComment(o), e.splice(i, 1);
					else {
						h === n && (o.trailingNode = t);
						break;
					}
				}
			}
			finalizeComment(t) {
				let { comments: e } = t;
				if (t.leadingNode !== null || t.trailingNode !== null) t.leadingNode !== null && is(t.leadingNode, e), t.trailingNode !== null && Vi(t.trailingNode, e);
				else {
					let s = t.containingNode, i = t.start;
					if (this.input.charCodeAt(this.offsetToSourcePos(i) - 1) === 44) switch (s.type) {
						case "ObjectExpression":
						case "ObjectPattern":
						case "RecordExpression":
							$(s, s.properties, t);
							break;
						case "CallExpression":
						case "OptionalCallExpression":
							$(s, s.arguments, t);
							break;
						case "ImportExpression":
							$(s, [s.source, s.options ?? null], t);
							break;
						case "FunctionDeclaration":
						case "FunctionExpression":
						case "ArrowFunctionExpression":
						case "ObjectMethod":
						case "ClassMethod":
						case "ClassPrivateMethod":
							$(s, s.params, t);
							break;
						case "ArrayExpression":
						case "ArrayPattern":
						case "TupleExpression":
							$(s, s.elements, t);
							break;
						case "ExportNamedDeclaration":
						case "ImportDeclaration":
							$(s, s.specifiers, t);
							break;
						case "TSEnumDeclaration":
							X(s, e);
							break;
						case "TSEnumBody":
							$(s, s.members, t);
							break;
						default: X(s, e);
					}
					else X(s, e);
				}
			}
			finalizeRemainingComments() {
				let { commentStack: t } = this.state;
				for (let e = t.length - 1; e >= 0; e--) this.finalizeComment(t[e]);
				this.state.commentStack = [];
			}
			resetPreviousNodeTrailingComments(t) {
				let { commentStack: e } = this.state, { length: s } = e;
				if (s === 0) return;
				let i = e[s - 1];
				i.leadingNode === t && (i.leadingNode = null);
			}
			takeSurroundingComments(t, e, s) {
				let { commentStack: i } = this.state, r = i.length;
				if (r === 0) return;
				let n = r - 1;
				for (; n >= 0; n--) {
					let o = i[n], h = o.end;
					if (o.start === s) o.leadingNode = t;
					else if (h === e) o.trailingNode = t;
					else if (h < e) break;
				}
			}
		}, et = class a {
			flags = 1024;
			get strict() {
				return (this.flags & 1) > 0;
			}
			set strict(t) {
				t ? this.flags |= 1 : this.flags &= -2;
			}
			startIndex;
			curLine;
			lineStart;
			startLoc;
			endLoc;
			init({ strictMode: t, sourceType: e, startIndex: s, startLine: i, startColumn: r }) {
				this.strict = t === !1 ? !1 : t === !0 ? !0 : e === "module", this.startIndex = s, this.curLine = i, this.lineStart = -r, this.startLoc = this.endLoc = new R(i, r, s);
			}
			errors = [];
			potentialArrowAt = -1;
			noArrowAt = [];
			noArrowParamsConversionAt = [];
			get maybeInArrowParameters() {
				return (this.flags & 2) > 0;
			}
			set maybeInArrowParameters(t) {
				t ? this.flags |= 2 : this.flags &= -3;
			}
			get inType() {
				return (this.flags & 4) > 0;
			}
			set inType(t) {
				t ? this.flags |= 4 : this.flags &= -5;
			}
			get noAnonFunctionType() {
				return (this.flags & 8) > 0;
			}
			set noAnonFunctionType(t) {
				t ? this.flags |= 8 : this.flags &= -9;
			}
			get hasFlowComment() {
				return (this.flags & 16) > 0;
			}
			set hasFlowComment(t) {
				t ? this.flags |= 16 : this.flags &= -17;
			}
			get isAmbientContext() {
				return (this.flags & 32) > 0;
			}
			set isAmbientContext(t) {
				t ? this.flags |= 32 : this.flags &= -33;
			}
			get inAbstractClass() {
				return (this.flags & 64) > 0;
			}
			set inAbstractClass(t) {
				t ? this.flags |= 64 : this.flags &= -65;
			}
			get inDisallowConditionalTypesContext() {
				return (this.flags & 128) > 0;
			}
			set inDisallowConditionalTypesContext(t) {
				t ? this.flags |= 128 : this.flags &= -129;
			}
			topicContext = {
				maxNumOfResolvableTopics: 0,
				maxTopicIndex: null
			};
			get soloAwait() {
				return (this.flags & 256) > 0;
			}
			set soloAwait(t) {
				t ? this.flags |= 256 : this.flags &= -257;
			}
			get inFSharpPipelineDirectBody() {
				return (this.flags & 512) > 0;
			}
			set inFSharpPipelineDirectBody(t) {
				t ? this.flags |= 512 : this.flags &= -513;
			}
			labels = [];
			commentsLen = 0;
			commentStack = [];
			pos = 0;
			type = 140;
			value = null;
			start = 0;
			end = 0;
			lastTokEndLoc = null;
			lastTokStartLoc = null;
			context = [E.brace];
			get canStartJSXElement() {
				return (this.flags & 1024) > 0;
			}
			set canStartJSXElement(t) {
				t ? this.flags |= 1024 : this.flags &= -1025;
			}
			get containsEsc() {
				return (this.flags & 2048) > 0;
			}
			set containsEsc(t) {
				t ? this.flags |= 2048 : this.flags &= -2049;
			}
			firstInvalidTemplateEscapePos = null;
			get hasTopLevelAwait() {
				return (this.flags & 4096) > 0;
			}
			set hasTopLevelAwait(t) {
				t ? this.flags |= 4096 : this.flags &= -4097;
			}
			strictErrors = /* @__PURE__ */ new Map();
			tokensLength = 0;
			curPosition() {
				return new R(this.curLine, this.pos - this.lineStart, this.pos + this.startIndex);
			}
			clone() {
				let t = new a();
				return t.flags = this.flags, t.startIndex = this.startIndex, t.curLine = this.curLine, t.lineStart = this.lineStart, t.startLoc = this.startLoc, t.endLoc = this.endLoc, t.errors = this.errors.slice(), t.potentialArrowAt = this.potentialArrowAt, t.noArrowAt = this.noArrowAt.slice(), t.noArrowParamsConversionAt = this.noArrowParamsConversionAt.slice(), t.topicContext = this.topicContext, t.labels = this.labels.slice(), t.commentsLen = this.commentsLen, t.commentStack = this.commentStack.slice(), t.pos = this.pos, t.type = this.type, t.value = this.value, t.start = this.start, t.end = this.end, t.lastTokEndLoc = this.lastTokEndLoc, t.lastTokStartLoc = this.lastTokStartLoc, t.context = this.context.slice(), t.firstInvalidTemplateEscapePos = this.firstInvalidTemplateEscapePos, t.strictErrors = this.strictErrors, t.tokensLength = this.tokensLength, t;
			}
		}, zi = function(t) {
			return t >= 48 && t <= 57;
		}, jt = {
			decBinOct: new Set([
				46,
				66,
				69,
				79,
				95,
				98,
				101,
				111
			]),
			hex: new Set([
				46,
				88,
				95,
				120
			])
		}, Te = {
			bin: (a) => a === 48 || a === 49,
			oct: (a) => a >= 48 && a <= 55,
			dec: (a) => a >= 48 && a <= 57,
			hex: (a) => a >= 48 && a <= 57 || a >= 65 && a <= 70 || a >= 97 && a <= 102
		};
		function Vt(a, t, e, s, i, r) {
			let n = e, o = s, h = i, l = "", u = null, f = e, { length: d } = t;
			for (;;) {
				if (e >= d) {
					r.unterminated(n, o, h), l += t.slice(f, e);
					break;
				}
				let x = t.charCodeAt(e);
				if (qi(a, x, t, e)) {
					l += t.slice(f, e);
					break;
				}
				if (x === 92) {
					l += t.slice(f, e);
					let A = $i(t, e, s, i, a === "template", r);
					A.ch === null && !u ? u = {
						pos: e,
						lineStart: s,
						curLine: i
					} : l += A.ch, {pos: e, lineStart: s, curLine: i} = A, f = e;
				} else x === 8232 || x === 8233 ? (++e, ++i, s = e) : x === 10 || x === 13 ? a === "template" ? (l += t.slice(f, e) + `
`, ++e, x === 13 && t.charCodeAt(e) === 10 && ++e, ++i, f = s = e) : r.unterminated(n, o, h) : ++e;
			}
			return {
				pos: e,
				str: l,
				firstInvalidLoc: u,
				lineStart: s,
				curLine: i
			};
		}
		function qi(a, t, e, s) {
			return a === "template" ? t === 96 || t === 36 && e.charCodeAt(s + 1) === 123 : t === (a === "double" ? 34 : 39);
		}
		function $i(a, t, e, s, i, r) {
			let n = !i;
			t++;
			let o = (l) => ({
				pos: t,
				ch: l,
				lineStart: e,
				curLine: s
			}), h = a.charCodeAt(t++);
			switch (h) {
				case 110: return o(`
`);
				case 114: return o("\r");
				case 120: {
					let l;
					return {code: l, pos: t} = tt(a, t, e, s, 2, !1, n, r), o(l === null ? null : String.fromCharCode(l));
				}
				case 117: {
					let l;
					return {code: l, pos: t} = as(a, t, e, s, n, r), o(l === null ? null : String.fromCodePoint(l));
				}
				case 116: return o("	");
				case 98: return o("\b");
				case 118: return o("\v");
				case 102: return o("\f");
				case 13: a.charCodeAt(t) === 10 && ++t;
				case 10: e = t, ++s;
				case 8232:
				case 8233: return o("");
				case 56:
				case 57:
					if (i) return o(null);
					r.strictNumericEscape(t - 1, e, s);
				default:
					if (h >= 48 && h <= 55) {
						let l = t - 1, f = /^[0-7]+/.exec(a.slice(l, t + 2))[0], d = parseInt(f, 8);
						d > 255 && (f = f.slice(0, -1), d = parseInt(f, 8)), t += f.length - 1;
						let x = a.charCodeAt(t);
						if (f !== "0" || x === 56 || x === 57) {
							if (i) return o(null);
							r.strictNumericEscape(l, e, s);
						}
						return o(String.fromCharCode(d));
					}
					return o(String.fromCharCode(h));
			}
		}
		function tt(a, t, e, s, i, r, n, o) {
			let h = t, l;
			return {n: l, pos: t} = rs(a, t, e, s, 16, i, r, !1, o, !n), l === null && (n ? o.invalidEscapeSequence(h, e, s) : t = h - 1), {
				code: l,
				pos: t
			};
		}
		function rs(a, t, e, s, i, r, n, o, h, l) {
			let u = t, f = i === 16 ? jt.hex : jt.decBinOct, d = i === 16 ? Te.hex : i === 10 ? Te.dec : i === 8 ? Te.oct : Te.bin, x = !1, A = 0;
			for (let k = 0, N = r ?? Infinity; k < N; ++k) {
				let C = a.charCodeAt(t), I;
				if (C === 95 && o !== "bail") {
					let Pe = a.charCodeAt(t - 1), ae = a.charCodeAt(t + 1);
					if (o) {
						if (Number.isNaN(ae) || !d(ae) || f.has(Pe) || f.has(ae)) {
							if (l) return {
								n: null,
								pos: t
							};
							h.unexpectedNumericSeparator(t, e, s);
						}
					} else {
						if (l) return {
							n: null,
							pos: t
						};
						h.numericSeparatorInEscapeSequence(t, e, s);
					}
					++t;
					continue;
				}
				if (C >= 97 ? I = C - 97 + 10 : C >= 65 ? I = C - 65 + 10 : zi(C) ? I = C - 48 : I = Infinity, I >= i) {
					if (I <= 9 && l) return {
						n: null,
						pos: t
					};
					if (I <= 9 && h.invalidDigit(t, e, s, i)) I = 0;
					else if (n) I = 0, x = !0;
					else break;
				}
				++t, A = A * i + I;
			}
			return t === u || r != null && t - u !== r || x ? {
				n: null,
				pos: t
			} : {
				n: A,
				pos: t
			};
		}
		function as(a, t, e, s, i, r) {
			let n = a.charCodeAt(t), o;
			if (n === 123) {
				if (++t, {code: o, pos: t} = tt(a, t, e, s, a.indexOf("}", t) - t, !0, i, r), ++t, o !== null && o > 1114111) if (i) r.invalidCodePoint(t, e, s);
				else return {
					code: null,
					pos: t
				};
			} else ({code: o, pos: t} = tt(a, t, e, s, 4, !1, i, r));
			return {
				code: o,
				pos: t
			};
		}
		function he(a, t, e) {
			return new R(e, a - t, a);
		}
		var Ki = new Set([
			103,
			109,
			115,
			105,
			121,
			117,
			100,
			118
		]), st = class {
			constructor(t) {
				let e = t.startIndex || 0;
				this.type = t.type, this.value = t.value, this.start = e + t.start, this.end = e + t.end, this.loc = new Q(t.startLoc, t.endLoc);
			}
		}, it = class extends Ze {
			isLookahead;
			tokens = [];
			constructor(t, e) {
				super(), this.state = new et(), this.state.init(t), this.input = e, this.length = e.length, this.comments = [], this.isLookahead = !1;
			}
			pushToken(t) {
				this.tokens.length = this.state.tokensLength, this.tokens.push(t), ++this.state.tokensLength;
			}
			next() {
				this.checkKeywordEscapes(), this.optionFlags & 256 && this.pushToken(new st(this.state)), this.state.lastTokEndLoc = this.state.endLoc, this.state.lastTokStartLoc = this.state.startLoc, this.nextToken();
			}
			eat(t) {
				return this.match(t) ? (this.next(), !0) : !1;
			}
			match(t) {
				return this.state.type === t;
			}
			createLookaheadState(t) {
				return {
					pos: t.pos,
					value: null,
					type: t.type,
					start: t.start,
					end: t.end,
					context: [this.curContext()],
					inType: t.inType,
					startLoc: t.startLoc,
					lastTokEndLoc: t.lastTokEndLoc,
					curLine: t.curLine,
					lineStart: t.lineStart,
					curPosition: t.curPosition
				};
			}
			lookahead() {
				let t = this.state;
				this.state = this.createLookaheadState(t), this.isLookahead = !0, this.nextToken(), this.isLookahead = !1;
				let e = this.state;
				return this.state = t, e;
			}
			nextTokenStart() {
				return this.nextTokenStartSince(this.state.pos);
			}
			nextTokenStartSince(t) {
				return je.lastIndex = t, je.test(this.input) ? je.lastIndex : t;
			}
			lookaheadCharCode() {
				return this.lookaheadCharCodeSince(this.state.pos);
			}
			lookaheadCharCodeSince(t) {
				return this.input.charCodeAt(this.nextTokenStartSince(t));
			}
			nextTokenInLineStart() {
				return this.nextTokenInLineStartSince(this.state.pos);
			}
			nextTokenInLineStartSince(t) {
				return Ve.lastIndex = t, Ve.test(this.input) ? Ve.lastIndex : t;
			}
			lookaheadInLineCharCode() {
				return this.input.charCodeAt(this.nextTokenInLineStart());
			}
			codePointAtPos(t) {
				let e = this.input.charCodeAt(t);
				if ((e & 64512) === 55296 && ++t < this.input.length) {
					let s = this.input.charCodeAt(t);
					(s & 64512) === 56320 && (e = 65536 + ((e & 1023) << 10) + (s & 1023));
				}
				return e;
			}
			setStrict(t) {
				this.state.strict = t, t && (this.state.strictErrors.forEach(([e, s]) => this.raise(e, s)), this.state.strictErrors.clear());
			}
			curContext() {
				return this.state.context[this.state.context.length - 1];
			}
			nextToken() {
				if (this.skipSpace(), this.state.start = this.state.pos, this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.pos >= this.length) {
					this.finishToken(140);
					return;
				}
				this.getTokenFromCode(this.codePointAtPos(this.state.pos));
			}
			skipBlockComment(t) {
				let e;
				this.isLookahead || (e = this.state.curPosition());
				let s = this.state.pos, i = this.input.indexOf(t, s + 2);
				if (i === -1) throw this.raise(p.UnterminatedComment, this.state.curPosition());
				for (this.state.pos = i + t.length, ge.lastIndex = s + 2; ge.test(this.input) && ge.lastIndex <= i;) ++this.state.curLine, this.state.lineStart = ge.lastIndex;
				if (this.isLookahead) return;
				let r = {
					type: "CommentBlock",
					value: this.input.slice(s + 2, i),
					start: this.sourceToOffsetPos(s),
					end: this.sourceToOffsetPos(i + t.length),
					loc: new Q(e, this.state.curPosition())
				};
				return this.optionFlags & 256 && this.pushToken(r), r;
			}
			skipLineComment(t) {
				let e = this.state.pos, s;
				this.isLookahead || (s = this.state.curPosition());
				let i = this.input.charCodeAt(this.state.pos += t);
				if (this.state.pos < this.length) for (; !G(i) && ++this.state.pos < this.length;) i = this.input.charCodeAt(this.state.pos);
				if (this.isLookahead) return;
				let r = this.state.pos, o = {
					type: "CommentLine",
					value: this.input.slice(e + t, r),
					start: this.sourceToOffsetPos(e),
					end: this.sourceToOffsetPos(r),
					loc: new Q(s, this.state.curPosition())
				};
				return this.optionFlags & 256 && this.pushToken(o), o;
			}
			skipSpace() {
				let t = this.state.pos, e = this.optionFlags & 4096 ? [] : null;
				e: for (; this.state.pos < this.length;) {
					let s = this.input.charCodeAt(this.state.pos);
					switch (s) {
						case 32:
						case 160:
						case 9:
							++this.state.pos;
							break;
						case 13: this.input.charCodeAt(this.state.pos + 1) === 10 && ++this.state.pos;
						case 10:
						case 8232:
						case 8233:
							++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
							break;
						case 47:
							switch (this.input.charCodeAt(this.state.pos + 1)) {
								case 42: {
									let i = this.skipBlockComment("*/");
									i !== void 0 && (this.addComment(i), e?.push(i));
									break;
								}
								case 47: {
									let i = this.skipLineComment(2);
									i !== void 0 && (this.addComment(i), e?.push(i));
									break;
								}
								default: break e;
							}
							break;
						default: if (_i(s)) ++this.state.pos;
						else if (s === 45 && !this.inModule && this.optionFlags & 8192) {
							let i = this.state.pos;
							if (this.input.charCodeAt(i + 1) === 45 && this.input.charCodeAt(i + 2) === 62 && (t === 0 || this.state.lineStart > t)) {
								let r = this.skipLineComment(3);
								r !== void 0 && (this.addComment(r), e?.push(r));
							} else break e;
						} else if (s === 60 && !this.inModule && this.optionFlags & 8192) {
							let i = this.state.pos;
							if (this.input.charCodeAt(i + 1) === 33 && this.input.charCodeAt(i + 2) === 45 && this.input.charCodeAt(i + 3) === 45) {
								let r = this.skipLineComment(4);
								r !== void 0 && (this.addComment(r), e?.push(r));
							} else break e;
						} else break e;
					}
				}
				if (e?.length > 0) {
					let s = this.state.pos, i = {
						start: this.sourceToOffsetPos(t),
						end: this.sourceToOffsetPos(s),
						comments: e,
						leadingNode: null,
						trailingNode: null,
						containingNode: null
					};
					this.state.commentStack.push(i);
				}
			}
			finishToken(t, e) {
				this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();
				let s = this.state.type;
				this.state.type = t, this.state.value = e, this.isLookahead || this.updateContext(s);
			}
			replaceToken(t) {
				this.state.type = t, this.updateContext();
			}
			readToken_numberSign() {
				if (this.state.pos === 0 && this.readToken_interpreter()) return;
				let t = this.state.pos + 1, e = this.codePointAtPos(t);
				if (e >= 48 && e <= 57) throw this.raise(p.UnexpectedDigitAfterHash, this.state.curPosition());
				B(e) ? (++this.state.pos, this.finishToken(139, this.readWord1(e))) : e === 92 ? (++this.state.pos, this.finishToken(139, this.readWord1())) : this.finishOp(27, 1);
			}
			readToken_dot() {
				let t = this.input.charCodeAt(this.state.pos + 1);
				if (t >= 48 && t <= 57) {
					this.readNumber(!0);
					return;
				}
				t === 46 && this.input.charCodeAt(this.state.pos + 2) === 46 ? (this.state.pos += 3, this.finishToken(21)) : (++this.state.pos, this.finishToken(16));
			}
			readToken_slash() {
				this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(31, 2) : this.finishOp(56, 1);
			}
			readToken_interpreter() {
				if (this.state.pos !== 0 || this.length < 2) return !1;
				let t = this.input.charCodeAt(this.state.pos + 1);
				if (t !== 33) return !1;
				let e = this.state.pos;
				for (this.state.pos += 1; !G(t) && ++this.state.pos < this.length;) t = this.input.charCodeAt(this.state.pos);
				let s = this.input.slice(e + 2, this.state.pos);
				return this.finishToken(28, s), !0;
			}
			readToken_mult_modulo(t) {
				let e = t === 42 ? 55 : 54, s = 1, i = this.input.charCodeAt(this.state.pos + 1);
				t === 42 && i === 42 && (s++, i = this.input.charCodeAt(this.state.pos + 2), e = 57), i === 61 && !this.state.inType && (s++, e = t === 37 ? 33 : 30), this.finishOp(e, s);
			}
			readToken_pipe_amp(t) {
				let e = this.input.charCodeAt(this.state.pos + 1);
				if (e === t) {
					this.input.charCodeAt(this.state.pos + 2) === 61 ? this.finishOp(30, 3) : this.finishOp(t === 124 ? 41 : 42, 2);
					return;
				}
				if (t === 124 && e === 62) {
					this.finishOp(39, 2);
					return;
				}
				if (e === 61) {
					this.finishOp(30, 2);
					return;
				}
				this.finishOp(t === 124 ? 43 : 45, 1);
			}
			readToken_caret() {
				let t = this.input.charCodeAt(this.state.pos + 1);
				t === 61 && !this.state.inType ? this.finishOp(32, 2) : t === 94 && this.hasPlugin(["pipelineOperator", {
					proposal: "hack",
					topicToken: "^^"
				}]) ? (this.finishOp(37, 2), this.input.codePointAt(this.state.pos) === 94 && this.unexpected()) : this.finishOp(44, 1);
			}
			readToken_atSign() {
				this.input.charCodeAt(this.state.pos + 1) === 64 && this.hasPlugin(["pipelineOperator", {
					proposal: "hack",
					topicToken: "@@"
				}]) ? this.finishOp(38, 2) : this.finishOp(26, 1);
			}
			readToken_plus_min(t) {
				let e = this.input.charCodeAt(this.state.pos + 1);
				if (e === t) {
					this.finishOp(34, 2);
					return;
				}
				e === 61 ? this.finishOp(30, 2) : this.finishOp(53, 1);
			}
			readToken_lt() {
				let { pos: t } = this.state, e = this.input.charCodeAt(t + 1);
				if (e === 60) {
					if (this.input.charCodeAt(t + 2) === 61) {
						this.finishOp(30, 3);
						return;
					}
					this.finishOp(51, 2);
					return;
				}
				if (e === 61) {
					this.finishOp(49, 2);
					return;
				}
				this.finishOp(47, 1);
			}
			readToken_gt() {
				let { pos: t } = this.state, e = this.input.charCodeAt(t + 1);
				if (e === 62) {
					let s = this.input.charCodeAt(t + 2) === 62 ? 3 : 2;
					if (this.input.charCodeAt(t + s) === 61) {
						this.finishOp(30, s + 1);
						return;
					}
					this.finishOp(52, s);
					return;
				}
				if (e === 61) {
					this.finishOp(49, 2);
					return;
				}
				this.finishOp(48, 1);
			}
			readToken_eq_excl(t) {
				let e = this.input.charCodeAt(this.state.pos + 1);
				if (e === 61) {
					this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
					return;
				}
				if (t === 61 && e === 62) {
					this.state.pos += 2, this.finishToken(19);
					return;
				}
				this.finishOp(t === 61 ? 29 : 35, 1);
			}
			readToken_question() {
				let t = this.input.charCodeAt(this.state.pos + 1), e = this.input.charCodeAt(this.state.pos + 2);
				t === 63 ? e === 61 ? this.finishOp(30, 3) : this.finishOp(40, 2) : t === 46 && !(e >= 48 && e <= 57) ? (this.state.pos += 2, this.finishToken(18)) : (++this.state.pos, this.finishToken(17));
			}
			getTokenFromCode(t) {
				switch (t) {
					case 46:
						this.readToken_dot();
						return;
					case 40:
						++this.state.pos, this.finishToken(10);
						return;
					case 41:
						++this.state.pos, this.finishToken(11);
						return;
					case 59:
						++this.state.pos, this.finishToken(13);
						return;
					case 44:
						++this.state.pos, this.finishToken(12);
						return;
					case 91:
						++this.state.pos, this.finishToken(0);
						return;
					case 93:
						++this.state.pos, this.finishToken(3);
						return;
					case 123:
						++this.state.pos, this.finishToken(5);
						return;
					case 125:
						++this.state.pos, this.finishToken(8);
						return;
					case 58:
						this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58 ? this.finishOp(15, 2) : (++this.state.pos, this.finishToken(14));
						return;
					case 63:
						this.readToken_question();
						return;
					case 96:
						this.readTemplateToken();
						return;
					case 48: {
						let e = this.input.charCodeAt(this.state.pos + 1);
						if (e === 120 || e === 88) {
							this.readRadixNumber(16);
							return;
						}
						if (e === 111 || e === 79) {
							this.readRadixNumber(8);
							return;
						}
						if (e === 98 || e === 66) {
							this.readRadixNumber(2);
							return;
						}
					}
					case 49:
					case 50:
					case 51:
					case 52:
					case 53:
					case 54:
					case 55:
					case 56:
					case 57:
						this.readNumber(!1);
						return;
					case 34:
					case 39:
						this.readString(t);
						return;
					case 47:
						this.readToken_slash();
						return;
					case 37:
					case 42:
						this.readToken_mult_modulo(t);
						return;
					case 124:
					case 38:
						this.readToken_pipe_amp(t);
						return;
					case 94:
						this.readToken_caret();
						return;
					case 43:
					case 45:
						this.readToken_plus_min(t);
						return;
					case 60:
						this.readToken_lt();
						return;
					case 62:
						this.readToken_gt();
						return;
					case 61:
					case 33:
						this.readToken_eq_excl(t);
						return;
					case 126:
						this.finishOp(36, 1);
						return;
					case 64:
						this.readToken_atSign();
						return;
					case 35:
						this.readToken_numberSign();
						return;
					case 92:
						this.readWord();
						return;
					default: if (B(t)) {
						this.readWord(t);
						return;
					}
				}
				throw this.raise(p.InvalidOrUnexpectedToken, this.state.curPosition(), { unexpected: String.fromCodePoint(t) });
			}
			finishOp(t, e) {
				let s = this.input.slice(this.state.pos, this.state.pos + e);
				this.state.pos += e, this.finishToken(t, s);
			}
			readRegexp() {
				let t = this.state.startLoc, e = this.state.start + 1, s, i, { pos: r } = this.state;
				for (;; ++r) {
					if (r >= this.length) throw this.raise(p.UnterminatedRegExp, D(t, 1));
					let l = this.input.charCodeAt(r);
					if (G(l)) throw this.raise(p.UnterminatedRegExp, D(t, 1));
					if (s) s = !1;
					else {
						if (l === 91) i = !0;
						else if (l === 93 && i) i = !1;
						else if (l === 47 && !i) break;
						s = l === 92;
					}
				}
				let n = this.input.slice(e, r);
				++r;
				let o = "", h = () => D(t, r + 2 - e);
				for (; r < this.length;) {
					let l = this.codePointAtPos(r), u = String.fromCharCode(l);
					if (Ki.has(l)) l === 118 ? o.includes("u") && this.raise(p.IncompatibleRegExpUVFlags, h()) : l === 117 && o.includes("v") && this.raise(p.IncompatibleRegExpUVFlags, h()), o.includes(u) && this.raise(p.DuplicateRegExpFlags, h());
					else if (K(l) || l === 92) this.raise(p.MalformedRegExpFlags, h());
					else break;
					++r, o += u;
				}
				this.state.pos = r, this.finishToken(138, {
					pattern: n,
					flags: o
				});
			}
			readInt(t, e, s = !1, i = !0) {
				let { n: r, pos: n } = rs(this.input, this.state.pos, this.state.lineStart, this.state.curLine, t, e, s, i, this.errorHandlers_readInt, !1);
				return this.state.pos = n, r;
			}
			readRadixNumber(t) {
				let e = this.state.pos, s = this.state.curPosition(), i = !1;
				this.state.pos += 2;
				let r = this.readInt(t);
				r ?? this.raise(p.InvalidDigit, D(s, 2), { radix: t });
				let n = this.input.charCodeAt(this.state.pos);
				if (n === 110) ++this.state.pos, i = !0;
				else if (n === 109) throw this.raise(p.InvalidDecimal, s);
				if (B(this.codePointAtPos(this.state.pos))) throw this.raise(p.NumberIdentifier, this.state.curPosition());
				if (i) {
					let o = this.input.slice(e, this.state.pos).replace(/[_n]/g, "");
					this.finishToken(136, o);
					return;
				}
				this.finishToken(135, r);
			}
			readNumber(t) {
				let e = this.state.pos, s = this.state.curPosition(), i = !1, r = !1, n = !1;
				!t && this.readInt(10) === null && this.raise(p.InvalidNumber, this.state.curPosition());
				let o = this.state.pos - e >= 2 && this.input.charCodeAt(e) === 48;
				if (o) {
					let f = this.input.slice(e, this.state.pos);
					if (this.recordStrictModeErrors(p.StrictOctalLiteral, s), !this.state.strict) {
						let d = f.indexOf("_");
						d > 0 && this.raise(p.ZeroDigitNumericSeparator, D(s, d));
					}
					n = o && !/[89]/.test(f);
				}
				let h = this.input.charCodeAt(this.state.pos);
				if (h === 46 && !n && (++this.state.pos, this.readInt(10), i = !0, h = this.input.charCodeAt(this.state.pos)), (h === 69 || h === 101) && !n && (h = this.input.charCodeAt(++this.state.pos), (h === 43 || h === 45) && ++this.state.pos, this.readInt(10) === null && this.raise(p.InvalidOrMissingExponent, s), i = !0, h = this.input.charCodeAt(this.state.pos)), h === 110 && ((i || o) && this.raise(p.InvalidBigIntLiteral, s), ++this.state.pos, r = !0), B(this.codePointAtPos(this.state.pos))) throw this.raise(p.NumberIdentifier, this.state.curPosition());
				let l = this.input.slice(e, this.state.pos).replace(/[_mn]/g, "");
				if (r) {
					this.finishToken(136, l);
					return;
				}
				let u = n ? parseInt(l, 8) : parseFloat(l);
				this.finishToken(135, u);
			}
			readCodePoint(t) {
				let { code: e, pos: s } = as(this.input, this.state.pos, this.state.lineStart, this.state.curLine, t, this.errorHandlers_readCodePoint);
				return this.state.pos = s, e;
			}
			readString(t) {
				let { str: e, pos: s, curLine: i, lineStart: r } = Vt(t === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
				this.state.pos = s + 1, this.state.lineStart = r, this.state.curLine = i, this.finishToken(134, e);
			}
			readTemplateContinuation() {
				this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken();
			}
			readTemplateToken() {
				let t = this.input[this.state.pos], { str: e, firstInvalidLoc: s, pos: i, curLine: r, lineStart: n } = Vt("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
				this.state.pos = i + 1, this.state.lineStart = n, this.state.curLine = r, s && (this.state.firstInvalidTemplateEscapePos = new R(s.curLine, s.pos - s.lineStart, this.sourceToOffsetPos(s.pos))), this.input.codePointAt(i) === 96 ? this.finishToken(24, s ? null : t + e + "`") : (this.state.pos++, this.finishToken(25, s ? null : t + e + "${"));
			}
			recordStrictModeErrors(t, e) {
				let s = e.index;
				this.state.strict && !this.state.strictErrors.has(s) ? this.raise(t, e) : this.state.strictErrors.set(s, [t, e]);
			}
			readWord1(t) {
				this.state.containsEsc = !1;
				let e = "", s = this.state.pos, i = this.state.pos;
				for (t !== void 0 && (this.state.pos += t <= 65535 ? 1 : 2); this.state.pos < this.length;) {
					let r = this.codePointAtPos(this.state.pos);
					if (K(r)) this.state.pos += r <= 65535 ? 1 : 2;
					else if (r === 92) {
						this.state.containsEsc = !0, e += this.input.slice(i, this.state.pos);
						let n = this.state.curPosition(), o = this.state.pos === s ? B : K;
						if (this.input.charCodeAt(++this.state.pos) !== 117) {
							this.raise(p.MissingUnicodeEscape, this.state.curPosition()), i = this.state.pos - 1;
							continue;
						}
						++this.state.pos;
						let h = this.readCodePoint(!0);
						h !== null && (o(h) || this.raise(p.EscapedCharNotAnIdentifier, n), e += String.fromCodePoint(h)), i = this.state.pos;
					} else break;
				}
				return e + this.input.slice(i, this.state.pos);
			}
			readWord(t) {
				let e = this.readWord1(t), s = dt.get(e);
				s !== void 0 ? this.finishToken(s, z(s)) : this.finishToken(132, e);
			}
			checkKeywordEscapes() {
				let { type: t } = this.state;
				bt(t) && this.state.containsEsc && this.raise(p.InvalidEscapedReservedWord, this.state.startLoc, { reservedWord: z(t) });
			}
			raise(t, e, s = {}) {
				let r = t(e instanceof R ? e : e.loc.start, s);
				if (!(this.optionFlags & 2048)) throw r;
				return this.isLookahead || this.state.errors.push(r), r;
			}
			raiseOverwrite(t, e, s = {}) {
				let i = e instanceof R ? e : e.loc.start, r = i.index, n = this.state.errors;
				for (let o = n.length - 1; o >= 0; o--) {
					let h = n[o];
					if (h.loc.index === r) return n[o] = t(i, s);
					if (h.loc.index < r) break;
				}
				return this.raise(t, e, s);
			}
			updateContext(t) {}
			unexpected(t, e) {
				throw this.raise(p.UnexpectedToken, t ?? this.state.startLoc, { expected: e ? z(e) : null });
			}
			expectPlugin(t, e) {
				if (this.hasPlugin(t)) return !0;
				throw this.raise(p.MissingPlugin, e ?? this.state.startLoc, { missingPlugin: [t] });
			}
			expectOnePlugin(t) {
				if (!t.some((e) => this.hasPlugin(e))) throw this.raise(p.MissingOneOfPlugins, this.state.startLoc, { missingPlugin: t });
			}
			errorBuilder(t) {
				return (e, s, i) => {
					this.raise(t, he(e, s, i));
				};
			}
			errorHandlers_readInt = {
				invalidDigit: (t, e, s, i) => this.optionFlags & 2048 ? (this.raise(p.InvalidDigit, he(t, e, s), { radix: i }), !0) : !1,
				numericSeparatorInEscapeSequence: this.errorBuilder(p.NumericSeparatorInEscapeSequence),
				unexpectedNumericSeparator: this.errorBuilder(p.UnexpectedNumericSeparator)
			};
			errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {
				invalidEscapeSequence: this.errorBuilder(p.InvalidEscapeSequence),
				invalidCodePoint: this.errorBuilder(p.InvalidCodePoint)
			});
			errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {
				strictNumericEscape: (t, e, s) => {
					this.recordStrictModeErrors(p.StrictNumericEscape, he(t, e, s));
				},
				unterminated: (t, e, s) => {
					throw this.raise(p.UnterminatedString, he(t - 1, e, s));
				}
			});
			errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {
				strictNumericEscape: this.errorBuilder(p.StrictNumericEscape),
				unterminated: (t, e, s) => {
					throw this.raise(p.UnterminatedTemplate, he(t, e, s));
				}
			});
		}, rt = class {
			privateNames = /* @__PURE__ */ new Set();
			loneAccessors = /* @__PURE__ */ new Map();
			undefinedPrivateNames = /* @__PURE__ */ new Map();
		}, at = class {
			parser;
			stack = [];
			undefinedPrivateNames = /* @__PURE__ */ new Map();
			constructor(t) {
				this.parser = t;
			}
			current() {
				return this.stack[this.stack.length - 1];
			}
			enter() {
				this.stack.push(new rt());
			}
			exit() {
				let t = this.stack.pop(), e = this.current();
				for (let [s, i] of Array.from(t.undefinedPrivateNames)) e ? e.undefinedPrivateNames.has(s) || e.undefinedPrivateNames.set(s, i) : this.parser.raise(p.InvalidPrivateFieldResolution, i, { identifierName: s });
			}
			declarePrivateName(t, e, s) {
				let { privateNames: i, loneAccessors: r, undefinedPrivateNames: n } = this.current(), o = i.has(t);
				if (e & 3) {
					let h = o && r.get(t);
					if (h) {
						let l = h & 4, u = e & 4;
						o = (h & 3) === (e & 3) || l !== u, o || r.delete(t);
					} else o || r.set(t, e);
				}
				o && this.parser.raise(p.PrivateNameRedeclaration, s, { identifierName: t }), i.add(t), n.delete(t);
			}
			usePrivateName(t, e) {
				let s;
				for (s of this.stack) if (s.privateNames.has(t)) return;
				s ? s.undefinedPrivateNames.set(t, e) : this.parser.raise(p.InvalidPrivateFieldResolution, e, { identifierName: t });
			}
		}, Z = class {
			constructor(t = 0) {
				this.type = t;
			}
			canBeArrowParameterDeclaration() {
				return this.type === 2 || this.type === 1;
			}
			isCertainlyParameterDeclaration() {
				return this.type === 3;
			}
		}, Ce = class extends Z {
			declarationErrors = /* @__PURE__ */ new Map();
			constructor(t) {
				super(t);
			}
			recordDeclarationError(t, e) {
				let s = e.index;
				this.declarationErrors.set(s, [t, e]);
			}
			clearDeclarationError(t) {
				this.declarationErrors.delete(t);
			}
			iterateErrors(t) {
				this.declarationErrors.forEach(t);
			}
		}, nt = class {
			parser;
			stack = [new Z()];
			constructor(t) {
				this.parser = t;
			}
			enter(t) {
				this.stack.push(t);
			}
			exit() {
				this.stack.pop();
			}
			recordParameterInitializerError(t, e) {
				let s = e.loc.start, { stack: i } = this, r = i.length - 1, n = i[r];
				for (; !n.isCertainlyParameterDeclaration();) {
					if (n.canBeArrowParameterDeclaration()) n.recordDeclarationError(t, s);
					else return;
					n = i[--r];
				}
				this.parser.raise(t, s);
			}
			recordArrowParameterBindingError(t, e) {
				let { stack: s } = this, i = s[s.length - 1], r = e.loc.start;
				if (i.isCertainlyParameterDeclaration()) this.parser.raise(t, r);
				else if (i.canBeArrowParameterDeclaration()) i.recordDeclarationError(t, r);
				else return;
			}
			recordAsyncArrowParametersError(t) {
				let { stack: e } = this, s = e.length - 1, i = e[s];
				for (; i.canBeArrowParameterDeclaration();) i.type === 2 && i.recordDeclarationError(p.AwaitBindingIdentifier, t), i = e[--s];
			}
			validateAsPattern() {
				let { stack: t } = this, e = t[t.length - 1];
				e.canBeArrowParameterDeclaration() && e.iterateErrors(([s, i]) => {
					this.parser.raise(s, i);
					let r = t.length - 2, n = t[r];
					for (; n.canBeArrowParameterDeclaration();) n.clearDeclarationError(i.index), n = t[--r];
				});
			}
		};
		function Hi() {
			return new Z(3);
		}
		function Wi() {
			return new Ce(1);
		}
		function Ji() {
			return new Ce(2);
		}
		function ns() {
			return new Z();
		}
		var ot = class extends it {
			addExtra(t, e, s, i = !0) {
				if (!t) return;
				let { extra: r } = t;
				r ?? (r = {}, t.extra = r), i ? r[e] = s : Object.defineProperty(r, e, {
					enumerable: i,
					value: s
				});
			}
			isContextual(t) {
				return this.state.type === t && !this.state.containsEsc;
			}
			isUnparsedContextual(t, e) {
				if (this.input.startsWith(e, t)) {
					let s = this.input.charCodeAt(t + e.length);
					return !(K(s) || (s & 64512) === 55296);
				}
				return !1;
			}
			isLookaheadContextual(t) {
				let e = this.nextTokenStart();
				return this.isUnparsedContextual(e, t);
			}
			eatContextual(t) {
				return this.isContextual(t) ? (this.next(), !0) : !1;
			}
			expectContextual(t, e) {
				if (!this.eatContextual(t)) {
					if (e != null) throw this.raise(e, this.state.startLoc);
					this.unexpected(null, t);
				}
			}
			canInsertSemicolon() {
				return this.match(140) || this.match(8) || this.hasPrecedingLineBreak();
			}
			hasPrecedingLineBreak() {
				return _t(this.input, this.offsetToSourcePos(this.state.lastTokEndLoc.index), this.state.start);
			}
			hasFollowingLineBreak() {
				return _t(this.input, this.state.end, this.nextTokenStart());
			}
			isLineTerminator() {
				return this.eat(13) || this.canInsertSemicolon();
			}
			semicolon(t = !0) {
				(t ? this.isLineTerminator() : this.eat(13)) || this.raise(p.MissingSemicolon, this.state.lastTokEndLoc);
			}
			expect(t, e) {
				this.eat(t) || this.unexpected(e, t);
			}
			tryParse(t, e = this.state.clone()) {
				let s = { node: null };
				try {
					let i = t((r = null) => {
						throw s.node = r, s;
					});
					if (this.state.errors.length > e.errors.length) {
						let r = this.state;
						return this.state = e, this.state.tokensLength = r.tokensLength, {
							node: i,
							error: r.errors[e.errors.length],
							thrown: !1,
							aborted: !1,
							failState: r
						};
					}
					return {
						node: i,
						error: null,
						thrown: !1,
						aborted: !1,
						failState: null
					};
				} catch (i) {
					let r = this.state;
					if (this.state = e, i instanceof SyntaxError) return {
						node: null,
						error: i,
						thrown: !0,
						aborted: !1,
						failState: r
					};
					if (i === s) return {
						node: s.node,
						error: null,
						thrown: !1,
						aborted: !0,
						failState: r
					};
					throw i;
				}
			}
			checkExpressionErrors(t, e) {
				if (!t) return !1;
				let { shorthandAssignLoc: s, doubleProtoLoc: i, privateKeyLoc: r, optionalParametersLoc: n, voidPatternLoc: o } = t, h = !!s || !!i || !!n || !!r || !!o;
				if (!e) return h;
				s != null && this.raise(p.InvalidCoverInitializedName, s), i != null && this.raise(p.DuplicateProto, i), r != null && this.raise(p.UnexpectedPrivateField, r), n != null && this.unexpected(n), o != null && this.raise(p.InvalidCoverDiscardElement, o);
			}
			isLiteralPropertyName() {
				return Gt(this.state.type);
			}
			isPrivateName(t) {
				return t.type === "PrivateName";
			}
			getPrivateNameSV(t) {
				return t.id.name;
			}
			hasPropertyAsPrivateName(t) {
				return (t.type === "MemberExpression" || t.type === "OptionalMemberExpression") && this.isPrivateName(t.property);
			}
			isObjectProperty(t) {
				return t.type === "ObjectProperty";
			}
			isObjectMethod(t) {
				return t.type === "ObjectMethod";
			}
			initializeScopes(t = this.options.sourceType === "module") {
				let e = this.state.labels;
				this.state.labels = [];
				let s = this.exportedIdentifiers;
				this.exportedIdentifiers = /* @__PURE__ */ new Set();
				let i = this.inModule;
				this.inModule = t;
				let r = this.scope;
				this.scope = new (this.getScopeHandler())(this, t);
				let o = this.prodParam;
				this.prodParam = new Ye();
				let h = this.classScope;
				this.classScope = new at(this);
				let l = this.expressionScope;
				return this.expressionScope = new nt(this), () => {
					this.state.labels = e, this.exportedIdentifiers = s, this.inModule = i, this.scope = r, this.prodParam = o, this.classScope = h, this.expressionScope = l;
				};
			}
			enterInitialScopes() {
				let t = 0;
				(this.inModule || this.optionFlags & 1) && (t |= 2), this.optionFlags & 32 && (t |= 1);
				let e = !this.inModule && this.options.sourceType === "commonjs";
				(e || this.optionFlags & 2) && (t |= 4), this.prodParam.enter(t);
				let s = e ? 514 : 1;
				this.optionFlags & 4 && (s |= 512), this.optionFlags & 16 && (s |= 48), this.scope.enter(s);
			}
			checkDestructuringPrivate(t) {
				let { privateKeyLoc: e } = t;
				e !== null && this.expectPlugin("destructuringPrivate", e);
			}
		}, Y = class {
			shorthandAssignLoc = null;
			doubleProtoLoc = null;
			privateKeyLoc = null;
			optionalParametersLoc = null;
			voidPatternLoc = null;
		}, de = class {
			constructor(t, e, s) {
				this.start = e, this.end = 0, this.loc = new Q(s), t?.optionFlags & 128 && (this.range = [e, 0]), t?.filename && (this.loc.filename = t.filename);
			}
			type = "";
		}, zt = de.prototype, ht = class extends ot {
			startNode() {
				let t = this.state.startLoc;
				return new de(this, t.index, t);
			}
			startNodeAt(t) {
				return new de(this, t.index, t);
			}
			startNodeAtNode(t) {
				return this.startNodeAt(t.loc.start);
			}
			finishNode(t, e) {
				return this.finishNodeAt(t, e, this.state.lastTokEndLoc);
			}
			finishNodeAt(t, e, s) {
				return t.type = e, t.end = s.index, t.loc.end = s, this.optionFlags & 128 && (t.range[1] = s.index), this.optionFlags & 4096 && this.processComment(t), t;
			}
			resetStartLocation(t, e) {
				t.start = e.index, t.loc.start = e, this.optionFlags & 128 && (t.range[0] = e.index);
			}
			resetEndLocation(t, e = this.state.lastTokEndLoc) {
				t.end = e.index, t.loc.end = e, this.optionFlags & 128 && (t.range[1] = e.index);
			}
			resetStartLocationFromNode(t, e) {
				this.resetStartLocation(t, e.loc.start);
			}
			castNodeTo(t, e) {
				return t.type = e, t;
			}
			cloneIdentifier(t) {
				let { type: e, start: s, end: i, loc: r, range: n, name: o } = t, h = Object.create(zt);
				return h.type = e, h.start = s, h.end = i, h.loc = r, h.range = n, h.name = o, t.extra && (h.extra = t.extra), h;
			}
			cloneStringLiteral(t) {
				let { type: e, start: s, end: i, loc: r, range: n, extra: o } = t, h = Object.create(zt);
				return h.type = e, h.start = s, h.end = i, h.loc = r, h.range = n, h.extra = o, h.value = t.value, h;
			}
		}, ct = (a) => a.type === "ParenthesizedExpression" ? ct(a.expression) : a, lt = class extends ht {
			toAssignable(t, e = !1) {
				let s;
				switch ((t.type === "ParenthesizedExpression" || t.extra?.parenthesized) && (s = ct(t), e ? s.type === "Identifier" ? this.expressionScope.recordArrowParameterBindingError(p.InvalidParenthesizedAssignment, t) : s.type !== "CallExpression" && s.type !== "MemberExpression" && !this.isOptionalMemberExpression(s) && this.raise(p.InvalidParenthesizedAssignment, t) : this.raise(p.InvalidParenthesizedAssignment, t)), t.type) {
					case "Identifier":
					case "ObjectPattern":
					case "ArrayPattern":
					case "AssignmentPattern":
					case "RestElement":
					case "VoidPattern": break;
					case "ObjectExpression":
						this.castNodeTo(t, "ObjectPattern");
						for (let i = 0, r = t.properties.length, n = r - 1; i < r; i++) {
							let o = t.properties[i], h = i === n;
							this.toAssignableObjectExpressionProp(o, h, e), h && o.type === "RestElement" && t.extra?.trailingCommaLoc && this.raise(p.RestTrailingComma, t.extra.trailingCommaLoc);
						}
						break;
					case "ObjectProperty": {
						let { key: i, value: r } = t;
						this.isPrivateName(i) && this.classScope.usePrivateName(this.getPrivateNameSV(i), i.loc.start), this.toAssignable(r, e);
						break;
					}
					case "SpreadElement": throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
					case "ArrayExpression":
						this.castNodeTo(t, "ArrayPattern"), this.toAssignableList(t.elements, t.extra?.trailingCommaLoc, e);
						break;
					case "AssignmentExpression":
						t.operator !== "=" && this.raise(p.MissingEqInAssignment, t.left.loc.end), this.castNodeTo(t, "AssignmentPattern"), delete t.operator, t.left.type === "VoidPattern" && this.raise(p.VoidPatternInitializer, t.left), this.toAssignable(t.left, e);
						break;
					case "ParenthesizedExpression":
						this.toAssignable(s, e);
						break;
				}
			}
			toAssignableObjectExpressionProp(t, e, s) {
				if (t.type === "ObjectMethod") this.raise(t.kind === "get" || t.kind === "set" ? p.PatternHasAccessor : p.PatternHasMethod, t.key);
				else if (t.type === "SpreadElement") {
					this.castNodeTo(t, "RestElement");
					let i = t.argument;
					this.checkToRestConversion(i, !1), this.toAssignable(i, s), e || this.raise(p.RestTrailingComma, t);
				} else this.toAssignable(t, s);
			}
			toAssignableList(t, e, s) {
				let i = t.length - 1;
				for (let r = 0; r <= i; r++) {
					let n = t[r];
					n && (this.toAssignableListItem(t, r, s), n.type === "RestElement" && (r < i ? this.raise(p.RestTrailingComma, n) : e && this.raise(p.RestTrailingComma, e)));
				}
			}
			toAssignableListItem(t, e, s) {
				let i = t[e];
				if (i.type === "SpreadElement") {
					this.castNodeTo(i, "RestElement");
					let r = i.argument;
					this.checkToRestConversion(r, !0), this.toAssignable(r, s);
				} else this.toAssignable(i, s);
			}
			isAssignable(t, e) {
				switch (t.type) {
					case "Identifier":
					case "ObjectPattern":
					case "ArrayPattern":
					case "AssignmentPattern":
					case "RestElement":
					case "VoidPattern": return !0;
					case "ObjectExpression": {
						let s = t.properties.length - 1;
						return t.properties.every((i, r) => i.type !== "ObjectMethod" && (r === s || i.type !== "SpreadElement") && this.isAssignable(i));
					}
					case "ObjectProperty": return this.isAssignable(t.value);
					case "SpreadElement": return this.isAssignable(t.argument);
					case "ArrayExpression": return t.elements.every((s) => s === null || this.isAssignable(s));
					case "AssignmentExpression": return t.operator === "=";
					case "ParenthesizedExpression": return this.isAssignable(t.expression);
					case "MemberExpression":
					case "OptionalMemberExpression": return !e;
					default: return !1;
				}
			}
			toReferencedList(t, e) {
				return t;
			}
			toReferencedListDeep(t, e) {
				this.toReferencedList(t, e);
				for (let s of t) s?.type === "ArrayExpression" && this.toReferencedListDeep(s.elements);
			}
			parseSpread(t) {
				let e = this.startNode();
				return this.next(), e.argument = this.parseMaybeAssignAllowIn(t, void 0), this.finishNode(e, "SpreadElement");
			}
			parseRestBinding() {
				let t = this.startNode();
				this.next();
				let e = this.parseBindingAtom();
				return e.type === "VoidPattern" && this.raise(p.UnexpectedVoidPattern, e), t.argument = e, this.finishNode(t, "RestElement");
			}
			parseBindingAtom() {
				switch (this.state.type) {
					case 0: {
						let t = this.startNode();
						return this.next(), t.elements = this.parseBindingList(3, 93, 1), this.finishNode(t, "ArrayPattern");
					}
					case 5: return this.parseObjectLike(8, !0);
					case 88: return this.parseVoidPattern(null);
				}
				return this.parseIdentifier();
			}
			parseBindingList(t, e, s) {
				let i = s & 1, r = [], n = !0;
				for (; !this.eat(t);) if (n ? n = !1 : this.expect(12), i && this.match(12)) r.push(null);
				else {
					if (this.eat(t)) break;
					if (this.match(21)) {
						let o = this.parseRestBinding();
						if (s & 2 && (o = this.parseFunctionParamType(o)), r.push(o), !this.checkCommaAfterRest(e)) {
							this.expect(t);
							break;
						}
					} else {
						let o = [];
						if (s & 2) for (this.match(26) && this.hasPlugin("decorators") && this.raise(p.UnsupportedParameterDecorator, this.state.startLoc); this.match(26);) o.push(this.parseDecorator());
						r.push(this.parseBindingElement(s, o));
					}
				}
				return r;
			}
			parseBindingRestProperty(t) {
				return this.next(), this.hasPlugin("discardBinding") && this.match(88) ? (t.argument = this.parseVoidPattern(null), this.raise(p.UnexpectedVoidPattern, t.argument)) : t.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(t, "RestElement");
			}
			parseBindingProperty() {
				let { type: t, startLoc: e } = this.state;
				if (t === 21) return this.parseBindingRestProperty(this.startNode());
				let s = this.startNode();
				return t === 139 ? (this.expectPlugin("destructuringPrivate", e), this.classScope.usePrivateName(this.state.value, e), s.key = this.parsePrivateName()) : this.parsePropertyName(s), s.method = !1, this.parseObjPropValue(s, e, !1, !1, !0, !1);
			}
			parseBindingElement(t, e) {
				let s = this.parseMaybeDefault();
				return t & 2 && this.parseFunctionParamType(s), e.length && (s.decorators = e, this.resetStartLocationFromNode(s, e[0])), this.parseMaybeDefault(s.loc.start, s);
			}
			parseFunctionParamType(t) {
				return t;
			}
			parseMaybeDefault(t, e) {
				if (t ?? (t = this.state.startLoc), e = e ?? this.parseBindingAtom(), !this.eat(29)) return e;
				let s = this.startNodeAt(t);
				return e.type === "VoidPattern" && this.raise(p.VoidPatternInitializer, e), s.left = e, s.right = this.parseMaybeAssignAllowIn(), this.finishNode(s, "AssignmentPattern");
			}
			isValidLVal(t, e, s, i) {
				switch (t) {
					case "AssignmentPattern": return "left";
					case "RestElement": return "argument";
					case "ObjectProperty": return "value";
					case "ParenthesizedExpression": return "expression";
					case "ArrayPattern": return "elements";
					case "ObjectPattern": return "properties";
					case "VoidPattern": return !0;
					case "CallExpression": if (!e && !this.state.strict && this.optionFlags & 8192) return !0;
				}
				return !1;
			}
			isOptionalMemberExpression(t) {
				return t.type === "OptionalMemberExpression";
			}
			checkLVal(t, e, s = 64, i = !1, r = !1, n = !1, o = !1) {
				let h = t.type;
				if (this.isObjectMethod(t)) return;
				let l = this.isOptionalMemberExpression(t);
				if (l || h === "MemberExpression") {
					l && (this.expectPlugin("optionalChainingAssign", t.loc.start), e.type !== "AssignmentExpression" && this.raise(p.InvalidLhsOptionalChaining, t, { ancestor: e })), s !== 64 && this.raise(p.InvalidPropertyBindingPattern, t);
					return;
				}
				if (h === "Identifier") {
					this.checkIdentifier(t, s, r);
					let { name: N } = t;
					i && (i.has(N) ? this.raise(p.ParamDupe, t) : i.add(N));
					return;
				} else h === "VoidPattern" && e.type === "CatchClause" && this.raise(p.VoidPatternCatchClauseParam, t);
				let u = ct(t);
				o || (o = u.type === "CallExpression" && (u.callee.type === "Import" || u.callee.type === "Super"));
				let f = this.isValidLVal(h, o, !(n || t.extra?.parenthesized) && e.type === "AssignmentExpression", s);
				if (f === !0) return;
				if (f === !1) {
					let N = s === 64 ? p.InvalidLhs : p.InvalidLhsBinding;
					this.raise(N, t, { ancestor: e });
					return;
				}
				let d, x;
				typeof f == "string" ? (d = f, x = h === "ParenthesizedExpression") : [d, x] = f;
				let A = h === "ArrayPattern" || h === "ObjectPattern" ? { type: h } : e, k = t[d];
				if (Array.isArray(k)) for (let N of k) N && this.checkLVal(N, A, s, i, r, x, !0);
				else k && this.checkLVal(k, A, s, i, r, x, o);
			}
			checkIdentifier(t, e, s = !1) {
				this.state.strict && (s ? ss(t.name, this.inModule) : ts(t.name)) && (e === 64 ? this.raise(p.StrictEvalArguments, t, { referenceName: t.name }) : this.raise(p.StrictEvalArgumentsBinding, t, { bindingName: t.name })), e & 8192 && t.name === "let" && this.raise(p.LetInLexicalBinding, t), e & 64 || this.declareNameFromIdentifier(t, e);
			}
			declareNameFromIdentifier(t, e) {
				this.scope.declareName(t.name, e, t.loc.start);
			}
			checkToRestConversion(t, e) {
				switch (t.type) {
					case "ParenthesizedExpression":
						this.checkToRestConversion(t.expression, e);
						break;
					case "Identifier":
					case "MemberExpression": break;
					case "ArrayExpression":
					case "ObjectExpression": if (e) break;
					default: this.raise(p.InvalidRestAssignmentPattern, t);
				}
			}
			checkCommaAfterRest(t) {
				return this.match(12) ? (this.raise(this.lookaheadCharCode() === t ? p.RestTrailingComma : p.ElementAfterRest, this.state.startLoc), !0) : !1;
			}
		}, ze = /in(?:stanceof)?|as|satisfies/y;
		function Gi(a) {
			if (a == null) throw new Error(`Unexpected ${a} value.`);
			return a;
		}
		function qt(a) {
			if (!a) throw new Error("Assert fail");
		}
		var y = F`typescript`({
			AbstractMethodHasImplementation: ({ methodName: a }) => `Method '${a}' cannot have an implementation because it is marked abstract.`,
			AbstractPropertyHasInitializer: ({ propertyName: a }) => `Property '${a}' cannot have an initializer because it is marked abstract.`,
			AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.",
			AccessorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
			AccessorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
			ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
			ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
			ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.",
			ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
			DeclareAccessor: ({ kind: a }) => `'declare' is not allowed in ${a}ters.`,
			DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
			DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
			DuplicateAccessibilityModifier: ({ modifier: a }) => `Accessibility modifier already seen: '${a}'.`,
			DuplicateModifier: ({ modifier: a }) => `Duplicate modifier: '${a}'.`,
			EmptyHeritageClauseType: ({ token: a }) => `'${a}' list cannot be empty.`,
			EmptyTypeArguments: "Type argument list cannot be empty.",
			EmptyTypeParameters: "Type parameter list cannot be empty.",
			ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
			ImportAliasHasImportType: "An import alias can not use 'import type'.",
			ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier",
			IncompatibleModifiers: ({ modifiers: a }) => `'${a[0]}' modifier cannot be used with '${a[1]}' modifier.`,
			IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
			IndexSignatureHasAccessibility: ({ modifier: a }) => `Index signatures cannot have an accessibility modifier ('${a}').`,
			IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
			IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
			IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
			InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.",
			InvalidHeritageClauseType: ({ token: a }) => `'${a}' list can only include identifiers or qualified-names with optional type arguments.`,
			InvalidModifierOnAwaitUsingDeclaration: (a) => `'${a}' modifier cannot appear on an await using declaration.`,
			InvalidModifierOnTypeMember: ({ modifier: a }) => `'${a}' modifier cannot appear on a type member.`,
			InvalidModifierOnTypeParameter: ({ modifier: a }) => `'${a}' modifier cannot appear on a type parameter.`,
			InvalidModifierOnTypeParameterPositions: ({ modifier: a }) => `'${a}' modifier can only appear on a type parameter of a class, interface or type alias.`,
			InvalidModifierOnUsingDeclaration: (a) => `'${a}' modifier cannot appear on a using declaration.`,
			InvalidModifiersOrder: ({ orderedModifiers: a }) => `'${a[0]}' modifier must precede '${a[1]}' modifier.`,
			InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.",
			InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
			MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
			NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
			NonClassMethodPropertyHasAbstractModifier: "'abstract' modifier can only appear on a class, method, or property declaration.",
			OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
			OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
			PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
			PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
			PrivateElementHasAccessibility: ({ modifier: a }) => `Private elements cannot have an accessibility modifier ('${a}').`,
			ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
			ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
			ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
			SetAccessorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
			SetAccessorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
			SetAccessorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
			SingleTypeParameterWithoutTrailingComma: ({ typeParameterName: a }) => `Single type parameter ${a} should have a trailing comma. Example usage: <${a},>.`,
			StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
			TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).",
			TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
			TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
			TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.",
			TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.",
			UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
			UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
			UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
			UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
			UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
			UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
			UnsupportedSignatureParameterKind: ({ type: a }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${a}.`,
			UsingDeclarationInAmbientContext: (a) => `'${a}' declarations are not allowed in ambient contexts.`
		});
		function Xi(a) {
			switch (a) {
				case "any": return "TSAnyKeyword";
				case "boolean": return "TSBooleanKeyword";
				case "bigint": return "TSBigIntKeyword";
				case "never": return "TSNeverKeyword";
				case "number": return "TSNumberKeyword";
				case "object": return "TSObjectKeyword";
				case "string": return "TSStringKeyword";
				case "symbol": return "TSSymbolKeyword";
				case "undefined": return "TSUndefinedKeyword";
				case "unknown": return "TSUnknownKeyword";
				default: return;
			}
		}
		function $t(a) {
			return a === "private" || a === "public" || a === "protected";
		}
		function Yi(a) {
			return a === "in" || a === "out";
		}
		function pt(a) {
			if (a.extra?.parenthesized) return !1;
			switch (a.type) {
				case "Identifier": return !0;
				case "MemberExpression": return !a.computed && pt(a.object);
				case "TSInstantiationExpression": return pt(a.expression);
				default: return !1;
			}
		}
		var Qi = (a) => class extends a {
			getScopeHandler() {
				return Xe;
			}
			tsIsIdentifier() {
				return w(this.state.type);
			}
			tsTokenCanFollowModifier() {
				return this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(139) || this.isLiteralPropertyName();
			}
			tsNextTokenOnSameLineAndCanFollowModifier() {
				return this.next(), this.hasPrecedingLineBreak() ? !1 : this.tsTokenCanFollowModifier();
			}
			tsNextTokenCanFollowModifier() {
				return this.match(106) ? (this.next(), this.tsTokenCanFollowModifier()) : this.tsNextTokenOnSameLineAndCanFollowModifier();
			}
			tsParseModifier(e, s, i) {
				if (!w(this.state.type) && this.state.type !== 58 && this.state.type !== 75) return;
				let r = this.state.value;
				if (e.includes(r)) {
					if (i && this.match(106) || s && this.tsIsStartOfStaticBlocks()) return;
					if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) return r;
				}
			}
			tsParseModifiers({ allowedModifiers: e, disallowedModifiers: s, stopOnStartOfClassStaticBlock: i, errorTemplate: r = y.InvalidModifierOnTypeMember }, n) {
				let o = (l, u, f, d) => {
					u === f && n[d] && this.raise(y.InvalidModifiersOrder, l, { orderedModifiers: [f, d] });
				}, h = (l, u, f, d) => {
					(n[f] && u === d || n[d] && u === f) && this.raise(y.IncompatibleModifiers, l, { modifiers: [f, d] });
				};
				for (;;) {
					let { startLoc: l } = this.state, u = this.tsParseModifier(e.concat(s ?? []), i, n.static);
					if (!u) break;
					$t(u) ? n.accessibility ? this.raise(y.DuplicateAccessibilityModifier, l, { modifier: u }) : (o(l, u, u, "override"), o(l, u, u, "static"), o(l, u, u, "readonly"), n.accessibility = u) : Yi(u) ? (n[u] && this.raise(y.DuplicateModifier, l, { modifier: u }), n[u] = !0, o(l, u, "in", "out")) : (Object.prototype.hasOwnProperty.call(n, u) ? this.raise(y.DuplicateModifier, l, { modifier: u }) : (o(l, u, "static", "readonly"), o(l, u, "static", "override"), o(l, u, "override", "readonly"), o(l, u, "abstract", "override"), h(l, u, "declare", "override"), h(l, u, "static", "abstract")), n[u] = !0), s?.includes(u) && this.raise(r, l, { modifier: u });
				}
			}
			tsIsListTerminator(e) {
				switch (e) {
					case "EnumMembers":
					case "TypeMembers": return this.match(8);
					case "HeritageClauseElement": return this.match(5);
					case "TupleElementTypes": return this.match(3);
					case "TypeParametersOrArguments": return this.match(48);
				}
			}
			tsParseList(e, s) {
				let i = [];
				for (; !this.tsIsListTerminator(e);) i.push(s());
				return i;
			}
			tsParseDelimitedList(e, s, i) {
				return Gi(this.tsParseDelimitedListWorker(e, s, !0, i));
			}
			tsParseDelimitedListWorker(e, s, i, r) {
				let n = [], o = -1;
				for (; !this.tsIsListTerminator(e);) {
					o = -1;
					let h = s();
					if (h == null) return;
					if (n.push(h), this.eat(12)) {
						o = this.state.lastTokStartLoc.index;
						continue;
					}
					if (this.tsIsListTerminator(e)) break;
					i && this.expect(12);
					return;
				}
				return r && (r.value = o), n;
			}
			tsParseBracketedList(e, s, i, r, n) {
				r || (i ? this.expect(0) : this.expect(47));
				let o = this.tsParseDelimitedList(e, s, n);
				return i ? this.expect(3) : this.expect(48), o;
			}
			tsParseImportType() {
				let e = this.startNode();
				return this.expect(83), this.expect(10), this.match(134) ? e.argument = this.tsParseLiteralTypeNode() : (this.raise(y.UnsupportedImportTypeArgument, this.state.startLoc), e.argument = this.tsParseNonConditionalType()), this.eat(12) ? e.options = this.tsParseImportTypeOptions() : e.options = null, this.expect(11), this.eat(16) && (e.qualifier = this.tsParseEntityName(3)), this.match(47) && (e.typeArguments = this.tsParseTypeArguments()), this.finishNode(e, "TSImportType");
			}
			tsParseImportTypeOptions() {
				let e = this.startNode();
				this.expect(5);
				let s = this.startNode();
				return this.isContextual(76) ? (s.method = !1, s.key = this.parseIdentifier(!0), s.computed = !1, s.shorthand = !1) : this.unexpected(null, 76), this.expect(14), s.value = this.tsParseImportTypeWithPropertyValue(), e.properties = [this.finishObjectProperty(s)], this.eat(12), this.expect(8), this.finishNode(e, "ObjectExpression");
			}
			tsParseImportTypeWithPropertyValue() {
				let e = this.startNode(), s = [];
				for (this.expect(5); !this.match(8);) {
					let i = this.state.type;
					w(i) || i === 134 ? s.push(super.parsePropertyDefinition(null)) : this.unexpected(), this.eat(12);
				}
				return e.properties = s, this.next(), this.finishNode(e, "ObjectExpression");
			}
			tsParseEntityName(e) {
				let s;
				if (e & 1 && this.match(78)) if (e & 2) s = this.parseIdentifier(!0);
				else {
					let i = this.startNode();
					this.next(), s = this.finishNode(i, "ThisExpression");
				}
				else s = this.parseIdentifier(!!(e & 1));
				for (; this.eat(16);) {
					let i = this.startNodeAtNode(s);
					i.left = s, i.right = this.parseIdentifier(!!(e & 1)), s = this.finishNode(i, "TSQualifiedName");
				}
				return s;
			}
			tsParseTypeReference() {
				let e = this.startNode();
				return e.typeName = this.tsParseEntityName(1), !this.hasPrecedingLineBreak() && this.match(47) && (e.typeArguments = this.tsParseTypeArguments()), this.finishNode(e, "TSTypeReference");
			}
			tsParseThisTypePredicate(e) {
				this.next();
				let s = this.startNodeAtNode(e);
				return s.parameterName = e, s.typeAnnotation = this.tsParseTypeAnnotation(!1), s.asserts = !1, this.finishNode(s, "TSTypePredicate");
			}
			tsParseThisTypeNode() {
				let e = this.startNode();
				return this.next(), this.finishNode(e, "TSThisType");
			}
			tsParseTypeQuery() {
				let e = this.startNode();
				return this.expect(87), this.match(83) ? e.exprName = this.tsParseImportType() : e.exprName = this.tsParseEntityName(1), !this.hasPrecedingLineBreak() && this.match(47) && (e.typeArguments = this.tsParseTypeArguments()), this.finishNode(e, "TSTypeQuery");
			}
			tsParseInOutModifiers = this.tsParseModifiers.bind(this, {
				allowedModifiers: ["in", "out"],
				disallowedModifiers: [
					"const",
					"public",
					"private",
					"protected",
					"readonly",
					"declare",
					"abstract",
					"override"
				],
				errorTemplate: y.InvalidModifierOnTypeParameter
			});
			tsParseConstModifier = this.tsParseModifiers.bind(this, {
				allowedModifiers: ["const"],
				disallowedModifiers: ["in", "out"],
				errorTemplate: y.InvalidModifierOnTypeParameterPositions
			});
			tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, {
				allowedModifiers: [
					"in",
					"out",
					"const"
				],
				disallowedModifiers: [
					"public",
					"private",
					"protected",
					"readonly",
					"declare",
					"abstract",
					"override"
				],
				errorTemplate: y.InvalidModifierOnTypeParameter
			});
			tsParseTypeParameter(e) {
				let s = this.startNode();
				return e(s), s.name = this.tsParseTypeParameterName(), s.constraint = this.tsEatThenParseType(81), s.default = this.tsEatThenParseType(29), this.finishNode(s, "TSTypeParameter");
			}
			tsTryParseTypeParameters(e) {
				if (this.match(47)) return this.tsParseTypeParameters(e);
			}
			tsParseTypeParameters(e) {
				let s = this.startNode();
				this.match(47) || this.match(143) ? this.next() : this.unexpected();
				let i = { value: -1 };
				return s.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, e), !1, !0, i), s.params.length === 0 && this.raise(y.EmptyTypeParameters, s), i.value !== -1 && this.addExtra(s, "trailingComma", i.value), this.finishNode(s, "TSTypeParameterDeclaration");
			}
			tsFillSignature(e, s) {
				let i = e === 19, r = "params", n = "returnType";
				s.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier), this.expect(10), s[r] = this.tsParseBindingListForSignature(), i ? s[n] = this.tsParseTypeOrTypePredicateAnnotation(e) : this.match(e) && (s[n] = this.tsParseTypeOrTypePredicateAnnotation(e));
			}
			tsParseBindingListForSignature() {
				let e = super.parseBindingList(11, 41, 2);
				for (let s of e) {
					let { type: i } = s;
					(i === "AssignmentPattern" || i === "TSParameterProperty") && this.raise(y.UnsupportedSignatureParameterKind, s, { type: i });
				}
				return e;
			}
			tsParseTypeMemberSemicolon() {
				!this.eat(12) && !this.isLineTerminator() && this.expect(13);
			}
			tsParseSignatureMember(e, s) {
				return this.tsFillSignature(14, s), this.tsParseTypeMemberSemicolon(), this.finishNode(s, e);
			}
			tsIsUnambiguouslyIndexSignature() {
				return this.next(), w(this.state.type) ? (this.next(), this.match(14)) : !1;
			}
			tsTryParseIndexSignature(e) {
				if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) return;
				this.expect(0);
				let s = this.parseIdentifier();
				s.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(s), this.expect(3), e.parameters = [s];
				let i = this.tsTryParseTypeAnnotation();
				return i && (e.typeAnnotation = i), this.tsParseTypeMemberSemicolon(), this.finishNode(e, "TSIndexSignature");
			}
			tsParsePropertyOrMethodSignature(e, s) {
				if (this.eat(17) && (e.optional = !0), this.match(10) || this.match(47)) {
					s && this.raise(y.ReadonlyForMethodSignature, e);
					let i = e;
					i.kind && this.match(47) && this.raise(y.AccessorCannotHaveTypeParameters, this.state.curPosition()), this.tsFillSignature(14, i), this.tsParseTypeMemberSemicolon();
					let r = "params", n = "returnType";
					if (i.kind === "get") i[r].length > 0 && (this.raise(p.BadGetterArity, this.state.curPosition()), this.isThisParam(i[r][0]) && this.raise(y.AccessorCannotDeclareThisParameter, this.state.curPosition()));
					else if (i.kind === "set") {
						if (i[r].length !== 1) this.raise(p.BadSetterArity, this.state.curPosition());
						else {
							let o = i[r][0];
							this.isThisParam(o) && this.raise(y.AccessorCannotDeclareThisParameter, this.state.curPosition()), o.type === "Identifier" && o.optional && this.raise(y.SetAccessorCannotHaveOptionalParameter, this.state.curPosition()), o.type === "RestElement" && this.raise(y.SetAccessorCannotHaveRestParameter, this.state.curPosition());
						}
						i[n] && this.raise(y.SetAccessorCannotHaveReturnType, i[n]);
					} else i.kind = "method";
					return this.finishNode(i, "TSMethodSignature");
				} else {
					let i = e;
					s && (i.readonly = !0);
					let r = this.tsTryParseTypeAnnotation();
					return r && (i.typeAnnotation = r), this.tsParseTypeMemberSemicolon(), this.finishNode(i, "TSPropertySignature");
				}
			}
			tsParseTypeMember() {
				let e = this.startNode();
				if (this.match(10) || this.match(47)) return this.tsParseSignatureMember("TSCallSignatureDeclaration", e);
				if (this.match(77)) {
					let i = this.startNode();
					return this.next(), this.match(10) || this.match(47) ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", e) : (e.key = this.createIdentifier(i, "new"), this.tsParsePropertyOrMethodSignature(e, !1));
				}
				this.tsParseModifiers({
					allowedModifiers: ["readonly"],
					disallowedModifiers: [
						"declare",
						"abstract",
						"private",
						"protected",
						"public",
						"static",
						"override"
					]
				}, e);
				return this.tsTryParseIndexSignature(e) || (super.parsePropertyName(e), !e.computed && e.key.type === "Identifier" && (e.key.name === "get" || e.key.name === "set") && this.tsTokenCanFollowModifier() && (e.kind = e.key.name, super.parsePropertyName(e), !this.match(10) && !this.match(47) && this.unexpected(null, 10)), this.tsParsePropertyOrMethodSignature(e, !!e.readonly));
			}
			tsParseTypeLiteral() {
				let e = this.startNode();
				return e.members = this.tsParseObjectTypeMembers(), this.finishNode(e, "TSTypeLiteral");
			}
			tsParseObjectTypeMembers() {
				this.expect(5);
				let e = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
				return this.expect(8), e;
			}
			tsIsStartOfMappedType() {
				return this.next(), this.eat(53) ? this.isContextual(122) : (this.isContextual(122) && this.next(), !this.match(0) || (this.next(), !this.tsIsIdentifier()) ? !1 : (this.next(), this.match(58)));
			}
			tsParseMappedType() {
				let e = this.startNode();
				return this.expect(5), this.match(53) ? (e.readonly = this.state.value, this.next(), this.expectContextual(122)) : this.eatContextual(122) && (e.readonly = !0), this.expect(0), e.key = this.tsParseTypeParameterName(), e.constraint = this.tsExpectThenParseType(58), e.nameType = this.eatContextual(93) ? this.tsParseType() : null, this.expect(3), this.match(53) ? (e.optional = this.state.value, this.next(), this.expect(17)) : this.eat(17) && (e.optional = !0), e.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(8), this.finishNode(e, "TSMappedType");
			}
			tsParseTupleType() {
				let e = this.startNode();
				e.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), !0, !1);
				let s = !1;
				return e.elementTypes.forEach((i) => {
					let { type: r } = i;
					s && r !== "TSRestType" && r !== "TSOptionalType" && !(r === "TSNamedTupleMember" && i.optional) && this.raise(y.OptionalTypeBeforeRequired, i), s || (s = r === "TSNamedTupleMember" && i.optional || r === "TSOptionalType");
				}), this.finishNode(e, "TSTupleType");
			}
			tsParseTupleElementType() {
				let e = this.state.startLoc, s = this.eat(21), { startLoc: i } = this.state, r, n, o, h, u = O(this.state.type) ? this.lookaheadCharCode() : null;
				if (u === 58) r = !0, o = !1, n = this.parseIdentifier(!0), this.expect(14), h = this.tsParseType();
				else if (u === 63) {
					o = !0;
					let f = this.state.value, d = this.tsParseNonArrayType();
					this.lookaheadCharCode() === 58 ? (r = !0, n = this.createIdentifier(this.startNodeAt(i), f), this.expect(17), this.expect(14), h = this.tsParseType()) : (r = !1, h = d, this.expect(17));
				} else h = this.tsParseType(), o = this.eat(17), r = this.eat(14);
				if (r) {
					let f;
					n ? (f = this.startNodeAt(i), f.optional = o, f.label = n, f.elementType = h, this.eat(17) && (f.optional = !0, this.raise(y.TupleOptionalAfterType, this.state.lastTokStartLoc))) : (f = this.startNodeAt(i), f.optional = o, this.raise(y.InvalidTupleMemberLabel, h), f.label = h, f.elementType = this.tsParseType()), h = this.finishNode(f, "TSNamedTupleMember");
				} else if (o) {
					let f = this.startNodeAt(i);
					f.typeAnnotation = h, h = this.finishNode(f, "TSOptionalType");
				}
				if (s) {
					let f = this.startNodeAt(e);
					f.typeAnnotation = h, h = this.finishNode(f, "TSRestType");
				}
				return h;
			}
			tsParseParenthesizedType() {
				let e = this.startNode();
				return this.expect(10), e.typeAnnotation = this.tsParseType(), this.expect(11), this.finishNode(e, "TSParenthesizedType");
			}
			tsParseFunctionOrConstructorType(e, s) {
				let i = this.startNode();
				return e === "TSConstructorType" && (i.abstract = !!s, s && this.next(), this.next()), this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, i)), this.finishNode(i, e);
			}
			tsParseLiteralTypeNode() {
				let e = this.startNode();
				switch (this.state.type) {
					case 135:
					case 136:
					case 134:
					case 85:
					case 86:
						e.literal = super.parseExprAtom();
						break;
					default: this.unexpected();
				}
				return this.finishNode(e, "TSLiteralType");
			}
			tsParseTemplateLiteralType() {
				{
					let e = this.state.startLoc, s = this.parseTemplateElement(!1), i = [s];
					if (s.tail) {
						let r = this.startNodeAt(e), n = this.startNodeAt(e);
						return n.expressions = [], n.quasis = i, r.literal = this.finishNode(n, "TemplateLiteral"), this.finishNode(r, "TSLiteralType");
					} else {
						let r = [];
						for (; !s.tail;) r.push(this.tsParseType()), this.readTemplateContinuation(), i.push(s = this.parseTemplateElement(!1));
						let n = this.startNodeAt(e);
						return n.types = r, n.quasis = i, this.finishNode(n, "TSTemplateLiteralType");
					}
				}
			}
			parseTemplateSubstitution() {
				return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
			}
			tsParseThisTypeOrThisTypePredicate() {
				let e = this.tsParseThisTypeNode();
				return this.isContextual(116) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(e) : e;
			}
			tsParseNonArrayType() {
				switch (this.state.type) {
					case 134:
					case 135:
					case 136:
					case 85:
					case 86: return this.tsParseLiteralTypeNode();
					case 53:
						if (this.state.value === "-") {
							let e = this.startNode(), s = this.lookahead();
							return s.type !== 135 && s.type !== 136 && this.unexpected(), e.literal = this.parseMaybeUnary(), this.finishNode(e, "TSLiteralType");
						}
						break;
					case 78: return this.tsParseThisTypeOrThisTypePredicate();
					case 87: return this.tsParseTypeQuery();
					case 83: return this.tsParseImportType();
					case 5: return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
					case 0: return this.tsParseTupleType();
					case 10:
						if (!(this.optionFlags & 1024)) {
							let e = this.state.startLoc;
							this.next();
							let s = this.tsParseType();
							return this.expect(11), this.addExtra(s, "parenthesized", !0), this.addExtra(s, "parenStart", e.index), s;
						}
						return this.tsParseParenthesizedType();
					case 25:
					case 24: return this.tsParseTemplateLiteralType();
					default: {
						let { type: e } = this.state;
						if (w(e) || e === 88 || e === 84) {
							let s = e === 88 ? "TSVoidKeyword" : e === 84 ? "TSNullKeyword" : Xi(this.state.value);
							if (s !== void 0 && this.lookaheadCharCode() !== 46) {
								let i = this.startNode();
								return this.next(), this.finishNode(i, s);
							}
							return this.tsParseTypeReference();
						}
					}
				}
				throw this.unexpected();
			}
			tsParseArrayTypeOrHigher() {
				let { startLoc: e } = this.state, s = this.tsParseNonArrayType();
				for (; !this.hasPrecedingLineBreak() && this.eat(0);) if (this.match(3)) {
					let i = this.startNodeAt(e);
					i.elementType = s, this.expect(3), s = this.finishNode(i, "TSArrayType");
				} else {
					let i = this.startNodeAt(e);
					i.objectType = s, i.indexType = this.tsParseType(), this.expect(3), s = this.finishNode(i, "TSIndexedAccessType");
				}
				return s;
			}
			tsParseTypeOperator() {
				let e = this.startNode(), s = this.state.value;
				return this.next(), e.operator = s, e.typeAnnotation = this.tsParseTypeOperatorOrHigher(), s === "readonly" && this.tsCheckTypeAnnotationForReadOnly(e), this.finishNode(e, "TSTypeOperator");
			}
			tsCheckTypeAnnotationForReadOnly(e) {
				switch (e.typeAnnotation.type) {
					case "TSTupleType":
					case "TSArrayType": return;
					default: this.raise(y.UnexpectedReadonly, e);
				}
			}
			tsParseInferType() {
				let e = this.startNode();
				this.expectContextual(115);
				let s = this.startNode();
				return s.name = this.tsParseTypeParameterName(), s.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType()), e.typeParameter = this.finishNode(s, "TSTypeParameter"), this.finishNode(e, "TSInferType");
			}
			tsParseConstraintForInferType() {
				if (this.eat(81)) {
					let e = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
					if (this.state.inDisallowConditionalTypesContext || !this.match(17)) return e;
				}
			}
			tsParseTypeOperatorOrHigher() {
				return gi(this.state.type) && !this.state.containsEsc ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
			}
			tsParseUnionOrIntersectionType(e, s, i) {
				let r = this.startNode(), n = this.eat(i), o = [];
				do
					o.push(s());
				while (this.eat(i));
				return o.length === 1 && !n ? o[0] : (r.types = o, this.finishNode(r, e));
			}
			tsParseIntersectionTypeOrHigher() {
				return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
			}
			tsParseUnionTypeOrHigher() {
				return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
			}
			tsIsStartOfFunctionType() {
				return this.match(47) ? !0 : this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
			}
			tsSkipParameterStart() {
				if (w(this.state.type) || this.match(78)) return this.next(), !0;
				if (this.match(5)) {
					let { errors: e } = this.state, s = e.length;
					try {
						return this.parseObjectLike(8, !0), e.length === s;
					} catch {
						return !1;
					}
				}
				if (this.match(0)) {
					this.next();
					let { errors: e } = this.state, s = e.length;
					try {
						return super.parseBindingList(3, 93, 1), e.length === s;
					} catch {
						return !1;
					}
				}
				return !1;
			}
			tsIsUnambiguouslyStartOfFunctionType() {
				return this.next(), !!(this.match(11) || this.match(21) || this.tsSkipParameterStart() && (this.match(14) || this.match(12) || this.match(17) || this.match(29) || this.match(11) && (this.next(), this.match(19))));
			}
			tsParseTypeOrTypePredicateAnnotation(e) {
				return this.tsInType(() => {
					let s = this.startNode();
					this.expect(e);
					let i = this.startNode(), r = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
					if (r && this.match(78)) {
						let h = this.tsParseThisTypeOrThisTypePredicate();
						return h.type === "TSThisType" ? (i.parameterName = h, i.asserts = !0, i.typeAnnotation = null, h = this.finishNode(i, "TSTypePredicate")) : (this.resetStartLocationFromNode(h, i), h.asserts = !0), s.typeAnnotation = h, this.finishNode(s, "TSTypeAnnotation");
					}
					let n = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
					if (!n) return r ? (i.parameterName = this.parseIdentifier(), i.asserts = r, i.typeAnnotation = null, s.typeAnnotation = this.finishNode(i, "TSTypePredicate"), this.finishNode(s, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(!1, s);
					let o = this.tsParseTypeAnnotation(!1);
					return i.parameterName = n, i.typeAnnotation = o, i.asserts = r, s.typeAnnotation = this.finishNode(i, "TSTypePredicate"), this.finishNode(s, "TSTypeAnnotation");
				});
			}
			tsTryParseTypeOrTypePredicateAnnotation() {
				if (this.match(14)) return this.tsParseTypeOrTypePredicateAnnotation(14);
			}
			tsTryParseTypeAnnotation() {
				if (this.match(14)) return this.tsParseTypeAnnotation();
			}
			tsTryParseType() {
				return this.tsEatThenParseType(14);
			}
			tsParseTypePredicatePrefix() {
				let e = this.parseIdentifier();
				if (this.isContextual(116) && !this.hasPrecedingLineBreak()) return this.next(), e;
			}
			tsParseTypePredicateAsserts() {
				if (this.state.type !== 109) return !1;
				let e = this.state.containsEsc;
				return this.next(), !w(this.state.type) && !this.match(78) ? !1 : (e && this.raise(p.InvalidEscapedReservedWord, this.state.lastTokStartLoc, { reservedWord: "asserts" }), !0);
			}
			tsParseTypeAnnotation(e = !0, s = this.startNode()) {
				return this.tsInType(() => {
					e && this.expect(14), s.typeAnnotation = this.tsParseType();
				}), this.finishNode(s, "TSTypeAnnotation");
			}
			tsParseType() {
				qt(this.state.inType);
				let e = this.tsParseNonConditionalType();
				if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81)) return e;
				let s = this.startNodeAtNode(e);
				return s.checkType = e, s.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType()), this.expect(17), s.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.expect(14), s.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.finishNode(s, "TSConditionalType");
			}
			isAbstractConstructorSignature() {
				return this.isContextual(124) && this.isLookaheadContextual("new");
			}
			tsParseNonConditionalType() {
				return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(77) ? this.tsParseFunctionOrConstructorType("TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", !0) : this.tsParseUnionTypeOrHigher();
			}
			tsParseTypeAssertion() {
				this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(y.ReservedTypeAssertion, this.state.startLoc);
				let e = this.startNode();
				return e.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? this.tsParseTypeReference() : this.tsParseType())), this.expect(48), e.expression = this.parseMaybeUnary(), this.finishNode(e, "TSTypeAssertion");
			}
			tsParseHeritageClause(e) {
				let s = this.state.startLoc, i = this.tsParseDelimitedList("HeritageClauseElement", () => {
					{
						let r = super.parseExprSubscripts();
						pt(r) || this.raise(y.InvalidHeritageClauseType, r.loc.start, { token: e });
						let n = e === "extends" ? "TSInterfaceHeritage" : "TSClassImplements";
						if (r.type === "TSInstantiationExpression") return r.type = n, r;
						let o = this.startNodeAtNode(r);
						return o.expression = r, (this.match(47) || this.match(51)) && (o.typeArguments = this.tsParseTypeArgumentsInExpression()), this.finishNode(o, n);
					}
				});
				return i.length || this.raise(y.EmptyHeritageClauseType, s, { token: e }), i;
			}
			tsParseInterfaceDeclaration(e, s = {}) {
				if (this.hasFollowingLineBreak()) return null;
				this.expectContextual(129), s.declare && (e.declare = !0), w(this.state.type) ? (e.id = this.parseIdentifier(), this.checkIdentifier(e.id, 130)) : (e.id = null, this.raise(y.MissingInterfaceName, this.state.startLoc)), e.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers), this.eat(81) && (e.extends = this.tsParseHeritageClause("extends"));
				let i = this.startNode();
				return i.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), e.body = this.finishNode(i, "TSInterfaceBody"), this.finishNode(e, "TSInterfaceDeclaration");
			}
			tsParseTypeAliasDeclaration(e) {
				return e.id = this.parseIdentifier(), this.checkIdentifier(e.id, 2), e.typeAnnotation = this.tsInType(() => {
					if (e.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers), this.expect(29), this.isContextual(114) && this.lookaheadCharCode() !== 46) {
						let s = this.startNode();
						return this.next(), this.finishNode(s, "TSIntrinsicKeyword");
					}
					return this.tsParseType();
				}), this.semicolon(), this.finishNode(e, "TSTypeAliasDeclaration");
			}
			tsInTopLevelContext(e) {
				if (this.curContext() !== E.brace) {
					let s = this.state.context;
					this.state.context = [s[0]];
					try {
						return e();
					} finally {
						this.state.context = s;
					}
				} else return e();
			}
			tsInType(e) {
				let s = this.state.inType;
				this.state.inType = !0;
				try {
					return e();
				} finally {
					this.state.inType = s;
				}
			}
			tsInDisallowConditionalTypesContext(e) {
				let s = this.state.inDisallowConditionalTypesContext;
				this.state.inDisallowConditionalTypesContext = !0;
				try {
					return e();
				} finally {
					this.state.inDisallowConditionalTypesContext = s;
				}
			}
			tsInAllowConditionalTypesContext(e) {
				let s = this.state.inDisallowConditionalTypesContext;
				this.state.inDisallowConditionalTypesContext = !1;
				try {
					return e();
				} finally {
					this.state.inDisallowConditionalTypesContext = s;
				}
			}
			tsEatThenParseType(e) {
				if (this.match(e)) return this.tsNextThenParseType();
			}
			tsExpectThenParseType(e) {
				return this.tsInType(() => (this.expect(e), this.tsParseType()));
			}
			tsNextThenParseType() {
				return this.tsInType(() => (this.next(), this.tsParseType()));
			}
			tsParseEnumMember() {
				let e = this.startNode();
				return e.id = this.match(134) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(!0), this.eat(29) && (e.initializer = super.parseMaybeAssignAllowIn()), this.finishNode(e, "TSEnumMember");
			}
			tsParseEnumDeclaration(e, s = {}) {
				return s.const && (e.const = !0), s.declare && (e.declare = !0), this.expectContextual(126), e.id = this.parseIdentifier(), this.checkIdentifier(e.id, e.const ? 8971 : 8459), e.body = this.tsParseEnumBody(), this.finishNode(e, "TSEnumDeclaration");
			}
			tsParseEnumBody() {
				let e = this.startNode();
				return this.expect(5), e.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(8), this.finishNode(e, "TSEnumBody");
			}
			tsParseModuleBlock() {
				let e = this.startNode();
				return this.scope.enter(0), this.expect(5), super.parseBlockOrModuleBlockBody(e.body = [], void 0, !0, 8), this.scope.exit(), this.finishNode(e, "TSModuleBlock");
			}
			tsParseModuleOrNamespaceDeclaration(e, s = !1) {
				return e.id = this.tsParseEntityName(1), e.id.type === "Identifier" && this.checkIdentifier(e.id, 1024), this.scope.enter(1024), this.prodParam.enter(0), e.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit(), this.finishNode(e, "TSModuleDeclaration");
			}
			tsParseAmbientExternalModuleDeclaration(e) {
				return this.isContextual(112) ? (e.kind = "global", e.id = this.parseIdentifier()) : this.match(134) ? (e.kind = "module", e.id = super.parseStringLiteral(this.state.value)) : this.unexpected(), this.match(5) ? (this.scope.enter(1024), this.prodParam.enter(0), e.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(e, "TSModuleDeclaration");
			}
			tsParseImportEqualsDeclaration(e, s, i) {
				e.id = s || this.parseIdentifier(), this.checkIdentifier(e.id, 4096), this.expect(29);
				let r = this.tsParseModuleReference();
				return e.importKind === "type" && r.type !== "TSExternalModuleReference" && this.raise(y.ImportAliasHasImportType, r), e.moduleReference = r, this.semicolon(), this.finishNode(e, "TSImportEqualsDeclaration");
			}
			tsIsExternalModuleReference() {
				return this.isContextual(119) && this.lookaheadCharCode() === 40;
			}
			tsParseModuleReference() {
				return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(0);
			}
			tsParseExternalModuleReference() {
				let e = this.startNode();
				return this.expectContextual(119), this.expect(10), this.match(134) || this.unexpected(), e.expression = super.parseExprAtom(), this.expect(11), this.sawUnambiguousESM = !0, this.finishNode(e, "TSExternalModuleReference");
			}
			tsLookAhead(e) {
				let s = this.state.clone(), i = e();
				return this.state = s, i;
			}
			tsTryParseAndCatch(e) {
				let s = this.tryParse((i) => e() || i());
				if (!(s.aborted || !s.node)) return s.error && (this.state = s.failState), s.node;
			}
			tsTryParse(e) {
				let s = this.state.clone(), i = e();
				if (i !== void 0 && i !== !1) return i;
				this.state = s;
			}
			tsTryParseDeclare(e) {
				if (this.isLineTerminator()) return;
				let s = this.state.type;
				return this.tsInAmbientContext(() => {
					switch (s) {
						case 68: return e.declare = !0, super.parseFunctionStatement(e, !1, !1);
						case 80: return e.declare = !0, this.parseClass(e, !0, !1);
						case 126: return this.tsParseEnumDeclaration(e, { declare: !0 });
						case 112: return this.tsParseAmbientExternalModuleDeclaration(e);
						case 100: if (this.state.containsEsc) return;
						case 75:
						case 74: return !this.match(75) || !this.isLookaheadContextual("enum") ? (e.declare = !0, this.parseVarStatement(e, this.state.value, !0)) : (this.expect(75), this.tsParseEnumDeclaration(e, {
							const: !0,
							declare: !0
						}));
						case 107:
							if (this.isUsing()) return this.raise(y.InvalidModifierOnUsingDeclaration, this.state.startLoc, "declare"), e.declare = !0, this.parseVarStatement(e, "using", !0);
							break;
						case 96:
							if (this.isAwaitUsing()) return this.raise(y.InvalidModifierOnAwaitUsingDeclaration, this.state.startLoc, "declare"), e.declare = !0, this.next(), this.parseVarStatement(e, "await using", !0);
							break;
						case 129: {
							let i = this.tsParseInterfaceDeclaration(e, { declare: !0 });
							if (i) return i;
						}
						default: if (w(s)) return this.tsParseDeclaration(e, this.state.type, !0, null);
					}
				});
			}
			tsTryParseExportDeclaration() {
				return this.tsParseDeclaration(this.startNode(), this.state.type, !0, null);
			}
			tsParseDeclaration(e, s, i, r) {
				switch (s) {
					case 124:
						if (this.tsCheckLineTerminator(i) && (this.match(80) || w(this.state.type))) return this.tsParseAbstractDeclaration(e, r);
						break;
					case 127:
						if (this.tsCheckLineTerminator(i)) {
							if (this.match(134)) return this.tsParseAmbientExternalModuleDeclaration(e);
							if (w(this.state.type)) return e.kind = "module", this.tsParseModuleOrNamespaceDeclaration(e);
						}
						break;
					case 128:
						if (this.tsCheckLineTerminator(i) && w(this.state.type)) return e.kind = "namespace", this.tsParseModuleOrNamespaceDeclaration(e);
						break;
					case 130:
						if (this.tsCheckLineTerminator(i) && w(this.state.type)) return this.tsParseTypeAliasDeclaration(e);
						break;
				}
			}
			tsCheckLineTerminator(e) {
				return e ? this.hasFollowingLineBreak() ? !1 : (this.next(), !0) : !this.isLineTerminator();
			}
			tsTryParseGenericAsyncArrowFunction(e) {
				if (!this.match(47)) return;
				let s = this.state.maybeInArrowParameters;
				this.state.maybeInArrowParameters = !0;
				let i = this.tsTryParseAndCatch(() => {
					let r = this.startNodeAt(e);
					return r.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier), super.parseFunctionParams(r), r.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(), this.expect(19), r;
				});
				if (this.state.maybeInArrowParameters = s, !!i) return super.parseArrowExpression(i, null, !0);
			}
			tsParseTypeArgumentsInExpression() {
				if (this.reScan_lt() === 47) return this.tsParseTypeArguments();
			}
			tsParseTypeArguments() {
				let e = this.startNode();
				return e.params = this.tsInType(() => this.tsInTopLevelContext(() => (this.expect(47), this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this))))), e.params.length === 0 ? this.raise(y.EmptyTypeArguments, e) : !this.state.inType && this.curContext() === E.brace && this.reScan_lt_gt(), this.expect(48), this.finishNode(e, "TSTypeParameterInstantiation");
			}
			tsIsDeclarationStart() {
				return Ti(this.state.type);
			}
			isExportDefaultSpecifier() {
				return this.tsIsDeclarationStart() ? !1 : super.isExportDefaultSpecifier();
			}
			parseBindingElement(e, s) {
				let i = s.length ? s[0].loc.start : this.state.startLoc, r = {};
				this.tsParseModifiers({ allowedModifiers: [
					"public",
					"private",
					"protected",
					"override",
					"readonly"
				] }, r);
				let n = r.accessibility, o = r.override, h = r.readonly;
				!(e & 4) && (n || h || o) && this.raise(y.UnexpectedParameterModifier, i);
				let l = this.parseMaybeDefault();
				e & 2 && this.parseFunctionParamType(l);
				let u = this.parseMaybeDefault(l.loc.start, l);
				if (n || h || o) {
					let f = this.startNodeAt(i);
					return s.length && (f.decorators = s), n && (f.accessibility = n), h && (f.readonly = h), o && (f.override = o), u.type !== "Identifier" && u.type !== "AssignmentPattern" && this.raise(y.UnsupportedParameterPropertyKind, f), f.parameter = u, this.finishNode(f, "TSParameterProperty");
				}
				return s.length && (l.decorators = s), u;
			}
			isSimpleParameter(e) {
				return e.type === "TSParameterProperty" && super.isSimpleParameter(e.parameter) || super.isSimpleParameter(e);
			}
			tsDisallowOptionalPattern(e) {
				for (let s of e.params) s.type !== "Identifier" && s.optional && !this.state.isAmbientContext && this.raise(y.PatternIsOptional, s);
			}
			setArrowFunctionParameters(e, s, i) {
				super.setArrowFunctionParameters(e, s, i), this.tsDisallowOptionalPattern(e);
			}
			parseFunctionBodyAndFinish(e, s, i = !1) {
				this.match(14) && (e.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
				let r = s === "FunctionDeclaration" ? "TSDeclareFunction" : s === "ClassMethod" || s === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
				return r && !this.match(5) && this.isLineTerminator() ? this.finishNode(e, r) : r === "TSDeclareFunction" && this.state.isAmbientContext && (this.raise(y.DeclareFunctionHasImplementation, e), e.declare) ? super.parseFunctionBodyAndFinish(e, r, i) : (this.tsDisallowOptionalPattern(e), super.parseFunctionBodyAndFinish(e, s, i));
			}
			registerFunctionStatementId(e) {
				!e.body && e.id ? this.checkIdentifier(e.id, 1024) : super.registerFunctionStatementId(e);
			}
			tsCheckForInvalidTypeCasts(e) {
				e.forEach((s) => {
					s?.type === "TSTypeCastExpression" && this.raise(y.UnexpectedTypeAnnotation, s.typeAnnotation);
				});
			}
			toReferencedList(e, s) {
				return this.tsCheckForInvalidTypeCasts(e), e;
			}
			parseArrayLike(e, s, i) {
				let r = super.parseArrayLike(e, s, i);
				return r.type === "ArrayExpression" && this.tsCheckForInvalidTypeCasts(r.elements), r;
			}
			parseSubscript(e, s, i, r) {
				if (!this.hasPrecedingLineBreak() && this.match(35)) {
					this.state.canStartJSXElement = !1, this.next();
					let o = this.startNodeAt(s);
					return o.expression = e, this.finishNode(o, "TSNonNullExpression");
				}
				let n = !1;
				if (this.match(18) && this.lookaheadCharCode() === 60) {
					if (i) return r.stop = !0, e;
					r.optionalChainMember = n = !0, this.next();
				}
				if (this.match(47) || this.match(51)) {
					let o, h = this.tsTryParseAndCatch(() => {
						if (!i && this.atPossibleAsyncArrow(e)) {
							let d = this.tsTryParseGenericAsyncArrowFunction(s);
							if (d) return r.stop = !0, d;
						}
						let l = this.tsParseTypeArgumentsInExpression();
						if (!l) return;
						if (n && !this.match(10)) {
							o = this.state.curPosition();
							return;
						}
						if (Ke(this.state.type)) {
							let d = super.parseTaggedTemplateExpression(e, s, r);
							return d.typeArguments = l, d;
						}
						if (!i && this.eat(10)) {
							let d = this.startNodeAt(s);
							return d.callee = e, d.arguments = this.parseCallExpressionArguments(), this.tsCheckForInvalidTypeCasts(d.arguments), d.typeArguments = l, r.optionalChainMember && (d.optional = n), this.finishCallExpression(d, r.optionalChainMember);
						}
						let u = this.state.type;
						if (u === 48 || u === 52 || u !== 10 && ce(u) && !this.hasPrecedingLineBreak()) return;
						let f = this.startNodeAt(s);
						return f.expression = e, f.typeArguments = l, this.finishNode(f, "TSInstantiationExpression");
					});
					if (o && this.unexpected(o, 10), h) return h.type === "TSInstantiationExpression" && ((this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40) && this.raise(y.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc), !this.match(16) && !this.match(18) && (h.expression = super.stopParseSubscript(e, r))), h;
				}
				return super.parseSubscript(e, s, i, r);
			}
			parseNewCallee(e) {
				super.parseNewCallee(e);
				let { callee: s } = e;
				s.type === "TSInstantiationExpression" && !s.extra?.parenthesized && (e.typeArguments = s.typeArguments, e.callee = s.expression);
			}
			parseExprOp(e, s, i) {
				let r;
				if (Ae(58) > i && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (r = this.isContextual(120)))) {
					let n = this.startNodeAt(s);
					return n.expression = e, n.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? (r && this.raise(p.UnexpectedKeyword, this.state.startLoc, { keyword: "const" }), this.tsParseTypeReference()) : this.tsParseType())), this.finishNode(n, r ? "TSSatisfiesExpression" : "TSAsExpression"), this.reScan_lt_gt(), this.parseExprOp(n, s, i);
				}
				return super.parseExprOp(e, s, i);
			}
			checkReservedWord(e, s, i, r) {
				this.state.isAmbientContext || super.checkReservedWord(e, s, i, r);
			}
			checkImportReflection(e) {
				super.checkImportReflection(e), e.module && e.importKind !== "value" && this.raise(y.ImportReflectionHasImportType, e.specifiers[0].loc.start);
			}
			checkDuplicateExports() {}
			isPotentialImportPhase(e) {
				if (super.isPotentialImportPhase(e)) return !0;
				if (this.isContextual(130)) {
					let s = this.lookaheadCharCode();
					return e ? s === 123 || s === 42 : s !== 61;
				}
				return !e && this.isContextual(87);
			}
			applyImportPhase(e, s, i, r) {
				super.applyImportPhase(e, s, i, r), s ? e.exportKind = i === "type" ? "type" : "value" : e.importKind = i === "type" || i === "typeof" ? i : "value";
			}
			parseImport(e) {
				if (this.match(134)) return e.importKind = "value", super.parseImport(e);
				let s;
				if (w(this.state.type) && this.lookaheadCharCode() === 61) return e.importKind = "value", this.tsParseImportEqualsDeclaration(e);
				if (this.isContextual(130)) {
					let i = this.parseMaybeImportPhase(e, !1);
					if (this.lookaheadCharCode() === 61) return this.tsParseImportEqualsDeclaration(e, i);
					s = super.parseImportSpecifiersAndAfter(e, i);
				} else s = super.parseImport(e);
				return s.importKind === "type" && s.specifiers.length > 1 && s.specifiers[0].type === "ImportDefaultSpecifier" && this.raise(y.TypeImportCannotSpecifyDefaultAndNamed, s), s;
			}
			parseExport(e, s) {
				if (this.match(83)) {
					let i = this.startNode();
					this.next();
					let r = null;
					this.isContextual(130) && this.isPotentialImportPhase(!1) ? r = this.parseMaybeImportPhase(i, !1) : i.importKind = "value";
					let n = this.tsParseImportEqualsDeclaration(i, r, !0);
					return e.attributes = [], e.declaration = n, e.exportKind = "value", e.source = null, e.specifiers = [], this.finishNode(e, "ExportNamedDeclaration");
				} else if (this.eat(29)) {
					let i = e;
					return i.expression = super.parseExpression(), this.semicolon(), this.sawUnambiguousESM = !0, this.finishNode(i, "TSExportAssignment");
				} else if (this.eatContextual(93)) {
					let i = e;
					return this.expectContextual(128), i.id = this.parseIdentifier(), this.semicolon(), this.finishNode(i, "TSNamespaceExportDeclaration");
				} else return super.parseExport(e, s);
			}
			isAbstractClass() {
				return this.isContextual(124) && this.isLookaheadContextual("class");
			}
			parseExportDefaultExpression() {
				if (this.isAbstractClass()) {
					let e = this.startNode();
					return this.next(), e.abstract = !0, this.parseClass(e, !0, !0);
				}
				if (this.match(129)) {
					let e = this.tsParseInterfaceDeclaration(this.startNode());
					if (e) return e;
				}
				return super.parseExportDefaultExpression();
			}
			parseVarStatement(e, s, i = !1) {
				let { isAmbientContext: r } = this.state, n = super.parseVarStatement(e, s, i || r);
				if (!r) return n;
				if (!e.declare && (s === "using" || s === "await using")) return this.raiseOverwrite(y.UsingDeclarationInAmbientContext, e, s), n;
				for (let { id: o, init: h } of n.declarations) h && (s === "var" || s === "let" || o.typeAnnotation ? this.raise(y.InitializerNotAllowedInAmbientContext, h) : er(h, this.hasPlugin("estree")) || this.raise(y.ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference, h));
				return n;
			}
			parseStatementContent(e, s) {
				if (!this.state.containsEsc) switch (this.state.type) {
					case 75:
						if (this.isLookaheadContextual("enum")) {
							let i = this.startNode();
							return this.expect(75), this.tsParseEnumDeclaration(i, { const: !0 });
						}
						break;
					case 124:
					case 125:
						if (this.nextTokenIsIdentifierAndNotTSRelationalOperatorOnSameLine()) {
							let i = this.state.type, r = this.startNode();
							this.next();
							let n = i === 125 ? this.tsTryParseDeclare(r) : this.tsParseAbstractDeclaration(r, s);
							return n ? (i === 125 && (n.declare = !0), n) : (r.expression = this.createIdentifier(this.startNodeAt(r.loc.start), i === 125 ? "declare" : "abstract"), this.semicolon(!1), this.finishNode(r, "ExpressionStatement"));
						}
						break;
					case 126: return this.tsParseEnumDeclaration(this.startNode());
					case 112:
						if (this.lookaheadCharCode() === 123) {
							let r = this.startNode();
							return this.tsParseAmbientExternalModuleDeclaration(r);
						}
						break;
					case 129: {
						let i = this.tsParseInterfaceDeclaration(this.startNode());
						if (i) return i;
						break;
					}
					case 127:
						if (this.nextTokenIsIdentifierOrStringLiteralOnSameLine()) {
							let i = this.startNode();
							return this.next(), this.tsParseDeclaration(i, 127, !1, s);
						}
						break;
					case 128:
						if (this.nextTokenIsIdentifierOnSameLine()) {
							let i = this.startNode();
							return this.next(), this.tsParseDeclaration(i, 128, !1, s);
						}
						break;
					case 130:
						if (this.nextTokenIsIdentifierOnSameLine()) {
							let i = this.startNode();
							return this.next(), this.tsParseTypeAliasDeclaration(i);
						}
						break;
				}
				return super.parseStatementContent(e, s);
			}
			parseAccessModifier() {
				return this.tsParseModifier([
					"public",
					"protected",
					"private"
				]);
			}
			tsHasSomeModifiers(e, s) {
				return s.some((i) => $t(i) ? e.accessibility === i : !!e[i]);
			}
			tsIsStartOfStaticBlocks() {
				return this.isContextual(106) && this.lookaheadCharCode() === 123;
			}
			parseClassMember(e, s, i) {
				let r = [
					"declare",
					"private",
					"public",
					"protected",
					"override",
					"abstract",
					"readonly",
					"static"
				];
				this.tsParseModifiers({
					allowedModifiers: r,
					disallowedModifiers: ["in", "out"],
					stopOnStartOfClassStaticBlock: !0,
					errorTemplate: y.InvalidModifierOnTypeParameterPositions
				}, s);
				let n = () => {
					this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(s, r) && this.raise(y.StaticBlockCannotHaveModifier, this.state.curPosition()), super.parseClassStaticBlock(e, s)) : this.parseClassMemberWithIsStatic(e, s, i, !!s.static);
				};
				s.declare ? this.tsInAmbientContext(n) : n();
			}
			parseClassMemberWithIsStatic(e, s, i, r) {
				let n = this.tsTryParseIndexSignature(s);
				if (n) {
					e.body.push(n), s.abstract && this.raise(y.IndexSignatureHasAbstract, s), s.accessibility && this.raise(y.IndexSignatureHasAccessibility, s, { modifier: s.accessibility }), s.declare && this.raise(y.IndexSignatureHasDeclare, s), s.override && this.raise(y.IndexSignatureHasOverride, s);
					return;
				}
				!this.state.inAbstractClass && s.abstract && this.raise(y.NonAbstractClassHasAbstractMethod, s), s.override && (i.hadSuperClass || this.raise(y.OverrideNotInSubClass, s)), super.parseClassMemberWithIsStatic(e, s, i, r);
			}
			parsePostMemberNameModifiers(e) {
				this.eat(17) && (e.optional = !0), e.readonly && this.match(10) && this.raise(y.ClassMethodHasReadonly, e), e.declare && this.match(10) && this.raise(y.ClassMethodHasDeclare, e);
			}
			shouldParseExportDeclaration() {
				return this.tsIsDeclarationStart() ? !0 : super.shouldParseExportDeclaration();
			}
			parseConditional(e, s, i) {
				if (!this.match(17)) return e;
				if (this.state.maybeInArrowParameters) {
					let r = this.lookaheadCharCode();
					if (r === 44 || r === 61 || r === 58 || r === 41) return this.setOptionalParametersError(i), e;
				}
				return super.parseConditional(e, s, i);
			}
			parseParenItem(e, s) {
				let i = super.parseParenItem(e, s);
				if (this.eat(17) && (i.optional = !0, this.resetEndLocation(e)), this.match(14)) {
					let r = this.startNodeAt(s);
					return r.expression = e, r.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(r, "TSTypeCastExpression");
				}
				return e;
			}
			parseExportDeclaration(e) {
				if (!this.state.isAmbientContext && this.isContextual(125)) return this.tsInAmbientContext(() => this.parseExportDeclaration(e));
				let s = this.state.startLoc, i = this.eatContextual(125);
				if (i && (this.isContextual(125) || !this.shouldParseExportDeclaration())) throw this.raise(y.ExpectedAmbientAfterExportDeclare, this.state.startLoc);
				let n = w(this.state.type) && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(e);
				return n ? ((n.type === "TSInterfaceDeclaration" || n.type === "TSTypeAliasDeclaration" || i) && (e.exportKind = "type"), i && n.type !== "TSImportEqualsDeclaration" && (this.resetStartLocation(n, s), n.declare = !0), n) : null;
			}
			parseClassId(e, s, i, r) {
				if ((!s || i) && this.isContextual(113)) return;
				super.parseClassId(e, s, i, e.declare ? 1024 : 8331);
				let n = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
				n && (e.typeParameters = n);
			}
			parseClassPropertyAnnotation(e) {
				e.optional || (this.eat(35) ? e.definite = !0 : this.eat(17) && (e.optional = !0));
				let s = this.tsTryParseTypeAnnotation();
				s && (e.typeAnnotation = s);
			}
			parseClassProperty(e) {
				if (this.parseClassPropertyAnnotation(e), this.state.isAmbientContext && !(e.readonly && !e.typeAnnotation) && this.match(29) && this.raise(y.DeclareClassFieldHasInitializer, this.state.startLoc), e.abstract && this.match(29)) {
					let { key: s } = e;
					this.raise(y.AbstractPropertyHasInitializer, this.state.startLoc, { propertyName: s.type === "Identifier" && !e.computed ? s.name : `[${this.input.slice(this.offsetToSourcePos(s.start), this.offsetToSourcePos(s.end))}]` });
				}
				return super.parseClassProperty(e);
			}
			parseClassPrivateProperty(e) {
				return e.abstract && this.raise(y.PrivateElementHasAbstract, e), e.accessibility && this.raise(y.PrivateElementHasAccessibility, e, { modifier: e.accessibility }), this.parseClassPropertyAnnotation(e), super.parseClassPrivateProperty(e);
			}
			parseClassAccessorProperty(e) {
				return this.parseClassPropertyAnnotation(e), e.optional && this.raise(y.AccessorCannotBeOptional, e), super.parseClassAccessorProperty(e);
			}
			pushClassMethod(e, s, i, r, n, o) {
				let h = this.tsTryParseTypeParameters(this.tsParseConstModifier);
				h && n && this.raise(y.ConstructorHasTypeParameters, h);
				let { declare: l = !1, kind: u } = s;
				l && (u === "get" || u === "set") && this.raise(y.DeclareAccessor, s, { kind: u }), h && (s.typeParameters = h), super.pushClassMethod(e, s, i, r, n, o);
			}
			pushClassPrivateMethod(e, s, i, r) {
				let n = this.tsTryParseTypeParameters(this.tsParseConstModifier);
				n && (s.typeParameters = n), super.pushClassPrivateMethod(e, s, i, r);
			}
			declareClassPrivateMethodInScope(e, s) {
				e.type !== "TSDeclareMethod" && (e.type === "MethodDefinition" && e.value.body == null || super.declareClassPrivateMethodInScope(e, s));
			}
			parseClassSuper(e) {
				super.parseClassSuper(e), e.superClass && (this.match(47) || this.match(51)) && (e.superTypeArguments = this.tsParseTypeArgumentsInExpression()), this.eatContextual(113) && (e.implements = this.tsParseHeritageClause("implements"));
			}
			parseObjPropValue(e, s, i, r, n, o, h) {
				let l = this.tsTryParseTypeParameters(this.tsParseConstModifier);
				return l && (e.typeParameters = l), super.parseObjPropValue(e, s, i, r, n, o, h);
			}
			parseFunctionParams(e, s) {
				let i = this.tsTryParseTypeParameters(this.tsParseConstModifier);
				i && (e.typeParameters = i), super.parseFunctionParams(e, s);
			}
			parseVarId(e, s) {
				super.parseVarId(e, s), e.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35) && (e.definite = !0);
				let i = this.tsTryParseTypeAnnotation();
				i && (e.id.typeAnnotation = i, this.resetEndLocation(e.id));
			}
			parseAsyncArrowFromCallExpression(e, s) {
				return this.match(14) && (e.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(e, s);
			}
			parseMaybeAssign(e, s) {
				let i, r, n;
				if (this.hasPlugin("jsx") && (this.match(143) || this.match(47))) {
					if (i = this.state.clone(), r = this.tryParse(() => super.parseMaybeAssign(e, s), i), !r.error) return r.node;
					let { context: l } = this.state, u = l[l.length - 1];
					(u === E.j_oTag || u === E.j_expr) && l.pop();
				}
				if (!r?.error && !this.match(47)) return super.parseMaybeAssign(e, s);
				(!i || i === this.state) && (i = this.state.clone());
				let o, h = this.tryParse((l) => {
					o = this.tsParseTypeParameters(this.tsParseConstModifier);
					let u = super.parseMaybeAssign(e, s);
					if ((u.type !== "ArrowFunctionExpression" || u.extra?.parenthesized) && l(), o?.params.length !== 0 && this.resetStartLocationFromNode(u, o), u.typeParameters = o, this.hasPlugin("jsx") && u.typeParameters.params.length === 1 && !u.typeParameters.extra?.trailingComma) {
						let f = u.typeParameters.params[0];
						f.constraint || this.raise(y.SingleTypeParameterWithoutTrailingComma, D(f.loc.end, 1), { typeParameterName: f.name.name });
					}
					return u;
				}, i);
				if (!h.error && !h.aborted) return o && this.reportReservedArrowTypeParam(o), h.node;
				if (!r && (qt(!this.hasPlugin("jsx")), n = this.tryParse(() => super.parseMaybeAssign(e, s), i), !n.error)) return n.node;
				if (r?.node) return this.state = r.failState, r.node;
				if (h.node) return this.state = h.failState, o && this.reportReservedArrowTypeParam(o), h.node;
				if (n?.node) return this.state = n.failState, n.node;
				throw r?.error || h.error || n?.error;
			}
			reportReservedArrowTypeParam(e) {
				e.params.length === 1 && !e.params[0].constraint && !e.extra?.trailingComma && this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(y.ReservedArrowTypeParam, e);
			}
			parseMaybeUnary(e, s) {
				return !this.hasPlugin("jsx") && this.match(47) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(e, s);
			}
			parseArrow(e) {
				if (this.match(14)) {
					let s = this.tryParse((i) => {
						let r = this.tsParseTypeOrTypePredicateAnnotation(14);
						return (this.canInsertSemicolon() || !this.match(19)) && i(), r;
					});
					if (s.aborted) return;
					s.thrown || (s.error && (this.state = s.failState), e.returnType = s.node);
				}
				return super.parseArrow(e);
			}
			parseFunctionParamType(e) {
				this.eat(17) && (e.optional = !0);
				let s = this.tsTryParseTypeAnnotation();
				return s && (e.typeAnnotation = s), this.resetEndLocation(e), e;
			}
			isAssignable(e, s) {
				switch (e.type) {
					case "TSTypeCastExpression": return this.isAssignable(e.expression, s);
					case "TSParameterProperty": return !0;
					default: return super.isAssignable(e, s);
				}
			}
			toAssignable(e, s = !1) {
				switch (e.type) {
					case "ParenthesizedExpression":
						this.toAssignableParenthesizedExpression(e, s);
						break;
					case "TSAsExpression":
					case "TSSatisfiesExpression":
					case "TSNonNullExpression":
					case "TSTypeAssertion":
						s ? this.expressionScope.recordArrowParameterBindingError(y.UnexpectedTypeCastInParameter, e) : this.raise(y.UnexpectedTypeCastInParameter, e), this.toAssignable(e.expression, s);
						break;
					case "AssignmentExpression": !s && e.left.type === "TSTypeCastExpression" && (e.left = this.typeCastToParameter(e.left));
					default: super.toAssignable(e, s);
				}
			}
			toAssignableParenthesizedExpression(e, s) {
				switch (e.expression.type) {
					case "TSAsExpression":
					case "TSSatisfiesExpression":
					case "TSNonNullExpression":
					case "TSTypeAssertion":
					case "ParenthesizedExpression":
						this.toAssignable(e.expression, s);
						break;
					default: super.toAssignable(e, s);
				}
			}
			checkToRestConversion(e, s) {
				switch (e.type) {
					case "TSAsExpression":
					case "TSSatisfiesExpression":
					case "TSTypeAssertion":
					case "TSNonNullExpression":
						this.checkToRestConversion(e.expression, !1);
						break;
					default: super.checkToRestConversion(e, s);
				}
			}
			isValidLVal(e, s, i, r) {
				switch (e) {
					case "TSTypeCastExpression": return !0;
					case "TSParameterProperty": return "parameter";
					case "TSNonNullExpression": return "expression";
					case "TSAsExpression":
					case "TSSatisfiesExpression":
					case "TSTypeAssertion": return (r !== 64 || !i) && ["expression", !0];
					default: return super.isValidLVal(e, s, i, r);
				}
			}
			parseBindingAtom() {
				return this.state.type === 78 ? this.parseIdentifier(!0) : super.parseBindingAtom();
			}
			parseMaybeDecoratorArguments(e, s) {
				if (this.match(47) || this.match(51)) {
					let i = this.tsParseTypeArgumentsInExpression();
					if (this.match(10)) {
						let r = super.parseMaybeDecoratorArguments(e, s);
						return r.typeArguments = i, r;
					}
					this.unexpected(null, 10);
				}
				return super.parseMaybeDecoratorArguments(e, s);
			}
			checkCommaAfterRest(e) {
				return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === e ? (this.next(), !1) : super.checkCommaAfterRest(e);
			}
			isClassMethod() {
				return this.match(47) || super.isClassMethod();
			}
			isClassProperty() {
				return this.match(35) || this.match(14) || super.isClassProperty();
			}
			parseMaybeDefault(e, s) {
				let i = super.parseMaybeDefault(e, s);
				return i.type === "AssignmentPattern" && i.typeAnnotation && i.right.start < i.typeAnnotation.start && this.raise(y.TypeAnnotationAfterAssign, i.typeAnnotation), i;
			}
			getTokenFromCode(e) {
				if (this.state.inType) {
					if (e === 62) {
						this.finishOp(48, 1);
						return;
					}
					if (e === 60) {
						this.finishOp(47, 1);
						return;
					}
				}
				super.getTokenFromCode(e);
			}
			reScan_lt_gt() {
				let { type: e } = this.state;
				e === 47 ? (this.state.pos -= 1, this.readToken_lt()) : e === 48 && (this.state.pos -= 1, this.readToken_gt());
			}
			reScan_lt() {
				let { type: e } = this.state;
				return e === 51 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : e;
			}
			toAssignableListItem(e, s, i) {
				let r = e[s];
				r.type === "TSTypeCastExpression" && (e[s] = this.typeCastToParameter(r)), super.toAssignableListItem(e, s, i);
			}
			typeCastToParameter(e) {
				return e.expression.typeAnnotation = e.typeAnnotation, this.resetEndLocation(e.expression, e.typeAnnotation.loc.end), e.expression;
			}
			shouldParseArrow(e) {
				return this.match(14) ? e.every((s) => this.isAssignable(s, !0)) : super.shouldParseArrow(e);
			}
			shouldParseAsyncArrow() {
				return this.match(14) || super.shouldParseAsyncArrow();
			}
			canHaveLeadingDecorator() {
				return super.canHaveLeadingDecorator() || this.isAbstractClass();
			}
			jsxParseOpeningElementAfterName(e) {
				if (this.match(47) || this.match(51)) {
					let s = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
					s && (e.typeArguments = s);
				}
				return super.jsxParseOpeningElementAfterName(e);
			}
			getGetterSetterExpectedParamCount(e) {
				let s = super.getGetterSetterExpectedParamCount(e), r = this.getObjectOrClassMethodParams(e)[0];
				return r && this.isThisParam(r) ? s + 1 : s;
			}
			parseCatchClauseParam() {
				let e = super.parseCatchClauseParam(), s = this.tsTryParseTypeAnnotation();
				return s && (e.typeAnnotation = s, this.resetEndLocation(e)), e;
			}
			tsInAmbientContext(e) {
				let { isAmbientContext: s, strict: i } = this.state;
				this.state.isAmbientContext = !0, this.state.strict = !1;
				try {
					return e();
				} finally {
					this.state.isAmbientContext = s, this.state.strict = i;
				}
			}
			parseClass(e, s, i) {
				let r = this.state.inAbstractClass;
				this.state.inAbstractClass = !!e.abstract;
				try {
					return super.parseClass(e, s, i);
				} finally {
					this.state.inAbstractClass = r;
				}
			}
			tsParseAbstractDeclaration(e, s) {
				if (this.match(80)) return e.abstract = !0, this.maybeTakeDecorators(s, this.parseClass(e, !0, !1));
				if (this.isContextual(129)) return this.hasFollowingLineBreak() ? null : (e.abstract = !0, this.raise(y.NonClassMethodPropertyHasAbstractModifier, e), this.tsParseInterfaceDeclaration(e));
				throw this.unexpected(null, 80);
			}
			parseMethod(e, s, i, r, n, o, h) {
				let l = super.parseMethod(e, s, i, r, n, o, h);
				if ((l.abstract || l.type === "TSAbstractMethodDefinition") && (this.hasPlugin("estree") ? l.value : l).body) {
					let { key: d } = l;
					this.raise(y.AbstractMethodHasImplementation, l, { methodName: d.type === "Identifier" && !l.computed ? d.name : `[${this.input.slice(this.offsetToSourcePos(d.start), this.offsetToSourcePos(d.end))}]` });
				}
				return l;
			}
			tsParseTypeParameterName() {
				return this.parseIdentifier();
			}
			shouldParseAsAmbientContext() {
				return !!this.getPluginOption("typescript", "dts");
			}
			parse() {
				return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.parse();
			}
			getExpression() {
				return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.getExpression();
			}
			parseExportSpecifier(e, s, i, r) {
				return !s && r ? (this.parseTypeOnlyImportExportSpecifier(e, !1, i), this.finishNode(e, "ExportSpecifier")) : (e.exportKind = "value", super.parseExportSpecifier(e, s, i, r));
			}
			parseImportSpecifier(e, s, i, r, n) {
				return !s && r ? (this.parseTypeOnlyImportExportSpecifier(e, !0, i), this.finishNode(e, "ImportSpecifier")) : (e.importKind = "value", super.parseImportSpecifier(e, s, i, r, i ? 4098 : 4096));
			}
			parseTypeOnlyImportExportSpecifier(e, s, i) {
				let r = s ? "imported" : "local", n = s ? "local" : "exported", o = e[r], h, l = !1, u = !0, f = o.loc.start;
				if (this.isContextual(93)) {
					let x = this.parseIdentifier();
					if (this.isContextual(93)) {
						let A = this.parseIdentifier();
						O(this.state.type) ? (l = !0, o = x, h = s ? this.parseIdentifier() : this.parseModuleExportName(), u = !1) : (h = A, u = !1);
					} else O(this.state.type) ? (u = !1, h = s ? this.parseIdentifier() : this.parseModuleExportName()) : (l = !0, o = x);
				} else O(this.state.type) && (l = !0, s ? (o = this.parseIdentifier(!0), this.isContextual(93) || this.checkReservedWord(o.name, o.loc.start, !0, !0)) : o = this.parseModuleExportName());
				l && i && this.raise(s ? y.TypeModifierIsUsedInTypeImports : y.TypeModifierIsUsedInTypeExports, f), e[r] = o, e[n] = h;
				let d = s ? "importKind" : "exportKind";
				e[d] = l ? "type" : "value", u && this.eatContextual(93) && (e[n] = s ? this.parseIdentifier() : this.parseModuleExportName()), e[n] || (e[n] = this.cloneIdentifier(e[r])), s && this.checkIdentifier(e[n], l ? 4098 : 4096);
			}
			fillOptionalPropertiesForTSESLint(e) {
				switch (e.type) {
					case "ExpressionStatement":
						e.directive ?? (e.directive = void 0);
						return;
					case "RestElement": e.value = void 0;
					case "Identifier":
					case "ArrayPattern":
					case "AssignmentPattern":
					case "ObjectPattern":
						e.decorators ?? (e.decorators = []), e.optional ?? (e.optional = !1), e.typeAnnotation ?? (e.typeAnnotation = void 0);
						return;
					case "TSParameterProperty":
						e.accessibility ?? (e.accessibility = void 0), e.decorators ?? (e.decorators = []), e.override ?? (e.override = !1), e.readonly ?? (e.readonly = !1), e.static ?? (e.static = !1);
						return;
					case "TSEmptyBodyFunctionExpression": e.body = null;
					case "TSDeclareFunction":
					case "FunctionDeclaration":
					case "FunctionExpression":
					case "ClassMethod":
					case "ClassPrivateMethod":
						e.declare ?? (e.declare = !1), e.returnType ?? (e.returnType = void 0), e.typeParameters ?? (e.typeParameters = void 0);
						return;
					case "Property":
						e.optional ?? (e.optional = !1);
						return;
					case "TSMethodSignature":
					case "TSPropertySignature": e.optional ?? (e.optional = !1);
					case "TSIndexSignature":
						e.accessibility ?? (e.accessibility = void 0), e.readonly ?? (e.readonly = !1), e.static ?? (e.static = !1);
						return;
					case "TSAbstractPropertyDefinition":
					case "PropertyDefinition":
					case "TSAbstractAccessorProperty":
					case "AccessorProperty": e.declare ?? (e.declare = !1), e.definite ?? (e.definite = !1), e.readonly ?? (e.readonly = !1), e.typeAnnotation ?? (e.typeAnnotation = void 0);
					case "TSAbstractMethodDefinition":
					case "MethodDefinition":
						e.accessibility ?? (e.accessibility = void 0), e.decorators ?? (e.decorators = []), e.override ?? (e.override = !1), e.optional ?? (e.optional = !1);
						return;
					case "ClassExpression": e.id ?? (e.id = null);
					case "ClassDeclaration":
						e.abstract ?? (e.abstract = !1), e.declare ?? (e.declare = !1), e.decorators ?? (e.decorators = []), e.implements ?? (e.implements = []), e.superTypeArguments ?? (e.superTypeArguments = void 0), e.typeParameters ?? (e.typeParameters = void 0);
						return;
					case "TSTypeAliasDeclaration":
					case "VariableDeclaration":
						e.declare ?? (e.declare = !1);
						return;
					case "VariableDeclarator":
						e.definite ?? (e.definite = !1);
						return;
					case "TSEnumDeclaration":
						e.const ?? (e.const = !1), e.declare ?? (e.declare = !1);
						return;
					case "TSEnumMember":
						e.computed ?? (e.computed = !1);
						return;
					case "TSImportType":
						e.qualifier ?? (e.qualifier = null), e.options ?? (e.options = null), e.typeArguments ?? (e.typeArguments = null);
						return;
					case "TSInterfaceDeclaration":
						e.declare ?? (e.declare = !1), e.extends ?? (e.extends = []);
						return;
					case "TSMappedType":
						e.optional ?? (e.optional = !1), e.readonly ?? (e.readonly = void 0);
						return;
					case "TSModuleDeclaration":
						e.declare ?? (e.declare = !1), e.global ?? (e.global = e.kind === "global");
						return;
					case "TSTypeParameter":
						e.const ?? (e.const = !1), e.in ?? (e.in = !1), e.out ?? (e.out = !1);
						return;
				}
			}
			chStartsBindingIdentifierAndNotRelationalOperator(e, s) {
				if (B(e)) {
					if (ze.lastIndex = s, ze.test(this.input)) {
						let i = this.codePointAtPos(ze.lastIndex);
						if (!K(i) && i !== 92) return !1;
					}
					return !0;
				} else return e === 92;
			}
			nextTokenIsIdentifierAndNotTSRelationalOperatorOnSameLine() {
				let e = this.nextTokenInLineStart(), s = this.codePointAtPos(e);
				return this.chStartsBindingIdentifierAndNotRelationalOperator(s, e);
			}
			nextTokenIsIdentifierOrStringLiteralOnSameLine() {
				let e = this.nextTokenInLineStart(), s = this.codePointAtPos(e);
				return this.chStartsBindingIdentifier(s, e) || s === 34 || s === 39;
			}
		};
		function Zi(a) {
			if (a.type !== "MemberExpression") return !1;
			let { computed: t, property: e } = a;
			return t && e.type !== "StringLiteral" && (e.type !== "TemplateLiteral" || e.expressions.length > 0) ? !1 : hs(a.object);
		}
		function er(a, t) {
			let { type: e } = a;
			if (a.extra?.parenthesized) return !1;
			if (t) {
				if (e === "Literal") {
					let { value: s } = a;
					if (typeof s == "string" || typeof s == "boolean") return !0;
				}
			} else if (e === "StringLiteral" || e === "BooleanLiteral") return !0;
			return !!(os(a, t) || tr(a, t) || e === "TemplateLiteral" && a.expressions.length === 0 || Zi(a));
		}
		function os(a, t) {
			return t ? a.type === "Literal" && (typeof a.value == "number" || "bigint" in a) : a.type === "NumericLiteral" || a.type === "BigIntLiteral";
		}
		function tr(a, t) {
			if (a.type === "UnaryExpression") {
				let { operator: e, argument: s } = a;
				if (e === "-" && os(s, t)) return !0;
			}
			return !1;
		}
		function hs(a) {
			return a.type === "Identifier" ? !0 : a.type !== "MemberExpression" || a.computed ? !1 : hs(a.object);
		}
		var Kt = F`placeholders`({
			ClassNameIsRequired: "A class name is required.",
			UnexpectedSpace: "Unexpected space in placeholder."
		}), sr = (a) => class extends a {
			parsePlaceholder(e) {
				if (this.match(133)) {
					let s = this.startNode();
					return this.next(), this.assertNoSpace(), s.name = super.parseIdentifier(!0), this.assertNoSpace(), this.expect(133), this.finishPlaceholder(s, e);
				}
			}
			finishPlaceholder(e, s) {
				let i = e;
				return (!i.expectedNode || !i.type) && (i = this.finishNode(i, "Placeholder")), i.expectedNode = s, i;
			}
			getTokenFromCode(e) {
				e === 37 && this.input.charCodeAt(this.state.pos + 1) === 37 ? this.finishOp(133, 2) : super.getTokenFromCode(e);
			}
			parseExprAtom(e) {
				return this.parsePlaceholder("Expression") || super.parseExprAtom(e);
			}
			parseIdentifier(e) {
				return this.parsePlaceholder("Identifier") || super.parseIdentifier(e);
			}
			checkReservedWord(e, s, i, r) {
				e !== void 0 && super.checkReservedWord(e, s, i, r);
			}
			cloneIdentifier(e) {
				let s = super.cloneIdentifier(e);
				return s.type === "Placeholder" && (s.expectedNode = e.expectedNode), s;
			}
			cloneStringLiteral(e) {
				return e.type === "Placeholder" ? this.cloneIdentifier(e) : super.cloneStringLiteral(e);
			}
			parseBindingAtom() {
				return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
			}
			isValidLVal(e, s, i, r) {
				return e === "Placeholder" || super.isValidLVal(e, s, i, r);
			}
			toAssignable(e, s) {
				e && e.type === "Placeholder" && e.expectedNode === "Expression" ? e.expectedNode = "Pattern" : super.toAssignable(e, s);
			}
			chStartsBindingIdentifier(e, s) {
				if (super.chStartsBindingIdentifier(e, s)) return !0;
				let i = this.nextTokenStart();
				return this.input.charCodeAt(i) === 37 && this.input.charCodeAt(i + 1) === 37;
			}
			verifyBreakContinue(e, s) {
				e.label && e.label.type === "Placeholder" || super.verifyBreakContinue(e, s);
			}
			parseExpressionStatement(e, s) {
				if (s.type !== "Placeholder" || s.extra?.parenthesized) return super.parseExpressionStatement(e, s);
				if (this.match(14)) {
					let r = e;
					return r.label = this.finishPlaceholder(s, "Identifier"), this.next(), r.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration(), this.finishNode(r, "LabeledStatement");
				}
				this.semicolon();
				let i = e;
				return i.name = s.name, this.finishPlaceholder(i, "Statement");
			}
			parseBlock(e, s, i) {
				return this.parsePlaceholder("BlockStatement") || super.parseBlock(e, s, i);
			}
			parseFunctionId(e) {
				return this.parsePlaceholder("Identifier") || super.parseFunctionId(e);
			}
			parseClass(e, s, i) {
				let r = s ? "ClassDeclaration" : "ClassExpression";
				this.next();
				let n = this.state.strict, o = this.parsePlaceholder("Identifier");
				if (o) if (this.match(81) || this.match(133) || this.match(5)) e.id = o;
				else {
					if (i || !s) return e.id = null, e.body = this.finishPlaceholder(o, "ClassBody"), this.finishNode(e, r);
					throw this.raise(Kt.ClassNameIsRequired, this.state.startLoc);
				}
				else this.parseClassId(e, s, i);
				return super.parseClassSuper(e), e.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!e.superClass, n), this.finishNode(e, r);
			}
			parseExport(e, s) {
				let i = this.parsePlaceholder("Identifier");
				if (!i) return super.parseExport(e, s);
				let r = e;
				if (!this.isContextual(98) && !this.match(12)) return r.specifiers = [], r.source = null, r.declaration = this.finishPlaceholder(i, "Declaration"), this.finishNode(r, "ExportNamedDeclaration");
				this.expectPlugin("exportDefaultFrom");
				let n = this.startNode();
				return n.exported = i, r.specifiers = [this.finishNode(n, "ExportDefaultSpecifier")], super.parseExport(r, s);
			}
			isExportDefaultSpecifier() {
				if (this.match(65)) {
					let e = this.nextTokenStart();
					if (this.isUnparsedContextual(e, "from") && this.input.startsWith(z(133), this.nextTokenStartSince(e + 4))) return !0;
				}
				return super.isExportDefaultSpecifier();
			}
			maybeParseExportDefaultSpecifier(e, s) {
				return e.specifiers?.length ? !0 : super.maybeParseExportDefaultSpecifier(e, s);
			}
			checkExport(e) {
				let { specifiers: s } = e;
				s?.length && (e.specifiers = s.filter((i) => i.exported.type === "Placeholder")), super.checkExport(e), e.specifiers = s;
			}
			parseImport(e) {
				let s = this.parsePlaceholder("Identifier");
				if (!s) return super.parseImport(e);
				if (e.specifiers = [], !this.isContextual(98) && !this.match(12)) return e.source = this.finishPlaceholder(s, "StringLiteral"), this.semicolon(), this.finishNode(e, "ImportDeclaration");
				let i = this.startNodeAtNode(s);
				return i.local = s, e.specifiers.push(this.finishNode(i, "ImportDefaultSpecifier")), this.eat(12) && (this.maybeParseStarImportSpecifier(e) || this.parseNamedImportSpecifiers(e)), this.expectContextual(98), e.source = this.parseImportSource(), this.semicolon(), this.finishNode(e, "ImportDeclaration");
			}
			parseImportSource() {
				return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
			}
			assertNoSpace() {
				this.state.start > this.offsetToSourcePos(this.state.lastTokEndLoc.index) && this.raise(Kt.UnexpectedSpace, this.state.lastTokEndLoc);
			}
		}, ir = (a) => class extends a {
			parseV8Intrinsic() {
				if (this.match(54)) {
					let e = this.state.startLoc, s = this.startNode();
					if (this.next(), w(this.state.type)) {
						let i = this.parseIdentifierName(), r = this.createIdentifier(s, i);
						if (this.castNodeTo(r, "V8IntrinsicIdentifier"), this.match(10)) return r;
					}
					this.unexpected(e);
				}
			}
			parseExprAtom(e) {
				return this.parseV8Intrinsic() || super.parseExprAtom(e);
			}
		}, Ht = ["fsharp", "hack"], Wt = [
			"^^",
			"@@",
			"^",
			"%",
			"#"
		];
		function rr(a) {
			if (a.has("decorators")) {
				if (a.has("decorators-legacy")) throw new Error("Cannot use the decorators and decorators-legacy plugin together");
				let t = a.get("decorators").decoratorsBeforeExport;
				if (t != null && typeof t != "boolean") throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
				let e = a.get("decorators").allowCallParenthesized;
				if (e != null && typeof e != "boolean") throw new Error("'allowCallParenthesized' must be a boolean.");
			}
			if (a.has("flow") && a.has("typescript")) throw new Error("Cannot combine flow and typescript plugins.");
			if (a.has("placeholders") && a.has("v8intrinsic")) throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
			if (a.has("pipelineOperator")) {
				let t = a.get("pipelineOperator").proposal;
				if (!Ht.includes(t)) {
					let e = Ht.map((s) => `"${s}"`).join(", ");
					throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${e}.`);
				}
				if (t === "hack") {
					if (a.has("placeholders")) throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
					if (a.has("v8intrinsic")) throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
					let e = a.get("pipelineOperator").topicToken;
					if (!Wt.includes(e)) {
						let s = Wt.map((i) => `"${i}"`).join(", ");
						throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${s}.`);
					}
				}
			}
			if (a.has("moduleAttributes")) throw new Error("`moduleAttributes` has been removed in Babel 8, please migrate to import attributes instead.");
			if (a.has("importAssertions")) throw new Error("`importAssertions` has been removed in Babel 8, please use import attributes instead. To use the non-standard `assert` syntax you can enable the `deprecatedImportAssert` parser plugin.");
			if (!a.has("deprecatedImportAssert") && a.has("importAttributes") && a.get("importAttributes").deprecatedAssertSyntax) throw new Error("The 'importAttributes' plugin has been removed in Babel 8. If you need to enable support for the deprecated `assert` syntax, you can enable the `deprecatedImportAssert` parser plugin.");
			if (a.has("recordAndTuple")) throw new Error("The 'recordAndTuple' plugin has been removed in Babel 8. Please remove it from your configuration.");
			if (a.has("asyncDoExpressions") && !a.has("doExpressions")) {
				let t = /* @__PURE__ */ new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
				throw t.missingPlugins = "doExpressions", t;
			}
			if (a.has("optionalChainingAssign") && a.get("optionalChainingAssign").version !== "2023-07") throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is '2023-07'.");
			if (a.has("discardBinding") && a.get("discardBinding").syntaxType !== "void") throw new Error("The 'discardBinding' plugin requires a 'syntaxType' option. Currently the only supported value is 'void'.");
			if (a.has("decimal")) throw new Error("The 'decimal' plugin has been removed in Babel 8. Please remove it from your configuration.");
			if (a.has("importReflection")) throw new Error("The 'importReflection' plugin has been removed in Babel 8. Use 'sourcePhaseImports' instead, and replace 'import module' with 'import source' in your code.");
		}
		var cs = {
			estree: ci,
			jsx: ji,
			flow: Ri,
			typescript: Qi,
			v8intrinsic: ir,
			placeholders: sr
		}, ar = Object.keys(cs), ut = class extends lt {
			checkProto(t, e, s, i) {
				if (t.type === "SpreadElement" || this.isObjectMethod(t) || t.computed || t.shorthand) return s;
				let r = t.key;
				return (r.type === "Identifier" ? r.name : r.value) === "__proto__" ? e ? (this.raise(p.RecordNoProto, r), !0) : (s && (i ? i.doubleProtoLoc === null && (i.doubleProtoLoc = r.loc.start) : this.raise(p.DuplicateProto, r)), !0) : s;
			}
			shouldExitDescending(t, e) {
				return t.type === "ArrowFunctionExpression" && this.offsetToSourcePos(t.start) === e;
			}
			getExpression() {
				if (this.enterInitialScopes(), this.nextToken(), this.match(140)) throw this.raise(p.ParseExpressionEmptyInput, this.state.startLoc);
				let t = this.parseExpression();
				if (!this.match(140)) throw this.raise(p.ParseExpressionExpectsEOF, this.state.startLoc, { unexpected: this.input.codePointAt(this.state.start) });
				return this.finalizeRemainingComments(), t.comments = this.comments, t.errors = this.state.errors, this.optionFlags & 256 && (t.tokens = this.tokens), t;
			}
			parseExpression(t, e) {
				return t ? this.disallowInAnd(() => this.parseExpressionBase(e)) : this.allowInAnd(() => this.parseExpressionBase(e));
			}
			parseExpressionBase(t) {
				let e = this.state.startLoc, s = this.parseMaybeAssign(t);
				if (this.match(12)) {
					let i = this.startNodeAt(e);
					for (i.expressions = [s]; this.eat(12);) i.expressions.push(this.parseMaybeAssign(t));
					return this.toReferencedList(i.expressions), this.finishNode(i, "SequenceExpression");
				}
				return s;
			}
			parseMaybeAssignDisallowIn(t, e) {
				return this.disallowInAnd(() => this.parseMaybeAssign(t, e));
			}
			parseMaybeAssignAllowIn(t, e) {
				return this.allowInAnd(() => this.parseMaybeAssign(t, e));
			}
			setOptionalParametersError(t) {
				t.optionalParametersLoc = this.state.startLoc;
			}
			parseMaybeAssign(t, e) {
				let s = this.state.startLoc, i = this.isContextual(108);
				if (i && this.prodParam.hasYield) {
					this.next();
					let h = this.parseYield(s);
					return e && (h = e.call(this, h, s)), h;
				}
				let r;
				t ? r = !1 : (t = new Y(), r = !0);
				let { type: n } = this.state;
				(n === 10 || w(n)) && (this.state.potentialArrowAt = this.state.start);
				let o = this.parseMaybeConditional(t);
				if (e && (o = e.call(this, o, s)), di(this.state.type)) {
					let h = this.startNodeAt(s), l = this.state.value;
					if (h.operator = l, this.match(29)) {
						this.toAssignable(o, !0), h.left = o;
						let u = s.index;
						t.doubleProtoLoc != null && t.doubleProtoLoc.index >= u && (t.doubleProtoLoc = null), t.shorthandAssignLoc != null && t.shorthandAssignLoc.index >= u && (t.shorthandAssignLoc = null), t.privateKeyLoc != null && t.privateKeyLoc.index >= u && (this.checkDestructuringPrivate(t), t.privateKeyLoc = null), t.voidPatternLoc != null && t.voidPatternLoc.index >= u && (t.voidPatternLoc = null);
					} else h.left = o;
					return this.next(), h.right = this.parseMaybeAssign(), this.checkLVal(o, this.finishNode(h, "AssignmentExpression"), void 0, void 0, void 0, void 0, l === "||=" || l === "&&=" || l === "??="), h;
				} else r && this.checkExpressionErrors(t, !0);
				if (i) {
					let { type: h } = this.state;
					if ((this.hasPlugin("v8intrinsic") ? ce(h) : ce(h) && !this.match(54)) && !this.isAmbiguousPrefixOrIdentifier()) return this.raiseOverwrite(p.YieldNotInGeneratorFunction, s), this.parseYield(s);
				}
				return o;
			}
			parseMaybeConditional(t) {
				let e = this.state.startLoc, s = this.state.potentialArrowAt, i = this.parseExprOps(t);
				return this.shouldExitDescending(i, s) ? i : this.parseConditional(i, e, t);
			}
			parseConditional(t, e, s) {
				if (this.eat(17)) {
					let i = this.startNodeAt(e);
					return i.test = t, i.consequent = this.parseMaybeAssignAllowIn(), this.expect(14), i.alternate = this.parseMaybeAssign(), this.finishNode(i, "ConditionalExpression");
				}
				return t;
			}
			parseMaybeUnaryOrPrivate(t) {
				return this.match(139) ? this.parsePrivateName() : this.parseMaybeUnary(t);
			}
			parseExprOps(t) {
				let e = this.state.startLoc, s = this.state.potentialArrowAt, i = this.parseMaybeUnaryOrPrivate(t);
				return this.shouldExitDescending(i, s) ? i : this.parseExprOp(i, e, -1);
			}
			parseExprOp(t, e, s) {
				if (this.isPrivateName(t)) {
					let r = this.getPrivateNameSV(t);
					(s >= Ae(58) || !this.prodParam.hasIn || !this.match(58)) && this.raise(p.PrivateInExpectedIn, t, { identifierName: r }), this.classScope.usePrivateName(r, t.loc.start);
				}
				let i = this.state.type;
				if (yi(i) && (this.prodParam.hasIn || !this.match(58))) {
					let r = Ae(i);
					if (r > s) {
						if (i === 39) {
							if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody) return t;
							this.checkPipelineAtInfixOperator(t, e);
						}
						let n = this.startNodeAt(e);
						n.left = t, n.operator = this.state.value;
						let o = i === 41 || i === 42, h = i === 40;
						h && (r = Ae(42)), this.next(), n.right = this.parseExprOpRightExpr(i, r);
						let l = this.finishNode(n, o || h ? "LogicalExpression" : "BinaryExpression"), u = this.state.type;
						if (h && (u === 41 || u === 42) || o && u === 40) throw this.raise(p.MixingCoalesceWithLogical, this.state.startLoc);
						return this.parseExprOp(l, e, s);
					}
				}
				return t;
			}
			parseExprOpRightExpr(t, e) {
				switch (this.state.startLoc, t) {
					case 39: switch (this.getPluginOption("pipelineOperator", "proposal")) {
						case "hack": return this.withTopicBindingContext(() => this.parseHackPipeBody());
						case "fsharp": return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(e));
					}
					default: return this.parseExprOpBaseRightExpr(t, e);
				}
			}
			parseExprOpBaseRightExpr(t, e) {
				let s = this.state.startLoc;
				return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), s, bi(t) ? e - 1 : e);
			}
			parseHackPipeBody() {
				let { startLoc: t } = this.state, e = this.parseMaybeAssign();
				return si.has(e.type) && !e.extra?.parenthesized && this.raise(p.PipeUnparenthesizedBody, t, { type: e.type }), this.topicReferenceWasUsedInCurrentContext() || this.raise(p.PipeTopicUnused, t), e;
			}
			checkExponentialAfterUnary(t) {
				this.match(57) && this.raise(p.UnexpectedTokenUnaryExponentiation, t.argument);
			}
			parseMaybeUnary(t, e) {
				let s = this.state.startLoc, i = this.isContextual(96);
				if (i && this.recordAwaitIfAllowed()) {
					this.next();
					let h = this.parseAwait(s);
					return e || this.checkExponentialAfterUnary(h), h;
				}
				let r = this.match(34), n = this.startNode();
				if (Pi(this.state.type)) {
					n.operator = this.state.value, n.prefix = !0, this.match(72) && this.expectPlugin("throwExpressions");
					let h = this.match(89);
					if (this.next(), n.argument = this.parseMaybeUnary(null, !0), this.checkExpressionErrors(t, !0), this.state.strict && h) {
						let l = n.argument;
						l.type === "Identifier" ? this.raise(p.StrictDelete, n) : this.hasPropertyAsPrivateName(l) && this.raise(p.DeletePrivateField, n);
					}
					if (!r) return e || this.checkExponentialAfterUnary(n), this.finishNode(n, "UnaryExpression");
				}
				let o = this.parseUpdate(n, r, t);
				if (i) {
					let { type: h } = this.state;
					if ((this.hasPlugin("v8intrinsic") ? ce(h) : ce(h) && !this.match(54)) && !this.isAmbiguousPrefixOrIdentifier()) return this.raiseOverwrite(p.AwaitNotInAsyncContext, s), this.parseAwait(s);
				}
				return o;
			}
			parseUpdate(t, e, s) {
				if (e) {
					let n = t;
					return this.checkLVal(n.argument, this.finishNode(n, "UpdateExpression")), t;
				}
				let i = this.state.startLoc, r = this.parseExprSubscripts(s);
				if (this.checkExpressionErrors(s, !1)) return r;
				for (; xi(this.state.type) && !this.canInsertSemicolon();) {
					let n = this.startNodeAt(i);
					n.operator = this.state.value, n.prefix = !1, n.argument = r, this.next(), this.checkLVal(r, r = this.finishNode(n, "UpdateExpression"));
				}
				return r;
			}
			parseExprSubscripts(t) {
				let e = this.state.startLoc, s = this.state.potentialArrowAt, i = this.parseExprAtom(t);
				return this.shouldExitDescending(i, s) ? i : this.parseSubscripts(i, e);
			}
			parseSubscripts(t, e, s) {
				let i = {
					optionalChainMember: !1,
					maybeAsyncArrow: this.atPossibleAsyncArrow(t),
					stop: !1
				};
				do
					t = this.parseSubscript(t, e, s, i), i.maybeAsyncArrow = !1;
				while (!i.stop);
				return t;
			}
			parseSubscript(t, e, s, i) {
				let { type: r } = this.state;
				if (!s && r === 15) return this.parseBind(t, e, s, i);
				if (Ke(r)) return this.parseTaggedTemplateExpression(t, e, i);
				let n = !1;
				if (r === 18) {
					if (s && (this.raise(p.OptionalChainingNoNew, this.state.startLoc), this.lookaheadCharCode() === 40)) return this.stopParseSubscript(t, i);
					i.optionalChainMember = n = !0, this.next();
				}
				if (!s && this.match(10)) return this.parseCoverCallAndAsyncArrowHead(t, e, i, n);
				{
					let o = this.eat(0);
					return o || n || this.eat(16) ? this.parseMember(t, e, i, o, n) : this.stopParseSubscript(t, i);
				}
			}
			stopParseSubscript(t, e) {
				return e.stop = !0, t;
			}
			parseMember(t, e, s, i, r) {
				let n = this.startNodeAt(e);
				return n.object = t, n.computed = i, i ? (n.property = this.parseExpression(), this.expect(3)) : this.match(139) ? (t.type === "Super" && this.raise(p.SuperPrivateField, e), this.classScope.usePrivateName(this.state.value, this.state.startLoc), n.property = this.parsePrivateName()) : n.property = this.parseIdentifier(!0), s.optionalChainMember ? (n.optional = r, this.finishNode(n, "OptionalMemberExpression")) : this.finishNode(n, "MemberExpression");
			}
			parseBind(t, e, s, i) {
				let r = this.startNodeAt(e);
				return r.object = t, this.next(), r.callee = this.parseNoCallExpr(), i.stop = !0, this.parseSubscripts(this.finishNode(r, "BindExpression"), e, s);
			}
			parseCoverCallAndAsyncArrowHead(t, e, s, i) {
				let r = this.state.maybeInArrowParameters, n = null;
				this.state.maybeInArrowParameters = !0, this.next();
				let o = this.startNodeAt(e);
				o.callee = t;
				let { maybeAsyncArrow: h, optionalChainMember: l } = s;
				h && (this.expressionScope.enter(Ji()), n = new Y()), l && (o.optional = i), i ? o.arguments = this.parseCallExpressionArguments() : o.arguments = this.parseCallExpressionArguments(t.type !== "Super", o, n);
				let u = this.finishCallExpression(o, l);
				return h && this.shouldParseAsyncArrow() && !i ? (s.stop = !0, this.checkDestructuringPrivate(n), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), u = this.parseAsyncArrowFromCallExpression(this.startNodeAt(e), u)) : (h && (this.checkExpressionErrors(n, !0), this.expressionScope.exit()), this.toReferencedArguments(u)), this.state.maybeInArrowParameters = r, u;
			}
			toReferencedArguments(t, e) {
				this.toReferencedListDeep(t.arguments, e);
			}
			parseTaggedTemplateExpression(t, e, s) {
				let i = this.startNodeAt(e);
				return i.tag = t, i.quasi = this.parseTemplate(!0), s.optionalChainMember && this.raise(p.OptionalChainingNoTemplate, e), this.finishNode(i, "TaggedTemplateExpression");
			}
			atPossibleAsyncArrow(t) {
				return t.type === "Identifier" && t.name === "async" && this.state.lastTokEndLoc.index === t.end && !this.canInsertSemicolon() && t.end - t.start === 5 && this.offsetToSourcePos(t.start) === this.state.potentialArrowAt;
			}
			finishCallExpression(t, e) {
				if (t.callee.type === "Import") if (t.arguments.length === 0 || t.arguments.length > 2) this.raise(p.ImportCallArity, t);
				else for (let s of t.arguments) s.type === "SpreadElement" && this.raise(p.ImportCallSpreadArgument, s);
				return this.finishNode(t, e ? "OptionalCallExpression" : "CallExpression");
			}
			parseCallExpressionArguments(t, e, s) {
				let i = [], r = !0, n = this.state.inFSharpPipelineDirectBody;
				for (this.state.inFSharpPipelineDirectBody = !1; !this.eat(11);) {
					if (r) r = !1;
					else if (this.expect(12), this.match(11)) {
						e && this.addTrailingCommaExtraToNode(e), this.next();
						break;
					}
					i.push(this.parseExprListItem(11, !1, s, t));
				}
				return this.state.inFSharpPipelineDirectBody = n, i;
			}
			shouldParseAsyncArrow() {
				return this.match(19) && !this.canInsertSemicolon();
			}
			parseAsyncArrowFromCallExpression(t, e) {
				return this.resetPreviousNodeTrailingComments(e), this.expect(19), this.parseArrowExpression(t, e.arguments, !0, e.extra?.trailingCommaLoc), e.innerComments && X(t, e.innerComments), e.callee.trailingComments && X(t, e.callee.trailingComments), t;
			}
			parseNoCallExpr() {
				let t = this.state.startLoc;
				return this.parseSubscripts(this.parseExprAtom(), t, !0);
			}
			parseExprAtom(t) {
				let e, s = null, { type: i } = this.state;
				switch (i) {
					case 79: return this.parseSuper();
					case 83: return e = this.startNode(), this.next(), this.match(16) ? this.parseImportMetaPropertyOrPhaseCall(e) : this.match(10) ? this.optionFlags & 512 ? this.parseImportCall(e) : this.finishNode(e, "Import") : (this.raise(p.UnsupportedImport, this.state.lastTokStartLoc), this.finishNode(e, "Import"));
					case 78: return e = this.startNode(), this.next(), this.finishNode(e, "ThisExpression");
					case 90: return this.parseDo(this.startNode(), !1);
					case 56:
					case 31: return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
					case 135: return this.parseNumericLiteral(this.state.value);
					case 136: return this.parseBigIntLiteral(this.state.value);
					case 134: return this.parseStringLiteral(this.state.value);
					case 84: return this.parseNullLiteral();
					case 85: return this.parseBooleanLiteral(!0);
					case 86: return this.parseBooleanLiteral(!1);
					case 10: {
						let r = this.state.potentialArrowAt === this.state.start;
						return this.parseParenAndDistinguishExpression(r);
					}
					case 0: return this.parseArrayLike(3, !1, t);
					case 5: return this.parseObjectLike(8, !1, !1, t);
					case 68: return this.parseFunctionOrFunctionSent();
					case 26: s = this.parseDecorators();
					case 80: return this.parseClass(this.maybeTakeDecorators(s, this.startNode()), !1);
					case 77: return this.parseNewOrNewTarget();
					case 25:
					case 24: return this.parseTemplate(!1);
					case 15: {
						e = this.startNode(), this.next(), e.object = null;
						let r = e.callee = this.parseNoCallExpr();
						if (r.type === "MemberExpression") return this.finishNode(e, "BindExpression");
						throw this.raise(p.UnsupportedBind, r);
					}
					case 139: return this.raise(p.PrivateInExpectedIn, this.state.startLoc, { identifierName: this.state.value }), this.parsePrivateName();
					case 33: return this.parseTopicReferenceThenEqualsSign(54, "%");
					case 32: return this.parseTopicReferenceThenEqualsSign(44, "^");
					case 37:
					case 38: return this.parseTopicReference("hack");
					case 44:
					case 54:
					case 27: {
						let r = this.getPluginOption("pipelineOperator", "proposal");
						if (r) return this.parseTopicReference(r);
						throw this.unexpected();
					}
					case 47: {
						let r = this.input.codePointAt(this.nextTokenStart());
						throw B(r) || r === 62 ? this.expectOnePlugin([
							"jsx",
							"flow",
							"typescript"
						]) : this.unexpected();
					}
					default: if (w(i)) {
						if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123) return this.parseModuleExpression();
						let r = this.state.potentialArrowAt === this.state.start, n = this.state.containsEsc, o = this.parseIdentifier();
						if (!n && o.name === "async" && !this.canInsertSemicolon()) {
							let { type: h } = this.state;
							if (h === 68) return this.resetPreviousNodeTrailingComments(o), this.next(), this.parseAsyncFunctionExpression(this.startNodeAtNode(o));
							if (w(h)) return this.lookaheadCharCode() === 61 ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(o)) : o;
							if (h === 90) return this.resetPreviousNodeTrailingComments(o), this.parseDo(this.startNodeAtNode(o), !0);
						}
						return r && this.match(19) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(o), [o], !1)) : o;
					} else throw this.unexpected();
				}
			}
			parseTopicReferenceThenEqualsSign(t, e) {
				let s = this.getPluginOption("pipelineOperator", "proposal");
				if (s) return this.state.type = t, this.state.value = e, this.state.pos--, this.state.end--, this.state.endLoc = D(this.state.endLoc, -1), this.parseTopicReference(s);
				throw this.unexpected();
			}
			parseTopicReference(t) {
				let e = this.startNode(), s = this.state.startLoc, i = this.state.type;
				return this.next(), this.finishTopicReference(e, s, t, i);
			}
			finishTopicReference(t, e, s, i) {
				if (this.testTopicReferenceConfiguration(s, e, i)) return this.topicReferenceIsAllowedInCurrentContext() || this.raise(p.PipeTopicUnbound, e), this.registerTopicReference(), this.finishNode(t, "TopicReference");
				throw this.raise(p.PipeTopicUnconfiguredToken, e, { token: z(i) });
			}
			testTopicReferenceConfiguration(t, e, s) {
				switch (t) {
					case "hack": return this.hasPlugin(["pipelineOperator", { topicToken: z(s) }]);
					case "smart": return s === 27;
					default: throw this.raise(p.PipeTopicRequiresHackPipes, e);
				}
			}
			parseAsyncArrowUnaryFunction(t) {
				this.prodParam.enter(Se(!0, this.prodParam.hasYield));
				let e = [this.parseIdentifier()];
				return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(p.LineTerminatorBeforeArrow, this.state.curPosition()), this.expect(19), this.parseArrowExpression(t, e, !0);
			}
			parseDo(t, e) {
				this.expectPlugin("doExpressions"), e && this.expectPlugin("asyncDoExpressions"), t.async = e, this.next();
				let s = this.state.labels;
				return this.state.labels = [], e ? (this.prodParam.enter(2), t.body = this.parseBlock(), this.prodParam.exit()) : t.body = this.parseBlock(), this.state.labels = s, this.finishNode(t, "DoExpression");
			}
			parseSuper() {
				let t = this.startNode();
				return this.next(), this.match(10) && !this.scope.allowDirectSuper ? this.raise(p.SuperNotAllowed, t) : this.scope.allowSuper || this.raise(p.UnexpectedSuper, t), !this.match(10) && !this.match(0) && !this.match(16) && this.raise(p.UnsupportedSuper, t), this.finishNode(t, "Super");
			}
			parsePrivateName() {
				let t = this.startNode(), e = this.startNodeAt(D(this.state.startLoc, 1)), s = this.state.value;
				return this.next(), t.id = this.createIdentifier(e, s), this.finishNode(t, "PrivateName");
			}
			parseFunctionOrFunctionSent() {
				let t = this.startNode();
				if (this.next(), this.prodParam.hasYield && this.match(16)) {
					let e = this.createIdentifier(this.startNodeAtNode(t), "function");
					return this.next(), this.match(103) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected(), this.parseMetaProperty(t, e, "sent");
				}
				return this.parseFunction(t);
			}
			parseMetaProperty(t, e, s) {
				t.meta = e;
				let i = this.state.containsEsc;
				return t.property = this.parseIdentifier(!0), (t.property.name !== s || i) && this.raise(p.UnsupportedMetaProperty, t.property, {
					target: e.name,
					onlyValidPropertyName: s
				}), this.finishNode(t, "MetaProperty");
			}
			parseImportMetaPropertyOrPhaseCall(t) {
				if (this.next(), this.isContextual(105) || this.isContextual(97)) {
					let e = this.isContextual(105);
					return this.expectPlugin(e ? "sourcePhaseImports" : "deferredImportEvaluation"), this.next(), t.phase = e ? "source" : "defer", this.parseImportCall(t);
				} else {
					let e = this.createIdentifierAt(this.startNodeAtNode(t), "import", this.state.lastTokStartLoc);
					return this.isContextual(101) && (this.inModule || this.raise(p.ImportMetaOutsideModule, e), this.sawUnambiguousESM = !0), this.parseMetaProperty(t, e, "meta");
				}
			}
			parseLiteralAtNode(t, e, s) {
				return this.addExtra(s, "rawValue", t), this.addExtra(s, "raw", this.input.slice(this.offsetToSourcePos(s.start), this.state.end)), s.value = t, this.next(), this.finishNode(s, e);
			}
			parseLiteral(t, e) {
				let s = this.startNode();
				return this.parseLiteralAtNode(t, e, s);
			}
			parseStringLiteral(t) {
				return this.parseLiteral(t, "StringLiteral");
			}
			parseNumericLiteral(t) {
				return this.parseLiteral(t, "NumericLiteral");
			}
			parseBigIntLiteral(t) {
				{
					let e;
					try {
						e = BigInt(t);
					} catch {
						e = null;
					}
					return this.parseLiteral(e, "BigIntLiteral");
				}
			}
			parseDecimalLiteral(t) {
				return this.parseLiteral(t, "DecimalLiteral");
			}
			parseRegExpLiteral(t) {
				let e = this.startNode();
				return this.addExtra(e, "raw", this.input.slice(this.offsetToSourcePos(e.start), this.state.end)), e.pattern = t.pattern, e.flags = t.flags, this.next(), this.finishNode(e, "RegExpLiteral");
			}
			parseBooleanLiteral(t) {
				let e = this.startNode();
				return e.value = t, this.next(), this.finishNode(e, "BooleanLiteral");
			}
			parseNullLiteral() {
				let t = this.startNode();
				return this.next(), this.finishNode(t, "NullLiteral");
			}
			parseParenAndDistinguishExpression(t) {
				let e = this.state.startLoc, s;
				this.next(), this.expressionScope.enter(Wi());
				let i = this.state.maybeInArrowParameters, r = this.state.inFSharpPipelineDirectBody;
				this.state.maybeInArrowParameters = !0, this.state.inFSharpPipelineDirectBody = !1;
				let n = this.state.startLoc, o = [], h = new Y(), l = !0, u, f;
				for (; !this.match(11);) {
					if (l) l = !1;
					else if (this.expect(12, h.optionalParametersLoc === null ? null : h.optionalParametersLoc), this.match(11)) {
						f = this.state.startLoc;
						break;
					}
					if (this.match(21)) {
						let A = this.state.startLoc;
						if (u = this.state.startLoc, o.push(this.parseParenItem(this.parseRestBinding(), A)), !this.checkCommaAfterRest(41)) break;
					} else o.push(this.parseMaybeAssignAllowInOrVoidPattern(11, h, this.parseParenItem));
				}
				let d = this.state.lastTokEndLoc;
				this.expect(11), this.state.maybeInArrowParameters = i, this.state.inFSharpPipelineDirectBody = r;
				let x = this.startNodeAt(e);
				return t && this.shouldParseArrow(o) && (x = this.parseArrow(x)) ? (this.checkDestructuringPrivate(h), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), this.parseArrowExpression(x, o, !1), x) : (this.expressionScope.exit(), o.length || this.unexpected(this.state.lastTokStartLoc), f && this.unexpected(f), u && this.unexpected(u), this.checkExpressionErrors(h, !0), this.toReferencedListDeep(o, !0), o.length > 1 ? (s = this.startNodeAt(n), s.expressions = o, this.finishNode(s, "SequenceExpression"), this.resetEndLocation(s, d)) : s = o[0], this.wrapParenthesis(e, s));
			}
			wrapParenthesis(t, e) {
				if (!(this.optionFlags & 1024)) return this.addExtra(e, "parenthesized", !0), this.addExtra(e, "parenStart", t.index), this.takeSurroundingComments(e, t.index, this.state.lastTokEndLoc.index), e;
				let s = this.startNodeAt(t);
				return s.expression = e, this.finishNode(s, "ParenthesizedExpression");
			}
			shouldParseArrow(t) {
				return !this.canInsertSemicolon();
			}
			parseArrow(t) {
				if (this.eat(19)) return t;
			}
			parseParenItem(t, e) {
				return t;
			}
			parseNewOrNewTarget() {
				let t = this.startNode();
				if (this.next(), this.match(16)) {
					let e = this.createIdentifier(this.startNodeAtNode(t), "new");
					this.next();
					let s = this.parseMetaProperty(t, e, "target");
					return this.scope.allowNewTarget || this.raise(p.UnexpectedNewTarget, s), s;
				}
				return this.parseNew(t);
			}
			parseNew(t) {
				if (this.parseNewCallee(t), this.eat(10)) {
					let e = this.parseExprList(11);
					this.toReferencedList(e), t.arguments = e;
				} else t.arguments = [];
				return this.finishNode(t, "NewExpression");
			}
			parseNewCallee(t) {
				let e = this.match(83), s = this.parseNoCallExpr();
				t.callee = s, e && (s.type === "Import" || s.type === "ImportExpression") && this.raise(p.ImportCallNotNewExpression, s);
			}
			parseTemplateElement(t) {
				let { start: e, startLoc: s, end: i, value: r } = this.state, n = e + 1, o = this.startNodeAt(D(s, 1));
				r === null && (t || this.raise(p.InvalidEscapeSequenceTemplate, D(this.state.firstInvalidTemplateEscapePos, 1)));
				let h = this.match(24), l = h ? -1 : -2, u = i + l;
				o.value = {
					raw: this.input.slice(n, u).replace(/\r\n?/g, `
`),
					cooked: r === null ? null : r.slice(1, l)
				}, o.tail = h, this.next();
				let f = this.finishNode(o, "TemplateElement");
				return this.resetEndLocation(f, D(this.state.lastTokEndLoc, l)), f;
			}
			parseTemplate(t) {
				let e = this.startNode(), s = this.parseTemplateElement(t), i = [s], r = [];
				for (; !s.tail;) r.push(this.parseTemplateSubstitution()), this.readTemplateContinuation(), i.push(s = this.parseTemplateElement(t));
				return e.expressions = r, e.quasis = i, this.finishNode(e, "TemplateLiteral");
			}
			parseTemplateSubstitution() {
				return this.parseExpression();
			}
			parseObjectLike(t, e, s, i) {
				s && this.expectPlugin("recordAndTuple");
				let r = this.state.inFSharpPipelineDirectBody;
				this.state.inFSharpPipelineDirectBody = !1;
				let n = !1, o = !0, h = this.startNode();
				for (h.properties = [], this.next(); !this.match(t);) {
					if (o) o = !1;
					else if (this.expect(12), this.match(t)) {
						this.addTrailingCommaExtraToNode(h);
						break;
					}
					let u;
					e ? u = this.parseBindingProperty() : (u = this.parsePropertyDefinition(i), n = this.checkProto(u, s, n, i)), s && !this.isObjectProperty(u) && u.type !== "SpreadElement" && this.raise(p.InvalidRecordProperty, u), h.properties.push(u);
				}
				this.next(), this.state.inFSharpPipelineDirectBody = r;
				let l = "ObjectExpression";
				return e ? l = "ObjectPattern" : s && (l = "RecordExpression"), this.finishNode(h, l);
			}
			addTrailingCommaExtraToNode(t) {
				this.addExtra(t, "trailingComma", this.state.lastTokStartLoc.index), this.addExtra(t, "trailingCommaLoc", this.state.lastTokStartLoc, !1);
			}
			maybeAsyncOrAccessorProp(t) {
				return !t.computed && t.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
			}
			parsePropertyDefinition(t) {
				let e = [];
				if (this.match(26)) for (this.hasPlugin("decorators") && this.raise(p.UnsupportedPropertyDecorator, this.state.startLoc); this.match(26);) e.push(this.parseDecorator());
				let s = this.startNode(), i = !1, r = !1, n;
				if (this.match(21)) return e.length && this.unexpected(), this.parseSpread();
				e.length && (s.decorators = e, e = []), s.method = !1, t && (n = this.state.startLoc);
				let o = this.eat(55);
				this.parsePropertyNamePrefixOperator(s);
				let h = this.state.containsEsc;
				if (this.parsePropertyName(s, t), !o && !h && this.maybeAsyncOrAccessorProp(s)) {
					let { key: l } = s, u = l.name;
					u === "async" && !this.hasPrecedingLineBreak() && (i = !0, this.resetPreviousNodeTrailingComments(l), o = this.eat(55), this.parsePropertyName(s)), (u === "get" || u === "set") && (r = !0, this.resetPreviousNodeTrailingComments(l), s.kind = u, this.match(55) && (o = !0, this.raise(p.AccessorIsGenerator, this.state.curPosition(), { kind: u }), this.next()), this.parsePropertyName(s));
				}
				return this.parseObjPropValue(s, n, o, i, !1, r, t);
			}
			getGetterSetterExpectedParamCount(t) {
				return t.kind === "get" ? 0 : 1;
			}
			getObjectOrClassMethodParams(t) {
				return t.params;
			}
			checkGetterSetterParams(t) {
				let e = this.getGetterSetterExpectedParamCount(t), s = this.getObjectOrClassMethodParams(t);
				s.length !== e && this.raise(t.kind === "get" ? p.BadGetterArity : p.BadSetterArity, t), t.kind === "set" && s[s.length - 1]?.type === "RestElement" && this.raise(p.BadSetterRestParameter, t);
			}
			parseObjectMethod(t, e, s, i, r) {
				if (r) {
					let n = this.parseMethod(t, e, !1, !1, !1, "ObjectMethod");
					return this.checkGetterSetterParams(n), n;
				}
				if (s || e || this.match(10)) return i && this.unexpected(), t.kind = "method", t.method = !0, this.parseMethod(t, e, s, !1, !1, "ObjectMethod");
			}
			parseObjectProperty(t, e, s, i) {
				if (t.shorthand = !1, this.eat(14)) return t.value = s ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowInOrVoidPattern(8, i), this.finishObjectProperty(t);
				if (!t.computed && t.key.type === "Identifier") {
					if (this.checkReservedWord(t.key.name, t.key.loc.start, !0, !1), s) t.value = this.parseMaybeDefault(e, this.cloneIdentifier(t.key));
					else if (this.match(29)) {
						let r = this.state.startLoc;
						i != null ? i.shorthandAssignLoc === null && (i.shorthandAssignLoc = r) : this.raise(p.InvalidCoverInitializedName, r), t.value = this.parseMaybeDefault(e, this.cloneIdentifier(t.key));
					} else t.value = this.cloneIdentifier(t.key);
					return t.shorthand = !0, this.finishObjectProperty(t);
				}
			}
			finishObjectProperty(t) {
				return this.finishNode(t, "ObjectProperty");
			}
			parseObjPropValue(t, e, s, i, r, n, o) {
				let h = this.parseObjectMethod(t, s, i, r, n) || this.parseObjectProperty(t, e, r, o);
				return h || this.unexpected(), h;
			}
			parsePropertyName(t, e) {
				if (this.eat(0)) t.computed = !0, t.key = this.parseMaybeAssignAllowIn(), this.expect(3);
				else {
					let { type: s, value: i } = this.state, r;
					if (O(s)) r = this.parseIdentifier(!0);
					else switch (s) {
						case 135:
							r = this.parseNumericLiteral(i);
							break;
						case 134:
							r = this.parseStringLiteral(i);
							break;
						case 136:
							r = this.parseBigIntLiteral(i);
							break;
						case 139: {
							let n = this.state.startLoc;
							e != null ? e.privateKeyLoc === null && (e.privateKeyLoc = n) : this.raise(p.UnexpectedPrivateField, n), r = this.parsePrivateName();
							break;
						}
						default: this.unexpected();
					}
					t.key = r, s !== 139 && (t.computed = !1);
				}
			}
			initFunction(t, e) {
				t.id = null, t.generator = !1, t.async = e;
			}
			parseMethod(t, e, s, i, r, n, o = !1) {
				this.initFunction(t, s), t.generator = e, this.scope.enter(530 | (o ? 576 : 0) | (r ? 32 : 0)), this.prodParam.enter(Se(s, t.generator)), this.parseFunctionParams(t, i);
				let h = this.parseFunctionBodyAndFinish(t, n, !0);
				return this.prodParam.exit(), this.scope.exit(), h;
			}
			parseArrayLike(t, e, s) {
				e && this.expectPlugin("recordAndTuple");
				let i = this.state.inFSharpPipelineDirectBody;
				this.state.inFSharpPipelineDirectBody = !1;
				let r = this.startNode();
				return this.next(), r.elements = this.parseExprList(t, !e, s, r), this.state.inFSharpPipelineDirectBody = i, this.finishNode(r, e ? "TupleExpression" : "ArrayExpression");
			}
			parseArrowExpression(t, e, s, i) {
				this.scope.enter(518);
				let r = Se(s, !1);
				!this.match(5) && this.prodParam.hasIn && (r |= 8), this.prodParam.enter(r), this.initFunction(t, s);
				let n = this.state.maybeInArrowParameters;
				return e && (this.state.maybeInArrowParameters = !0, this.setArrowFunctionParameters(t, e, i)), this.state.maybeInArrowParameters = !1, this.parseFunctionBody(t, !0), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = n, this.finishNode(t, "ArrowFunctionExpression");
			}
			setArrowFunctionParameters(t, e, s) {
				this.toAssignableList(e, s, !1), t.params = e;
			}
			parseFunctionBodyAndFinish(t, e, s = !1) {
				return this.parseFunctionBody(t, !1, s), this.finishNode(t, e);
			}
			parseFunctionBody(t, e, s = !1) {
				let i = e && !this.match(5);
				if (this.expressionScope.enter(ns()), i) t.body = this.parseMaybeAssign(), this.checkParams(t, !1, e, !1);
				else {
					let r = this.state.strict, n = this.state.labels;
					this.state.labels = [], this.prodParam.enter(this.prodParam.currentFlags() | 4), t.body = this.parseBlock(!0, !1, (o) => {
						let h = !this.isSimpleParamList(t.params);
						o && h && this.raise(p.IllegalLanguageModeDirective, (t.kind === "method" || t.kind === "constructor") && t.key ? t.key.loc.end : t);
						let l = !r && this.state.strict;
						this.checkParams(t, !this.state.strict && !e && !s && !h, e, l), this.state.strict && t.id && this.checkIdentifier(t.id, 65, l);
					}), this.prodParam.exit(), this.state.labels = n;
				}
				this.expressionScope.exit();
			}
			isSimpleParameter(t) {
				return t.type === "Identifier";
			}
			isSimpleParamList(t) {
				for (let e = 0, s = t.length; e < s; e++) if (!this.isSimpleParameter(t[e])) return !1;
				return !0;
			}
			checkParams(t, e, s, i = !0) {
				let r = !e && /* @__PURE__ */ new Set(), n = { type: "FormalParameters" };
				for (let o of t.params) this.checkLVal(o, n, 5, r, i);
			}
			parseExprList(t, e, s, i) {
				let r = [], n = !0;
				for (; !this.eat(t);) {
					if (n) n = !1;
					else if (this.expect(12), this.match(t)) {
						i && this.addTrailingCommaExtraToNode(i), this.next();
						break;
					}
					r.push(this.parseExprListItem(t, e, s));
				}
				return r;
			}
			parseExprListItem(t, e, s, i) {
				let r;
				if (this.match(12)) e || this.raise(p.UnexpectedToken, this.state.curPosition(), { unexpected: "," }), r = null;
				else if (this.match(21)) {
					let n = this.state.startLoc;
					r = this.parseParenItem(this.parseSpread(s), n);
				} else if (this.match(17)) {
					this.expectPlugin("partialApplication"), i || this.raise(p.UnexpectedArgumentPlaceholder, this.state.startLoc);
					let n = this.startNode();
					this.next(), r = this.finishNode(n, "ArgumentPlaceholder");
				} else r = this.parseMaybeAssignAllowInOrVoidPattern(t, s, this.parseParenItem);
				return r;
			}
			parseIdentifier(t) {
				let e = this.startNode(), s = this.parseIdentifierName(t);
				return this.createIdentifier(e, s);
			}
			createIdentifier(t, e) {
				return t.name = e, t.loc.identifierName = e, this.finishNode(t, "Identifier");
			}
			createIdentifierAt(t, e, s) {
				return t.name = e, t.loc.identifierName = e, this.finishNodeAt(t, "Identifier", s);
			}
			parseIdentifierName(t) {
				let e, { startLoc: s, type: i } = this.state;
				O(i) ? e = this.state.value : this.unexpected();
				let r = ui(i);
				return t ? r && this.replaceToken(132) : this.checkReservedWord(e, s, r, !1), this.next(), e;
			}
			checkReservedWord(t, e, s, i) {
				if (t.length > 10 || !Li(t)) return;
				if (s && Ni(t)) {
					this.raise(p.UnexpectedKeyword, e, { keyword: t });
					return;
				}
				if ((this.state.strict ? i ? ss : es : Zt)(t, this.inModule)) {
					this.raise(p.UnexpectedReservedWord, e, { reservedWord: t });
					return;
				} else if (t === "yield") {
					if (this.prodParam.hasYield) {
						this.raise(p.YieldBindingIdentifier, e);
						return;
					}
				} else if (t === "await") {
					if (this.prodParam.hasAwait) {
						this.raise(p.AwaitBindingIdentifier, e);
						return;
					}
					if (this.scope.inStaticBlock) {
						this.raise(p.AwaitBindingIdentifierInStaticBlock, e);
						return;
					}
					this.expressionScope.recordAsyncArrowParametersError(e);
				} else if (t === "arguments" && this.scope.inClassAndNotInNonArrowFunction) {
					this.raise(p.ArgumentsInClass, e);
					return;
				}
			}
			recordAwaitIfAllowed() {
				let t = this.prodParam.hasAwait;
				return t && !this.scope.inFunction && (this.state.hasTopLevelAwait = !0), t;
			}
			parseAwait(t) {
				let e = this.startNodeAt(t);
				return this.expressionScope.recordParameterInitializerError(p.AwaitExpressionFormalParameter, e), this.eat(55) && this.raise(p.ObsoleteAwaitStar, e), !this.scope.inFunction && !(this.optionFlags & 1) && (this.isAmbiguousPrefixOrIdentifier() ? this.ambiguousScriptDifferentAst = !0 : this.sawUnambiguousESM = !0), this.state.soloAwait || (e.argument = this.parseMaybeUnary(null, !0)), this.finishNode(e, "AwaitExpression");
			}
			isAmbiguousPrefixOrIdentifier() {
				if (this.hasPrecedingLineBreak()) return !0;
				let { type: t } = this.state;
				return t === 53 || t === 10 || t === 0 || Ke(t) || t === 102 && !this.state.containsEsc || t === 138 || t === 56 || this.hasPlugin("v8intrinsic") && t === 54;
			}
			parseYield(t) {
				let e = this.startNodeAt(t);
				this.expressionScope.recordParameterInitializerError(p.YieldInParameter, e);
				let s = !1, i = null;
				if (!this.hasPrecedingLineBreak()) switch (s = this.eat(55), this.state.type) {
					case 13:
					case 140:
					case 8:
					case 11:
					case 3:
					case 9:
					case 14:
					case 12: if (!s) break;
					default: i = this.parseMaybeAssign();
				}
				return e.delegate = s, e.argument = i, this.finishNode(e, "YieldExpression");
			}
			parseImportCall(t) {
				if (this.next(), t.source = this.parseMaybeAssignAllowIn(), t.options = null, this.eat(12)) {
					if (this.match(11)) this.addTrailingCommaExtraToNode(t.source);
					else if (t.options = this.parseMaybeAssignAllowIn(), this.eat(12) && (this.addTrailingCommaExtraToNode(t.options), !this.match(11))) {
						do
							this.parseMaybeAssignAllowIn();
						while (this.eat(12) && !this.match(11));
						this.raise(p.ImportCallArity, t);
					}
				}
				return this.expect(11), this.finishNode(t, "ImportExpression");
			}
			checkPipelineAtInfixOperator(t, e) {
				this.hasPlugin(["pipelineOperator", { proposal: "smart" }]) && t.type === "SequenceExpression" && this.raise(p.PipelineHeadSequenceExpression, e);
			}
			parseSmartPipelineBodyInStyle(t, e) {
				if (this.isSimpleReference(t)) {
					let s = this.startNodeAt(e);
					return s.callee = t, this.finishNode(s, "PipelineBareFunction");
				} else {
					let s = this.startNodeAt(e);
					return this.checkSmartPipeTopicBodyEarlyErrors(e), s.expression = t, this.finishNode(s, "PipelineTopicExpression");
				}
			}
			isSimpleReference(t) {
				switch (t.type) {
					case "MemberExpression": return !t.computed && this.isSimpleReference(t.object);
					case "Identifier": return !0;
					default: return !1;
				}
			}
			checkSmartPipeTopicBodyEarlyErrors(t) {
				if (this.match(19)) throw this.raise(p.PipelineBodyNoArrow, this.state.startLoc);
				this.topicReferenceWasUsedInCurrentContext() || this.raise(p.PipelineTopicUnused, t);
			}
			withTopicBindingContext(t) {
				let e = this.state.topicContext;
				this.state.topicContext = {
					maxNumOfResolvableTopics: 1,
					maxTopicIndex: null
				};
				try {
					return t();
				} finally {
					this.state.topicContext = e;
				}
			}
			withSmartMixTopicForbiddingContext(t) {
				return t();
			}
			withSoloAwaitPermittingContext(t) {
				let e = this.state.soloAwait;
				this.state.soloAwait = !0;
				try {
					return t();
				} finally {
					this.state.soloAwait = e;
				}
			}
			allowInAnd(t) {
				let e = this.prodParam.currentFlags();
				if (8 & ~e) {
					this.prodParam.enter(e | 8);
					try {
						return t();
					} finally {
						this.prodParam.exit();
					}
				}
				return t();
			}
			disallowInAnd(t) {
				let e = this.prodParam.currentFlags();
				if (8 & e) {
					this.prodParam.enter(e & -9);
					try {
						return t();
					} finally {
						this.prodParam.exit();
					}
				}
				return t();
			}
			registerTopicReference() {
				this.state.topicContext.maxTopicIndex = 0;
			}
			topicReferenceIsAllowedInCurrentContext() {
				return this.state.topicContext.maxNumOfResolvableTopics >= 1;
			}
			topicReferenceWasUsedInCurrentContext() {
				return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
			}
			parseFSharpPipelineBody(t) {
				let e = this.state.startLoc;
				this.state.potentialArrowAt = this.state.start;
				let s = this.state.inFSharpPipelineDirectBody;
				this.state.inFSharpPipelineDirectBody = !0;
				let i = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), e, t);
				return this.state.inFSharpPipelineDirectBody = s, i;
			}
			parseModuleExpression() {
				this.expectPlugin("moduleBlocks");
				let t = this.startNode();
				this.next(), this.match(5) || this.unexpected(null, 5);
				let e = this.startNodeAt(this.state.endLoc);
				this.next();
				let s = this.initializeScopes(!0);
				this.enterInitialScopes();
				try {
					t.body = this.parseProgram(e, 8, "module");
				} finally {
					s();
				}
				return this.finishNode(t, "ModuleExpression");
			}
			parseVoidPattern(t) {
				this.expectPlugin("discardBinding");
				let e = this.startNode();
				return t != null && (t.voidPatternLoc = this.state.startLoc), this.next(), this.finishNode(e, "VoidPattern");
			}
			parseMaybeAssignAllowInOrVoidPattern(t, e, s) {
				if (e != null && this.match(88)) {
					let i = this.lookaheadCharCode();
					if (i === 44 || i === (t === 3 ? 93 : t === 8 ? 125 : 41) || i === 61) return this.parseMaybeDefault(this.state.startLoc, this.parseVoidPattern(e));
				}
				return this.parseMaybeAssignAllowIn(e, s);
			}
			parsePropertyNamePrefixOperator(t) {}
		}, qe = { kind: 1 }, nr = { kind: 2 }, or = /[\uD800-\uDFFF]/u, $e = /in(?:stanceof)?/y;
		function hr(a, t, e) {
			for (let s = 0; s < a.length; s++) {
				let i = a[s], { type: r } = i;
				typeof r == "number" && (i.type = Xt(r));
			}
			return a;
		}
		var ft = class extends ut {
			parseTopLevel(t, e) {
				return t.program = this.parseProgram(e, 140, this.options.sourceType === "module" ? "module" : "script"), t.comments = this.comments, this.optionFlags & 256 && (t.tokens = hr(this.tokens, this.input, this.startIndex)), this.finishNode(t, "File");
			}
			parseProgram(t, e, s) {
				if (t.sourceType = s, t.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(t, !0, !0, e), this.inModule) {
					if (!(this.optionFlags & 64) && this.scope.undefinedExports.size > 0) for (let [r, n] of Array.from(this.scope.undefinedExports)) this.raise(p.ModuleExportUndefined, n, { localName: r });
					this.addExtra(t, "topLevelAwait", this.state.hasTopLevelAwait);
				}
				let i;
				return e === 140 ? i = this.finishNode(t, "Program") : i = this.finishNodeAt(t, "Program", D(this.state.startLoc, -1)), i;
			}
			stmtToDirective(t) {
				let e = this.castNodeTo(t, "Directive"), s = this.castNodeTo(t.expression, "DirectiveLiteral"), i = s.value, r = this.input.slice(this.offsetToSourcePos(s.start), this.offsetToSourcePos(s.end)), n = s.value = r.slice(1, -1);
				return this.addExtra(s, "raw", r), this.addExtra(s, "rawValue", n), this.addExtra(s, "expressionValue", i), e.value = s, delete t.expression, e;
			}
			parseInterpreterDirective() {
				if (!this.match(28)) return null;
				let t = this.startNode();
				return t.value = this.state.value, this.next(), this.finishNode(t, "InterpreterDirective");
			}
			isLet() {
				return this.isContextual(100) ? this.hasFollowingBindingAtom() : !1;
			}
			isUsing() {
				return this.isContextual(107) ? this.nextTokenIsIdentifierOnSameLine() : !1;
			}
			isForUsing() {
				if (!this.isContextual(107)) return !1;
				let t = this.nextTokenInLineStart(), e = this.codePointAtPos(t);
				if (this.isUnparsedContextual(t, "of")) {
					let s = this.lookaheadCharCodeSince(t + 2);
					if (s !== 61 && s !== 58 && s !== 59) return !1;
				}
				return !!(this.chStartsBindingIdentifier(e, t) || this.isUnparsedContextual(t, "void"));
			}
			nextTokenIsIdentifierOnSameLine() {
				let t = this.nextTokenInLineStart(), e = this.codePointAtPos(t);
				return this.chStartsBindingIdentifier(e, t);
			}
			isAwaitUsing() {
				if (!this.isContextual(96)) return !1;
				let t = this.nextTokenInLineStart();
				if (this.isUnparsedContextual(t, "using")) {
					t = this.nextTokenInLineStartSince(t + 5);
					let e = this.codePointAtPos(t);
					if (this.chStartsBindingIdentifier(e, t)) return !0;
				}
				return !1;
			}
			chStartsBindingIdentifier(t, e) {
				if (B(t)) {
					if ($e.lastIndex = e, $e.test(this.input)) {
						let s = this.codePointAtPos($e.lastIndex);
						if (!K(s) && s !== 92) return !1;
					}
					return !0;
				} else return t === 92;
			}
			chStartsBindingPattern(t) {
				return t === 91 || t === 123;
			}
			hasFollowingBindingAtom() {
				let t = this.nextTokenStart(), e = this.codePointAtPos(t);
				return this.chStartsBindingPattern(e) || this.chStartsBindingIdentifier(e, t);
			}
			hasInLineFollowingBindingIdentifierOrBrace() {
				let t = this.nextTokenInLineStart(), e = this.codePointAtPos(t);
				return e === 123 || this.chStartsBindingIdentifier(e, t);
			}
			allowsUsing() {
				return (this.scope.inModule || !this.scope.inTopLevel) && !this.scope.inBareCaseStatement;
			}
			parseModuleItem() {
				return this.parseStatementLike(15);
			}
			parseStatementListItem() {
				return this.parseStatementLike(6 | (!this.options.annexB || this.state.strict ? 0 : 8));
			}
			parseStatementOrSloppyAnnexBFunctionDeclaration(t = !1) {
				let e = 0;
				return this.options.annexB && !this.state.strict && (e |= 4, t && (e |= 8)), this.parseStatementLike(e);
			}
			parseStatement() {
				return this.parseStatementLike(0);
			}
			parseStatementLike(t) {
				let e = null;
				return this.match(26) && (e = this.parseDecorators(!0)), this.parseStatementContent(t, e);
			}
			parseStatementContent(t, e) {
				let s = this.state.type, i = this.startNode(), r = !!(t & 2), n = !!(t & 4), o = t & 1;
				switch (s) {
					case 60: return this.parseBreakContinueStatement(i, !0);
					case 63: return this.parseBreakContinueStatement(i, !1);
					case 64: return this.parseDebuggerStatement(i);
					case 90: return this.parseDoWhileStatement(i);
					case 91: return this.parseForStatement(i);
					case 68:
						if (this.lookaheadCharCode() === 46) break;
						return n || this.raise(this.state.strict ? p.StrictFunction : this.options.annexB ? p.SloppyFunctionAnnexB : p.SloppyFunction, this.state.startLoc), this.parseFunctionStatement(i, !1, !r && n);
					case 80: return r || this.unexpected(), this.parseClass(this.maybeTakeDecorators(e, i), !0);
					case 69: return this.parseIfStatement(i);
					case 70: return this.parseReturnStatement(i);
					case 71: return this.parseSwitchStatement(i);
					case 72: return this.parseThrowStatement(i);
					case 73: return this.parseTryStatement(i);
					case 96:
						if (this.isAwaitUsing()) return this.allowsUsing() ? r ? this.recordAwaitIfAllowed() || this.raise(p.AwaitUsingNotInAsyncContext, i) : this.raise(p.UnexpectedLexicalDeclaration, i) : this.raise(p.UnexpectedUsingDeclaration, i), this.next(), this.parseVarStatement(i, "await using");
						break;
					case 107:
						if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifierOrBrace()) break;
						return this.allowsUsing() ? r || this.raise(p.UnexpectedLexicalDeclaration, this.state.startLoc) : this.raise(p.UnexpectedUsingDeclaration, this.state.startLoc), this.parseVarStatement(i, "using");
					case 100: {
						if (this.state.containsEsc) break;
						let u = this.nextTokenStart(), f = this.codePointAtPos(u);
						if (f !== 91 && (!r && this.hasFollowingLineBreak() || !this.chStartsBindingIdentifier(f, u) && f !== 123)) break;
					}
					case 75: r || this.raise(p.UnexpectedLexicalDeclaration, this.state.startLoc);
					case 74: {
						let u = this.state.value;
						return this.parseVarStatement(i, u);
					}
					case 92: return this.parseWhileStatement(i);
					case 76: return this.parseWithStatement(i);
					case 5: return this.parseBlock();
					case 13: return this.parseEmptyStatement(i);
					case 83: {
						let u = this.lookaheadCharCode();
						if (u === 40 || u === 46) break;
					}
					case 82: {
						!(this.optionFlags & 8) && !o && this.raise(p.UnexpectedImportExport, this.state.startLoc), this.next();
						let u;
						return s === 83 ? u = this.parseImport(i) : u = this.parseExport(i, e), this.assertModuleNodeAllowed(u), u;
					}
					default: if (this.isAsyncFunction()) return r || this.raise(p.AsyncFunctionInSingleStatementContext, this.state.startLoc), this.next(), this.parseFunctionStatement(i, !0, !r && n);
				}
				let h = this.state.value, l = this.parseExpression();
				return w(s) && l.type === "Identifier" && this.eat(14) ? this.parseLabeledStatement(i, h, l, t) : this.parseExpressionStatement(i, l, e);
			}
			assertModuleNodeAllowed(t) {
				!(this.optionFlags & 8) && !this.inModule && this.raise(p.ImportOutsideModule, t);
			}
			decoratorsEnabledBeforeExport() {
				return this.hasPlugin("decorators-legacy") ? !0 : this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") !== !1;
			}
			maybeTakeDecorators(t, e, s) {
				return t && (e.decorators?.length ? (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") != "boolean" && this.raise(p.DecoratorsBeforeAfterExport, e.decorators[0]), e.decorators.unshift(...t)) : e.decorators = t, this.resetStartLocationFromNode(e, t[0]), s && this.resetStartLocationFromNode(s, e)), e;
			}
			canHaveLeadingDecorator() {
				return this.match(80);
			}
			parseDecorators(t) {
				let e = [];
				do
					e.push(this.parseDecorator());
				while (this.match(26));
				if (this.match(82)) t || this.unexpected(), this.decoratorsEnabledBeforeExport() || this.raise(p.DecoratorExportClass, this.state.startLoc);
				else if (!this.canHaveLeadingDecorator()) throw this.raise(p.UnexpectedLeadingDecorator, this.state.startLoc);
				return e;
			}
			parseDecorator() {
				this.expectOnePlugin(["decorators", "decorators-legacy"]);
				let t = this.startNode();
				if (this.next(), this.hasPlugin("decorators")) {
					let e = this.state.startLoc, s;
					if (this.match(10)) {
						let i = this.state.startLoc;
						this.next(), s = this.parseExpression(), this.expect(11), s = this.wrapParenthesis(i, s);
						let r = this.state.startLoc;
						t.expression = this.parseMaybeDecoratorArguments(s, i), this.getPluginOption("decorators", "allowCallParenthesized") === !1 && t.expression !== s && this.raise(p.DecoratorArgumentsOutsideParentheses, r);
					} else {
						for (s = this.parseIdentifier(!1); this.eat(16);) {
							let i = this.startNodeAt(e);
							i.object = s, this.match(139) ? (this.classScope.usePrivateName(this.state.value, this.state.startLoc), i.property = this.parsePrivateName()) : i.property = this.parseIdentifier(!0), i.computed = !1, s = this.finishNode(i, "MemberExpression");
						}
						t.expression = this.parseMaybeDecoratorArguments(s, e);
					}
				} else t.expression = this.parseExprSubscripts();
				return this.finishNode(t, "Decorator");
			}
			parseMaybeDecoratorArguments(t, e) {
				if (this.eat(10)) {
					let s = this.startNodeAt(e);
					return s.callee = t, s.arguments = this.parseCallExpressionArguments(), this.toReferencedList(s.arguments), this.finishNode(s, "CallExpression");
				}
				return t;
			}
			parseBreakContinueStatement(t, e) {
				return this.next(), this.isLineTerminator() ? t.label = null : (t.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(t, e), this.finishNode(t, e ? "BreakStatement" : "ContinueStatement");
			}
			verifyBreakContinue(t, e) {
				let s;
				for (s = 0; s < this.state.labels.length; ++s) {
					let i = this.state.labels[s];
					if ((t.label == null || i.name === t.label.name) && (i.kind != null && (e || i.kind === 1) || t.label && e)) break;
				}
				if (s === this.state.labels.length) {
					let i = e ? "BreakStatement" : "ContinueStatement";
					this.raise(p.IllegalBreakContinue, t, { type: i });
				}
			}
			parseDebuggerStatement(t) {
				return this.next(), this.semicolon(), this.finishNode(t, "DebuggerStatement");
			}
			parseHeaderExpression() {
				this.expect(10);
				let t = this.parseExpression();
				return this.expect(11), t;
			}
			parseDoWhileStatement(t) {
				return this.next(), this.state.labels.push(qe), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.expect(92), t.test = this.parseHeaderExpression(), this.eat(13), this.finishNode(t, "DoWhileStatement");
			}
			parseForStatement(t) {
				this.next(), this.state.labels.push(qe);
				let e = null;
				if (this.isContextual(96) && this.recordAwaitIfAllowed() && (e = this.state.startLoc, this.next()), this.scope.enter(0), this.expect(10), this.match(13)) return e !== null && this.unexpected(e), this.parseFor(t, null);
				let s = this.isContextual(100);
				{
					let h = this.isAwaitUsing(), l = h || this.isForUsing(), u = s && this.hasFollowingBindingAtom() || l;
					if (this.match(74) || this.match(75) || u) {
						let f = this.startNode(), d;
						h ? (d = "await using", this.recordAwaitIfAllowed() || this.raise(p.AwaitUsingNotInAsyncContext, this.state.startLoc), this.next()) : d = this.state.value, this.next(), this.parseVar(f, !0, d);
						let x = this.finishNode(f, "VariableDeclaration"), A = this.match(58);
						return A && l && this.raise(p.ForInUsing, x), (A || this.isContextual(102)) && x.declarations.length === 1 ? this.parseForIn(t, x, e) : (e !== null && this.unexpected(e), this.parseFor(t, x));
					}
				}
				let i = this.isContextual(95), r = new Y(), n = this.parseExpression(!0, r), o = this.isContextual(102);
				if (o && (s && this.raise(p.ForOfLet, n), e === null && i && n.type === "Identifier" && this.raise(p.ForOfAsync, n)), o || this.match(58)) {
					this.checkDestructuringPrivate(r), this.toAssignable(n, !0);
					let h = o ? "ForOfStatement" : "ForInStatement";
					return this.checkLVal(n, { type: h }), this.parseForIn(t, n, e);
				} else this.checkExpressionErrors(r, !0);
				return e !== null && this.unexpected(e), this.parseFor(t, n);
			}
			parseFunctionStatement(t, e, s) {
				return this.next(), this.parseFunction(t, 1 | (s ? 2 : 0) | (e ? 8 : 0));
			}
			parseIfStatement(t) {
				return this.next(), t.test = this.parseHeaderExpression(), t.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration(), t.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null, this.finishNode(t, "IfStatement");
			}
			parseReturnStatement(t) {
				return this.prodParam.hasReturn || this.raise(p.IllegalReturn, this.state.startLoc), this.next(), this.isLineTerminator() ? t.argument = null : (t.argument = this.parseExpression(), this.semicolon()), this.finishNode(t, "ReturnStatement");
			}
			parseSwitchStatement(t) {
				this.next(), t.discriminant = this.parseHeaderExpression();
				let e = t.cases = [];
				this.expect(5), this.state.labels.push(nr), this.scope.enter(256);
				let s;
				for (let i; !this.match(8);) if (this.match(61) || this.match(65)) {
					let r = this.match(61);
					s && this.finishNode(s, "SwitchCase"), e.push(s = this.startNode()), s.consequent = [], this.next(), r ? s.test = this.parseExpression() : (i && this.raise(p.MultipleDefaultsInSwitch, this.state.lastTokStartLoc), i = !0, s.test = null), this.expect(14);
				} else s ? s.consequent.push(this.parseStatementListItem()) : this.unexpected();
				return this.scope.exit(), s && this.finishNode(s, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(t, "SwitchStatement");
			}
			parseThrowStatement(t) {
				return this.next(), this.hasPrecedingLineBreak() && this.raise(p.NewlineAfterThrow, this.state.lastTokEndLoc), t.argument = this.parseExpression(), this.semicolon(), this.finishNode(t, "ThrowStatement");
			}
			parseCatchClauseParam() {
				let t = this.parseBindingAtom();
				return this.scope.enter(this.options.annexB && t.type === "Identifier" ? 8 : 0), this.checkLVal(t, { type: "CatchClause" }, 9), t;
			}
			parseTryStatement(t) {
				if (this.next(), t.block = this.parseBlock(), t.handler = null, this.match(62)) {
					let e = this.startNode();
					this.next(), this.match(10) ? (this.expect(10), e.param = this.parseCatchClauseParam(), this.expect(11)) : (e.param = null, this.scope.enter(0)), e.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(!1, !1)), this.scope.exit(), t.handler = this.finishNode(e, "CatchClause");
				}
				return t.finalizer = this.eat(67) ? this.parseBlock() : null, !t.handler && !t.finalizer && this.raise(p.NoCatchOrFinally, t), this.finishNode(t, "TryStatement");
			}
			parseVarStatement(t, e, s = !1) {
				return this.next(), this.parseVar(t, !1, e, s), this.semicolon(), this.finishNode(t, "VariableDeclaration");
			}
			parseWhileStatement(t) {
				return this.next(), t.test = this.parseHeaderExpression(), this.state.labels.push(qe), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.finishNode(t, "WhileStatement");
			}
			parseWithStatement(t) {
				return this.state.strict && this.raise(p.StrictWith, this.state.startLoc), this.next(), t.object = this.parseHeaderExpression(), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.finishNode(t, "WithStatement");
			}
			parseEmptyStatement(t) {
				return this.next(), this.finishNode(t, "EmptyStatement");
			}
			parseLabeledStatement(t, e, s, i) {
				for (let n of this.state.labels) n.name === e && this.raise(p.LabelRedeclaration, s, { labelName: e });
				let r = mi(this.state.type) ? 1 : this.match(71) ? 2 : null;
				for (let n = this.state.labels.length - 1; n >= 0; n--) {
					let o = this.state.labels[n];
					if (o.statementStart === t.start) o.statementStart = this.sourceToOffsetPos(this.state.start), o.kind = r;
					else break;
				}
				return this.state.labels.push({
					name: e,
					kind: r,
					statementStart: this.sourceToOffsetPos(this.state.start)
				}), t.body = i & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(!0) : this.parseStatement(), this.state.labels.pop(), t.label = s, this.finishNode(t, "LabeledStatement");
			}
			parseExpressionStatement(t, e, s) {
				return t.expression = e, this.semicolon(), this.finishNode(t, "ExpressionStatement");
			}
			parseBlock(t = !1, e = !0, s) {
				let i = this.startNode();
				return t && this.state.strictErrors.clear(), this.expect(5), e && this.scope.enter(0), this.parseBlockBody(i, t, !1, 8, s), e && this.scope.exit(), this.finishNode(i, "BlockStatement");
			}
			isValidDirective(t) {
				return t.type === "ExpressionStatement" && t.expression.type === "StringLiteral" && !t.expression.extra.parenthesized;
			}
			parseBlockBody(t, e, s, i, r) {
				let n = t.body = [], o = t.directives = [];
				this.parseBlockOrModuleBlockBody(n, e ? o : void 0, s, i, r);
			}
			parseBlockOrModuleBlockBody(t, e, s, i, r) {
				let n = this.state.strict, o = !1, h = !1;
				for (; !this.match(i);) {
					let l = s ? this.parseModuleItem() : this.parseStatementListItem();
					if (e && !h) {
						if (this.isValidDirective(l)) {
							let u = this.stmtToDirective(l);
							e.push(u), !o && u.value.value === "use strict" && (o = !0, this.setStrict(!0));
							continue;
						}
						h = !0, this.state.strictErrors.clear();
					}
					t.push(l);
				}
				r?.call(this, o), n || this.setStrict(!1), this.next();
			}
			parseFor(t, e) {
				return t.init = e, this.semicolon(!1), t.test = this.match(13) ? null : this.parseExpression(), this.semicolon(!1), t.update = this.match(11) ? null : this.parseExpression(), this.expect(11), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(t, "ForStatement");
			}
			parseForIn(t, e, s) {
				let i = this.match(58);
				return this.next(), i ? s !== null && this.unexpected(s) : t.await = s !== null, e.type === "VariableDeclaration" && e.declarations[0].init != null && (!i || !this.options.annexB || this.state.strict || e.kind !== "var" || e.declarations[0].id.type !== "Identifier") && this.raise(p.ForInOfLoopInitializer, e, { type: i ? "ForInStatement" : "ForOfStatement" }), e.type === "AssignmentPattern" && this.raise(p.InvalidLhs, e, { ancestor: { type: "ForStatement" } }), t.left = e, t.right = i ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(11), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(t, i ? "ForInStatement" : "ForOfStatement");
			}
			parseVar(t, e, s, i = !1) {
				let r = t.declarations = [];
				for (t.kind = s;;) {
					let n = this.startNode();
					if (this.parseVarId(n, s), n.init = this.eat(29) ? e ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : null, n.init === null && !i && (n.id.type !== "Identifier" && !(e && (this.match(58) || this.isContextual(102))) ? this.raise(p.DeclarationMissingInitializer, this.state.lastTokEndLoc, { kind: "destructuring" }) : (s === "const" || s === "using" || s === "await using") && !(this.match(58) || this.isContextual(102)) && this.raise(p.DeclarationMissingInitializer, this.state.lastTokEndLoc, { kind: s })), r.push(this.finishNode(n, "VariableDeclarator")), !this.eat(12)) break;
				}
				return t;
			}
			parseVarId(t, e) {
				let s = this.parseBindingAtom();
				e === "using" || e === "await using" ? (s.type === "ArrayPattern" || s.type === "ObjectPattern") && this.raise(p.UsingDeclarationHasBindingPattern, s.loc.start) : s.type === "VoidPattern" && this.raise(p.UnexpectedVoidPattern, s.loc.start), this.checkLVal(s, { type: "VariableDeclarator" }, e === "var" ? 5 : 8201), t.id = s;
			}
			parseAsyncFunctionExpression(t) {
				return this.parseFunction(t, 8);
			}
			parseFunction(t, e = 0) {
				let s = e & 2, i = !!(e & 1), r = i && !(e & 4), n = !!(e & 8);
				this.initFunction(t, n), this.match(55) && (s && this.raise(p.GeneratorInSingleStatementContext, this.state.startLoc), this.next(), t.generator = !0), i && (t.id = this.parseFunctionId(r));
				let o = this.state.maybeInArrowParameters;
				return this.state.maybeInArrowParameters = !1, this.scope.enter(514), this.prodParam.enter(Se(n, t.generator)), i || (t.id = this.parseFunctionId()), this.parseFunctionParams(t, !1), this.withSmartMixTopicForbiddingContext(() => {
					this.parseFunctionBodyAndFinish(t, i ? "FunctionDeclaration" : "FunctionExpression");
				}), this.prodParam.exit(), this.scope.exit(), i && !s && this.registerFunctionStatementId(t), this.state.maybeInArrowParameters = o, t;
			}
			parseFunctionId(t) {
				return t || w(this.state.type) ? this.parseIdentifier() : null;
			}
			parseFunctionParams(t, e) {
				this.expect(10), this.expressionScope.enter(Hi()), t.params = this.parseBindingList(11, 41, 2 | (e ? 4 : 0)), this.expressionScope.exit();
			}
			registerFunctionStatementId(t) {
				t.id && this.scope.declareName(t.id.name, !this.options.annexB || this.state.strict || t.generator || t.async ? this.scope.treatFunctionsAsVar ? 5 : 8201 : 17, t.id.loc.start);
			}
			parseClass(t, e, s) {
				this.next();
				let i = this.state.strict;
				return this.state.strict = !0, this.parseClassId(t, e, s), this.parseClassSuper(t), t.body = this.parseClassBody(!!t.superClass, i), this.finishNode(t, e ? "ClassDeclaration" : "ClassExpression");
			}
			isClassProperty() {
				return this.match(29) || this.match(13) || this.match(8);
			}
			isClassMethod() {
				return this.match(10);
			}
			nameIsConstructor(t) {
				return t.type === "Identifier" && t.name === "constructor" || t.type === "StringLiteral" && t.value === "constructor";
			}
			isNonstaticConstructor(t) {
				return !t.computed && !t.static && this.nameIsConstructor(t.key);
			}
			parseClassBody(t, e) {
				this.classScope.enter();
				let s = {
					hadConstructor: !1,
					hadSuperClass: t
				}, i = [], r = this.startNode();
				if (r.body = [], this.expect(5), this.withSmartMixTopicForbiddingContext(() => {
					for (; !this.match(8);) {
						if (this.eat(13)) {
							if (i.length > 0) throw this.raise(p.DecoratorSemicolon, this.state.lastTokEndLoc);
							continue;
						}
						if (this.match(26)) {
							i.push(this.parseDecorator());
							continue;
						}
						let n = this.startNode();
						i.length && (n.decorators = i, this.resetStartLocationFromNode(n, i[0]), i = []), this.parseClassMember(r, n, s), n.kind === "constructor" && n.decorators && n.decorators.length > 0 && this.raise(p.DecoratorConstructor, n);
					}
				}), this.state.strict = e, this.next(), i.length) throw this.raise(p.TrailingDecorator, this.state.startLoc);
				return this.classScope.exit(), this.finishNode(r, "ClassBody");
			}
			parseClassMemberFromModifier(t, e) {
				let s = this.parseIdentifier(!0);
				if (this.isClassMethod()) {
					let i = e;
					return i.kind = "method", i.computed = !1, i.key = s, i.static = !1, this.pushClassMethod(t, i, !1, !1, !1, !1), !0;
				} else if (this.isClassProperty()) {
					let i = e;
					return i.computed = !1, i.key = s, i.static = !1, t.body.push(this.parseClassProperty(i)), !0;
				}
				return this.resetPreviousNodeTrailingComments(s), !1;
			}
			parseClassMember(t, e, s) {
				let i = this.isContextual(106);
				if (i) {
					if (this.parseClassMemberFromModifier(t, e)) return;
					if (this.eat(5)) {
						this.parseClassStaticBlock(t, e);
						return;
					}
				}
				this.parseClassMemberWithIsStatic(t, e, s, i);
			}
			parseClassMemberWithIsStatic(t, e, s, i) {
				let r = e, n = e, o = e, h = e, l = e, u = r, f = r;
				if (e.static = i, this.parsePropertyNamePrefixOperator(e), this.eat(55)) {
					u.kind = "method";
					let C = this.match(139);
					if (this.parseClassElementName(u), this.parsePostMemberNameModifiers(u), C) {
						this.pushClassPrivateMethod(t, n, !0, !1);
						return;
					}
					this.isNonstaticConstructor(r) && this.raise(p.ConstructorIsGenerator, r.key), this.pushClassMethod(t, r, !0, !1, !1, !1);
					return;
				}
				let d = !this.state.containsEsc && w(this.state.type), x = this.parseClassElementName(e), A = d ? x.name : null, k = this.isPrivateName(x), N = this.state.startLoc;
				if (this.parsePostMemberNameModifiers(f), this.isClassMethod()) {
					if (u.kind = "method", k) {
						this.pushClassPrivateMethod(t, n, !1, !1);
						return;
					}
					let C = this.isNonstaticConstructor(r), I = !1;
					C && (r.kind = "constructor", s.hadConstructor && !this.hasPlugin("typescript") && this.raise(p.DuplicateConstructor, x), C && this.hasPlugin("typescript") && e.override && this.raise(p.OverrideOnConstructor, x), s.hadConstructor = !0, I = s.hadSuperClass), this.pushClassMethod(t, r, !1, !1, C, I);
				} else if (this.isClassProperty()) k ? this.pushClassPrivateProperty(t, h) : this.pushClassProperty(t, o);
				else if (A === "async" && !this.isLineTerminator()) {
					this.resetPreviousNodeTrailingComments(x);
					let C = this.eat(55);
					f.optional && this.unexpected(N), u.kind = "method";
					let I = this.match(139);
					this.parseClassElementName(u), this.parsePostMemberNameModifiers(f), I ? this.pushClassPrivateMethod(t, n, C, !0) : (this.isNonstaticConstructor(r) && this.raise(p.ConstructorIsAsync, r.key), this.pushClassMethod(t, r, C, !0, !1, !1));
				} else if ((A === "get" || A === "set") && !(this.match(55) && this.isLineTerminator())) {
					this.resetPreviousNodeTrailingComments(x), u.kind = A;
					let C = this.match(139);
					this.parseClassElementName(r), C ? this.pushClassPrivateMethod(t, n, !1, !1) : (this.isNonstaticConstructor(r) && this.raise(p.ConstructorIsAccessor, r.key), this.pushClassMethod(t, r, !1, !1, !1, !1)), this.checkGetterSetterParams(r);
				} else if (A === "accessor" && !this.isLineTerminator()) {
					this.expectPlugin("decoratorAutoAccessors"), this.resetPreviousNodeTrailingComments(x);
					let C = this.match(139);
					this.parseClassElementName(o), this.pushClassAccessorProperty(t, l, C);
				} else this.isLineTerminator() ? k ? this.pushClassPrivateProperty(t, h) : this.pushClassProperty(t, o) : this.unexpected();
			}
			parseClassElementName(t) {
				let { type: e, value: s } = this.state;
				if ((e === 132 || e === 134) && t.static && s === "prototype" && this.raise(p.StaticPrototype, this.state.startLoc), e === 139) {
					s === "constructor" && this.raise(p.ConstructorClassPrivateField, this.state.startLoc);
					let i = this.parsePrivateName();
					return t.key = i, i;
				}
				return this.parsePropertyName(t), t.key;
			}
			parseClassStaticBlock(t, e) {
				this.scope.enter(720);
				let s = this.state.labels;
				this.state.labels = [], this.prodParam.enter(0);
				let i = e.body = [];
				this.parseBlockOrModuleBlockBody(i, void 0, !1, 8), this.prodParam.exit(), this.scope.exit(), this.state.labels = s, t.body.push(this.finishNode(e, "StaticBlock")), e.decorators?.length && this.raise(p.DecoratorStaticBlock, e);
			}
			pushClassProperty(t, e) {
				!e.computed && this.nameIsConstructor(e.key) && this.raise(p.ConstructorClassField, e.key), t.body.push(this.parseClassProperty(e));
			}
			pushClassPrivateProperty(t, e) {
				let s = this.parseClassPrivateProperty(e);
				t.body.push(s), this.classScope.declarePrivateName(this.getPrivateNameSV(s.key), 0, s.key.loc.start);
			}
			pushClassAccessorProperty(t, e, s) {
				!s && !e.computed && this.nameIsConstructor(e.key) && this.raise(p.ConstructorClassField, e.key);
				let i = this.parseClassAccessorProperty(e);
				t.body.push(i), s && this.classScope.declarePrivateName(this.getPrivateNameSV(i.key), 0, i.key.loc.start);
			}
			pushClassMethod(t, e, s, i, r, n) {
				t.body.push(this.parseMethod(e, s, i, r, n, "ClassMethod", !0));
			}
			pushClassPrivateMethod(t, e, s, i) {
				let r = this.parseMethod(e, s, i, !1, !1, "ClassPrivateMethod", !0);
				t.body.push(r);
				let n = r.kind === "get" ? r.static ? 6 : 2 : r.kind === "set" ? r.static ? 5 : 1 : 0;
				this.declareClassPrivateMethodInScope(r, n);
			}
			declareClassPrivateMethodInScope(t, e) {
				this.classScope.declarePrivateName(this.getPrivateNameSV(t.key), e, t.key.loc.start);
			}
			parsePostMemberNameModifiers(t) {}
			parseClassPrivateProperty(t) {
				return this.parseInitializer(t), this.semicolon(), this.finishNode(t, "ClassPrivateProperty");
			}
			parseClassProperty(t) {
				return this.parseInitializer(t), this.semicolon(), this.finishNode(t, "ClassProperty");
			}
			parseClassAccessorProperty(t) {
				return this.parseInitializer(t), this.semicolon(), this.finishNode(t, "ClassAccessorProperty");
			}
			parseInitializer(t) {
				this.scope.enter(592), this.expressionScope.enter(ns()), this.prodParam.enter(0), t.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
			}
			parseClassId(t, e, s, i = 8331) {
				if (w(this.state.type)) t.id = this.parseIdentifier(), e && this.declareNameFromIdentifier(t.id, i);
				else if (s || !e) t.id = null;
				else throw this.raise(p.MissingClassName, this.state.startLoc);
			}
			parseClassSuper(t) {
				t.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
			}
			parseExport(t, e) {
				let s = this.parseMaybeImportPhase(t, !0), i = this.maybeParseExportDefaultSpecifier(t, s), r = !i || this.eat(12), n = r && this.eatExportStar(t), o = n && this.maybeParseExportNamespaceSpecifier(t), h = r && (!o || this.eat(12)), l = i || n;
				if (n && !o) {
					if (i && this.unexpected(), e) throw this.raise(p.UnsupportedDecoratorExport, t);
					return this.parseExportFrom(t, !0), this.sawUnambiguousESM = !0, this.finishNode(t, "ExportAllDeclaration");
				}
				let u = this.maybeParseExportNamedSpecifiers(t);
				i && r && !n && !u && this.unexpected(null, 5), o && h && this.unexpected(null, 98);
				let f;
				if (l || u) {
					if (f = !1, e) throw this.raise(p.UnsupportedDecoratorExport, t);
					this.parseExportFrom(t, l);
				} else f = this.maybeParseExportDeclaration(t);
				if (l || u || f) {
					let d = t;
					if (this.checkExport(d, !0, !1, !!d.source), d.declaration?.type === "ClassDeclaration") this.maybeTakeDecorators(e, d.declaration, d);
					else if (e) throw this.raise(p.UnsupportedDecoratorExport, t);
					return this.sawUnambiguousESM = !0, this.finishNode(d, "ExportNamedDeclaration");
				}
				if (this.eat(65)) {
					let d = t, x = this.parseExportDefaultExpression();
					if (d.declaration = x, x.type === "ClassDeclaration") this.maybeTakeDecorators(e, x, d);
					else if (e) throw this.raise(p.UnsupportedDecoratorExport, t);
					return this.checkExport(d, !0, !0), this.sawUnambiguousESM = !0, this.finishNode(d, "ExportDefaultDeclaration");
				}
				throw this.unexpected(null, 5);
			}
			eatExportStar(t) {
				return this.eat(55);
			}
			maybeParseExportDefaultSpecifier(t, e) {
				if (e || this.isExportDefaultSpecifier()) {
					this.expectPlugin("exportDefaultFrom", e?.loc.start);
					let s = e || this.parseIdentifier(!0), i = this.startNodeAtNode(s);
					return i.exported = s, t.specifiers = [this.finishNode(i, "ExportDefaultSpecifier")], !0;
				}
				return !1;
			}
			maybeParseExportNamespaceSpecifier(t) {
				if (this.isContextual(93)) {
					t.specifiers ?? (t.specifiers = []);
					let e = this.startNodeAt(this.state.lastTokStartLoc);
					return this.next(), e.exported = this.parseModuleExportName(), t.specifiers.push(this.finishNode(e, "ExportNamespaceSpecifier")), !0;
				}
				return !1;
			}
			maybeParseExportNamedSpecifiers(t) {
				if (this.match(5)) {
					let e = t;
					e.specifiers || (e.specifiers = []);
					let s = e.exportKind === "type";
					return e.specifiers.push(...this.parseExportSpecifiers(s)), e.source = null, e.attributes = [], e.declaration = null, !0;
				}
				return !1;
			}
			maybeParseExportDeclaration(t) {
				return this.shouldParseExportDeclaration() ? (t.specifiers = [], t.source = null, t.attributes = [], t.declaration = this.parseExportDeclaration(t), !0) : !1;
			}
			isAsyncFunction() {
				if (!this.isContextual(95)) return !1;
				let t = this.nextTokenInLineStart();
				return this.isUnparsedContextual(t, "function");
			}
			parseExportDefaultExpression() {
				let t = this.startNode();
				if (this.match(68)) return this.next(), this.parseFunction(t, 5);
				if (this.isAsyncFunction()) return this.next(), this.next(), this.parseFunction(t, 13);
				if (this.match(80)) return this.parseClass(t, !0, !0);
				if (this.match(26)) return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === !0 && this.raise(p.DecoratorBeforeExport, this.state.startLoc), this.parseClass(this.maybeTakeDecorators(this.parseDecorators(!1), this.startNode()), !0, !0);
				if (this.match(75) || this.match(74) || this.isLet() || this.isUsing() || this.isAwaitUsing()) throw this.raise(p.UnsupportedDefaultExport, this.state.startLoc);
				let e = this.parseMaybeAssignAllowIn();
				return this.semicolon(), e;
			}
			parseExportDeclaration(t) {
				return this.match(80) ? this.parseClass(this.startNode(), !0, !1) : this.parseStatementListItem();
			}
			isExportDefaultSpecifier() {
				let { type: t } = this.state;
				if (w(t)) {
					if (t === 95 && !this.state.containsEsc || t === 100) return !1;
					if ((t === 130 || t === 129) && !this.state.containsEsc) {
						let i = this.nextTokenStart(), r = this.input.charCodeAt(i);
						if (r === 123 || this.chStartsBindingIdentifier(r, i) && !this.input.startsWith("from", i)) return this.expectOnePlugin(["flow", "typescript"]), !1;
					}
				} else if (!this.match(65)) return !1;
				let e = this.nextTokenStart(), s = this.isUnparsedContextual(e, "from");
				if (this.input.charCodeAt(e) === 44 || w(this.state.type) && s) return !0;
				if (this.match(65) && s) {
					let i = this.input.charCodeAt(this.nextTokenStartSince(e + 4));
					return i === 34 || i === 39;
				}
				return !1;
			}
			parseExportFrom(t, e) {
				this.eatContextual(98) ? (t.source = this.parseImportSource(), this.checkExport(t), this.maybeParseImportAttributes(t), this.checkJSONModuleImport(t)) : e && this.unexpected(), this.semicolon();
			}
			shouldParseExportDeclaration() {
				let { type: t } = this.state;
				return t === 26 && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators")) ? (this.getPluginOption("decorators", "decoratorsBeforeExport") === !0 && this.raise(p.DecoratorBeforeExport, this.state.startLoc), !0) : this.isUsing() ? (this.raise(p.UsingDeclarationExport, this.state.startLoc), !0) : this.isAwaitUsing() ? (this.raise(p.UsingDeclarationExport, this.state.startLoc), !0) : t === 74 || t === 75 || t === 68 || t === 80 || this.isLet() || this.isAsyncFunction();
			}
			checkExport(t, e, s, i) {
				if (e) {
					if (s) {
						if (this.checkDuplicateExports(t, "default"), this.hasPlugin("exportDefaultFrom")) {
							let r = t.declaration;
							r.type === "Identifier" && r.name === "from" && r.end - r.start === 4 && !r.extra?.parenthesized && this.raise(p.ExportDefaultFromAsIdentifier, r);
						}
					} else if (t.specifiers?.length) for (let r of t.specifiers) {
						let { exported: n } = r, o = n.type === "Identifier" ? n.name : n.value;
						if (this.checkDuplicateExports(r, o), !i && r.local) {
							let { local: h } = r;
							h.type !== "Identifier" ? this.raise(p.ExportBindingIsString, r, {
								localName: h.value,
								exportName: o
							}) : (this.checkReservedWord(h.name, h.loc.start, !0, !1), this.scope.checkLocalExport(h));
						}
					}
					else if (t.declaration) {
						let r = t.declaration;
						if (r.type === "FunctionDeclaration" || r.type === "ClassDeclaration") {
							let { id: n } = r;
							if (!n) throw new Error("Assertion failure");
							this.checkDuplicateExports(t, n.name);
						} else if (r.type === "VariableDeclaration") for (let n of r.declarations) this.checkDeclaration(n.id);
					}
				}
			}
			checkDeclaration(t) {
				if (t.type === "Identifier") this.checkDuplicateExports(t, t.name);
				else if (t.type === "ObjectPattern") for (let e of t.properties) this.checkDeclaration(e);
				else if (t.type === "ArrayPattern") for (let e of t.elements) e && this.checkDeclaration(e);
				else t.type === "ObjectProperty" ? this.checkDeclaration(t.value) : t.type === "RestElement" ? this.checkDeclaration(t.argument) : t.type === "AssignmentPattern" && this.checkDeclaration(t.left);
			}
			checkDuplicateExports(t, e) {
				this.exportedIdentifiers.has(e) && (e === "default" ? this.raise(p.DuplicateDefaultExport, t) : this.raise(p.DuplicateExport, t, { exportName: e })), this.exportedIdentifiers.add(e);
			}
			parseExportSpecifiers(t) {
				let e = [], s = !0;
				for (this.expect(5); !this.eat(8);) {
					if (s) s = !1;
					else if (this.expect(12), this.eat(8)) break;
					let i = this.isContextual(130), r = this.match(134), n = this.startNode();
					n.local = this.parseModuleExportName(), e.push(this.parseExportSpecifier(n, r, t, i));
				}
				return e;
			}
			parseExportSpecifier(t, e, s, i) {
				return this.eatContextual(93) ? t.exported = this.parseModuleExportName() : e ? t.exported = this.cloneStringLiteral(t.local) : t.exported || (t.exported = this.cloneIdentifier(t.local)), this.finishNode(t, "ExportSpecifier");
			}
			parseModuleExportName() {
				if (this.match(134)) {
					let t = this.parseStringLiteral(this.state.value), e = or.exec(t.value);
					return e && this.raise(p.ModuleExportNameHasLoneSurrogate, t, { surrogateCharCode: e[0].charCodeAt(0) }), t;
				}
				return this.parseIdentifier(!0);
			}
			isJSONModuleImport(t) {
				return t.assertions != null ? t.assertions.some(({ key: e, value: s }) => s.value === "json" && (e.type === "Identifier" ? e.name === "type" : e.value === "type")) : !1;
			}
			checkImportReflection(t) {
				let { specifiers: e } = t, s = e.length === 1 ? e[0].type : null;
				t.phase === "source" ? s !== "ImportDefaultSpecifier" && this.raise(p.SourcePhaseImportRequiresDefault, e[0].loc.start) : t.phase === "defer" ? s !== "ImportNamespaceSpecifier" && this.raise(p.DeferImportRequiresNamespace, e[0].loc.start) : t.module && (s !== "ImportDefaultSpecifier" && this.raise(p.ImportReflectionNotBinding, e[0].loc.start), t.assertions?.length > 0 && this.raise(p.ImportReflectionHasAssertion, e[0].loc.start));
			}
			checkJSONModuleImport(t) {
				if (this.isJSONModuleImport(t) && t.type !== "ExportAllDeclaration") {
					let { specifiers: e } = t;
					if (e != null) {
						let s = e.find((i) => {
							let r;
							if (i.type === "ExportSpecifier" ? r = i.local : i.type === "ImportSpecifier" && (r = i.imported), r !== void 0) return r.type === "Identifier" ? r.name !== "default" : r.value !== "default";
						});
						s !== void 0 && this.raise(p.ImportJSONBindingNotDefault, s.loc.start);
					}
				}
			}
			isPotentialImportPhase(t) {
				return t ? !1 : this.isContextual(105) || this.isContextual(97);
			}
			applyImportPhase(t, e, s, i) {
				e || (this.hasPlugin("importReflection") && (t.module = !1), s === "source" ? (this.expectPlugin("sourcePhaseImports", i), t.phase = "source") : s === "defer" ? (this.expectPlugin("deferredImportEvaluation", i), t.phase = "defer") : this.hasPlugin("sourcePhaseImports") && (t.phase = null));
			}
			parseMaybeImportPhase(t, e) {
				if (!this.isPotentialImportPhase(e)) return this.applyImportPhase(t, e, null), null;
				let s = this.startNode(), i = this.parseIdentifierName(!0), { type: r } = this.state;
				return (O(r) ? r !== 98 || this.lookaheadCharCode() === 102 : r !== 12) ? (this.applyImportPhase(t, e, i, s.loc.start), null) : (this.applyImportPhase(t, e, null), this.createIdentifier(s, i));
			}
			isPrecedingIdImportPhase(t) {
				let { type: e } = this.state;
				return w(e) ? e !== 98 || this.lookaheadCharCode() === 102 : e !== 12;
			}
			parseImport(t) {
				return this.match(134) ? this.parseImportSourceAndAttributes(t) : this.parseImportSpecifiersAndAfter(t, this.parseMaybeImportPhase(t, !1));
			}
			parseImportSpecifiersAndAfter(t, e) {
				t.specifiers = [];
				let i = !this.maybeParseDefaultImportSpecifier(t, e) || this.eat(12), r = i && this.maybeParseStarImportSpecifier(t);
				return i && !r && this.parseNamedImportSpecifiers(t), this.expectContextual(98), this.parseImportSourceAndAttributes(t);
			}
			parseImportSourceAndAttributes(t) {
				return t.specifiers ?? (t.specifiers = []), t.source = this.parseImportSource(), this.maybeParseImportAttributes(t), this.checkImportReflection(t), this.checkJSONModuleImport(t), this.semicolon(), this.sawUnambiguousESM = !0, this.finishNode(t, "ImportDeclaration");
			}
			parseImportSource() {
				return this.match(134) || this.unexpected(), this.parseExprAtom();
			}
			parseImportSpecifierLocal(t, e, s) {
				e.local = this.parseIdentifier(), t.specifiers.push(this.finishImportSpecifier(e, s));
			}
			finishImportSpecifier(t, e, s = 8201) {
				return this.checkLVal(t.local, { type: e }, s), this.finishNode(t, e);
			}
			parseImportAttributes() {
				this.expect(5);
				let t = [], e = /* @__PURE__ */ new Set();
				do {
					if (this.match(8)) break;
					let s = this.startNode(), i = this.state.value;
					if (e.has(i) && this.raise(p.ModuleAttributesWithDuplicateKeys, this.state.startLoc, { key: i }), e.add(i), this.match(134) ? s.key = this.parseStringLiteral(i) : s.key = this.parseIdentifier(!0), this.expect(14), !this.match(134)) throw this.raise(p.ModuleAttributeInvalidValue, this.state.startLoc);
					s.value = this.parseStringLiteral(this.state.value), t.push(this.finishNode(s, "ImportAttribute"));
				} while (this.eat(12));
				return this.expect(8), t;
			}
			parseModuleAttributes() {
				let t = [], e = /* @__PURE__ */ new Set();
				do {
					let s = this.startNode();
					if (s.key = this.parseIdentifier(!0), s.key.name !== "type" && this.raise(p.ModuleAttributeDifferentFromType, s.key), e.has(s.key.name) && this.raise(p.ModuleAttributesWithDuplicateKeys, s.key, { key: s.key.name }), e.add(s.key.name), this.expect(14), !this.match(134)) throw this.raise(p.ModuleAttributeInvalidValue, this.state.startLoc);
					s.value = this.parseStringLiteral(this.state.value), t.push(this.finishNode(s, "ImportAttribute"));
				} while (this.eat(12));
				return t;
			}
			maybeParseImportAttributes(t) {
				let e;
				if (this.match(76)) {
					if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40) return;
					this.next(), e = this.parseImportAttributes();
				} else this.isContextual(94) && !this.hasPrecedingLineBreak() ? (this.hasPlugin("deprecatedImportAssert") || this.raise(p.ImportAttributesUseAssert, this.state.startLoc), this.addExtra(t, "deprecatedAssertSyntax", !0), this.next(), e = this.parseImportAttributes()) : e = [];
				t.attributes = e;
			}
			maybeParseDefaultImportSpecifier(t, e) {
				if (e) {
					let s = this.startNodeAtNode(e);
					return s.local = e, t.specifiers.push(this.finishImportSpecifier(s, "ImportDefaultSpecifier")), !0;
				} else if (O(this.state.type)) return this.parseImportSpecifierLocal(t, this.startNode(), "ImportDefaultSpecifier"), !0;
				return !1;
			}
			maybeParseStarImportSpecifier(t) {
				if (this.match(55)) {
					let e = this.startNode();
					return this.next(), this.expectContextual(93), this.parseImportSpecifierLocal(t, e, "ImportNamespaceSpecifier"), !0;
				}
				return !1;
			}
			parseNamedImportSpecifiers(t) {
				let e = !0;
				for (this.expect(5); !this.eat(8);) {
					if (e) e = !1;
					else {
						if (this.eat(14)) throw this.raise(p.DestructureNamedImport, this.state.startLoc);
						if (this.expect(12), this.eat(8)) break;
					}
					let s = this.startNode(), i = this.match(134), r = this.isContextual(130);
					s.imported = this.parseModuleExportName();
					let n = this.parseImportSpecifier(s, i, t.importKind === "type" || t.importKind === "typeof", r, void 0);
					t.specifiers.push(n);
				}
			}
			parseImportSpecifier(t, e, s, i, r) {
				if (this.eatContextual(93)) t.local = this.parseIdentifier();
				else {
					let { imported: n } = t;
					if (e) throw this.raise(p.ImportBindingIsString, t, { importName: n.value });
					this.checkReservedWord(n.name, t.loc.start, !0, !0), t.local || (t.local = this.cloneIdentifier(n));
				}
				return this.finishImportSpecifier(t, "ImportSpecifier", r);
			}
			isThisParam(t) {
				return t.type === "Identifier" && t.name === "this";
			}
		}, Ee = class extends ft {
			constructor(t, e, s) {
				let i = oi(t);
				super(i, e), this.options = i, this.initializeScopes(), this.plugins = s, this.filename = i.sourceFilename, this.startIndex = i.startIndex;
				let r = 0;
				i.allowAwaitOutsideFunction && (r |= 1), i.allowReturnOutsideFunction && (r |= 2), i.allowImportExportEverywhere && (r |= 8), i.allowSuperOutsideMethod && (r |= 16), i.allowUndeclaredExports && (r |= 64), i.allowNewTargetOutsideFunction && (r |= 4), i.allowYieldOutsideFunction && (r |= 32), i.ranges && (r |= 128), i.tokens && (r |= 256), i.createImportExpressions && (r |= 512), i.createParenthesizedExpressions && (r |= 1024), i.errorRecovery && (r |= 2048), i.attachComment && (r |= 4096), i.annexB && (r |= 8192), this.optionFlags = r;
			}
			getScopeHandler() {
				return fe;
			}
			parse() {
				this.enterInitialScopes();
				let t = this.startNode(), e = this.startNode();
				this.nextToken(), t.errors = null;
				let s = this.parseTopLevel(t, e);
				return s.errors = this.state.errors, s.comments.length = this.state.commentsLen, s;
			}
		};
		function Ie(a, t) {
			if (t?.sourceType === "unambiguous") {
				t = Object.assign({}, t);
				try {
					t.sourceType = "module";
					let e = le(t, a), s = e.parse();
					if (e.sawUnambiguousESM) return s;
					if (e.ambiguousScriptDifferentAst) try {
						return t.sourceType = "script", le(t, a).parse();
					} catch {}
					else s.program.sourceType = "script";
					return s;
				} catch (e) {
					try {
						return t.sourceType = "script", le(t, a).parse();
					} catch {}
					throw e;
				}
			} else return le(t, a).parse();
		}
		function Ne(a, t) {
			let e = le(t, a);
			return e.options.strictMode && (e.state.strict = !0), e.getExpression();
		}
		function cr(a) {
			let t = {};
			for (let e of Object.keys(a)) t[e] = Xt(a[e]);
			return t;
		}
		cr(pi);
		function le(a, t) {
			let e = Ee, s = /* @__PURE__ */ new Map();
			if (a?.plugins) {
				for (let i of a.plugins) {
					let r, n;
					typeof i == "string" ? r = i : [r, n] = i, s.has(r) || s.set(r, n || {});
				}
				rr(s), e = lr(s);
			}
			return new e(a, t, s);
		}
		var Jt = /* @__PURE__ */ new Map();
		function lr(a) {
			let t = [];
			for (let i of ar) a.has(i) && t.push(i);
			let e = t.join("|"), s = Jt.get(e);
			if (!s) {
				s = Ee;
				for (let i of t) s = cs[i](s);
				Jt.set(e, s);
			}
			return s;
		}
		function ke(a) {
			return (t, e, s) => {
				let i = !!s?.backwards;
				if (e === !1) return !1;
				let { length: r } = t, n = e;
				for (; n >= 0 && n < r;) {
					let o = t.charAt(n);
					if (a instanceof RegExp) {
						if (!a.test(o)) return n;
					} else if (!a.includes(o)) return n;
					i ? n-- : n++;
				}
				return n === -1 || n === r ? n : !1;
			};
		}
		ke(/\s/u);
		var ls = ke(" 	");
		ke(",; 	");
		var ps = ke(/[^\n\r]/u);
		function pr(a, t) {
			if (t === !1) return !1;
			if (a.charAt(t) === "/" && a.charAt(t + 1) === "*") {
				for (let e = t + 2; e < a.length; ++e) if (a.charAt(e) === "*" && a.charAt(e + 1) === "/") return e + 2;
			}
			return t;
		}
		var us = pr;
		var fs = (a) => a === `
` || a === "\r" || a === "\u2028" || a === "\u2029";
		function ur(a, t, e) {
			let s = !!e?.backwards;
			if (t === !1) return !1;
			let i = a.charAt(t);
			if (s) {
				if (a.charAt(t - 1) === "\r" && i === `
`) return t - 2;
				if (fs(i)) return t - 1;
			} else {
				if (i === "\r" && a.charAt(t + 1) === `
`) return t + 2;
				if (fs(i)) return t + 1;
			}
			return t;
		}
		var ds = ur;
		function fr(a, t) {
			return t === !1 ? !1 : a.charAt(t) === "/" && a.charAt(t + 1) === "/" ? ps(a, t) : t;
		}
		var ms = fr;
		function dr(a, t) {
			let e = null, s = t;
			for (; s !== e;) e = s, s = ls(a, s), s = us(a, s), s = ms(a, s), s = ds(a, s);
			return s;
		}
		var ys = dr;
		function xs(a) {
			let t = [];
			for (let e of a) try {
				return e();
			} catch (s) {
				t.push(s);
			}
			throw Object.assign(/* @__PURE__ */ new Error("All combinations failed"), { errors: t });
		}
		function mr(a) {
			if (!a.startsWith("#!")) return "";
			let t = a.indexOf(`
`);
			return t === -1 ? a : a.slice(0, t);
		}
		var ve = mr;
		var ee = (a, t) => (e, s, ...i) => e | 1 && s == null ? void 0 : (t.call(s) ?? s[a]).apply(s, i);
		var yr = Array.prototype.findLast ?? function(a) {
			for (let t = this.length - 1; t >= 0; t--) {
				let e = this[t];
				if (a(e, t, this)) return e;
			}
		}, Ps = ee("findLast", function() {
			if (Array.isArray(this)) return yr;
		});
		function Pr(a) {
			return this[a < 0 ? this.length + a : a];
		}
		var gs = ee("at", function() {
			if (Array.isArray(this) || typeof this == "string") return Pr;
		});
		function M(a) {
			let t = a.range?.[0] ?? a.start, e = (a.declaration?.decorators ?? a.decorators)?.[0];
			return e ? Math.min(M(e), t) : t;
		}
		function L(a) {
			return a.range?.[1] ?? a.end;
		}
		function Tr(a) {
			let t = new Set(a);
			return (e) => t.has(e?.type);
		}
		var te = Tr;
		var se = te([
			"Block",
			"CommentBlock",
			"MultiLine"
		]);
		var Ts = te([
			"Line",
			"CommentLine",
			"SingleLine",
			"HashbangComment",
			"HTMLOpen",
			"HTMLClose",
			"Hashbang",
			"InterpreterDirective"
		]);
		var wt = /* @__PURE__ */ new WeakMap();
		function Sr(a) {
			return wt.has(a) || wt.set(a, se(a) && a.value[0] === "*" && /@(?:type|satisfies)\b/u.test(a.value)), wt.get(a);
		}
		var bs = Sr;
		function wr(a) {
			if (!se(a)) return !1;
			let t = `*${a.value}*`.split(`
`);
			return t.length > 1 && t.every((e) => e.trimStart()[0] === "*");
		}
		var Ct = /* @__PURE__ */ new WeakMap();
		function Cr(a) {
			return Ct.has(a) || Ct.set(a, wr(a)), Ct.get(a);
		}
		var Et = Cr;
		function Er(a) {
			if (a.length < 2) return;
			let t;
			for (let e = a.length - 1; e >= 0; e--) {
				let s = a[e];
				if (t && L(s) === M(t) && Et(s) && Et(t) && (a.splice(e + 1, 1), s.value += "*//*" + t.value, s.range = [M(s), L(t)]), !Ts(s) && !se(s)) throw new TypeError(`Unknown comment type: "${s.type}".`);
				t = s;
			}
		}
		var As = Er;
		function Ir(a) {
			return a !== null && typeof a == "object";
		}
		var Ss = Ir;
		var me = null;
		function ye(a) {
			if (me !== null && typeof me.property) {
				let t = me;
				return me = ye.prototype = null, t;
			}
			return me = ye.prototype = a ?? Object.create(null), new ye();
		}
		var Nr = 10;
		for (let a = 0; a <= Nr; a++) ye();
		function It(a) {
			return ye(a);
		}
		function kr(a, t = "type") {
			It(a);
			function e(s) {
				let i = s[t], r = a[i];
				if (!Array.isArray(r)) throw Object.assign(/* @__PURE__ */ new Error(`Missing visitor keys for '${i}'.`), { node: s });
				return r;
			}
			return e;
		}
		var ws = kr;
		var c = [
			[
				"decorators",
				"key",
				"typeAnnotation",
				"value"
			],
			[],
			["elementType"],
			["expression"],
			["expression", "typeAnnotation"],
			["left", "right"],
			["argument"],
			["directives", "body"],
			["label"],
			[
				"callee",
				"typeArguments",
				"arguments"
			],
			["body"],
			[
				"decorators",
				"id",
				"typeParameters",
				"superClass",
				"superTypeArguments",
				"mixins",
				"implements",
				"body",
				"superTypeParameters"
			],
			["id", "typeParameters"],
			[
				"decorators",
				"key",
				"typeParameters",
				"params",
				"returnType",
				"body"
			],
			[
				"decorators",
				"variance",
				"key",
				"typeAnnotation",
				"value"
			],
			["name", "typeAnnotation"],
			[
				"test",
				"consequent",
				"alternate"
			],
			[
				"checkType",
				"extendsType",
				"trueType",
				"falseType"
			],
			["value"],
			["id", "body"],
			[
				"declaration",
				"specifiers",
				"source",
				"attributes"
			],
			["id"],
			[
				"id",
				"typeParameters",
				"extends",
				"body"
			],
			["typeAnnotation"],
			[
				"id",
				"typeParameters",
				"right"
			],
			["body", "test"],
			["members"],
			["id", "init"],
			["exported"],
			[
				"left",
				"right",
				"body"
			],
			[
				"id",
				"typeParameters",
				"params",
				"predicate",
				"returnType",
				"body"
			],
			[
				"id",
				"params",
				"body",
				"typeParameters",
				"returnType"
			],
			["key", "value"],
			["local"],
			["objectType", "indexType"],
			["typeParameter"],
			["types"],
			["node"],
			["object", "property"],
			["argument", "cases"],
			[
				"pattern",
				"body",
				"guard"
			],
			["literal"],
			[
				"decorators",
				"key",
				"value"
			],
			["expressions"],
			["qualification", "id"],
			[
				"decorators",
				"key",
				"typeAnnotation"
			],
			[
				"typeParameters",
				"params",
				"returnType"
			],
			["expression", "typeArguments"],
			["params"],
			["parameterName", "typeAnnotation"]
		];
		var Es = ws({
			AccessorProperty: c[0],
			AnyTypeAnnotation: c[1],
			ArgumentPlaceholder: c[1],
			ArrayExpression: ["elements"],
			ArrayPattern: [
				"elements",
				"typeAnnotation",
				"decorators"
			],
			ArrayTypeAnnotation: c[2],
			ArrowFunctionExpression: [
				"typeParameters",
				"params",
				"predicate",
				"returnType",
				"body"
			],
			AsConstExpression: c[3],
			AsExpression: c[4],
			AssignmentExpression: c[5],
			AssignmentPattern: [
				"left",
				"right",
				"decorators",
				"typeAnnotation"
			],
			AwaitExpression: c[6],
			BigIntLiteral: c[1],
			BigIntLiteralTypeAnnotation: c[1],
			BigIntTypeAnnotation: c[1],
			BinaryExpression: c[5],
			BindExpression: ["object", "callee"],
			BlockStatement: c[7],
			BooleanLiteral: c[1],
			BooleanLiteralTypeAnnotation: c[1],
			BooleanTypeAnnotation: c[1],
			BreakStatement: c[8],
			CallExpression: c[9],
			CatchClause: ["param", "body"],
			ChainExpression: c[3],
			ClassAccessorProperty: c[0],
			ClassBody: c[10],
			ClassDeclaration: c[11],
			ClassExpression: c[11],
			ClassImplements: c[12],
			ClassMethod: c[13],
			ClassPrivateMethod: c[13],
			ClassPrivateProperty: c[14],
			ClassProperty: c[14],
			ComponentDeclaration: [
				"id",
				"params",
				"body",
				"typeParameters",
				"rendersType"
			],
			ComponentParameter: ["name", "local"],
			ComponentTypeAnnotation: [
				"params",
				"rest",
				"typeParameters",
				"rendersType"
			],
			ComponentTypeParameter: c[15],
			ConditionalExpression: c[16],
			ConditionalTypeAnnotation: c[17],
			ContinueStatement: c[8],
			DebuggerStatement: c[1],
			DeclareClass: [
				"id",
				"typeParameters",
				"extends",
				"mixins",
				"implements",
				"body"
			],
			DeclareComponent: [
				"id",
				"params",
				"rest",
				"typeParameters",
				"rendersType"
			],
			DeclaredPredicate: c[18],
			DeclareEnum: c[19],
			DeclareExportAllDeclaration: ["source", "attributes"],
			DeclareExportDeclaration: c[20],
			DeclareFunction: ["id", "predicate"],
			DeclareHook: c[21],
			DeclareInterface: c[22],
			DeclareModule: c[19],
			DeclareModuleExports: c[23],
			DeclareNamespace: c[19],
			DeclareOpaqueType: [
				"id",
				"typeParameters",
				"supertype",
				"lowerBound",
				"upperBound"
			],
			DeclareTypeAlias: c[24],
			DeclareVariable: c[21],
			Decorator: c[3],
			Directive: c[18],
			DirectiveLiteral: c[1],
			DoExpression: c[10],
			DoWhileStatement: c[25],
			EmptyStatement: c[1],
			EmptyTypeAnnotation: c[1],
			EnumBigIntBody: c[26],
			EnumBigIntMember: c[27],
			EnumBooleanBody: c[26],
			EnumBooleanMember: c[27],
			EnumDeclaration: c[19],
			EnumDefaultedMember: c[21],
			EnumNumberBody: c[26],
			EnumNumberMember: c[27],
			EnumStringBody: c[26],
			EnumStringMember: c[27],
			EnumSymbolBody: c[26],
			ExistsTypeAnnotation: c[1],
			ExperimentalRestProperty: c[6],
			ExperimentalSpreadProperty: c[6],
			ExportAllDeclaration: [
				"source",
				"attributes",
				"exported"
			],
			ExportDefaultDeclaration: ["declaration"],
			ExportDefaultSpecifier: c[28],
			ExportNamedDeclaration: c[20],
			ExportNamespaceSpecifier: c[28],
			ExportSpecifier: ["local", "exported"],
			ExpressionStatement: c[3],
			File: ["program"],
			ForInStatement: c[29],
			ForOfStatement: c[29],
			ForStatement: [
				"init",
				"test",
				"update",
				"body"
			],
			FunctionDeclaration: c[30],
			FunctionExpression: c[30],
			FunctionTypeAnnotation: [
				"typeParameters",
				"this",
				"params",
				"rest",
				"returnType"
			],
			FunctionTypeParam: c[15],
			GenericTypeAnnotation: c[12],
			HookDeclaration: c[31],
			HookTypeAnnotation: [
				"params",
				"returnType",
				"rest",
				"typeParameters"
			],
			Identifier: ["typeAnnotation", "decorators"],
			IfStatement: c[16],
			ImportAttribute: c[32],
			ImportDeclaration: [
				"specifiers",
				"source",
				"attributes"
			],
			ImportDefaultSpecifier: c[33],
			ImportExpression: ["source", "options"],
			ImportNamespaceSpecifier: c[33],
			ImportSpecifier: ["imported", "local"],
			IndexedAccessType: c[34],
			InferredPredicate: c[1],
			InferTypeAnnotation: c[35],
			InterfaceDeclaration: c[22],
			InterfaceExtends: c[12],
			InterfaceTypeAnnotation: ["extends", "body"],
			InterpreterDirective: c[1],
			IntersectionTypeAnnotation: c[36],
			JsExpressionRoot: c[37],
			JsonRoot: c[37],
			JSXAttribute: ["name", "value"],
			JSXClosingElement: ["name"],
			JSXClosingFragment: c[1],
			JSXElement: [
				"openingElement",
				"children",
				"closingElement"
			],
			JSXEmptyExpression: c[1],
			JSXExpressionContainer: c[3],
			JSXFragment: [
				"openingFragment",
				"children",
				"closingFragment"
			],
			JSXIdentifier: c[1],
			JSXMemberExpression: c[38],
			JSXNamespacedName: ["namespace", "name"],
			JSXOpeningElement: [
				"name",
				"typeArguments",
				"attributes"
			],
			JSXOpeningFragment: c[1],
			JSXSpreadAttribute: c[6],
			JSXSpreadChild: c[3],
			JSXText: c[1],
			KeyofTypeAnnotation: c[6],
			LabeledStatement: ["label", "body"],
			Literal: c[1],
			LogicalExpression: c[5],
			MatchArrayPattern: ["elements", "rest"],
			MatchAsPattern: ["pattern", "target"],
			MatchBindingPattern: c[21],
			MatchExpression: c[39],
			MatchExpressionCase: c[40],
			MatchIdentifierPattern: c[21],
			MatchLiteralPattern: c[41],
			MatchMemberPattern: ["base", "property"],
			MatchObjectPattern: ["properties", "rest"],
			MatchObjectPatternProperty: ["key", "pattern"],
			MatchOrPattern: ["patterns"],
			MatchRestPattern: c[6],
			MatchStatement: c[39],
			MatchStatementCase: c[40],
			MatchUnaryPattern: c[6],
			MatchWildcardPattern: c[1],
			MemberExpression: c[38],
			MetaProperty: ["meta", "property"],
			MethodDefinition: c[42],
			MixedTypeAnnotation: c[1],
			ModuleExpression: c[10],
			NeverTypeAnnotation: c[1],
			NewExpression: c[9],
			NGChainedExpression: c[43],
			NGEmptyExpression: c[1],
			NGMicrosyntax: c[10],
			NGMicrosyntaxAs: ["key", "alias"],
			NGMicrosyntaxExpression: ["expression", "alias"],
			NGMicrosyntaxKey: c[1],
			NGMicrosyntaxKeyedExpression: ["key", "expression"],
			NGMicrosyntaxLet: c[32],
			NGPipeExpression: [
				"left",
				"right",
				"arguments"
			],
			NGRoot: c[37],
			NullableTypeAnnotation: c[23],
			NullLiteral: c[1],
			NullLiteralTypeAnnotation: c[1],
			NumberLiteralTypeAnnotation: c[1],
			NumberTypeAnnotation: c[1],
			NumericLiteral: c[1],
			ObjectExpression: ["properties"],
			ObjectMethod: c[13],
			ObjectPattern: [
				"decorators",
				"properties",
				"typeAnnotation"
			],
			ObjectProperty: c[42],
			ObjectTypeAnnotation: [
				"properties",
				"indexers",
				"callProperties",
				"internalSlots"
			],
			ObjectTypeCallProperty: c[18],
			ObjectTypeIndexer: [
				"variance",
				"id",
				"key",
				"value"
			],
			ObjectTypeInternalSlot: ["id", "value"],
			ObjectTypeMappedTypeProperty: [
				"keyTparam",
				"propType",
				"sourceType",
				"variance"
			],
			ObjectTypeProperty: [
				"key",
				"value",
				"variance"
			],
			ObjectTypeSpreadProperty: c[6],
			OpaqueType: [
				"id",
				"typeParameters",
				"supertype",
				"impltype",
				"lowerBound",
				"upperBound"
			],
			OptionalCallExpression: c[9],
			OptionalIndexedAccessType: c[34],
			OptionalMemberExpression: c[38],
			ParenthesizedExpression: c[3],
			PipelineBareFunction: ["callee"],
			PipelinePrimaryTopicReference: c[1],
			PipelineTopicExpression: c[3],
			Placeholder: c[1],
			PrivateIdentifier: c[1],
			PrivateName: c[21],
			Program: c[7],
			Property: c[32],
			PropertyDefinition: c[14],
			QualifiedTypeIdentifier: c[44],
			QualifiedTypeofIdentifier: c[44],
			RegExpLiteral: c[1],
			RestElement: [
				"argument",
				"typeAnnotation",
				"decorators"
			],
			ReturnStatement: c[6],
			SatisfiesExpression: c[4],
			SequenceExpression: c[43],
			SpreadElement: c[6],
			StaticBlock: c[10],
			StringLiteral: c[1],
			StringLiteralTypeAnnotation: c[1],
			StringTypeAnnotation: c[1],
			Super: c[1],
			SwitchCase: ["test", "consequent"],
			SwitchStatement: ["discriminant", "cases"],
			SymbolTypeAnnotation: c[1],
			TaggedTemplateExpression: [
				"tag",
				"typeArguments",
				"quasi"
			],
			TemplateElement: c[1],
			TemplateLiteral: ["quasis", "expressions"],
			ThisExpression: c[1],
			ThisTypeAnnotation: c[1],
			ThrowStatement: c[6],
			TopicReference: c[1],
			TryStatement: [
				"block",
				"handler",
				"finalizer"
			],
			TSAbstractAccessorProperty: c[45],
			TSAbstractKeyword: c[1],
			TSAbstractMethodDefinition: c[32],
			TSAbstractPropertyDefinition: c[45],
			TSAnyKeyword: c[1],
			TSArrayType: c[2],
			TSAsExpression: c[4],
			TSAsyncKeyword: c[1],
			TSBigIntKeyword: c[1],
			TSBooleanKeyword: c[1],
			TSCallSignatureDeclaration: c[46],
			TSClassImplements: c[47],
			TSConditionalType: c[17],
			TSConstructorType: c[46],
			TSConstructSignatureDeclaration: c[46],
			TSDeclareFunction: c[31],
			TSDeclareKeyword: c[1],
			TSDeclareMethod: [
				"decorators",
				"key",
				"typeParameters",
				"params",
				"returnType"
			],
			TSEmptyBodyFunctionExpression: [
				"id",
				"typeParameters",
				"params",
				"returnType"
			],
			TSEnumBody: c[26],
			TSEnumDeclaration: c[19],
			TSEnumMember: ["id", "initializer"],
			TSExportAssignment: c[3],
			TSExportKeyword: c[1],
			TSExternalModuleReference: c[3],
			TSFunctionType: c[46],
			TSImportEqualsDeclaration: ["id", "moduleReference"],
			TSImportType: [
				"options",
				"qualifier",
				"typeArguments",
				"source"
			],
			TSIndexedAccessType: c[34],
			TSIndexSignature: ["parameters", "typeAnnotation"],
			TSInferType: c[35],
			TSInstantiationExpression: c[47],
			TSInterfaceBody: c[10],
			TSInterfaceDeclaration: c[22],
			TSInterfaceHeritage: c[47],
			TSIntersectionType: c[36],
			TSIntrinsicKeyword: c[1],
			TSJSDocAllType: c[1],
			TSJSDocNonNullableType: c[23],
			TSJSDocNullableType: c[23],
			TSJSDocUnknownType: c[1],
			TSLiteralType: c[41],
			TSMappedType: [
				"key",
				"constraint",
				"nameType",
				"typeAnnotation"
			],
			TSMethodSignature: [
				"key",
				"typeParameters",
				"params",
				"returnType"
			],
			TSModuleBlock: c[10],
			TSModuleDeclaration: c[19],
			TSNamedTupleMember: ["label", "elementType"],
			TSNamespaceExportDeclaration: c[21],
			TSNeverKeyword: c[1],
			TSNonNullExpression: c[3],
			TSNullKeyword: c[1],
			TSNumberKeyword: c[1],
			TSObjectKeyword: c[1],
			TSOptionalType: c[23],
			TSParameterProperty: ["parameter", "decorators"],
			TSParenthesizedType: c[23],
			TSPrivateKeyword: c[1],
			TSPropertySignature: ["key", "typeAnnotation"],
			TSProtectedKeyword: c[1],
			TSPublicKeyword: c[1],
			TSQualifiedName: c[5],
			TSReadonlyKeyword: c[1],
			TSRestType: c[23],
			TSSatisfiesExpression: c[4],
			TSStaticKeyword: c[1],
			TSStringKeyword: c[1],
			TSSymbolKeyword: c[1],
			TSTemplateLiteralType: ["quasis", "types"],
			TSThisType: c[1],
			TSTupleType: ["elementTypes"],
			TSTypeAliasDeclaration: [
				"id",
				"typeParameters",
				"typeAnnotation"
			],
			TSTypeAnnotation: c[23],
			TSTypeAssertion: c[4],
			TSTypeLiteral: c[26],
			TSTypeOperator: c[23],
			TSTypeParameter: [
				"name",
				"constraint",
				"default"
			],
			TSTypeParameterDeclaration: c[48],
			TSTypeParameterInstantiation: c[48],
			TSTypePredicate: c[49],
			TSTypeQuery: ["exprName", "typeArguments"],
			TSTypeReference: ["typeName", "typeArguments"],
			TSUndefinedKeyword: c[1],
			TSUnionType: c[36],
			TSUnknownKeyword: c[1],
			TSVoidKeyword: c[1],
			TupleTypeAnnotation: ["types", "elementTypes"],
			TupleTypeLabeledElement: [
				"label",
				"elementType",
				"variance"
			],
			TupleTypeSpreadElement: ["label", "typeAnnotation"],
			TypeAlias: c[24],
			TypeAnnotation: c[23],
			TypeCastExpression: c[4],
			TypeofTypeAnnotation: ["argument", "typeArguments"],
			TypeOperator: c[23],
			TypeParameter: [
				"bound",
				"default",
				"variance"
			],
			TypeParameterDeclaration: c[48],
			TypeParameterInstantiation: c[48],
			TypePredicate: c[49],
			UnaryExpression: c[6],
			UndefinedTypeAnnotation: c[1],
			UnionTypeAnnotation: c[36],
			UnknownTypeAnnotation: c[1],
			UpdateExpression: c[6],
			V8IntrinsicIdentifier: c[1],
			VariableDeclaration: ["declarations"],
			VariableDeclarator: c[27],
			Variance: c[1],
			VoidPattern: c[1],
			VoidTypeAnnotation: c[1],
			WhileStatement: c[25],
			WithStatement: ["object", "body"],
			YieldExpression: c[6]
		});
		function Le(a, t) {
			if (!Ss(a)) return a;
			if (Array.isArray(a)) {
				for (let s = 0; s < a.length; s++) a[s] = Le(a[s], t);
				return a;
			}
			if (t.onEnter) {
				let s = t.onEnter(a) ?? a;
				if (s !== a) return Le(s, t);
				a = s;
			}
			let e = Es(a);
			for (let s = 0; s < e.length; s++) a[e[s]] = Le(a[e[s]], t);
			return t.onLeave && (a = t.onLeave(a) || a), a;
		}
		var Is = Le;
		te([
			"RegExpLiteral",
			"BigIntLiteral",
			"NumericLiteral",
			"StringLiteral",
			"DirectiveLiteral",
			"Literal",
			"JSXText",
			"TemplateElement",
			"StringLiteralTypeAnnotation",
			"NumberLiteralTypeAnnotation",
			"BigIntLiteralTypeAnnotation"
		]);
		function Lr(a, t) {
			let { parser: e, text: s } = t, { comments: i } = a, r = e === "oxc" && t.oxcAstType === "ts";
			As(i);
			let n = a.type === "File" ? a.program : a;
			n.interpreter && (i.unshift(n.interpreter), delete n.interpreter), r && a.hashbang && (i.unshift(a.hashbang), delete a.hashbang), a.type === "Program" && (a.range = [0, s.length]);
			let o;
			return a = Is(a, {
				onEnter(h) {
					switch (h.type) {
						case "ParenthesizedExpression": {
							let { expression: l } = h, u = M(h);
							if (l.type === "TypeCastExpression") return l.range = [u, L(h)], l;
							let f = !1;
							if (!r) {
								if (!o) {
									o = [];
									for (let x of i) bs(x) && o.push(L(x));
								}
								let d = Ps(0, o, (x) => x <= u);
								f = d && s.slice(d, u).trim().length === 0;
							}
							return f ? void 0 : (l.extra = {
								...l.extra,
								parenthesized: !0
							}, l);
						}
						case "TemplateLiteral":
							if (h.expressions.length !== h.quasis.length - 1) throw new Error("Malformed template literal.");
							break;
						case "TemplateElement":
							if (e === "flow" || e === "hermes" || e === "espree" || e === "typescript" || r) h.range = [M(h) + 1, L(h) - (h.tail ? 1 : 2)];
							break;
						case "VariableDeclaration": {
							let l = gs(0, h.declarations, -1);
							l?.init && s[L(l)] !== ";" && (h.range = [M(h), L(l)]);
							break;
						}
						case "TSParenthesizedType": return h.typeAnnotation;
						case "TopicReference":
							a.extra = {
								...a.extra,
								__isUsingHackPipeline: !0
							};
							break;
						case "TSUnionType":
						case "TSIntersectionType":
							if (h.types.length === 1) return h.types[0];
							break;
						case "ImportExpression":
							e === "hermes" && h.attributes && !h.options && (h.options = h.attributes);
							break;
					}
				},
				onLeave(h) {
					switch (h.type) {
						case "LogicalExpression":
							if (Ns(h)) return Nt(h);
							break;
						case "TSImportType":
							!h.source && h.argument.type === "TSLiteralType" && (h.source = h.argument.literal, delete h.argument);
							break;
					}
				}
			}), a;
		}
		function Ns(a) {
			return a.type === "LogicalExpression" && a.right.type === "LogicalExpression" && a.operator === a.right.operator;
		}
		function Nt(a) {
			return Ns(a) ? Nt({
				type: "LogicalExpression",
				operator: a.operator,
				left: Nt({
					type: "LogicalExpression",
					operator: a.operator,
					left: a.left,
					right: a.right.left,
					range: [M(a.left), L(a.right.left)]
				}),
				right: a.right.right,
				range: [M(a), L(a)]
			}) : a;
		}
		var ks = Lr;
		function Dr(a, t) {
			let e = /* @__PURE__ */ new SyntaxError(a + " (" + t.loc.start.line + ":" + t.loc.start.column + ")");
			return Object.assign(e, t);
		}
		var De = Dr;
		var vs = "Unexpected parseExpression() input: ";
		function Mr(a) {
			let { message: t, loc: e, reasonCode: s } = a;
			if (!e) return a;
			let { line: i, column: r } = e, n = a;
			(s === "MissingPlugin" || s === "MissingOneOfPlugins") && (t = "Unexpected token.", n = void 0);
			let o = ` (${i}:${r})`;
			return t.endsWith(o) && (t = t.slice(0, -o.length)), t.startsWith(vs) && (t = t.slice(vs.length)), De(t, {
				loc: { start: {
					line: i,
					column: r + 1
				} },
				cause: n
			});
		}
		var Me = Mr;
		var Or = String.prototype.replaceAll ?? function(a, t) {
			return a.global ? this.replace(a, t) : this.split(a).join(t);
		}, xe = ee("replaceAll", function() {
			if (typeof this == "string") return Or;
		});
		var Br = /\*\/$/, Rr = /^\/\*\*?/, Ur = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, _r = /(^|\s+)\/\/([^\n\r]*)/g, Ls = /^(\r?\n)+/, jr = /(?:^|\r?\n) *(@[^\n\r]*?) *\r?\n *(?![^\n\r@]*\/\/[^]*)([^\s@][^\n\r@]+?) *\r?\n/g, Ds = /(?:^|\r?\n) *@(\S+) *([^\n\r]*)/g, Vr = /(\r?\n|^) *\* ?/g, zr = [];
		function Ms(a) {
			let t = a.match(Ur);
			return t ? t[0].trimStart() : "";
		}
		function Os(a) {
			a = xe(0, a.replace(Rr, "").replace(Br, ""), Vr, "$1");
			let e = "";
			for (; e !== a;) e = a, a = xe(0, a, jr, `
$1 $2
`);
			a = a.replace(Ls, "").trimEnd();
			let s = Object.create(null), i = xe(0, a, Ds, "").replace(Ls, "").trimEnd(), r;
			for (; r = Ds.exec(a);) {
				let n = xe(0, r[2], _r, "");
				if (typeof s[r[1]] == "string" || Array.isArray(s[r[1]])) {
					let o = s[r[1]];
					s[r[1]] = [
						...zr,
						...Array.isArray(o) ? o : [o],
						n
					];
				} else s[r[1]] = n;
			}
			return {
				comments: i,
				pragmas: s
			};
		}
		var Fs = ["noformat", "noprettier"], Bs = ["format", "prettier"];
		function Rs(a) {
			let t = ve(a);
			t && (a = a.slice(t.length + 1));
			let { pragmas: s, comments: i } = Os(Ms(a));
			return {
				shebang: t,
				text: a,
				pragmas: s,
				comments: i
			};
		}
		function Us(a) {
			let { pragmas: t } = Rs(a);
			return Bs.some((e) => Object.prototype.hasOwnProperty.call(t, e));
		}
		function _s(a) {
			let { pragmas: t } = Rs(a);
			return Fs.some((e) => Object.prototype.hasOwnProperty.call(t, e));
		}
		function qr(a) {
			return a = typeof a == "function" ? { parse: a } : a, {
				astFormat: "estree",
				hasPragma: Us,
				hasIgnorePragma: _s,
				locStart: M,
				locEnd: L,
				...a
			};
		}
		var H = qr;
		var Oe = "module";
		var kt = "commonjs";
		function js(a) {
			if (typeof a == "string") {
				if (a = a.toLowerCase(), /\.(?:mjs|mts)$/iu.test(a)) return Oe;
				if (/\.(?:cjs|cts)$/iu.test(a)) return kt;
			}
		}
		function $r(a, t) {
			let { type: e = "JsExpressionRoot", rootMarker: s, text: i } = t, { tokens: r, comments: n } = a;
			return delete a.tokens, delete a.comments, {
				tokens: r,
				comments: n,
				type: e,
				node: a,
				range: [0, i.length],
				rootMarker: s
			};
		}
		var Fe = $r;
		var ie = (a) => H(Gr(a)), Kr = {
			sourceType: Oe,
			allowImportExportEverywhere: !0,
			allowReturnOutsideFunction: !0,
			allowNewTargetOutsideFunction: !0,
			allowSuperOutsideMethod: !0,
			allowUndeclaredExports: !0,
			errorRecovery: !0,
			createParenthesizedExpressions: !0,
			attachComment: !1,
			plugins: [
				"doExpressions",
				"exportDefaultFrom",
				"functionBind",
				"functionSent",
				"throwExpressions",
				"partialApplication",
				"decorators",
				"moduleBlocks",
				"asyncDoExpressions",
				"destructuringPrivate",
				"decoratorAutoAccessors",
				"sourcePhaseImports",
				"deferredImportEvaluation",
				["optionalChainingAssign", { version: "2023-07" }],
				["discardBinding", { syntaxType: "void" }]
			],
			tokens: !1,
			ranges: !1
		}, Vs = "v8intrinsic", zs = [["pipelineOperator", {
			proposal: "hack",
			topicToken: "%"
		}], ["pipelineOperator", { proposal: "fsharp" }]], _ = (a, t = Kr) => ({
			...t,
			plugins: [...t.plugins, ...a]
		}), Hr = /@(?:no)?flow\b/u;
		function Wr(a, t) {
			if (t?.endsWith(".js.flow")) return !0;
			let e = ve(a);
			e && (a = a.slice(e.length));
			let s = ys(a, 0);
			return s !== !1 && (a = a.slice(0, s)), Hr.test(a);
		}
		function Jr(a, t, e) {
			let s = a(t, e), i = s.errors.find((r) => !Xr.has(r.reasonCode));
			if (i) throw i;
			return s;
		}
		function Gr({ isExpression: a = !1, optionsCombinations: t }) {
			return (e, s = {}) => {
				let { filepath: i } = s;
				if (typeof i != "string" && (i = void 0), (s.parser === "babel" || s.parser === "__babel_estree") && Wr(e, i)) return s.parser = "babel-flow", $s.parse(e, s);
				let r = t, n = s.__babelSourceType ?? js(i);
				n && n !== Oe && (r = r.map((u) => ({
					...u,
					sourceType: n,
					...n === kt ? {
						allowReturnOutsideFunction: void 0,
						allowNewTargetOutsideFunction: void 0
					} : void 0
				})));
				let o = /%[A-Z]/u.test(e);
				e.includes("|>") ? r = (o ? [...zs, Vs] : zs).flatMap((f) => r.map((d) => _([f], d))) : o && (r = r.map((u) => _([Vs], u)));
				let h = a ? Ne : Ie, l;
				try {
					l = xs(r.map((u) => () => Jr(h, e, u)));
				} catch ({ errors: [u] }) {
					throw Me(u);
				}
				return a && (l = Fe(l, {
					text: e,
					rootMarker: s.rootMarker
				})), ks(l, { text: e });
			};
		}
		var Xr = new Set([
			"StrictNumericEscape",
			"StrictWith",
			"StrictOctalLiteral",
			"StrictDelete",
			"StrictEvalArguments",
			"StrictEvalArgumentsBinding",
			"StrictFunction",
			"ForInOfLoopInitializer",
			"ConstructorHasTypeParameters",
			"UnsupportedParameterPropertyKind",
			"DecoratorExportClass",
			"ParamDupe",
			"InvalidDecimal",
			"RestTrailingComma",
			"UnsupportedParameterDecorator",
			"UnterminatedJsxContent",
			"UnexpectedReservedWord",
			"ModuleAttributesWithDuplicateKeys",
			"InvalidEscapeSequenceTemplate",
			"NonAbstractClassHasAbstractMethod",
			"OptionalTypeBeforeRequired",
			"PatternIsOptional",
			"DeclareClassFieldHasInitializer",
			"TypeImportCannotSpecifyDefaultAndNamed",
			"VarRedeclaration",
			"InvalidPrivateFieldResolution",
			"DuplicateExport",
			"ImportAttributesUseAssert",
			"DeclarationMissingInitializer"
		]), qs = [_(["jsx"])], Yr = ie({ optionsCombinations: qs }), Qr = ie({ optionsCombinations: [_(["jsx", "typescript"]), _(["typescript"])] }), Zr = ie({
			isExpression: !0,
			optionsCombinations: [_(["jsx"])]
		}), ea = ie({
			isExpression: !0,
			optionsCombinations: [_(["typescript"])]
		}), $s = ie({ optionsCombinations: [_([
			"jsx",
			["flow", { all: !0 }],
			"flowComments"
		])] }), ta = ie({ optionsCombinations: qs.map((a) => _(["estree"], a)) });
		var Dt = {};
		Ue(Dt, {
			json: () => ra,
			"json-stringify": () => oa,
			json5: () => aa,
			jsonc: () => na
		});
		function sa(a) {
			return Array.isArray(a) && a.length > 0;
		}
		var Lt = sa;
		var Ks = {
			tokens: !1,
			ranges: !1,
			attachComment: !1,
			createParenthesizedExpressions: !0
		};
		function ia(a) {
			let t = Ie(a, Ks), { program: e } = t;
			if (e.body.length === 0 && e.directives.length === 0 && !e.interpreter) return t;
		}
		function Be(a, t = {}) {
			let { allowComments: e = !0, allowEmpty: s = !1 } = t, i;
			try {
				i = Ne(a, Ks);
			} catch (r) {
				if (s && r.code === "BABEL_PARSER_SYNTAX_ERROR" && r.reasonCode === "ParseExpressionEmptyInput") try {
					i = ia(a);
				} catch {}
				if (!i) throw Me(r);
			}
			if (!e && Lt(i.comments)) throw q(i.comments[0], "Comment");
			return i = Fe(i, {
				type: "JsonRoot",
				text: a
			}), i.node.type === "File" ? delete i.node : re(i.node), i;
		}
		function q(a, t) {
			let [e, s] = [a.loc.start, a.loc.end].map(({ line: i, column: r }) => ({
				line: i,
				column: r + 1
			}));
			return De(`${t} is not allowed in JSON.`, { loc: {
				start: e,
				end: s
			} });
		}
		function re(a) {
			switch (a.type) {
				case "ArrayExpression":
					for (let t of a.elements) t !== null && re(t);
					return;
				case "ObjectExpression":
					for (let t of a.properties) re(t);
					return;
				case "ObjectProperty":
					if (a.computed) throw q(a.key, "Computed key");
					if (a.shorthand) throw q(a.key, "Shorthand property");
					a.key.type !== "Identifier" && re(a.key), re(a.value);
					return;
				case "UnaryExpression": {
					let { operator: t, argument: e } = a;
					if (t !== "+" && t !== "-") throw q(a, `Operator '${a.operator}'`);
					if (e.type === "NumericLiteral" || e.type === "Identifier" && (e.name === "Infinity" || e.name === "NaN")) return;
					throw q(e, `Operator '${t}' before '${e.type}'`);
				}
				case "Identifier":
					if (a.name !== "Infinity" && a.name !== "NaN" && a.name !== "undefined") throw q(a, `Identifier '${a.name}'`);
					return;
				case "TemplateLiteral":
					if (Lt(a.expressions)) throw q(a.expressions[0], "'TemplateLiteral' with expression");
					for (let t of a.quasis) re(t);
					return;
				case "NullLiteral":
				case "BooleanLiteral":
				case "NumericLiteral":
				case "StringLiteral":
				case "TemplateElement": return;
				default: throw q(a, `'${a.type}'`);
			}
		}
		var ra = H({
			parse: (a) => Be(a),
			hasPragma: () => !0,
			hasIgnorePragma: () => !1
		}), aa = H((a) => Be(a)), na = H((a) => Be(a, { allowEmpty: !0 })), oa = H({
			parse: (a) => Be(a, { allowComments: !1 }),
			astFormat: "estree-json"
		});
		var ha = {
			...vt,
			...Dt
		};
		return Xs(ca);
	});
}));

//#endregion
//#region node_modules/prettier/doc.js
var require_doc = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	(function(factory) {
		function interopModuleDefault() {
			var module$1 = factory();
			return module$1.default || module$1;
		}
		if (typeof exports === "object" && typeof module === "object") module.exports = interopModuleDefault();
		else if (typeof define === "function" && define.amd) define(interopModuleDefault);
		else {
			var root = typeof globalThis !== "undefined" ? globalThis : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : this || {};
			root.doc = interopModuleDefault();
		}
	})(function() {
		"use strict";
		var __defProp = Object.defineProperty;
		var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
		var __getOwnPropNames = Object.getOwnPropertyNames;
		var __hasOwnProp = Object.prototype.hasOwnProperty;
		var __export = (target, all) => {
			for (var name in all) __defProp(target, name, {
				get: all[name],
				enumerable: true
			});
		};
		var __copyProps = (to, from, except, desc) => {
			if (from && typeof from === "object" || typeof from === "function") {
				for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
					get: () => from[key],
					enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
				});
			}
			return to;
		};
		var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
		var public_exports = {};
		__export(public_exports, {
			builders: () => builders,
			printer: () => printer,
			utils: () => utils
		});
		var OPTIONAL_OBJECT = 1;
		var createMethodShim = (methodName, getImplementation) => (flags, object, ...arguments_) => {
			if (flags | OPTIONAL_OBJECT && (object === void 0 || object === null)) return;
			return (getImplementation.call(object) ?? object[methodName]).apply(object, arguments_);
		};
		function stringOrArrayAt(index) {
			return this[index < 0 ? this.length + index : index];
		}
		var method_at_default = createMethodShim("at", function() {
			if (Array.isArray(this) || typeof this === "string") return stringOrArrayAt;
		});
		var noop = () => {};
		var noop_default = noop;
		var DOC_TYPE_STRING = "string";
		var DOC_TYPE_ARRAY = "array";
		var DOC_TYPE_CURSOR = "cursor";
		var DOC_TYPE_INDENT = "indent";
		var DOC_TYPE_ALIGN = "align";
		var DOC_TYPE_TRIM = "trim";
		var DOC_TYPE_GROUP = "group";
		var DOC_TYPE_FILL = "fill";
		var DOC_TYPE_IF_BREAK = "if-break";
		var DOC_TYPE_INDENT_IF_BREAK = "indent-if-break";
		var DOC_TYPE_LINE_SUFFIX = "line-suffix";
		var DOC_TYPE_LINE_SUFFIX_BOUNDARY = "line-suffix-boundary";
		var DOC_TYPE_LINE = "line";
		var DOC_TYPE_LABEL = "label";
		var DOC_TYPE_BREAK_PARENT = "break-parent";
		var VALID_OBJECT_DOC_TYPES = /* @__PURE__ */ new Set([
			DOC_TYPE_CURSOR,
			DOC_TYPE_INDENT,
			DOC_TYPE_ALIGN,
			DOC_TYPE_TRIM,
			DOC_TYPE_GROUP,
			DOC_TYPE_FILL,
			DOC_TYPE_IF_BREAK,
			DOC_TYPE_INDENT_IF_BREAK,
			DOC_TYPE_LINE_SUFFIX,
			DOC_TYPE_LINE_SUFFIX_BOUNDARY,
			DOC_TYPE_LINE,
			DOC_TYPE_LABEL,
			DOC_TYPE_BREAK_PARENT
		]);
		function trimNewlinesEnd(string) {
			let end = string.length;
			while (end > 0 && (string[end - 1] === "\r" || string[end - 1] === "\n")) end--;
			return end < string.length ? string.slice(0, end) : string;
		}
		function getDocType(doc) {
			if (typeof doc === "string") return DOC_TYPE_STRING;
			if (Array.isArray(doc)) return DOC_TYPE_ARRAY;
			if (!doc) return;
			const { type } = doc;
			if (VALID_OBJECT_DOC_TYPES.has(type)) return type;
		}
		var get_doc_type_default = getDocType;
		var disjunctionListFormat = (list) => new Intl.ListFormat("en-US", { type: "disjunction" }).format(list);
		function getDocErrorMessage(doc) {
			const type = doc === null ? "null" : typeof doc;
			if (type !== "string" && type !== "object") return `Unexpected doc '${type}', 
Expected it to be 'string' or 'object'.`;
			if (get_doc_type_default(doc)) throw new Error("doc is valid.");
			const objectType = Object.prototype.toString.call(doc);
			if (objectType !== "[object Object]") return `Unexpected doc '${objectType}'.`;
			const EXPECTED_TYPE_VALUES = disjunctionListFormat([...VALID_OBJECT_DOC_TYPES].map((type2) => `'${type2}'`));
			return `Unexpected doc.type '${doc.type}'.
Expected it to be ${EXPECTED_TYPE_VALUES}.`;
		}
		var InvalidDocError = class extends Error {
			name = "InvalidDocError";
			constructor(doc) {
				super(getDocErrorMessage(doc));
				this.doc = doc;
			}
		};
		var invalid_doc_error_default = InvalidDocError;
		var traverseDocOnExitStackMarker = {};
		function traverseDoc(doc, onEnter, onExit, shouldTraverseConditionalGroups) {
			const docsStack = [doc];
			while (docsStack.length > 0) {
				const doc2 = docsStack.pop();
				if (doc2 === traverseDocOnExitStackMarker) {
					onExit(docsStack.pop());
					continue;
				}
				if (onExit) docsStack.push(doc2, traverseDocOnExitStackMarker);
				const docType = get_doc_type_default(doc2);
				if (!docType) throw new invalid_doc_error_default(doc2);
				if (onEnter?.(doc2) === false) continue;
				switch (docType) {
					case DOC_TYPE_ARRAY:
					case DOC_TYPE_FILL: {
						const parts = docType === DOC_TYPE_ARRAY ? doc2 : doc2.parts;
						for (let i = parts.length - 1; i >= 0; --i) docsStack.push(parts[i]);
						break;
					}
					case DOC_TYPE_IF_BREAK:
						docsStack.push(doc2.flatContents, doc2.breakContents);
						break;
					case DOC_TYPE_GROUP:
						if (shouldTraverseConditionalGroups && doc2.expandedStates) for (let i = doc2.expandedStates.length - 1; i >= 0; --i) docsStack.push(doc2.expandedStates[i]);
						else docsStack.push(doc2.contents);
						break;
					case DOC_TYPE_ALIGN:
					case DOC_TYPE_INDENT:
					case DOC_TYPE_INDENT_IF_BREAK:
					case DOC_TYPE_LABEL:
					case DOC_TYPE_LINE_SUFFIX:
						docsStack.push(doc2.contents);
						break;
					case DOC_TYPE_STRING:
					case DOC_TYPE_CURSOR:
					case DOC_TYPE_TRIM:
					case DOC_TYPE_LINE_SUFFIX_BOUNDARY:
					case DOC_TYPE_LINE:
					case DOC_TYPE_BREAK_PARENT: break;
					default: throw new invalid_doc_error_default(doc2);
				}
			}
		}
		var traverse_doc_default = traverseDoc;
		function mapDoc(doc, cb) {
			if (typeof doc === "string") return cb(doc);
			const mapped = /* @__PURE__ */ new Map();
			return rec(doc);
			function rec(doc2) {
				if (mapped.has(doc2)) return mapped.get(doc2);
				const result = process2(doc2);
				mapped.set(doc2, result);
				return result;
			}
			function process2(doc2) {
				switch (get_doc_type_default(doc2)) {
					case DOC_TYPE_ARRAY: return cb(doc2.map(rec));
					case DOC_TYPE_FILL: return cb({
						...doc2,
						parts: doc2.parts.map(rec)
					});
					case DOC_TYPE_IF_BREAK: return cb({
						...doc2,
						breakContents: rec(doc2.breakContents),
						flatContents: rec(doc2.flatContents)
					});
					case DOC_TYPE_GROUP: {
						let { expandedStates, contents } = doc2;
						if (expandedStates) {
							expandedStates = expandedStates.map(rec);
							contents = expandedStates[0];
						} else contents = rec(contents);
						return cb({
							...doc2,
							contents,
							expandedStates
						});
					}
					case DOC_TYPE_ALIGN:
					case DOC_TYPE_INDENT:
					case DOC_TYPE_INDENT_IF_BREAK:
					case DOC_TYPE_LABEL:
					case DOC_TYPE_LINE_SUFFIX: return cb({
						...doc2,
						contents: rec(doc2.contents)
					});
					case DOC_TYPE_STRING:
					case DOC_TYPE_CURSOR:
					case DOC_TYPE_TRIM:
					case DOC_TYPE_LINE_SUFFIX_BOUNDARY:
					case DOC_TYPE_LINE:
					case DOC_TYPE_BREAK_PARENT: return cb(doc2);
					default: throw new invalid_doc_error_default(doc2);
				}
			}
		}
		function findInDoc(doc, fn, defaultValue) {
			let result = defaultValue;
			let shouldSkipFurtherProcessing = false;
			function findInDocOnEnterFn(doc2) {
				if (shouldSkipFurtherProcessing) return false;
				const maybeResult = fn(doc2);
				if (maybeResult !== void 0) {
					shouldSkipFurtherProcessing = true;
					result = maybeResult;
				}
			}
			traverse_doc_default(doc, findInDocOnEnterFn);
			return result;
		}
		function willBreakFn(doc) {
			if (doc.type === DOC_TYPE_GROUP && doc.break) return true;
			if (doc.type === DOC_TYPE_LINE && doc.hard) return true;
			if (doc.type === DOC_TYPE_BREAK_PARENT) return true;
		}
		function willBreak(doc) {
			return findInDoc(doc, willBreakFn, false);
		}
		function breakParentGroup(groupStack) {
			if (groupStack.length > 0) {
				const parentGroup = method_at_default(0, groupStack, -1);
				if (!parentGroup.expandedStates && !parentGroup.break) parentGroup.break = "propagated";
			}
			return null;
		}
		function propagateBreaks(doc) {
			const alreadyVisitedSet = /* @__PURE__ */ new Set();
			const groupStack = [];
			function propagateBreaksOnEnterFn(doc2) {
				if (doc2.type === DOC_TYPE_BREAK_PARENT) breakParentGroup(groupStack);
				if (doc2.type === DOC_TYPE_GROUP) {
					groupStack.push(doc2);
					if (alreadyVisitedSet.has(doc2)) return false;
					alreadyVisitedSet.add(doc2);
				}
			}
			function propagateBreaksOnExitFn(doc2) {
				if (doc2.type === DOC_TYPE_GROUP) {
					if (groupStack.pop().break) breakParentGroup(groupStack);
				}
			}
			traverse_doc_default(doc, propagateBreaksOnEnterFn, propagateBreaksOnExitFn, true);
		}
		function removeLinesFn(doc) {
			if (doc.type === DOC_TYPE_LINE && !doc.hard) return doc.soft ? "" : " ";
			if (doc.type === DOC_TYPE_IF_BREAK) return doc.flatContents;
			return doc;
		}
		function removeLines(doc) {
			return mapDoc(doc, removeLinesFn);
		}
		function stripTrailingHardlineFromParts(parts) {
			parts = [...parts];
			while (parts.length >= 2 && method_at_default(0, parts, -2).type === DOC_TYPE_LINE && method_at_default(0, parts, -1).type === DOC_TYPE_BREAK_PARENT) parts.length -= 2;
			if (parts.length > 0) {
				const lastPart = stripTrailingHardlineFromDoc(method_at_default(0, parts, -1));
				parts[parts.length - 1] = lastPart;
			}
			return parts;
		}
		function stripTrailingHardlineFromDoc(doc) {
			switch (get_doc_type_default(doc)) {
				case DOC_TYPE_INDENT:
				case DOC_TYPE_INDENT_IF_BREAK:
				case DOC_TYPE_GROUP:
				case DOC_TYPE_LINE_SUFFIX:
				case DOC_TYPE_LABEL: {
					const contents = stripTrailingHardlineFromDoc(doc.contents);
					return {
						...doc,
						contents
					};
				}
				case DOC_TYPE_IF_BREAK: return {
					...doc,
					breakContents: stripTrailingHardlineFromDoc(doc.breakContents),
					flatContents: stripTrailingHardlineFromDoc(doc.flatContents)
				};
				case DOC_TYPE_FILL: return {
					...doc,
					parts: stripTrailingHardlineFromParts(doc.parts)
				};
				case DOC_TYPE_ARRAY: return stripTrailingHardlineFromParts(doc);
				case DOC_TYPE_STRING: return trimNewlinesEnd(doc);
				case DOC_TYPE_ALIGN:
				case DOC_TYPE_CURSOR:
				case DOC_TYPE_TRIM:
				case DOC_TYPE_LINE_SUFFIX_BOUNDARY:
				case DOC_TYPE_LINE:
				case DOC_TYPE_BREAK_PARENT: break;
				default: throw new invalid_doc_error_default(doc);
			}
			return doc;
		}
		function stripTrailingHardline(doc) {
			return stripTrailingHardlineFromDoc(cleanDoc(doc));
		}
		function cleanDocFn(doc) {
			switch (get_doc_type_default(doc)) {
				case DOC_TYPE_FILL:
					if (doc.parts.every((part) => part === "")) return "";
					break;
				case DOC_TYPE_GROUP:
					if (!doc.contents && !doc.id && !doc.break && !doc.expandedStates) return "";
					if (doc.contents.type === DOC_TYPE_GROUP && doc.contents.id === doc.id && doc.contents.break === doc.break && doc.contents.expandedStates === doc.expandedStates) return doc.contents;
					break;
				case DOC_TYPE_ALIGN:
				case DOC_TYPE_INDENT:
				case DOC_TYPE_INDENT_IF_BREAK:
				case DOC_TYPE_LINE_SUFFIX:
					if (!doc.contents) return "";
					break;
				case DOC_TYPE_IF_BREAK:
					if (!doc.flatContents && !doc.breakContents) return "";
					break;
				case DOC_TYPE_ARRAY: {
					const parts = [];
					for (const part of doc) {
						if (!part) continue;
						const [currentPart, ...restParts] = Array.isArray(part) ? part : [part];
						if (typeof currentPart === "string" && typeof method_at_default(0, parts, -1) === "string") parts[parts.length - 1] += currentPart;
						else parts.push(currentPart);
						parts.push(...restParts);
					}
					if (parts.length === 0) return "";
					if (parts.length === 1) return parts[0];
					return parts;
				}
				case DOC_TYPE_STRING:
				case DOC_TYPE_CURSOR:
				case DOC_TYPE_TRIM:
				case DOC_TYPE_LINE_SUFFIX_BOUNDARY:
				case DOC_TYPE_LINE:
				case DOC_TYPE_LABEL:
				case DOC_TYPE_BREAK_PARENT: break;
				default: throw new invalid_doc_error_default(doc);
			}
			return doc;
		}
		function cleanDoc(doc) {
			return mapDoc(doc, (currentDoc) => cleanDocFn(currentDoc));
		}
		function replaceEndOfLine(doc, replacement = literalline) {
			return mapDoc(doc, (currentDoc) => typeof currentDoc === "string" ? join(replacement, currentDoc.split("\n")) : currentDoc);
		}
		function canBreakFn(doc) {
			if (doc.type === DOC_TYPE_LINE) return true;
		}
		function canBreak(doc) {
			return findInDoc(doc, canBreakFn, false);
		}
		var assertDoc = noop_default;
		var assertDocArray = noop_default;
		var assertDocFillParts = noop_default;
		var assertAlignType = noop_default;
		function indent(contents) {
			assertDoc(contents);
			return {
				type: DOC_TYPE_INDENT,
				contents
			};
		}
		function align(alignType, contents) {
			assertAlignType(alignType);
			assertDoc(contents);
			return {
				type: DOC_TYPE_ALIGN,
				contents,
				n: alignType
			};
		}
		function dedentToRoot(contents) {
			return align(Number.NEGATIVE_INFINITY, contents);
		}
		function markAsRoot(contents) {
			return align({ type: "root" }, contents);
		}
		function dedent(contents) {
			return align(-1, contents);
		}
		function addAlignmentToDoc(doc, size, tabWidth) {
			assertDoc(doc);
			let aligned = doc;
			if (size > 0) {
				for (let level = 0; level < Math.floor(size / tabWidth); ++level) aligned = indent(aligned);
				aligned = align(size % tabWidth, aligned);
				aligned = align(Number.NEGATIVE_INFINITY, aligned);
			}
			return aligned;
		}
		var breakParent = { type: DOC_TYPE_BREAK_PARENT };
		var cursor = { type: DOC_TYPE_CURSOR };
		function fill(parts) {
			assertDocFillParts(parts);
			return {
				type: DOC_TYPE_FILL,
				parts
			};
		}
		function group(contents, options = {}) {
			assertDoc(contents);
			assertDocArray(options.expandedStates, true);
			return {
				type: DOC_TYPE_GROUP,
				id: options.id,
				contents,
				break: Boolean(options.shouldBreak),
				expandedStates: options.expandedStates
			};
		}
		function conditionalGroup(states, options) {
			return group(states[0], {
				...options,
				expandedStates: states
			});
		}
		function ifBreak(breakContents, flatContents = "", options = {}) {
			assertDoc(breakContents);
			if (flatContents !== "") assertDoc(flatContents);
			return {
				type: DOC_TYPE_IF_BREAK,
				breakContents,
				flatContents,
				groupId: options.groupId
			};
		}
		function indentIfBreak(contents, options) {
			assertDoc(contents);
			return {
				type: DOC_TYPE_INDENT_IF_BREAK,
				contents,
				groupId: options.groupId,
				negate: options.negate
			};
		}
		function join(separator, docs) {
			assertDoc(separator);
			assertDocArray(docs);
			const parts = [];
			for (let i = 0; i < docs.length; i++) {
				if (i !== 0) parts.push(separator);
				parts.push(docs[i]);
			}
			return parts;
		}
		function label(label2, contents) {
			assertDoc(contents);
			return label2 ? {
				type: DOC_TYPE_LABEL,
				label: label2,
				contents
			} : contents;
		}
		var line = { type: DOC_TYPE_LINE };
		var softline = {
			type: DOC_TYPE_LINE,
			soft: true
		};
		var hardlineWithoutBreakParent = {
			type: DOC_TYPE_LINE,
			hard: true
		};
		var hardline = [hardlineWithoutBreakParent, breakParent];
		var literallineWithoutBreakParent = {
			type: DOC_TYPE_LINE,
			hard: true,
			literal: true
		};
		var literalline = [literallineWithoutBreakParent, breakParent];
		function lineSuffix(contents) {
			assertDoc(contents);
			return {
				type: DOC_TYPE_LINE_SUFFIX,
				contents
			};
		}
		var lineSuffixBoundary = { type: DOC_TYPE_LINE_SUFFIX_BOUNDARY };
		var trim = { type: DOC_TYPE_TRIM };
		var stringReplaceAll = String.prototype.replaceAll ?? function(pattern, replacement) {
			if (pattern.global) return this.replace(pattern, replacement);
			return this.split(pattern).join(replacement);
		};
		var method_replace_all_default = createMethodShim("replaceAll", function() {
			if (typeof this === "string") return stringReplaceAll;
		});
		var OPTION_CR = "cr";
		var OPTION_CRLF = "crlf";
		var CHARACTER_CR = "\r";
		var CHARACTER_CRLF = "\r\n";
		var DEFAULT_EOL = "\n";
		function convertEndOfLineOptionToCharacter(endOfLineOption) {
			return endOfLineOption === OPTION_CR ? CHARACTER_CR : endOfLineOption === OPTION_CRLF ? CHARACTER_CRLF : DEFAULT_EOL;
		}
		var emoji_regex_default = () => {
			return /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E-\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED8\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFC-\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFB-\uDFFE])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFB-\uDFFE])))?))?|\uDD75(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3C-\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE8A\uDE8E-\uDEC2\uDEC6\uDEC8\uDECD-\uDEDC\uDEDF-\uDEEA\uDEEF]|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
		};
		function isFullWidth(x) {
			return x === 12288 || x >= 65281 && x <= 65376 || x >= 65504 && x <= 65510;
		}
		function isWide(x) {
			return x >= 4352 && x <= 4447 || x === 8986 || x === 8987 || x === 9001 || x === 9002 || x >= 9193 && x <= 9196 || x === 9200 || x === 9203 || x === 9725 || x === 9726 || x === 9748 || x === 9749 || x >= 9776 && x <= 9783 || x >= 9800 && x <= 9811 || x === 9855 || x >= 9866 && x <= 9871 || x === 9875 || x === 9889 || x === 9898 || x === 9899 || x === 9917 || x === 9918 || x === 9924 || x === 9925 || x === 9934 || x === 9940 || x === 9962 || x === 9970 || x === 9971 || x === 9973 || x === 9978 || x === 9981 || x === 9989 || x === 9994 || x === 9995 || x === 10024 || x === 10060 || x === 10062 || x >= 10067 && x <= 10069 || x === 10071 || x >= 10133 && x <= 10135 || x === 10160 || x === 10175 || x === 11035 || x === 11036 || x === 11088 || x === 11093 || x >= 11904 && x <= 11929 || x >= 11931 && x <= 12019 || x >= 12032 && x <= 12245 || x >= 12272 && x <= 12287 || x >= 12289 && x <= 12350 || x >= 12353 && x <= 12438 || x >= 12441 && x <= 12543 || x >= 12549 && x <= 12591 || x >= 12593 && x <= 12686 || x >= 12688 && x <= 12773 || x >= 12783 && x <= 12830 || x >= 12832 && x <= 12871 || x >= 12880 && x <= 42124 || x >= 42128 && x <= 42182 || x >= 43360 && x <= 43388 || x >= 44032 && x <= 55203 || x >= 63744 && x <= 64255 || x >= 65040 && x <= 65049 || x >= 65072 && x <= 65106 || x >= 65108 && x <= 65126 || x >= 65128 && x <= 65131 || x >= 94176 && x <= 94180 || x >= 94192 && x <= 94198 || x >= 94208 && x <= 101589 || x >= 101631 && x <= 101662 || x >= 101760 && x <= 101874 || x >= 110576 && x <= 110579 || x >= 110581 && x <= 110587 || x === 110589 || x === 110590 || x >= 110592 && x <= 110882 || x === 110898 || x >= 110928 && x <= 110930 || x === 110933 || x >= 110948 && x <= 110951 || x >= 110960 && x <= 111355 || x >= 119552 && x <= 119638 || x >= 119648 && x <= 119670 || x === 126980 || x === 127183 || x === 127374 || x >= 127377 && x <= 127386 || x >= 127488 && x <= 127490 || x >= 127504 && x <= 127547 || x >= 127552 && x <= 127560 || x === 127568 || x === 127569 || x >= 127584 && x <= 127589 || x >= 127744 && x <= 127776 || x >= 127789 && x <= 127797 || x >= 127799 && x <= 127868 || x >= 127870 && x <= 127891 || x >= 127904 && x <= 127946 || x >= 127951 && x <= 127955 || x >= 127968 && x <= 127984 || x === 127988 || x >= 127992 && x <= 128062 || x === 128064 || x >= 128066 && x <= 128252 || x >= 128255 && x <= 128317 || x >= 128331 && x <= 128334 || x >= 128336 && x <= 128359 || x === 128378 || x === 128405 || x === 128406 || x === 128420 || x >= 128507 && x <= 128591 || x >= 128640 && x <= 128709 || x === 128716 || x >= 128720 && x <= 128722 || x >= 128725 && x <= 128728 || x >= 128732 && x <= 128735 || x === 128747 || x === 128748 || x >= 128756 && x <= 128764 || x >= 128992 && x <= 129003 || x === 129008 || x >= 129292 && x <= 129338 || x >= 129340 && x <= 129349 || x >= 129351 && x <= 129535 || x >= 129648 && x <= 129660 || x >= 129664 && x <= 129674 || x >= 129678 && x <= 129734 || x === 129736 || x >= 129741 && x <= 129756 || x >= 129759 && x <= 129770 || x >= 129775 && x <= 129784 || x >= 131072 && x <= 196605 || x >= 196608 && x <= 262141;
		}
		var narrow_emojis_evaluate_default = "©®‼⁉™ℹ↔↕↖↗↘↙↩↪⌨⏏⏱⏲⏸⏹⏺▪▫▶◀◻◼☀☁☂☃☄☎☑☘☝☠☢☣☦☪☮☯☸☹☺♀♂♟♠♣♥♦♨♻♾⚒⚔⚕⚖⚗⚙⚛⚜⚠⚧⚰⚱⛈⛏⛑⛓⛩⛱⛷⛸⛹✂✈✉✌✍✏✒✔✖✝✡✳✴❄❇❣❤➡⤴⤵⬅⬆⬇";
		var notAsciiRegex = /[^\x20-\x7F]/u;
		var narrowEmojisSet = new Set(narrow_emojis_evaluate_default);
		function getStringWidth(text) {
			if (!text) return 0;
			if (!notAsciiRegex.test(text)) return text.length;
			text = text.replace(emoji_regex_default(), (match) => narrowEmojisSet.has(match) ? " " : "  ");
			let width = 0;
			for (const character of text) {
				const codePoint = character.codePointAt(0);
				if (codePoint <= 31 || codePoint >= 127 && codePoint <= 159) continue;
				if (codePoint >= 768 && codePoint <= 879) continue;
				if (codePoint >= 65024 && codePoint <= 65039) continue;
				width += isFullWidth(codePoint) || isWide(codePoint) ? 2 : 1;
			}
			return width;
		}
		var get_string_width_default = getStringWidth;
		var INDENT_COMMAND_TYPE_INDENT = 0;
		var INDENT_COMMAND_TYPE_DEDENT = 1;
		var INDENT_COMMAND_TYPE_WIDTH = 2;
		var INDENT_COMMAND_TYPE_STRING = 3;
		var INDENT_COMMAND_INDENT = { type: INDENT_COMMAND_TYPE_INDENT };
		var INDENT_COMMAND_DEDENT = { type: INDENT_COMMAND_TYPE_DEDENT };
		var ROOT_INDENT = {
			value: "",
			length: 0,
			queue: [],
			get root() {
				return ROOT_INDENT;
			}
		};
		function generateIndent(indent2, command, options) {
			const queue = command.type === INDENT_COMMAND_TYPE_DEDENT ? indent2.queue.slice(0, -1) : [...indent2.queue, command];
			let value = "";
			let length = 0;
			let lastTabs = 0;
			let lastSpaces = 0;
			for (const command2 of queue) switch (command2.type) {
				case INDENT_COMMAND_TYPE_INDENT:
					flush();
					if (options.useTabs) addTabs(1);
					else addSpaces(options.tabWidth);
					break;
				case INDENT_COMMAND_TYPE_STRING: {
					const { string } = command2;
					flush();
					value += string;
					length += string.length;
					break;
				}
				case INDENT_COMMAND_TYPE_WIDTH: {
					const { width } = command2;
					lastTabs += 1;
					lastSpaces += width;
					break;
				}
				default: throw new Error(`Unexpected indent comment '${command2.type}'.`);
			}
			flushSpaces();
			return {
				...indent2,
				value,
				length,
				queue
			};
			function addTabs(count) {
				value += "	".repeat(count);
				length += options.tabWidth * count;
			}
			function addSpaces(count) {
				value += " ".repeat(count);
				length += count;
			}
			function flush() {
				if (options.useTabs) flushTabs();
				else flushSpaces();
			}
			function flushTabs() {
				if (lastTabs > 0) addTabs(lastTabs);
				resetLast();
			}
			function flushSpaces() {
				if (lastSpaces > 0) addSpaces(lastSpaces);
				resetLast();
			}
			function resetLast() {
				lastTabs = 0;
				lastSpaces = 0;
			}
		}
		function makeAlign(indent2, indentOptions, options) {
			if (!indentOptions) return indent2;
			if (indentOptions.type === "root") return {
				...indent2,
				root: indent2
			};
			if (indentOptions === Number.NEGATIVE_INFINITY) return indent2.root;
			let command;
			if (typeof indentOptions === "number") if (indentOptions < 0) command = INDENT_COMMAND_DEDENT;
			else command = {
				type: INDENT_COMMAND_TYPE_WIDTH,
				width: indentOptions
			};
			else command = {
				type: INDENT_COMMAND_TYPE_STRING,
				string: indentOptions
			};
			return generateIndent(indent2, command, options);
		}
		function makeIndent(indent2, options) {
			return generateIndent(indent2, INDENT_COMMAND_INDENT, options);
		}
		function getTrailingIndentionLength(text) {
			let length = 0;
			for (let index = text.length - 1; index >= 0; index--) {
				const character = text[index];
				if (character === " " || character === "	") length++;
				else break;
			}
			return length;
		}
		function trimIndentation(text) {
			const length = getTrailingIndentionLength(text);
			return {
				text: length === 0 ? text : text.slice(0, text.length - length),
				count: length
			};
		}
		var MODE_BREAK = Symbol("MODE_BREAK");
		var MODE_FLAT = Symbol("MODE_FLAT");
		var DOC_FILL_PRINTED_LENGTH = Symbol("DOC_FILL_PRINTED_LENGTH");
		function fits(next, restCommands, remainingWidth, hasLineSuffix, groupModeMap, mustBeFlat) {
			if (remainingWidth === Number.POSITIVE_INFINITY) return true;
			let restCommandsIndex = restCommands.length;
			let hasPendingSpace = false;
			const commands = [next];
			let output = "";
			while (remainingWidth >= 0) {
				if (commands.length === 0) {
					if (restCommandsIndex === 0) return true;
					commands.push(restCommands[--restCommandsIndex]);
					continue;
				}
				const { mode, doc } = commands.pop();
				const docType = get_doc_type_default(doc);
				switch (docType) {
					case DOC_TYPE_STRING:
						if (doc) {
							if (hasPendingSpace) {
								output += " ";
								remainingWidth -= 1;
								hasPendingSpace = false;
							}
							output += doc;
							remainingWidth -= get_string_width_default(doc);
						}
						break;
					case DOC_TYPE_ARRAY:
					case DOC_TYPE_FILL: {
						const parts = docType === DOC_TYPE_ARRAY ? doc : doc.parts;
						const end = doc[DOC_FILL_PRINTED_LENGTH] ?? 0;
						for (let index = parts.length - 1; index >= end; index--) commands.push({
							mode,
							doc: parts[index]
						});
						break;
					}
					case DOC_TYPE_INDENT:
					case DOC_TYPE_ALIGN:
					case DOC_TYPE_INDENT_IF_BREAK:
					case DOC_TYPE_LABEL:
						commands.push({
							mode,
							doc: doc.contents
						});
						break;
					case DOC_TYPE_TRIM: {
						const { text, count } = trimIndentation(output);
						output = text;
						remainingWidth += count;
						break;
					}
					case DOC_TYPE_GROUP: {
						if (mustBeFlat && doc.break) return false;
						const groupMode = doc.break ? MODE_BREAK : mode;
						const contents = doc.expandedStates && groupMode === MODE_BREAK ? method_at_default(0, doc.expandedStates, -1) : doc.contents;
						commands.push({
							mode: groupMode,
							doc: contents
						});
						break;
					}
					case DOC_TYPE_IF_BREAK: {
						const contents = (doc.groupId ? groupModeMap[doc.groupId] || MODE_FLAT : mode) === MODE_BREAK ? doc.breakContents : doc.flatContents;
						if (contents) commands.push({
							mode,
							doc: contents
						});
						break;
					}
					case DOC_TYPE_LINE:
						if (mode === MODE_BREAK || doc.hard) return true;
						if (!doc.soft) hasPendingSpace = true;
						break;
					case DOC_TYPE_LINE_SUFFIX:
						hasLineSuffix = true;
						break;
					case DOC_TYPE_LINE_SUFFIX_BOUNDARY:
						if (hasLineSuffix) return false;
						break;
				}
			}
			return false;
		}
		function printDocToString(doc, options) {
			const groupModeMap = /* @__PURE__ */ Object.create(null);
			const width = options.printWidth;
			const newLine = convertEndOfLineOptionToCharacter(options.endOfLine);
			let position = 0;
			const commands = [{
				indent: ROOT_INDENT,
				mode: MODE_BREAK,
				doc
			}];
			let output = "";
			let shouldRemeasure = false;
			const lineSuffix2 = [];
			const cursorPositions = [];
			const settledOutput = [];
			const settledCursorPositions = [];
			let settledTextLength = 0;
			propagateBreaks(doc);
			while (commands.length > 0) {
				const { indent: indent2, mode, doc: doc2 } = commands.pop();
				switch (get_doc_type_default(doc2)) {
					case DOC_TYPE_STRING: {
						const formatted2 = newLine !== "\n" ? method_replace_all_default(0, doc2, "\n", newLine) : doc2;
						if (formatted2) {
							output += formatted2;
							if (commands.length > 0) position += get_string_width_default(formatted2);
						}
						break;
					}
					case DOC_TYPE_ARRAY:
						for (let index = doc2.length - 1; index >= 0; index--) commands.push({
							indent: indent2,
							mode,
							doc: doc2[index]
						});
						break;
					case DOC_TYPE_CURSOR:
						if (cursorPositions.length >= 2) throw new Error("There are too many 'cursor' in doc.");
						cursorPositions.push(settledTextLength + output.length);
						break;
					case DOC_TYPE_INDENT:
						commands.push({
							indent: makeIndent(indent2, options),
							mode,
							doc: doc2.contents
						});
						break;
					case DOC_TYPE_ALIGN:
						commands.push({
							indent: makeAlign(indent2, doc2.n, options),
							mode,
							doc: doc2.contents
						});
						break;
					case DOC_TYPE_TRIM:
						trim2();
						break;
					case DOC_TYPE_GROUP:
						switch (mode) {
							case MODE_FLAT: if (!shouldRemeasure) {
								commands.push({
									indent: indent2,
									mode: doc2.break ? MODE_BREAK : MODE_FLAT,
									doc: doc2.contents
								});
								break;
							}
							case MODE_BREAK: {
								shouldRemeasure = false;
								const next = {
									indent: indent2,
									mode: MODE_FLAT,
									doc: doc2.contents
								};
								const remainingWidth = width - position;
								const hasLineSuffix = lineSuffix2.length > 0;
								if (!doc2.break && fits(next, commands, remainingWidth, hasLineSuffix, groupModeMap)) commands.push(next);
								else if (doc2.expandedStates) {
									const mostExpanded = method_at_default(0, doc2.expandedStates, -1);
									if (doc2.break) {
										commands.push({
											indent: indent2,
											mode: MODE_BREAK,
											doc: mostExpanded
										});
										break;
									} else for (let index = 1; index < doc2.expandedStates.length + 1; index++) if (index >= doc2.expandedStates.length) {
										commands.push({
											indent: indent2,
											mode: MODE_BREAK,
											doc: mostExpanded
										});
										break;
									} else {
										const cmd = {
											indent: indent2,
											mode: MODE_FLAT,
											doc: doc2.expandedStates[index]
										};
										if (fits(cmd, commands, remainingWidth, hasLineSuffix, groupModeMap)) {
											commands.push(cmd);
											break;
										}
									}
								} else commands.push({
									indent: indent2,
									mode: MODE_BREAK,
									doc: doc2.contents
								});
								break;
							}
						}
						if (doc2.id) groupModeMap[doc2.id] = method_at_default(0, commands, -1).mode;
						break;
					case DOC_TYPE_FILL: {
						const remainingWidth = width - position;
						const offset = doc2[DOC_FILL_PRINTED_LENGTH] ?? 0;
						const { parts } = doc2;
						const length = parts.length - offset;
						if (length === 0) break;
						const content = parts[offset + 0];
						const whitespace = parts[offset + 1];
						const contentFlatCommand = {
							indent: indent2,
							mode: MODE_FLAT,
							doc: content
						};
						const contentBreakCommand = {
							indent: indent2,
							mode: MODE_BREAK,
							doc: content
						};
						const contentFits = fits(contentFlatCommand, [], remainingWidth, lineSuffix2.length > 0, groupModeMap, true);
						if (length === 1) {
							if (contentFits) commands.push(contentFlatCommand);
							else commands.push(contentBreakCommand);
							break;
						}
						const whitespaceFlatCommand = {
							indent: indent2,
							mode: MODE_FLAT,
							doc: whitespace
						};
						const whitespaceBreakCommand = {
							indent: indent2,
							mode: MODE_BREAK,
							doc: whitespace
						};
						if (length === 2) {
							if (contentFits) commands.push(whitespaceFlatCommand, contentFlatCommand);
							else commands.push(whitespaceBreakCommand, contentBreakCommand);
							break;
						}
						const secondContent = parts[offset + 2];
						const remainingCommand = {
							indent: indent2,
							mode,
							doc: {
								...doc2,
								[DOC_FILL_PRINTED_LENGTH]: offset + 2
							}
						};
						const firstAndSecondContentFits = fits({
							indent: indent2,
							mode: MODE_FLAT,
							doc: [
								content,
								whitespace,
								secondContent
							]
						}, [], remainingWidth, lineSuffix2.length > 0, groupModeMap, true);
						commands.push(remainingCommand);
						if (firstAndSecondContentFits) commands.push(whitespaceFlatCommand, contentFlatCommand);
						else if (contentFits) commands.push(whitespaceBreakCommand, contentFlatCommand);
						else commands.push(whitespaceBreakCommand, contentBreakCommand);
						break;
					}
					case DOC_TYPE_IF_BREAK:
					case DOC_TYPE_INDENT_IF_BREAK: {
						const groupMode = doc2.groupId ? groupModeMap[doc2.groupId] : mode;
						if (groupMode === MODE_BREAK) {
							const breakContents = doc2.type === DOC_TYPE_IF_BREAK ? doc2.breakContents : doc2.negate ? doc2.contents : indent(doc2.contents);
							if (breakContents) commands.push({
								indent: indent2,
								mode,
								doc: breakContents
							});
						}
						if (groupMode === MODE_FLAT) {
							const flatContents = doc2.type === DOC_TYPE_IF_BREAK ? doc2.flatContents : doc2.negate ? indent(doc2.contents) : doc2.contents;
							if (flatContents) commands.push({
								indent: indent2,
								mode,
								doc: flatContents
							});
						}
						break;
					}
					case DOC_TYPE_LINE_SUFFIX:
						lineSuffix2.push({
							indent: indent2,
							mode,
							doc: doc2.contents
						});
						break;
					case DOC_TYPE_LINE_SUFFIX_BOUNDARY:
						if (lineSuffix2.length > 0) commands.push({
							indent: indent2,
							mode,
							doc: hardlineWithoutBreakParent
						});
						break;
					case DOC_TYPE_LINE:
						switch (mode) {
							case MODE_FLAT: if (!doc2.hard) {
								if (!doc2.soft) {
									output += " ";
									position += 1;
								}
								break;
							} else shouldRemeasure = true;
							case MODE_BREAK:
								if (lineSuffix2.length > 0) {
									commands.push({
										indent: indent2,
										mode,
										doc: doc2
									}, ...lineSuffix2.reverse());
									lineSuffix2.length = 0;
									break;
								}
								if (doc2.literal) {
									output += newLine;
									position = 0;
									if (indent2.root) {
										if (indent2.root.value) output += indent2.root.value;
										position = indent2.root.length;
									}
								} else {
									trim2();
									output += newLine + indent2.value;
									position = indent2.length;
								}
								break;
						}
						break;
					case DOC_TYPE_LABEL:
						commands.push({
							indent: indent2,
							mode,
							doc: doc2.contents
						});
						break;
					case DOC_TYPE_BREAK_PARENT: break;
					default: throw new invalid_doc_error_default(doc2);
				}
				if (commands.length === 0 && lineSuffix2.length > 0) {
					commands.push(...lineSuffix2.reverse());
					lineSuffix2.length = 0;
				}
			}
			const formatted = settledOutput.join("") + output;
			const finalCursorPositions = [...settledCursorPositions, ...cursorPositions];
			if (finalCursorPositions.length !== 2) return { formatted };
			const cursorNodeStart = finalCursorPositions[0];
			return {
				formatted,
				cursorNodeStart,
				cursorNodeText: formatted.slice(cursorNodeStart, method_at_default(0, finalCursorPositions, -1))
			};
			function trim2() {
				const { text: trimmed, count } = trimIndentation(output);
				if (trimmed) {
					settledOutput.push(trimmed);
					settledTextLength += trimmed.length;
				}
				output = "";
				position -= count;
				if (cursorPositions.length > 0) {
					settledCursorPositions.push(...cursorPositions.map((position2) => Math.min(position2, settledTextLength)));
					cursorPositions.length = 0;
				}
			}
		}
		var builders = {
			join,
			line,
			softline,
			hardline,
			literalline,
			group,
			conditionalGroup,
			fill,
			lineSuffix,
			lineSuffixBoundary,
			cursor,
			breakParent,
			ifBreak,
			trim,
			indent,
			indentIfBreak,
			align,
			addAlignmentToDoc,
			markAsRoot,
			dedentToRoot,
			dedent,
			hardlineWithoutBreakParent,
			literallineWithoutBreakParent,
			label,
			concat: (parts) => parts
		};
		var printer = { printDocToString };
		var utils = {
			willBreak,
			traverseDoc: traverse_doc_default,
			findInDoc,
			mapDoc,
			removeLines,
			stripTrailingHardline,
			replaceEndOfLine,
			canBreak
		};
		return __toCommonJS(public_exports);
	});
}));

//#endregion
//#region node_modules/prettier/index.cjs
var require_prettier = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var __defProp = Object.defineProperty;
	var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
	var __getOwnPropNames = Object.getOwnPropertyNames;
	var __hasOwnProp = Object.prototype.hasOwnProperty;
	var __esm = (fn, res) => function __init() {
		return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
	};
	var __export = (target, all) => {
		for (var name in all) __defProp(target, name, {
			get: all[name],
			enumerable: true
		});
	};
	var __copyProps = (to, from, except, desc) => {
		if (from && typeof from === "object" || typeof from === "function") {
			for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
				get: () => from[key],
				enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
			});
		}
		return to;
	};
	var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
	var OPTIONAL_OBJECT, createMethodShim;
	var init_shared = __esm({ "scripts/build/shims/shared.js"() {
		OPTIONAL_OBJECT = 1;
		createMethodShim = (methodName, getImplementation) => (flags, object, ...arguments_) => {
			if (flags | OPTIONAL_OBJECT && (object === void 0 || object === null)) return;
			return (getImplementation.call(object) ?? object[methodName]).apply(object, arguments_);
		};
	} });
	var stringReplaceAll, replaceAll, method_replace_all_default;
	var init_method_replace_all = __esm({ "scripts/build/shims/method-replace-all.js"() {
		init_shared();
		stringReplaceAll = String.prototype.replaceAll ?? function(pattern, replacement) {
			if (pattern.global) return this.replace(pattern, replacement);
			return this.split(pattern).join(replacement);
		};
		replaceAll = createMethodShim("replaceAll", function() {
			if (typeof this === "string") return stringReplaceAll;
		});
		method_replace_all_default = replaceAll;
	} });
	function skip(characters) {
		return (text, startIndex, options) => {
			const backwards = Boolean(options?.backwards);
			if (startIndex === false) return false;
			const { length } = text;
			let cursor = startIndex;
			while (cursor >= 0 && cursor < length) {
				const character = text.charAt(cursor);
				if (characters instanceof RegExp) {
					if (!characters.test(character)) return cursor;
				} else if (!characters.includes(character)) return cursor;
				backwards ? cursor-- : cursor++;
			}
			if (cursor === -1 || cursor === length) return cursor;
			return false;
		};
	}
	var skipWhitespace, skipSpaces, skipToLineEnd, skipEverythingButNewLine;
	var init_skip = __esm({ "src/utilities/skip.js"() {
		skipWhitespace = skip(/\s/u);
		skipSpaces = skip(" 	");
		skipToLineEnd = skip(",; 	");
		skipEverythingButNewLine = skip(/[^\n\r]/u);
	} });
	function skipInlineComment(text, startIndex) {
		if (startIndex === false) return false;
		if (text.charAt(startIndex) === "/" && text.charAt(startIndex + 1) === "*") {
			for (let i = startIndex + 2; i < text.length; ++i) if (text.charAt(i) === "*" && text.charAt(i + 1) === "/") return i + 2;
		}
		return startIndex;
	}
	var skip_inline_comment_default;
	var init_skip_inline_comment = __esm({ "src/utilities/skip-inline-comment.js"() {
		skip_inline_comment_default = skipInlineComment;
	} });
	function skipNewline(text, startIndex, options) {
		const backwards = Boolean(options?.backwards);
		if (startIndex === false) return false;
		const character = text.charAt(startIndex);
		if (backwards) {
			if (text.charAt(startIndex - 1) === "\r" && character === "\n") return startIndex - 2;
			if (isNewlineCharacter(character)) return startIndex - 1;
		} else {
			if (character === "\r" && text.charAt(startIndex + 1) === "\n") return startIndex + 2;
			if (isNewlineCharacter(character)) return startIndex + 1;
		}
		return startIndex;
	}
	var isNewlineCharacter, skip_newline_default;
	var init_skip_newline = __esm({ "src/utilities/skip-newline.js"() {
		isNewlineCharacter = (character) => character === "\n" || character === "\r" || character === "\u2028" || character === "\u2029";
		skip_newline_default = skipNewline;
	} });
	function skipTrailingComment(text, startIndex) {
		if (startIndex === false) return false;
		if (text.charAt(startIndex) === "/" && text.charAt(startIndex + 1) === "/") return skipEverythingButNewLine(text, startIndex);
		return startIndex;
	}
	var skip_trailing_comment_default;
	var init_skip_trailing_comment = __esm({ "src/utilities/skip-trailing-comment.js"() {
		init_skip();
		skip_trailing_comment_default = skipTrailingComment;
	} });
	function getNextNonSpaceNonCommentCharacterIndex(text, startIndex) {
		let oldIdx = null;
		let nextIdx = startIndex;
		while (nextIdx !== oldIdx) {
			oldIdx = nextIdx;
			nextIdx = skipSpaces(text, nextIdx);
			nextIdx = skip_inline_comment_default(text, nextIdx);
			nextIdx = skip_trailing_comment_default(text, nextIdx);
			nextIdx = skip_newline_default(text, nextIdx);
		}
		return nextIdx;
	}
	var get_next_non_space_non_comment_character_index_default;
	var init_get_next_non_space_non_comment_character_index = __esm({ "src/utilities/get-next-non-space-non-comment-character-index.js"() {
		init_skip();
		init_skip_inline_comment();
		init_skip_newline();
		init_skip_trailing_comment();
		get_next_non_space_non_comment_character_index_default = getNextNonSpaceNonCommentCharacterIndex;
	} });
	function hasNewline(text, startIndex, options = {}) {
		const idx = skipSpaces(text, options.backwards ? startIndex - 1 : startIndex, options);
		return idx !== skip_newline_default(text, idx, options);
	}
	var has_newline_default;
	var init_has_newline = __esm({ "src/utilities/has-newline.js"() {
		init_skip();
		init_skip_newline();
		has_newline_default = hasNewline;
	} });
	function isNextLineEmpty(text, startIndex) {
		let oldIdx = null;
		let idx = startIndex;
		while (idx !== oldIdx) {
			oldIdx = idx;
			idx = skipToLineEnd(text, idx);
			idx = skip_inline_comment_default(text, idx);
			idx = skipSpaces(text, idx);
		}
		idx = skip_trailing_comment_default(text, idx);
		idx = skip_newline_default(text, idx);
		return idx !== false && has_newline_default(text, idx);
	}
	var is_next_line_empty_default;
	var init_is_next_line_empty = __esm({ "src/utilities/is-next-line-empty.js"() {
		init_has_newline();
		init_skip();
		init_skip_inline_comment();
		init_skip_newline();
		init_skip_trailing_comment();
		is_next_line_empty_default = isNextLineEmpty;
	} });
	function isPreviousLineEmpty(text, startIndex) {
		let idx = startIndex - 1;
		idx = skipSpaces(text, idx, { backwards: true });
		idx = skip_newline_default(text, idx, { backwards: true });
		idx = skipSpaces(text, idx, { backwards: true });
		const idx2 = skip_newline_default(text, idx, { backwards: true });
		return idx !== idx2;
	}
	var is_previous_line_empty_default;
	var init_is_previous_line_empty = __esm({ "src/utilities/is-previous-line-empty.js"() {
		init_skip();
		init_skip_newline();
		is_previous_line_empty_default = isPreviousLineEmpty;
	} });
	function describeNodeForDebugging(node) {
		const nodeType = node.type || node.kind || "(unknown type)";
		let nodeName = String(node.name || node.id && (typeof node.id === "object" ? node.id.name : node.id) || node.key && (typeof node.key === "object" ? node.key.name : node.key) || node.value && (typeof node.value === "object" ? "" : String(node.value)) || node.operator || "");
		if (nodeName.length > 20) nodeName = nodeName.slice(0, 19) + "…";
		return nodeType + (nodeName ? " " + nodeName : "");
	}
	function addCommentHelper(node, comment) {
		(node.comments ?? (node.comments = [])).push(comment);
		comment.printed = false;
		comment.nodeDescription = describeNodeForDebugging(node);
	}
	function addLeadingComment(node, comment) {
		comment.leading = true;
		comment.trailing = false;
		addCommentHelper(node, comment);
	}
	function addDanglingComment(node, comment, marker) {
		comment.leading = false;
		comment.trailing = false;
		if (marker) comment.marker = marker;
		addCommentHelper(node, comment);
	}
	function addTrailingComment(node, comment) {
		comment.leading = false;
		comment.trailing = true;
		addCommentHelper(node, comment);
	}
	var init_utilities = __esm({ "src/main/comments/utilities.js"() {} });
	function getAlignmentSize(text, tabWidth, startIndex = 0) {
		let size = 0;
		for (let i = startIndex; i < text.length; ++i) if (text[i] === "	") size = size + tabWidth - size % tabWidth;
		else size++;
		return size;
	}
	var get_alignment_size_default;
	var init_get_alignment_size = __esm({ "src/utilities/get-alignment-size.js"() {
		get_alignment_size_default = getAlignmentSize;
	} });
	function getIndentSize(value, tabWidth) {
		const lastNewlineIndex = value.lastIndexOf("\n");
		if (lastNewlineIndex === -1) return 0;
		return get_alignment_size_default(value.slice(lastNewlineIndex + 1).match(/^[\t ]*/u)[0], tabWidth);
	}
	var get_indent_size_default;
	var init_get_indent_size = __esm({ "src/utilities/get-indent-size.js"() {
		init_get_alignment_size();
		get_indent_size_default = getIndentSize;
	} });
	function escapeStringRegexp(string) {
		if (typeof string !== "string") throw new TypeError("Expected a string");
		return string.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
	}
	var init_escape_string_regexp = __esm({ "node_modules/escape-string-regexp/index.js"() {} });
	function getMaxContinuousCount(text, searchString) {
		let results = text.matchAll(new RegExp(`(?:${escapeStringRegexp(searchString)})+`, "gu"));
		if (!results.reduce) results = [...results];
		return results.reduce((maxCount, [result]) => Math.max(maxCount, result.length), 0) / searchString.length;
	}
	var get_max_continuous_count_default;
	var init_get_max_continuous_count = __esm({ "src/utilities/get-max-continuous-count.js"() {
		init_escape_string_regexp();
		get_max_continuous_count_default = getMaxContinuousCount;
	} });
	function getNextNonSpaceNonCommentCharacter(text, startIndex) {
		const index = get_next_non_space_non_comment_character_index_default(text, startIndex);
		return index === false ? "" : text.charAt(index);
	}
	var get_next_non_space_non_comment_character_default;
	var init_get_next_non_space_non_comment_character = __esm({ "src/utilities/get-next-non-space-non-comment-character.js"() {
		init_get_next_non_space_non_comment_character_index();
		get_next_non_space_non_comment_character_default = getNextNonSpaceNonCommentCharacter;
	} });
	function getPreferredQuote(text, preferredQuoteOrPreferSingleQuote) {
		const { preferred, alternate } = preferredQuoteOrPreferSingleQuote === true || preferredQuoteOrPreferSingleQuote === SINGLE_QUOTE ? SINGLE_QUOTE_SETTINGS : DOUBLE_QUOTE_SETTINGS;
		const { length } = text;
		let preferredQuoteCount = 0;
		let alternateQuoteCount = 0;
		for (let index = 0; index < length; index++) {
			const codePoint = text.charCodeAt(index);
			if (codePoint === preferred.codePoint) preferredQuoteCount++;
			else if (codePoint === alternate.codePoint) alternateQuoteCount++;
		}
		return (preferredQuoteCount > alternateQuoteCount ? alternate : preferred).character;
	}
	var SINGLE_QUOTE, DOUBLE_QUOTE, SINGLE_QUOTE_DATA, DOUBLE_QUOTE_DATA, SINGLE_QUOTE_SETTINGS, DOUBLE_QUOTE_SETTINGS, get_preferred_quote_default;
	var init_get_preferred_quote = __esm({ "src/utilities/get-preferred-quote.js"() {
		SINGLE_QUOTE = "'";
		DOUBLE_QUOTE = "\"";
		SINGLE_QUOTE_DATA = Object.freeze({
			character: SINGLE_QUOTE,
			codePoint: 39
		});
		DOUBLE_QUOTE_DATA = Object.freeze({
			character: DOUBLE_QUOTE,
			codePoint: 34
		});
		SINGLE_QUOTE_SETTINGS = Object.freeze({
			preferred: SINGLE_QUOTE_DATA,
			alternate: DOUBLE_QUOTE_DATA
		});
		DOUBLE_QUOTE_SETTINGS = Object.freeze({
			preferred: DOUBLE_QUOTE_DATA,
			alternate: SINGLE_QUOTE_DATA
		});
		get_preferred_quote_default = getPreferredQuote;
	} });
	var emoji_regex_default;
	var init_emoji_regex = __esm({ "node_modules/emoji-regex/index.mjs"() {
		emoji_regex_default = () => {
			return /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E-\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED8\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFC-\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFB-\uDFFE])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFB-\uDFFE])))?))?|\uDD75(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3C-\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE8A\uDE8E-\uDEC2\uDEC6\uDEC8\uDECD-\uDEDC\uDEDF-\uDEEA\uDEEF]|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
		};
	} });
	function isFullWidth(x) {
		return x === 12288 || x >= 65281 && x <= 65376 || x >= 65504 && x <= 65510;
	}
	function isWide(x) {
		return x >= 4352 && x <= 4447 || x === 8986 || x === 8987 || x === 9001 || x === 9002 || x >= 9193 && x <= 9196 || x === 9200 || x === 9203 || x === 9725 || x === 9726 || x === 9748 || x === 9749 || x >= 9776 && x <= 9783 || x >= 9800 && x <= 9811 || x === 9855 || x >= 9866 && x <= 9871 || x === 9875 || x === 9889 || x === 9898 || x === 9899 || x === 9917 || x === 9918 || x === 9924 || x === 9925 || x === 9934 || x === 9940 || x === 9962 || x === 9970 || x === 9971 || x === 9973 || x === 9978 || x === 9981 || x === 9989 || x === 9994 || x === 9995 || x === 10024 || x === 10060 || x === 10062 || x >= 10067 && x <= 10069 || x === 10071 || x >= 10133 && x <= 10135 || x === 10160 || x === 10175 || x === 11035 || x === 11036 || x === 11088 || x === 11093 || x >= 11904 && x <= 11929 || x >= 11931 && x <= 12019 || x >= 12032 && x <= 12245 || x >= 12272 && x <= 12287 || x >= 12289 && x <= 12350 || x >= 12353 && x <= 12438 || x >= 12441 && x <= 12543 || x >= 12549 && x <= 12591 || x >= 12593 && x <= 12686 || x >= 12688 && x <= 12773 || x >= 12783 && x <= 12830 || x >= 12832 && x <= 12871 || x >= 12880 && x <= 42124 || x >= 42128 && x <= 42182 || x >= 43360 && x <= 43388 || x >= 44032 && x <= 55203 || x >= 63744 && x <= 64255 || x >= 65040 && x <= 65049 || x >= 65072 && x <= 65106 || x >= 65108 && x <= 65126 || x >= 65128 && x <= 65131 || x >= 94176 && x <= 94180 || x >= 94192 && x <= 94198 || x >= 94208 && x <= 101589 || x >= 101631 && x <= 101662 || x >= 101760 && x <= 101874 || x >= 110576 && x <= 110579 || x >= 110581 && x <= 110587 || x === 110589 || x === 110590 || x >= 110592 && x <= 110882 || x === 110898 || x >= 110928 && x <= 110930 || x === 110933 || x >= 110948 && x <= 110951 || x >= 110960 && x <= 111355 || x >= 119552 && x <= 119638 || x >= 119648 && x <= 119670 || x === 126980 || x === 127183 || x === 127374 || x >= 127377 && x <= 127386 || x >= 127488 && x <= 127490 || x >= 127504 && x <= 127547 || x >= 127552 && x <= 127560 || x === 127568 || x === 127569 || x >= 127584 && x <= 127589 || x >= 127744 && x <= 127776 || x >= 127789 && x <= 127797 || x >= 127799 && x <= 127868 || x >= 127870 && x <= 127891 || x >= 127904 && x <= 127946 || x >= 127951 && x <= 127955 || x >= 127968 && x <= 127984 || x === 127988 || x >= 127992 && x <= 128062 || x === 128064 || x >= 128066 && x <= 128252 || x >= 128255 && x <= 128317 || x >= 128331 && x <= 128334 || x >= 128336 && x <= 128359 || x === 128378 || x === 128405 || x === 128406 || x === 128420 || x >= 128507 && x <= 128591 || x >= 128640 && x <= 128709 || x === 128716 || x >= 128720 && x <= 128722 || x >= 128725 && x <= 128728 || x >= 128732 && x <= 128735 || x === 128747 || x === 128748 || x >= 128756 && x <= 128764 || x >= 128992 && x <= 129003 || x === 129008 || x >= 129292 && x <= 129338 || x >= 129340 && x <= 129349 || x >= 129351 && x <= 129535 || x >= 129648 && x <= 129660 || x >= 129664 && x <= 129674 || x >= 129678 && x <= 129734 || x === 129736 || x >= 129741 && x <= 129756 || x >= 129759 && x <= 129770 || x >= 129775 && x <= 129784 || x >= 131072 && x <= 196605 || x >= 196608 && x <= 262141;
	}
	var init_lookup = __esm({ "node_modules/get-east-asian-width/lookup.js"() {} });
	var init_get_east_asian_width = __esm({ "node_modules/get-east-asian-width/index.js"() {
		init_lookup();
	} });
	var narrow_emojis_evaluate_default;
	var init_narrow_emojis_evaluate = __esm({ "src/utilities/narrow-emojis.evaluate.js"() {
		narrow_emojis_evaluate_default = "©®‼⁉™ℹ↔↕↖↗↘↙↩↪⌨⏏⏱⏲⏸⏹⏺▪▫▶◀◻◼☀☁☂☃☄☎☑☘☝☠☢☣☦☪☮☯☸☹☺♀♂♟♠♣♥♦♨♻♾⚒⚔⚕⚖⚗⚙⚛⚜⚠⚧⚰⚱⛈⛏⛑⛓⛩⛱⛷⛸⛹✂✈✉✌✍✏✒✔✖✝✡✳✴❄❇❣❤➡⤴⤵⬅⬆⬇";
	} });
	function getStringWidth(text) {
		if (!text) return 0;
		if (!notAsciiRegex.test(text)) return text.length;
		text = text.replace(emoji_regex_default(), (match) => narrowEmojisSet.has(match) ? " " : "  ");
		let width = 0;
		for (const character of text) {
			const codePoint = character.codePointAt(0);
			if (codePoint <= 31 || codePoint >= 127 && codePoint <= 159) continue;
			if (codePoint >= 768 && codePoint <= 879) continue;
			if (codePoint >= 65024 && codePoint <= 65039) continue;
			width += isFullWidth(codePoint) || isWide(codePoint) ? 2 : 1;
		}
		return width;
	}
	var notAsciiRegex, narrowEmojisSet, get_string_width_default;
	var init_get_string_width = __esm({ "src/utilities/get-string-width.js"() {
		init_emoji_regex();
		init_get_east_asian_width();
		init_narrow_emojis_evaluate();
		notAsciiRegex = /[^\x20-\x7F]/u;
		narrowEmojisSet = new Set(narrow_emojis_evaluate_default);
		get_string_width_default = getStringWidth;
	} });
	function hasNewlineInRange(text, startIndex, endIndex) {
		for (let i = startIndex; i < endIndex; ++i) if (text.charAt(i) === "\n") return true;
		return false;
	}
	var has_newline_in_range_default;
	var init_has_newline_in_range = __esm({ "src/utilities/has-newline-in-range.js"() {
		has_newline_in_range_default = hasNewlineInRange;
	} });
	function hasSpaces(text, startIndex, options = {}) {
		return skipSpaces(text, options.backwards ? startIndex - 1 : startIndex, options) !== startIndex;
	}
	var has_spaces_default;
	var init_has_spaces = __esm({ "src/utilities/has-spaces.js"() {
		init_skip();
		has_spaces_default = hasSpaces;
	} });
	var public_exports = {};
	__export(public_exports, {
		addDanglingComment: () => addDanglingComment,
		addLeadingComment: () => addLeadingComment,
		addTrailingComment: () => addTrailingComment,
		getAlignmentSize: () => get_alignment_size_default,
		getIndentSize: () => get_indent_size_default,
		getMaxContinuousCount: () => get_max_continuous_count_default,
		getNextNonSpaceNonCommentCharacter: () => get_next_non_space_non_comment_character_default,
		getNextNonSpaceNonCommentCharacterIndex: () => getNextNonSpaceNonCommentCharacterIndex2,
		getPreferredQuote: () => get_preferred_quote_default,
		getStringWidth: () => get_string_width_default,
		hasNewline: () => has_newline_default,
		hasNewlineInRange: () => has_newline_in_range_default,
		hasSpaces: () => has_spaces_default,
		isNextLineEmpty: () => isNextLineEmpty2,
		isNextLineEmptyAfterIndex: () => is_next_line_empty_default,
		isPreviousLineEmpty: () => isPreviousLineEmpty2,
		makeString: () => makeString,
		skip: () => skip,
		skipEverythingButNewLine: () => skipEverythingButNewLine,
		skipInlineComment: () => skip_inline_comment_default,
		skipNewline: () => skip_newline_default,
		skipSpaces: () => skipSpaces,
		skipToLineEnd: () => skipToLineEnd,
		skipTrailingComment: () => skip_trailing_comment_default,
		skipWhitespace: () => skipWhitespace
	});
	function legacyGetNextNonSpaceNonCommentCharacterIndex(text, node, locEnd) {
		return get_next_non_space_non_comment_character_index_default(text, locEnd(node));
	}
	function getNextNonSpaceNonCommentCharacterIndex2(text, startIndex) {
		return arguments.length === 2 || typeof startIndex === "number" ? get_next_non_space_non_comment_character_index_default(text, startIndex) : legacyGetNextNonSpaceNonCommentCharacterIndex(...arguments);
	}
	function legacyIsPreviousLineEmpty(text, node, locStart) {
		return is_previous_line_empty_default(text, locStart(node));
	}
	function isPreviousLineEmpty2(text, startIndex) {
		return arguments.length === 2 || typeof startIndex === "number" ? is_previous_line_empty_default(text, startIndex) : legacyIsPreviousLineEmpty(...arguments);
	}
	function legacyIsNextLineEmpty(text, node, locEnd) {
		return is_next_line_empty_default(text, locEnd(node));
	}
	function makeString(rawText, enclosingQuote, unescapeUnnecessaryEscapes) {
		const otherQuote = enclosingQuote === "\"" ? "'" : "\"";
		return enclosingQuote + method_replace_all_default(0, rawText, /\\(.)|(["'])/gsu, (match, escaped, quote) => {
			if (escaped === otherQuote) return escaped;
			if (quote === enclosingQuote) return "\\" + quote;
			if (quote) return quote;
			return unescapeUnnecessaryEscapes && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/u.test(escaped) ? escaped : "\\" + escaped;
		}) + enclosingQuote;
	}
	function isNextLineEmpty2(text, startIndex) {
		return arguments.length === 2 || typeof startIndex === "number" ? is_next_line_empty_default(text, startIndex) : legacyIsNextLineEmpty(...arguments);
	}
	var init_public = __esm({ "src/utilities/public.js"() {
		init_method_replace_all();
		init_get_next_non_space_non_comment_character_index();
		init_is_next_line_empty();
		init_is_previous_line_empty();
		init_utilities();
		init_get_alignment_size();
		init_get_indent_size();
		init_get_max_continuous_count();
		init_get_next_non_space_non_comment_character();
		init_get_preferred_quote();
		init_get_string_width();
		init_has_newline();
		init_has_newline_in_range();
		init_has_spaces();
		init_skip();
		init_skip_inline_comment();
		init_skip_newline();
		init_skip_trailing_comment();
	} });
	var version_evaluate_exports = {};
	__export(version_evaluate_exports, { default: () => version_evaluate_default });
	var version_evaluate_default;
	var init_version_evaluate = __esm({ "src/main/version.evaluate.js"() {
		version_evaluate_default = "3.8.1";
	} });
	var prettierPromise = import("./prettier-CN5PPLCJ.js");
	var functionNames = [
		"formatWithCursor",
		"format",
		"check",
		"resolveConfig",
		"resolveConfigFile",
		"clearConfigCache",
		"getFileInfo",
		"getSupportInfo"
	];
	var prettier = /* @__PURE__ */ Object.create(null);
	for (const name of functionNames) prettier[name] = async (...args) => {
		return (await prettierPromise)[name](...args);
	};
	var debugApiFunctionNames = [
		"parse",
		"formatAST",
		"formatDoc",
		"printToDoc",
		"printDocToString"
	];
	var debugApis = /* @__PURE__ */ Object.create(null);
	for (const name of debugApiFunctionNames) debugApis[name] = async (...args) => {
		return (await prettierPromise).__debug[name](...args);
	};
	prettier.__debug = debugApis;
	prettier.util = (init_public(), __toCommonJS(public_exports));
	prettier.doc = require_doc();
	prettier.version = (init_version_evaluate(), __toCommonJS(version_evaluate_exports)).default;
	module.exports = prettier;
}));

//#endregion
//#region node_modules/svelte/compiler/index.js
var require_compiler = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	(function(e, t) {
		"object" == typeof exports && "undefined" != typeof module ? t(exports) : "function" == typeof define && define.amd ? define(["exports"], t) : t((e = "undefined" != typeof globalThis ? globalThis : e || self).svelte = {});
	})(exports, (function(e) {
		"use strict";
		function t(e, t, s) {
			const r = s._;
			let a = !1;
			function i(e, { next: t, state: n }) {
				t(n);
			}
			return function e(t, o, l) {
				if (a) return;
				if (!t.type) return;
				let c;
				const p = {}, u = {
					path: o,
					state: l,
					next: (s = l) => {
						o.push(t);
						for (const n in t) {
							if ("type" === n) continue;
							const r = t[n];
							if (r && "object" == typeof r) if (Array.isArray(r)) {
								const t = {};
								r.forEach(((n, r) => {
									if (n && "object" == typeof n) {
										const a = e(n, o, s);
										a && (t[r] = a);
									}
								})), Object.keys(t).length > 0 && (p[n] = r.map(((e, n) => t[n] ?? e)));
							} else {
								const t = e(r, o, s);
								t && (p[n] = t);
							}
						}
						if (o.pop(), Object.keys(p).length > 0) return n(t, p);
					},
					stop: () => {
						a = !0;
					},
					visit: (n, s = l) => {
						o.push(t);
						const r = e(n, o, s) ?? n;
						return o.pop(), r;
					}
				};
				let d = s[t.type] ?? i;
				if (r) {
					let e;
					c = r(t, {
						...u,
						next: (n = l) => (l = n, e = d(t, {
							...u,
							state: n
						}), e)
					}), !c && e && (c = e);
				} else c = d(t, u);
				return c || Object.keys(p).length > 0 && (c = n(t, p)), c || void 0;
			}(e, [], t) ?? e;
		}
		function n(e, t) {
			const n = {}, s = Object.getOwnPropertyDescriptors(e);
			for (const e in s) Object.defineProperty(n, e, s[e]);
			for (const e in t) n[e] = t[e];
			return n;
		}
		const s = /\s/, r = /\s+/, a = /^\r?\n/, i = /^\s/, o = /^[ \t\r\n]+/, l = /\s$/, c = /[ \t\r\n]+$/, p = /[^ \t\r\n]/, u = /[ \t\n\r\f]+/g, d = /^[ \t\n\r\f]+$/, h = /[^\n]/g, m = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/, f = /(^[^a-zA-Z_$]|[^a-zA-Z0-9_$])/g, y = /^[aeiou]/, v = /^h[1-6]$/, g = /(^[0-9-.])|[\^$@%&#?!|()[\]{}^*+~;]/, b = /[\u202a\u202b\u202c\u202d\u202e\u2066\u2067\u2068\u2069]+/g, _ = /^\W*javascript:/i, x = /\b(image|picture|photo)\b/i, w = 1, k = 2, C = 4, S = 8, P = 16, E = 4, T = 8, A = 1, $ = 2, R = 4, I = "http://www.w3.org/2000/svg", M = "http://www.w3.org/1998/Math/MathML";
		function q(e, t) {
			if (0 === t.length) return null;
			const n = new j(t).get(e);
			return n && n[0][0] > .7 ? n[0][1] : null;
		}
		function L(e, t) {
			if (null === e && null === t) throw "Trying to compare two null values";
			if (null === e || null === t) return 0;
			return 1 - function(e, t) {
				const n = [];
				let s = 0;
				for (let r = 0; r <= t.length; r++) for (let a = 0; a <= e.length; a++) {
					let i;
					i = r && a ? e.charAt(a - 1) === t.charAt(r - 1) ? s : Math.min(n[a], n[a - 1], s) + 1 : r + a, s = n[a], n[a] = i;
				}
				return n.pop();
			}(e = String(e), t = String(t)) / Math.max(e.length, t.length);
		}
		const O = /[^\w, ]+/;
		function N(e, t = 2) {
			const n = {}, s = function(e, t = 2) {
				const n = "-" + e.toLowerCase().replace(O, "") + "-", s = t - n.length, r = [];
				if (s > 0) for (let t = 0; t < s; ++t) e += "-";
				for (let e = 0; e < n.length - t + 1; ++e) r.push(n.slice(e, e + t));
				return r;
			}(e, t);
			let r = 0;
			for (; r < s.length; ++r) s[r] in n ? n[s[r]] += 1 : n[s[r]] = 1;
			return n;
		}
		function D(e, t) {
			return t[0] - e[0];
		}
		class j {
			exact_set = {};
			match_dict = {};
			items = {};
			constructor(e) {
				for (let e = 2; e < 4; ++e) this.items[e] = [];
				for (let t = 0; t < e.length; ++t) this.add(e[t]);
			}
			add(e) {
				if (e.toLowerCase() in this.exact_set) return !1;
				let t = 2;
				for (; t < 4; ++t) this._add(e, t);
			}
			_add(e, t) {
				const n = e.toLowerCase(), s = this.items[t] || [], r = s.length;
				s.push(0);
				const a = N(n, t);
				let i, o, l = 0;
				for (i in a) o = a[i], l += Math.pow(o, 2), i in this.match_dict ? this.match_dict[i].push([r, o]) : this.match_dict[i] = [[r, o]];
				s[r] = [Math.sqrt(l), n], this.items[t] = s, this.exact_set[n] = e;
			}
			get(e) {
				const t = e.toLowerCase(), n = this.exact_set[t];
				if (n) return [[1, n]];
				for (let t = 3; t >= 2; --t) {
					const n = this.__get(e, t);
					if (n.length > 0) return n;
				}
				return null;
			}
			__get(e, t) {
				const n = e.toLowerCase(), s = {}, r = N(n, t), a = this.items[t];
				let i, o, l, c, p, u = 0;
				for (i in r) if (o = r[i], u += Math.pow(o, 2), i in this.match_dict) for (l = 0; l < this.match_dict[i].length; ++l) c = this.match_dict[i][l][0], p = this.match_dict[i][l][1], c in s ? s[c] += o * p : s[c] = o * p;
				const d = Math.sqrt(u);
				let h, m = [];
				for (const e in s) h = s[e], m.push([h / (d * a[e][0]), a[e][1]]);
				m.sort(D);
				let f = [];
				const y = Math.min(50, m.length);
				for (let e = 0; e < y; ++e) f.push([L(m[e][1], n), m[e][1]]);
				m = f, m.sort(D), f = [];
				for (let e = 0; e < m.length; ++e) m[e][0] === m[0][0] && f.push([m[e][0], this.exact_set[m[e][1]]]);
				return f;
			}
		}
		function B(e, t) {
			return e.start <= t && t < e.end;
		}
		function F(e, t = {}) {
			const { offsetLine: n = 0, offsetColumn: s = 0 } = t;
			let r = 0;
			const a = e.split("\n").map(((e, t) => {
				const n = r + e.length + 1, s = {
					start: r,
					end: n,
					line: t
				};
				return r = n, s;
			}));
			let i = 0;
			return function(t, r) {
				if ("string" == typeof t && (t = e.indexOf(t, r ?? 0)), -1 === t) return;
				let o = a[i];
				const l = t >= o.end ? 1 : -1;
				for (; o;) {
					if (B(o, t)) return {
						line: n + o.line,
						column: s + t - o.start,
						character: t
					};
					i += l, o = a[i];
				}
			};
		}
		const V = /\r/g;
		function H(e) {
			let t = 5381, n = (e = e.replace(V, "")).length;
			for (; n--;) t = (t << 5) - t ^ e.charCodeAt(n);
			return (t >>> 0).toString(36);
		}
		const U = [
			"area",
			"base",
			"br",
			"col",
			"command",
			"embed",
			"hr",
			"img",
			"input",
			"keygen",
			"link",
			"meta",
			"param",
			"source",
			"track",
			"wbr"
		];
		function z(e) {
			return U.includes(e) || "!doctype" === e.toLowerCase();
		}
		const W = [
			"arguments",
			"await",
			"break",
			"case",
			"catch",
			"class",
			"const",
			"continue",
			"debugger",
			"default",
			"delete",
			"do",
			"else",
			"enum",
			"eval",
			"export",
			"extends",
			"false",
			"finally",
			"for",
			"function",
			"if",
			"implements",
			"import",
			"in",
			"instanceof",
			"interface",
			"let",
			"new",
			"null",
			"package",
			"private",
			"protected",
			"public",
			"return",
			"static",
			"super",
			"switch",
			"this",
			"throw",
			"true",
			"try",
			"typeof",
			"var",
			"void",
			"while",
			"with",
			"yield"
		];
		function G(e) {
			return W.includes(e);
		}
		const K = [
			"beforeinput",
			"click",
			"change",
			"dblclick",
			"contextmenu",
			"focusin",
			"focusout",
			"input",
			"keydown",
			"keyup",
			"mousedown",
			"mousemove",
			"mouseout",
			"mouseover",
			"mouseup",
			"pointerdown",
			"pointermove",
			"pointerout",
			"pointerover",
			"pointerup",
			"touchend",
			"touchmove",
			"touchstart"
		];
		const X = [
			"allowfullscreen",
			"async",
			"autofocus",
			"autoplay",
			"checked",
			"controls",
			"default",
			"disabled",
			"formnovalidate",
			"indeterminate",
			"inert",
			"ismap",
			"loop",
			"multiple",
			"muted",
			"nomodule",
			"novalidate",
			"open",
			"playsinline",
			"readonly",
			"required",
			"reversed",
			"seamless",
			"selected",
			"webkitdirectory",
			"defer",
			"disablepictureinpicture",
			"disableremoteplayback"
		];
		function Q(e) {
			return X.includes(e);
		}
		const Y = {
			formnovalidate: "formNoValidate",
			ismap: "isMap",
			nomodule: "noModule",
			playsinline: "playsInline",
			readonly: "readOnly",
			defaultvalue: "defaultValue",
			defaultchecked: "defaultChecked",
			srcobject: "srcObject",
			novalidate: "noValidate",
			allowfullscreen: "allowFullscreen",
			disablepictureinpicture: "disablePictureInPicture",
			disableremoteplayback: "disableRemotePlayback"
		};
		const J = [
			...X,
			"formNoValidate",
			"isMap",
			"noModule",
			"playsInline",
			"readOnly",
			"value",
			"volume",
			"defaultValue",
			"defaultChecked",
			"srcObject",
			"noValidate",
			"allowFullscreen",
			"disablePictureInPicture",
			"disableRemotePlayback"
		];
		const Z = [
			"autofocus",
			"muted",
			"defaultValue",
			"defaultChecked"
		];
		function ee(e) {
			return Z.includes(e);
		}
		const te = ["touchstart", "touchmove"];
		const ne = [
			"textContent",
			"innerHTML",
			"innerText"
		];
		function se(e) {
			return ne.includes(e);
		}
		const re = [
			"body",
			"embed",
			"iframe",
			"img",
			"link",
			"object",
			"script",
			"style",
			"track"
		];
		function ae(e) {
			return re.includes(e);
		}
		const ie = [
			"altGlyph",
			"altGlyphDef",
			"altGlyphItem",
			"animate",
			"animateColor",
			"animateMotion",
			"animateTransform",
			"circle",
			"clipPath",
			"color-profile",
			"cursor",
			"defs",
			"desc",
			"discard",
			"ellipse",
			"feBlend",
			"feColorMatrix",
			"feComponentTransfer",
			"feComposite",
			"feConvolveMatrix",
			"feDiffuseLighting",
			"feDisplacementMap",
			"feDistantLight",
			"feDropShadow",
			"feFlood",
			"feFuncA",
			"feFuncB",
			"feFuncG",
			"feFuncR",
			"feGaussianBlur",
			"feImage",
			"feMerge",
			"feMergeNode",
			"feMorphology",
			"feOffset",
			"fePointLight",
			"feSpecularLighting",
			"feSpotLight",
			"feTile",
			"feTurbulence",
			"filter",
			"font",
			"font-face",
			"font-face-format",
			"font-face-name",
			"font-face-src",
			"font-face-uri",
			"foreignObject",
			"g",
			"glyph",
			"glyphRef",
			"hatch",
			"hatchpath",
			"hkern",
			"image",
			"line",
			"linearGradient",
			"marker",
			"mask",
			"mesh",
			"meshgradient",
			"meshpatch",
			"meshrow",
			"metadata",
			"missing-glyph",
			"mpath",
			"path",
			"pattern",
			"polygon",
			"polyline",
			"radialGradient",
			"rect",
			"set",
			"solidcolor",
			"stop",
			"svg",
			"switch",
			"symbol",
			"text",
			"textPath",
			"tref",
			"tspan",
			"unknown",
			"use",
			"view",
			"vkern"
		];
		function oe(e) {
			return ie.includes(e);
		}
		const le = [
			"annotation",
			"annotation-xml",
			"maction",
			"math",
			"merror",
			"mfrac",
			"mi",
			"mmultiscripts",
			"mn",
			"mo",
			"mover",
			"mpadded",
			"mphantom",
			"mprescripts",
			"mroot",
			"mrow",
			"ms",
			"mspace",
			"msqrt",
			"mstyle",
			"msub",
			"msubsup",
			"msup",
			"mtable",
			"mtd",
			"mtext",
			"mtr",
			"munder",
			"munderover",
			"semantics"
		];
		function ce(e) {
			return le.includes(e);
		}
		const pe = [
			"$state",
			"$state.raw",
			"$derived",
			"$derived.by"
		], ue = [
			...pe,
			"$state.eager",
			"$state.snapshot",
			"$props",
			"$props.id",
			"$bindable",
			"$effect",
			"$effect.pre",
			"$effect.tracking",
			"$effect.root",
			"$effect.pending",
			"$inspect",
			"$inspect().with",
			"$inspect.trace",
			"$host"
		];
		function de(e) {
			return ue.includes(e);
		}
		const he = /^[a-zA-Z][a-zA-Z0-9]*(-[a-zA-Z0-9.\-_\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u{10000}-\u{EFFFF}]+)*$/u;
		let me, fe = [];
		const ye = "(unknown)";
		let ve, ge, be, _e, xe = "<unknown>", we = !1;
		function ke(e) {
			ve = e;
			const t = F(ve, { offsetLine: 1 });
			be = (e) => {
				const n = t(e);
				if (!n) throw new Error("An impossible situation occurred");
				return n;
			};
		}
		function Ce(e) {
			const t = be(e.start);
			return `${n = me, n?.replace(/\//g, "/​")}:${t?.line}:${t.column}`;
			var n;
		}
		let Se = [], Pe = /* @__PURE__ */ new Map();
		function Ee(e, t) {
			return ge && !!Pe.get(e)?.some(((e) => e.has(t)));
		}
		function Te(e) {
			ge = !1, we = !1, xe = ye, ve = "", me = (e.filename ?? ye).replace(/\\/g, "/"), _e = e.warning ?? (() => !0), fe = [];
		}
		function Ae(e) {
			const t = e.rootDir?.replace(/\\/g, "/");
			ge = e.dev, we = e.runes, xe = e.component_name ?? ye, "string" == typeof t && me.startsWith(t) && (me = me.replace(t, "").replace(/^[/\\]/, "")), Se = [], Pe.clear();
		}
		const $e = /^\t+/;
		function Re(e) {
			return e.replace($e, ((e) => e.split("	").join("  ")));
		}
		class Ie {
			name = "CompileDiagnostic";
			constructor(e, t, n) {
				this.code = e, this.message = t, me !== ye && (this.filename = me), n && (this.position = n, this.start = be(n[0]), this.end = be(n[1]), this.start && this.end && (this.frame = function(e, t, n) {
					const s = e.split("\n"), r = Math.max(0, t - 2), a = Math.min(t + 3, s.length), i = String(a + 1).length;
					return s.slice(r, a).map(((e, s) => {
						const a = r + s === t, o = String(s + r + 1).padStart(i, " ");
						if (a) {
							const t = " ".repeat(i + 2 + Re(e.slice(0, n)).length) + "^";
							return `${o}: ${Re(e)}\n${t}`;
						}
						return `${o}: ${Re(e)}`;
					})).join("\n");
				}(ve, this.start.line - 1, this.end.column)));
			}
			toString() {
				let e = `${this.code}: ${this.message}`;
				return this.filename && (e += `\n${this.filename}`, this.start && (e += `:${this.start.line}:${this.start.column}`)), this.frame && (e += `\n${this.frame}`), e;
			}
			toJSON() {
				return {
					code: this.code,
					message: this.message,
					filename: this.filename,
					start: this.start,
					end: this.end,
					position: this.position,
					frame: this.frame
				};
			}
		}
		class Me extends Ie {
			name = "CompileWarning";
			constructor(e, t, n) {
				super(e, t, n);
			}
		}
		function qe(e, t, n) {
			let s = Se;
			if (e && (s = Pe.get(e) ?? Se), s && s.at(-1)?.has(t)) return;
			const r = new Me(t, n, e && void 0 !== e.start ? [e.start, e.end ?? e.start] : void 0);
			_e(r) && fe.push(r);
		}
		function Le(e) {
			qe(e, "a11y_accesskey", "Avoid using accesskey\nhttps://svelte.dev/e/a11y_accesskey");
		}
		function Oe(e) {
			qe(e, "a11y_aria_activedescendant_has_tabindex", "An element with an aria-activedescendant attribute should have a tabindex value\nhttps://svelte.dev/e/a11y_aria_activedescendant_has_tabindex");
		}
		function Ne(e, t) {
			qe(e, "a11y_aria_attributes", `\`<${t}>\` should not have aria-* attributes\nhttps://svelte.dev/e/a11y_aria_attributes`);
		}
		function De(e) {
			qe(e, "a11y_autofocus", "Avoid using autofocus\nhttps://svelte.dev/e/a11y_autofocus");
		}
		function je(e, t) {
			qe(e, "a11y_hidden", `\`<${t}>\` element should not be hidden\nhttps://svelte.dev/e/a11y_hidden`);
		}
		function Be(e, t, n) {
			qe(e, "a11y_incorrect_aria_attribute_type", `The value of '${t}' must be a ${n}\nhttps://svelte.dev/e/a11y_incorrect_aria_attribute_type`);
		}
		function Fe(e, t) {
			qe(e, "a11y_interactive_supports_focus", `Elements with the '${t}' interactive role must have a tabindex value\nhttps://svelte.dev/e/a11y_interactive_supports_focus`);
		}
		function Ve(e, t) {
			qe(e, "a11y_misplaced_role", `\`<${t}>\` should not have role attribute\nhttps://svelte.dev/e/a11y_misplaced_role`);
		}
		function He(e) {
			qe(e, "a11y_misplaced_scope", "The scope attribute should only be used with `<th>` elements\nhttps://svelte.dev/e/a11y_misplaced_scope");
		}
		function Ue(e, t, n) {
			qe(e, "a11y_mouse_events_have_key_events", `'${t}' event must be accompanied by '${n}' event\nhttps://svelte.dev/e/a11y_mouse_events_have_key_events`);
		}
		function ze(e, t) {
			qe(e, "a11y_no_abstract_role", `Abstract role '${t}' is forbidden\nhttps://svelte.dev/e/a11y_no_abstract_role`);
		}
		function We(e, t, n) {
			qe(e, "a11y_no_interactive_element_to_noninteractive_role", `\`<${t}>\` cannot have role '${n}'\nhttps://svelte.dev/e/a11y_no_interactive_element_to_noninteractive_role`);
		}
		function Ge(e, t, n) {
			qe(e, "a11y_no_noninteractive_element_to_interactive_role", `Non-interactive element \`<${t}>\` cannot have interactive role '${n}'\nhttps://svelte.dev/e/a11y_no_noninteractive_element_to_interactive_role`);
		}
		function Ke(e, t) {
			qe(e, "a11y_no_redundant_roles", `Redundant role '${t}'\nhttps://svelte.dev/e/a11y_no_redundant_roles`);
		}
		function Xe(e) {
			qe(e, "a11y_positive_tabindex", "Avoid tabindex values above zero\nhttps://svelte.dev/e/a11y_positive_tabindex");
		}
		function Qe(e, t, n) {
			qe(e, "a11y_role_has_required_aria_props", `Elements with the ARIA role "${t}" must have the following attributes defined: ${n}\nhttps://svelte.dev/e/a11y_role_has_required_aria_props`);
		}
		function Ye(e, t, n) {
			qe(e, "a11y_role_supports_aria_props", `The attribute '${t}' is not supported by the role '${n}'\nhttps://svelte.dev/e/a11y_role_supports_aria_props`);
		}
		function Je(e, t, n, s) {
			qe(e, "a11y_role_supports_aria_props_implicit", `The attribute '${t}' is not supported by the role '${n}'. This role is implicit on the element \`<${s}>\`\nhttps://svelte.dev/e/a11y_role_supports_aria_props_implicit`);
		}
		function Ze(e, t, n) {
			qe(e, "a11y_unknown_aria_attribute", (n ? `Unknown aria attribute 'aria-${t}'. Did you mean '${n}'?` : `Unknown aria attribute 'aria-${t}'`) + "\nhttps://svelte.dev/e/a11y_unknown_aria_attribute");
		}
		function et(e, t, n) {
			qe(e, "a11y_unknown_role", (n ? `Unknown role '${t}'. Did you mean '${n}'?` : `Unknown role '${t}'`) + "\nhttps://svelte.dev/e/a11y_unknown_role");
		}
		function tt(e) {
			qe(e, "bidirectional_control_characters", "A bidirectional control character was detected in your code. These characters can be used to alter the visual direction of your code and could have unintended consequences\nhttps://svelte.dev/e/bidirectional_control_characters");
		}
		function nt(e, t, n) {
			qe(e, "legacy_code", `\`${t}\` is no longer valid — please use \`${n}\` instead\nhttps://svelte.dev/e/legacy_code`);
		}
		function st(e, t, n) {
			qe(e, "unknown_code", (n ? `\`${t}\` is not a recognised code (did you mean \`${n}\`?)` : `\`${t}\` is not a recognised code`) + "\nhttps://svelte.dev/e/unknown_code");
		}
		function rt(e) {
			qe(e, "options_deprecated_accessors", "The `accessors` option has been deprecated. It will have no effect in runes mode\nhttps://svelte.dev/e/options_deprecated_accessors");
		}
		function at(e) {
			qe(e, "options_deprecated_immutable", "The `immutable` option has been deprecated. It will have no effect in runes mode\nhttps://svelte.dev/e/options_deprecated_immutable");
		}
		function it(e) {
			qe(e, "options_missing_custom_element", "The `customElement` option is used when generating a custom element. Did you forget the `customElement: true` compile option?\nhttps://svelte.dev/e/options_missing_custom_element");
		}
		function ot(e) {
			qe(e, "options_renamed_ssr_dom", "`generate: \"dom\"` and `generate: \"ssr\"` options have been renamed to \"client\" and \"server\" respectively\nhttps://svelte.dev/e/options_renamed_ssr_dom");
		}
		function lt(e, t) {
			qe(e, "export_let_unused", `Component has unused export property '${t}'. If it is for external reference only, please consider using \`export const ${t}\`\nhttps://svelte.dev/e/export_let_unused`);
		}
		function ct(e, t) {
			qe(e, "non_reactive_update", `\`${t}\` is updated, but is not declared with \`$state(...)\`. Changing its value will not correctly trigger updates\nhttps://svelte.dev/e/non_reactive_update`);
		}
		function pt(e, t) {
			qe(e, "store_rune_conflict", `It looks like you're using the \`$${t}\` rune, but there is a local binding called \`${t}\`. Referencing a local variable with a \`$\` prefix will create a store subscription. Please rename \`${t}\` to avoid the ambiguity\nhttps://svelte.dev/e/store_rune_conflict`);
		}
		function ut(e) {
			qe(e, "attribute_avoid_is", "The \"is\" attribute is not supported cross-browser and should be avoided\nhttps://svelte.dev/e/attribute_avoid_is");
		}
		function dt(e, t) {
			qe(e, "attribute_global_event_reference", `You are referencing \`globalThis.${t}\`. Did you forget to declare a variable with that name?\nhttps://svelte.dev/e/attribute_global_event_reference`);
		}
		function ht(e, t, n) {
			qe(e, "attribute_invalid_property_name", `'${t}' is not a valid HTML attribute. Did you mean '${n}'?\nhttps://svelte.dev/e/attribute_invalid_property_name`);
		}
		function mt(e, t, n) {
			qe(e, "element_implicitly_closed", `This element is implicitly closed by the following \`${t}\`, which can cause an unexpected DOM structure. Add an explicit \`${n}\` to avoid surprises.\nhttps://svelte.dev/e/element_implicitly_closed`);
		}
		function ft(e, t) {
			qe(e, "node_invalid_placement_ssr", `${t}. When rendering this component on the server, the resulting HTML will be modified by the browser (by moving, removing, or inserting elements), likely resulting in a \`hydration_mismatch\` warning\nhttps://svelte.dev/e/node_invalid_placement_ssr`);
		}
		function yt(e) {
			qe(e, "script_unknown_attribute", "Unrecognized attribute — should be one of `generics`, `lang` or `module`. If this exists for a preprocessor, ensure that the preprocessor removes it\nhttps://svelte.dev/e/script_unknown_attribute");
		}
		const vt = /^\s*svelte-ignore\s/, gt = {
			"non-top-level-reactive-declaration": "reactive_declaration_invalid_placement",
			"module-script-reactive-declaration": "reactive_declaration_module_script",
			"empty-block": "block_empty",
			"avoid-is": "attribute_avoid_is",
			"invalid-html-attribute": "attribute_invalid_property_name",
			"a11y-structure": "a11y_figcaption_parent",
			"illegal-attribute-character": "attribute_illegal_colon",
			"invalid-rest-eachblock-binding": "bind_invalid_each_rest",
			"unused-export-let": "export_let_unused"
		}, bt = [
			"a11y_accesskey",
			"a11y_aria_activedescendant_has_tabindex",
			"a11y_aria_attributes",
			"a11y_autocomplete_valid",
			"a11y_autofocus",
			"a11y_click_events_have_key_events",
			"a11y_consider_explicit_label",
			"a11y_distracting_elements",
			"a11y_figcaption_index",
			"a11y_figcaption_parent",
			"a11y_hidden",
			"a11y_img_redundant_alt",
			"a11y_incorrect_aria_attribute_type",
			"a11y_incorrect_aria_attribute_type_boolean",
			"a11y_incorrect_aria_attribute_type_id",
			"a11y_incorrect_aria_attribute_type_idlist",
			"a11y_incorrect_aria_attribute_type_integer",
			"a11y_incorrect_aria_attribute_type_token",
			"a11y_incorrect_aria_attribute_type_tokenlist",
			"a11y_incorrect_aria_attribute_type_tristate",
			"a11y_interactive_supports_focus",
			"a11y_invalid_attribute",
			"a11y_label_has_associated_control",
			"a11y_media_has_caption",
			"a11y_misplaced_role",
			"a11y_misplaced_scope",
			"a11y_missing_attribute",
			"a11y_missing_content",
			"a11y_mouse_events_have_key_events",
			"a11y_no_abstract_role",
			"a11y_no_interactive_element_to_noninteractive_role",
			"a11y_no_noninteractive_element_interactions",
			"a11y_no_noninteractive_element_to_interactive_role",
			"a11y_no_noninteractive_tabindex",
			"a11y_no_redundant_roles",
			"a11y_no_static_element_interactions",
			"a11y_positive_tabindex",
			"a11y_role_has_required_aria_props",
			"a11y_role_supports_aria_props",
			"a11y_role_supports_aria_props_implicit",
			"a11y_unknown_aria_attribute",
			"a11y_unknown_role",
			"bidirectional_control_characters",
			"legacy_code",
			"unknown_code",
			"options_deprecated_accessors",
			"options_deprecated_immutable",
			"options_missing_custom_element",
			"options_removed_enable_sourcemap",
			"options_removed_hydratable",
			"options_removed_loop_guard_timeout",
			"options_renamed_ssr_dom",
			"custom_element_props_identifier",
			"export_let_unused",
			"legacy_component_creation",
			"non_reactive_update",
			"perf_avoid_inline_class",
			"perf_avoid_nested_class",
			"reactive_declaration_invalid_placement",
			"reactive_declaration_module_script_dependency",
			"state_referenced_locally",
			"store_rune_conflict",
			"css_unused_selector",
			"attribute_avoid_is",
			"attribute_global_event_reference",
			"attribute_illegal_colon",
			"attribute_invalid_property_name",
			"attribute_quoted",
			"bind_invalid_each_rest",
			"block_empty",
			"component_name_lowercase",
			"element_implicitly_closed",
			"element_invalid_self_closing_tag",
			"event_directive_deprecated",
			"node_invalid_placement_ssr",
			"script_context_deprecated",
			"script_unknown_attribute",
			"slot_element_deprecated",
			"svelte_component_deprecated",
			"svelte_element_invalid_this",
			"svelte_self_deprecated"
		].concat([
			"await_waterfall",
			"await_reactivity_loss",
			"state_snapshot_uncloneable",
			"binding_property_non_reactive",
			"hydration_attribute_changed",
			"hydration_html_changed",
			"ownership_invalid_binding",
			"ownership_invalid_mutation"
		]);
		function _t(e, t, n) {
			const s = vt.exec(t);
			if (!s) return [];
			let r = s[0].length;
			e += r;
			const a = [];
			if (n) for (const n of t.slice(r).matchAll(/([\w$-]+)(,)?/gm)) {
				const t = n[1];
				if (bt.includes(t)) a.push(t);
				else {
					const s = gt[t] ?? t.replace(/-/g, "_"), r = e + n.index, a = r + t.length;
					if (bt.includes(s)) nt({
						start: r,
						end: a
					}, t, s);
					else st({
						start: r,
						end: a
					}, t, q(t, bt));
				}
				if (!n[2]) break;
			}
			else for (const e of t.slice(r).matchAll(/[\w$-]+/gm)) {
				const t = e[0];
				if (a.push(t), !bt.includes(t)) {
					const e = gt[t] ?? t.replace(/-/g, "_");
					bt.includes(e) && a.push(e);
				}
			}
			return a;
		}
		function xt(e) {
			const t = vt.exec(e);
			if (!t) return e;
			const n = t[0].length;
			return e.substring(0, n) + e.substring(n).replace(/\w+-\w+(-\w+)*/g, ((t, s, r) => {
				let a = gt[t] ?? t.replace(/-/g, "_");
				return /\w+-\w+/.test(e.substring(n + r + t.length)) && (a += ","), a;
			}));
		}
		function wt(e) {
			const t = e.at(0), n = e.at(-1);
			"Text" === t?.type && (p.test(t.data) ? t.data = t.data.replace(o, "") : e.shift()), "Text" === n?.type && (p.test(n.data) ? n.data = n.data.replace(c, "") : e.pop());
		}
		var kt = [
			509,
			0,
			227,
			0,
			150,
			4,
			294,
			9,
			1368,
			2,
			2,
			1,
			6,
			3,
			41,
			2,
			5,
			0,
			166,
			1,
			574,
			3,
			9,
			9,
			7,
			9,
			32,
			4,
			318,
			1,
			80,
			3,
			71,
			10,
			50,
			3,
			123,
			2,
			54,
			14,
			32,
			10,
			3,
			1,
			11,
			3,
			46,
			10,
			8,
			0,
			46,
			9,
			7,
			2,
			37,
			13,
			2,
			9,
			6,
			1,
			45,
			0,
			13,
			2,
			49,
			13,
			9,
			3,
			2,
			11,
			83,
			11,
			7,
			0,
			3,
			0,
			158,
			11,
			6,
			9,
			7,
			3,
			56,
			1,
			2,
			6,
			3,
			1,
			3,
			2,
			10,
			0,
			11,
			1,
			3,
			6,
			4,
			4,
			68,
			8,
			2,
			0,
			3,
			0,
			2,
			3,
			2,
			4,
			2,
			0,
			15,
			1,
			83,
			17,
			10,
			9,
			5,
			0,
			82,
			19,
			13,
			9,
			214,
			6,
			3,
			8,
			28,
			1,
			83,
			16,
			16,
			9,
			82,
			12,
			9,
			9,
			7,
			19,
			58,
			14,
			5,
			9,
			243,
			14,
			166,
			9,
			71,
			5,
			2,
			1,
			3,
			3,
			2,
			0,
			2,
			1,
			13,
			9,
			120,
			6,
			3,
			6,
			4,
			0,
			29,
			9,
			41,
			6,
			2,
			3,
			9,
			0,
			10,
			10,
			47,
			15,
			343,
			9,
			54,
			7,
			2,
			7,
			17,
			9,
			57,
			21,
			2,
			13,
			123,
			5,
			4,
			0,
			2,
			1,
			2,
			6,
			2,
			0,
			9,
			9,
			49,
			4,
			2,
			1,
			2,
			4,
			9,
			9,
			330,
			3,
			10,
			1,
			2,
			0,
			49,
			6,
			4,
			4,
			14,
			10,
			5350,
			0,
			7,
			14,
			11465,
			27,
			2343,
			9,
			87,
			9,
			39,
			4,
			60,
			6,
			26,
			9,
			535,
			9,
			470,
			0,
			2,
			54,
			8,
			3,
			82,
			0,
			12,
			1,
			19628,
			1,
			4178,
			9,
			519,
			45,
			3,
			22,
			543,
			4,
			4,
			5,
			9,
			7,
			3,
			6,
			31,
			3,
			149,
			2,
			1418,
			49,
			513,
			54,
			5,
			49,
			9,
			0,
			15,
			0,
			23,
			4,
			2,
			14,
			1361,
			6,
			2,
			16,
			3,
			6,
			2,
			1,
			2,
			4,
			101,
			0,
			161,
			6,
			10,
			9,
			357,
			0,
			62,
			13,
			499,
			13,
			245,
			1,
			2,
			9,
			726,
			6,
			110,
			6,
			6,
			9,
			4759,
			9,
			787719,
			239
		], Ct = [
			0,
			11,
			2,
			25,
			2,
			18,
			2,
			1,
			2,
			14,
			3,
			13,
			35,
			122,
			70,
			52,
			268,
			28,
			4,
			48,
			48,
			31,
			14,
			29,
			6,
			37,
			11,
			29,
			3,
			35,
			5,
			7,
			2,
			4,
			43,
			157,
			19,
			35,
			5,
			35,
			5,
			39,
			9,
			51,
			13,
			10,
			2,
			14,
			2,
			6,
			2,
			1,
			2,
			10,
			2,
			14,
			2,
			6,
			2,
			1,
			4,
			51,
			13,
			310,
			10,
			21,
			11,
			7,
			25,
			5,
			2,
			41,
			2,
			8,
			70,
			5,
			3,
			0,
			2,
			43,
			2,
			1,
			4,
			0,
			3,
			22,
			11,
			22,
			10,
			30,
			66,
			18,
			2,
			1,
			11,
			21,
			11,
			25,
			71,
			55,
			7,
			1,
			65,
			0,
			16,
			3,
			2,
			2,
			2,
			28,
			43,
			28,
			4,
			28,
			36,
			7,
			2,
			27,
			28,
			53,
			11,
			21,
			11,
			18,
			14,
			17,
			111,
			72,
			56,
			50,
			14,
			50,
			14,
			35,
			39,
			27,
			10,
			22,
			251,
			41,
			7,
			1,
			17,
			2,
			60,
			28,
			11,
			0,
			9,
			21,
			43,
			17,
			47,
			20,
			28,
			22,
			13,
			52,
			58,
			1,
			3,
			0,
			14,
			44,
			33,
			24,
			27,
			35,
			30,
			0,
			3,
			0,
			9,
			34,
			4,
			0,
			13,
			47,
			15,
			3,
			22,
			0,
			2,
			0,
			36,
			17,
			2,
			24,
			20,
			1,
			64,
			6,
			2,
			0,
			2,
			3,
			2,
			14,
			2,
			9,
			8,
			46,
			39,
			7,
			3,
			1,
			3,
			21,
			2,
			6,
			2,
			1,
			2,
			4,
			4,
			0,
			19,
			0,
			13,
			4,
			31,
			9,
			2,
			0,
			3,
			0,
			2,
			37,
			2,
			0,
			26,
			0,
			2,
			0,
			45,
			52,
			19,
			3,
			21,
			2,
			31,
			47,
			21,
			1,
			2,
			0,
			185,
			46,
			42,
			3,
			37,
			47,
			21,
			0,
			60,
			42,
			14,
			0,
			72,
			26,
			38,
			6,
			186,
			43,
			117,
			63,
			32,
			7,
			3,
			0,
			3,
			7,
			2,
			1,
			2,
			23,
			16,
			0,
			2,
			0,
			95,
			7,
			3,
			38,
			17,
			0,
			2,
			0,
			29,
			0,
			11,
			39,
			8,
			0,
			22,
			0,
			12,
			45,
			20,
			0,
			19,
			72,
			200,
			32,
			32,
			8,
			2,
			36,
			18,
			0,
			50,
			29,
			113,
			6,
			2,
			1,
			2,
			37,
			22,
			0,
			26,
			5,
			2,
			1,
			2,
			31,
			15,
			0,
			328,
			18,
			16,
			0,
			2,
			12,
			2,
			33,
			125,
			0,
			80,
			921,
			103,
			110,
			18,
			195,
			2637,
			96,
			16,
			1071,
			18,
			5,
			26,
			3994,
			6,
			582,
			6842,
			29,
			1763,
			568,
			8,
			30,
			18,
			78,
			18,
			29,
			19,
			47,
			17,
			3,
			32,
			20,
			6,
			18,
			433,
			44,
			212,
			63,
			129,
			74,
			6,
			0,
			67,
			12,
			65,
			1,
			2,
			0,
			29,
			6135,
			9,
			1237,
			42,
			9,
			8936,
			3,
			2,
			6,
			2,
			1,
			2,
			290,
			16,
			0,
			30,
			2,
			3,
			0,
			15,
			3,
			9,
			395,
			2309,
			106,
			6,
			12,
			4,
			8,
			8,
			9,
			5991,
			84,
			2,
			70,
			2,
			1,
			3,
			0,
			3,
			1,
			3,
			3,
			2,
			11,
			2,
			0,
			2,
			6,
			2,
			64,
			2,
			3,
			3,
			7,
			2,
			6,
			2,
			27,
			2,
			3,
			2,
			4,
			2,
			0,
			4,
			6,
			2,
			339,
			3,
			24,
			2,
			24,
			2,
			30,
			2,
			24,
			2,
			30,
			2,
			24,
			2,
			30,
			2,
			24,
			2,
			30,
			2,
			24,
			2,
			7,
			1845,
			30,
			7,
			5,
			262,
			61,
			147,
			44,
			11,
			6,
			17,
			0,
			322,
			29,
			19,
			43,
			485,
			27,
			229,
			29,
			3,
			0,
			496,
			6,
			2,
			3,
			2,
			1,
			2,
			14,
			2,
			196,
			60,
			67,
			8,
			0,
			1205,
			3,
			2,
			26,
			2,
			1,
			2,
			0,
			3,
			0,
			2,
			9,
			2,
			3,
			2,
			0,
			2,
			0,
			7,
			0,
			5,
			0,
			2,
			0,
			2,
			0,
			2,
			2,
			2,
			1,
			2,
			0,
			3,
			0,
			2,
			0,
			2,
			0,
			2,
			0,
			2,
			0,
			2,
			1,
			2,
			0,
			3,
			3,
			2,
			6,
			2,
			3,
			2,
			3,
			2,
			0,
			2,
			9,
			2,
			16,
			6,
			2,
			2,
			4,
			2,
			16,
			4421,
			42719,
			33,
			4153,
			7,
			221,
			3,
			5761,
			15,
			7472,
			16,
			621,
			2467,
			541,
			1507,
			4938,
			6,
			4191
		], St = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲊᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟍꟐꟑꟓꟕ-Ƛꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ", Pt = {
			3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
			5: "class enum extends super const export import",
			6: "enum",
			strict: "implements interface let package private protected public static yield",
			strictBind: "eval arguments"
		}, Et = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this", Tt = {
			5: Et,
			"5module": Et + " export import",
			6: Et + " const class extends export import super"
		}, At = /^in(stanceof)?$/, $t = new RegExp("[" + St + "]"), Rt = new RegExp("[" + St + "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛ࢗ-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‌‍‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯・꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿･]");
		function It(e, t) {
			for (var n = 65536, s = 0; s < t.length; s += 2) {
				if ((n += t[s]) > e) return !1;
				if ((n += t[s + 1]) >= e) return !0;
			}
			return !1;
		}
		function Mt(e, t) {
			return e < 65 ? 36 === e : e < 91 || (e < 97 ? 95 === e : e < 123 || (e <= 65535 ? e >= 170 && $t.test(String.fromCharCode(e)) : !1 !== t && It(e, Ct)));
		}
		function qt(e, t) {
			return e < 48 ? 36 === e : e < 58 || !(e < 65) && (e < 91 || (e < 97 ? 95 === e : e < 123 || (e <= 65535 ? e >= 170 && Rt.test(String.fromCharCode(e)) : !1 !== t && (It(e, Ct) || It(e, kt)))));
		}
		var Lt = function(e, t) {
			void 0 === t && (t = {}), this.label = e, this.keyword = t.keyword, this.beforeExpr = !!t.beforeExpr, this.startsExpr = !!t.startsExpr, this.isLoop = !!t.isLoop, this.isAssign = !!t.isAssign, this.prefix = !!t.prefix, this.postfix = !!t.postfix, this.binop = t.binop || null, this.updateContext = null;
		};
		function Ot(e, t) {
			return new Lt(e, {
				beforeExpr: !0,
				binop: t
			});
		}
		var Nt = { beforeExpr: !0 }, Dt = { startsExpr: !0 }, jt = {};
		function Bt(e, t) {
			return void 0 === t && (t = {}), t.keyword = e, jt[e] = new Lt(e, t);
		}
		var Ft = {
			num: new Lt("num", Dt),
			regexp: new Lt("regexp", Dt),
			string: new Lt("string", Dt),
			name: new Lt("name", Dt),
			privateId: new Lt("privateId", Dt),
			eof: new Lt("eof"),
			bracketL: new Lt("[", {
				beforeExpr: !0,
				startsExpr: !0
			}),
			bracketR: new Lt("]"),
			braceL: new Lt("{", {
				beforeExpr: !0,
				startsExpr: !0
			}),
			braceR: new Lt("}"),
			parenL: new Lt("(", {
				beforeExpr: !0,
				startsExpr: !0
			}),
			parenR: new Lt(")"),
			comma: new Lt(",", Nt),
			semi: new Lt(";", Nt),
			colon: new Lt(":", Nt),
			dot: new Lt("."),
			question: new Lt("?", Nt),
			questionDot: new Lt("?."),
			arrow: new Lt("=>", Nt),
			template: new Lt("template"),
			invalidTemplate: new Lt("invalidTemplate"),
			ellipsis: new Lt("...", Nt),
			backQuote: new Lt("`", Dt),
			dollarBraceL: new Lt("${", {
				beforeExpr: !0,
				startsExpr: !0
			}),
			eq: new Lt("=", {
				beforeExpr: !0,
				isAssign: !0
			}),
			assign: new Lt("_=", {
				beforeExpr: !0,
				isAssign: !0
			}),
			incDec: new Lt("++/--", {
				prefix: !0,
				postfix: !0,
				startsExpr: !0
			}),
			prefix: new Lt("!/~", {
				beforeExpr: !0,
				prefix: !0,
				startsExpr: !0
			}),
			logicalOR: Ot("||", 1),
			logicalAND: Ot("&&", 2),
			bitwiseOR: Ot("|", 3),
			bitwiseXOR: Ot("^", 4),
			bitwiseAND: Ot("&", 5),
			equality: Ot("==/!=/===/!==", 6),
			relational: Ot("</>/<=/>=", 7),
			bitShift: Ot("<</>>/>>>", 8),
			plusMin: new Lt("+/-", {
				beforeExpr: !0,
				binop: 9,
				prefix: !0,
				startsExpr: !0
			}),
			modulo: Ot("%", 10),
			star: Ot("*", 10),
			slash: Ot("/", 10),
			starstar: new Lt("**", { beforeExpr: !0 }),
			coalesce: Ot("??", 1),
			_break: Bt("break"),
			_case: Bt("case", Nt),
			_catch: Bt("catch"),
			_continue: Bt("continue"),
			_debugger: Bt("debugger"),
			_default: Bt("default", Nt),
			_do: Bt("do", {
				isLoop: !0,
				beforeExpr: !0
			}),
			_else: Bt("else", Nt),
			_finally: Bt("finally"),
			_for: Bt("for", { isLoop: !0 }),
			_function: Bt("function", Dt),
			_if: Bt("if"),
			_return: Bt("return", Nt),
			_switch: Bt("switch"),
			_throw: Bt("throw", Nt),
			_try: Bt("try"),
			_var: Bt("var"),
			_const: Bt("const"),
			_while: Bt("while", { isLoop: !0 }),
			_with: Bt("with"),
			_new: Bt("new", {
				beforeExpr: !0,
				startsExpr: !0
			}),
			_this: Bt("this", Dt),
			_super: Bt("super", Dt),
			_class: Bt("class", Dt),
			_extends: Bt("extends", Nt),
			_export: Bt("export"),
			_import: Bt("import", Dt),
			_null: Bt("null", Dt),
			_true: Bt("true", Dt),
			_false: Bt("false", Dt),
			_in: Bt("in", {
				beforeExpr: !0,
				binop: 7
			}),
			_instanceof: Bt("instanceof", {
				beforeExpr: !0,
				binop: 7
			}),
			_typeof: Bt("typeof", {
				beforeExpr: !0,
				prefix: !0,
				startsExpr: !0
			}),
			_void: Bt("void", {
				beforeExpr: !0,
				prefix: !0,
				startsExpr: !0
			}),
			_delete: Bt("delete", {
				beforeExpr: !0,
				prefix: !0,
				startsExpr: !0
			})
		}, Vt = /\r\n?|\n|\u2028|\u2029/, Ht = new RegExp(Vt.source, "g");
		function Ut(e) {
			return 10 === e || 13 === e || 8232 === e || 8233 === e;
		}
		function zt(e, t, n) {
			void 0 === n && (n = e.length);
			for (var s = t; s < n; s++) {
				var r = e.charCodeAt(s);
				if (Ut(r)) return s < n - 1 && 13 === r && 10 === e.charCodeAt(s + 1) ? s + 2 : s + 1;
			}
			return -1;
		}
		var Wt = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/, Gt = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, Kt = Object.prototype, Xt = Kt.hasOwnProperty, Qt = Kt.toString, Yt = Object.hasOwn || function(e, t) {
			return Xt.call(e, t);
		}, Jt = Array.isArray || function(e) {
			return "[object Array]" === Qt.call(e);
		}, Zt = Object.create(null);
		function en(e) {
			return Zt[e] || (Zt[e] = new RegExp("^(?:" + e.replace(/ /g, "|") + ")$"));
		}
		function tn(e) {
			return e <= 65535 ? String.fromCharCode(e) : (e -= 65536, String.fromCharCode(55296 + (e >> 10), 56320 + (1023 & e)));
		}
		var nn = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/, sn = function(e, t) {
			this.line = e, this.column = t;
		};
		sn.prototype.offset = function(e) {
			return new sn(this.line, this.column + e);
		};
		var rn = function(e, t, n) {
			this.start = t, this.end = n, null !== e.sourceFile && (this.source = e.sourceFile);
		};
		function an(e, t) {
			for (var n = 1, s = 0;;) {
				var r = zt(e, s, t);
				if (r < 0) return new sn(n, t - s);
				++n, s = r;
			}
		}
		var on = {
			ecmaVersion: null,
			sourceType: "script",
			onInsertedSemicolon: null,
			onTrailingComma: null,
			allowReserved: null,
			allowReturnOutsideFunction: !1,
			allowImportExportEverywhere: !1,
			allowAwaitOutsideFunction: null,
			allowSuperOutsideMethod: null,
			allowHashBang: !1,
			checkPrivateFields: !0,
			locations: !1,
			onToken: null,
			onComment: null,
			ranges: !1,
			program: null,
			sourceFile: null,
			directSourceFile: null,
			preserveParens: !1
		}, ln = !1;
		function cn(e) {
			var t = {};
			for (var n in on) t[n] = e && Yt(e, n) ? e[n] : on[n];
			if ("latest" === t.ecmaVersion ? t.ecmaVersion = 1e8 : null == t.ecmaVersion ? (!ln && "object" == typeof console && console.warn && (ln = !0, console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.")), t.ecmaVersion = 11) : t.ecmaVersion >= 2015 && (t.ecmaVersion -= 2009), t.allowReserved ??= t.ecmaVersion < 5, e && null != e.allowHashBang || (t.allowHashBang = t.ecmaVersion >= 14), Jt(t.onToken)) {
				var s = t.onToken;
				t.onToken = function(e) {
					return s.push(e);
				};
			}
			return Jt(t.onComment) && (t.onComment = function(e, t) {
				return function(n, s, r, a, i, o) {
					var l = {
						type: n ? "Block" : "Line",
						value: s,
						start: r,
						end: a
					};
					e.locations && (l.loc = new rn(this, i, o)), e.ranges && (l.range = [r, a]), t.push(l);
				};
			}(t, t.onComment)), t;
		}
		var pn = 256, un = 259;
		function dn(e, t) {
			return 2 | (e ? 4 : 0) | (t ? 8 : 0);
		}
		var hn = function(e, t, n) {
			this.options = e = cn(e), this.sourceFile = e.sourceFile, this.keywords = en(Tt[e.ecmaVersion >= 6 ? 6 : "module" === e.sourceType ? "5module" : 5]);
			var s = "";
			!0 !== e.allowReserved && (s = Pt[e.ecmaVersion >= 6 ? 6 : 5 === e.ecmaVersion ? 5 : 3], "module" === e.sourceType && (s += " await")), this.reservedWords = en(s);
			var r = (s ? s + " " : "") + Pt.strict;
			this.reservedWordsStrict = en(r), this.reservedWordsStrictBind = en(r + " " + Pt.strictBind), this.input = String(t), this.containsEsc = !1, n ? (this.pos = n, this.lineStart = this.input.lastIndexOf("\n", n - 1) + 1, this.curLine = this.input.slice(0, this.lineStart).split(Vt).length) : (this.pos = this.lineStart = 0, this.curLine = 1), this.type = Ft.eof, this.value = null, this.start = this.end = this.pos, this.startLoc = this.endLoc = this.curPosition(), this.lastTokEndLoc = this.lastTokStartLoc = null, this.lastTokStart = this.lastTokEnd = this.pos, this.context = this.initialContext(), this.exprAllowed = !0, this.inModule = "module" === e.sourceType, this.strict = this.inModule || this.strictDirective(this.pos), this.potentialArrowAt = -1, this.potentialArrowInForAwait = !1, this.yieldPos = this.awaitPos = this.awaitIdentPos = 0, this.labels = [], this.undefinedExports = Object.create(null), 0 === this.pos && e.allowHashBang && "#!" === this.input.slice(0, 2) && this.skipLineComment(2), this.scopeStack = [], this.enterScope(1), this.regexpState = null, this.privateNameStack = [];
		}, mn = {
			inFunction: { configurable: !0 },
			inGenerator: { configurable: !0 },
			inAsync: { configurable: !0 },
			canAwait: { configurable: !0 },
			allowSuper: { configurable: !0 },
			allowDirectSuper: { configurable: !0 },
			treatFunctionsAsVar: { configurable: !0 },
			allowNewDotTarget: { configurable: !0 },
			inClassStaticBlock: { configurable: !0 }
		};
		hn.prototype.parse = function() {
			var e = this.options.program || this.startNode();
			return this.nextToken(), this.parseTopLevel(e);
		}, mn.inFunction.get = function() {
			return (2 & this.currentVarScope().flags) > 0;
		}, mn.inGenerator.get = function() {
			return (8 & this.currentVarScope().flags) > 0;
		}, mn.inAsync.get = function() {
			return (4 & this.currentVarScope().flags) > 0;
		}, mn.canAwait.get = function() {
			for (var e = this.scopeStack.length - 1; e >= 0; e--) {
				var t = this.scopeStack[e].flags;
				if (768 & t) return !1;
				if (2 & t) return (4 & t) > 0;
			}
			return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
		}, mn.allowSuper.get = function() {
			return (64 & this.currentThisScope().flags) > 0 || this.options.allowSuperOutsideMethod;
		}, mn.allowDirectSuper.get = function() {
			return (128 & this.currentThisScope().flags) > 0;
		}, mn.treatFunctionsAsVar.get = function() {
			return this.treatFunctionsAsVarInScope(this.currentScope());
		}, mn.allowNewDotTarget.get = function() {
			for (var e = this.scopeStack.length - 1; e >= 0; e--) {
				var t = this.scopeStack[e].flags;
				if (768 & t || 2 & t && !(16 & t)) return !0;
			}
			return !1;
		}, mn.inClassStaticBlock.get = function() {
			return (this.currentVarScope().flags & pn) > 0;
		}, hn.extend = function() {
			for (var e = [], t = arguments.length; t--;) e[t] = arguments[t];
			for (var n = this, s = 0; s < e.length; s++) n = e[s](n);
			return n;
		}, hn.parse = function(e, t) {
			return new this(t, e).parse();
		}, hn.parseExpressionAt = function(e, t, n) {
			var s = new this(n, e, t);
			return s.nextToken(), s.parseExpression();
		}, hn.tokenizer = function(e, t) {
			return new this(t, e);
		}, Object.defineProperties(hn.prototype, mn);
		var fn = hn.prototype, yn = /^(?:'((?:\\[^]|[^'\\])*?)'|"((?:\\[^]|[^"\\])*?)")/;
		fn.strictDirective = function(e) {
			if (this.options.ecmaVersion < 5) return !1;
			for (;;) {
				Gt.lastIndex = e, e += Gt.exec(this.input)[0].length;
				var t = yn.exec(this.input.slice(e));
				if (!t) return !1;
				if ("use strict" === (t[1] || t[2])) {
					Gt.lastIndex = e + t[0].length;
					var n = Gt.exec(this.input), s = n.index + n[0].length, r = this.input.charAt(s);
					return ";" === r || "}" === r || Vt.test(n[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(r) || "!" === r && "=" === this.input.charAt(s + 1));
				}
				e += t[0].length, Gt.lastIndex = e, e += Gt.exec(this.input)[0].length, ";" === this.input[e] && e++;
			}
		}, fn.eat = function(e) {
			return this.type === e && (this.next(), !0);
		}, fn.isContextual = function(e) {
			return this.type === Ft.name && this.value === e && !this.containsEsc;
		}, fn.eatContextual = function(e) {
			return !!this.isContextual(e) && (this.next(), !0);
		}, fn.expectContextual = function(e) {
			this.eatContextual(e) || this.unexpected();
		}, fn.canInsertSemicolon = function() {
			return this.type === Ft.eof || this.type === Ft.braceR || Vt.test(this.input.slice(this.lastTokEnd, this.start));
		}, fn.insertSemicolon = function() {
			if (this.canInsertSemicolon()) return this.options.onInsertedSemicolon && this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc), !0;
		}, fn.semicolon = function() {
			this.eat(Ft.semi) || this.insertSemicolon() || this.unexpected();
		}, fn.afterTrailingComma = function(e, t) {
			if (this.type === e) return this.options.onTrailingComma && this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc), t || this.next(), !0;
		}, fn.expect = function(e) {
			this.eat(e) || this.unexpected();
		}, fn.unexpected = function(e) {
			this.raise(null != e ? e : this.start, "Unexpected token");
		};
		var vn = function() {
			this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
		};
		fn.checkPatternErrors = function(e, t) {
			if (e) {
				e.trailingComma > -1 && this.raiseRecoverable(e.trailingComma, "Comma is not permitted after the rest element");
				var n = t ? e.parenthesizedAssign : e.parenthesizedBind;
				n > -1 && this.raiseRecoverable(n, t ? "Assigning to rvalue" : "Parenthesized pattern");
			}
		}, fn.checkExpressionErrors = function(e, t) {
			if (!e) return !1;
			var n = e.shorthandAssign, s = e.doubleProto;
			if (!t) return n >= 0 || s >= 0;
			n >= 0 && this.raise(n, "Shorthand property assignments are valid only in destructuring patterns"), s >= 0 && this.raiseRecoverable(s, "Redefinition of __proto__ property");
		}, fn.checkYieldAwaitInDefaultParams = function() {
			this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos) && this.raise(this.yieldPos, "Yield expression cannot be a default value"), this.awaitPos && this.raise(this.awaitPos, "Await expression cannot be a default value");
		}, fn.isSimpleAssignTarget = function(e) {
			return "ParenthesizedExpression" === e.type ? this.isSimpleAssignTarget(e.expression) : "Identifier" === e.type || "MemberExpression" === e.type;
		};
		var gn = hn.prototype;
		gn.parseTopLevel = function(e) {
			var t = Object.create(null);
			for (e.body || (e.body = []); this.type !== Ft.eof;) {
				var n = this.parseStatement(null, !0, t);
				e.body.push(n);
			}
			if (this.inModule) for (var s = 0, r = Object.keys(this.undefinedExports); s < r.length; s += 1) {
				var a = r[s];
				this.raiseRecoverable(this.undefinedExports[a].start, "Export '" + a + "' is not defined");
			}
			return this.adaptDirectivePrologue(e.body), this.next(), e.sourceType = this.options.sourceType, this.finishNode(e, "Program");
		};
		var bn = { kind: "loop" }, _n = { kind: "switch" };
		gn.isLet = function(e) {
			if (this.options.ecmaVersion < 6 || !this.isContextual("let")) return !1;
			Gt.lastIndex = this.pos;
			var t = Gt.exec(this.input), n = this.pos + t[0].length, s = this.input.charCodeAt(n);
			if (91 === s || 92 === s) return !0;
			if (e) return !1;
			if (123 === s || s > 55295 && s < 56320) return !0;
			if (Mt(s, !0)) {
				for (var r = n + 1; qt(s = this.input.charCodeAt(r), !0);) ++r;
				if (92 === s || s > 55295 && s < 56320) return !0;
				var a = this.input.slice(n, r);
				if (!At.test(a)) return !0;
			}
			return !1;
		}, gn.isAsyncFunction = function() {
			if (this.options.ecmaVersion < 8 || !this.isContextual("async")) return !1;
			Gt.lastIndex = this.pos;
			var e, t = Gt.exec(this.input), n = this.pos + t[0].length;
			return !(Vt.test(this.input.slice(this.pos, n)) || "function" !== this.input.slice(n, n + 8) || n + 8 !== this.input.length && (qt(e = this.input.charCodeAt(n + 8)) || e > 55295 && e < 56320));
		}, gn.isUsingKeyword = function(e, t) {
			if (this.options.ecmaVersion < 17 || !this.isContextual(e ? "await" : "using")) return !1;
			Gt.lastIndex = this.pos;
			var n = Gt.exec(this.input), s = this.pos + n[0].length;
			if (Vt.test(this.input.slice(this.pos, s))) return !1;
			if (e) {
				var r, a = s + 5;
				if ("using" !== this.input.slice(s, a) || a === this.input.length || qt(r = this.input.charCodeAt(a)) || r > 55295 && r < 56320) return !1;
				Gt.lastIndex = a;
				var i = Gt.exec(this.input);
				if (i && Vt.test(this.input.slice(a, a + i[0].length))) return !1;
			}
			if (t) {
				var o, l = s + 2;
				if (!("of" !== this.input.slice(s, l) || l !== this.input.length && (qt(o = this.input.charCodeAt(l)) || o > 55295 && o < 56320))) return !1;
			}
			var c = this.input.charCodeAt(s);
			return Mt(c, !0) || 92 === c;
		}, gn.isAwaitUsing = function(e) {
			return this.isUsingKeyword(!0, e);
		}, gn.isUsing = function(e) {
			return this.isUsingKeyword(!1, e);
		}, gn.parseStatement = function(e, t, n) {
			var s, r = this.type, a = this.startNode();
			switch (this.isLet(e) && (r = Ft._var, s = "let"), r) {
				case Ft._break:
				case Ft._continue: return this.parseBreakContinueStatement(a, r.keyword);
				case Ft._debugger: return this.parseDebuggerStatement(a);
				case Ft._do: return this.parseDoStatement(a);
				case Ft._for: return this.parseForStatement(a);
				case Ft._function: return e && (this.strict || "if" !== e && "label" !== e) && this.options.ecmaVersion >= 6 && this.unexpected(), this.parseFunctionStatement(a, !1, !e);
				case Ft._class: return e && this.unexpected(), this.parseClass(a, !0);
				case Ft._if: return this.parseIfStatement(a);
				case Ft._return: return this.parseReturnStatement(a);
				case Ft._switch: return this.parseSwitchStatement(a);
				case Ft._throw: return this.parseThrowStatement(a);
				case Ft._try: return this.parseTryStatement(a);
				case Ft._const:
				case Ft._var: return s = s || this.value, e && "var" !== s && this.unexpected(), this.parseVarStatement(a, s);
				case Ft._while: return this.parseWhileStatement(a);
				case Ft._with: return this.parseWithStatement(a);
				case Ft.braceL: return this.parseBlock(!0, a);
				case Ft.semi: return this.parseEmptyStatement(a);
				case Ft._export:
				case Ft._import:
					if (this.options.ecmaVersion > 10 && r === Ft._import) {
						Gt.lastIndex = this.pos;
						var i = Gt.exec(this.input), o = this.pos + i[0].length, l = this.input.charCodeAt(o);
						if (40 === l || 46 === l) return this.parseExpressionStatement(a, this.parseExpression());
					}
					return this.options.allowImportExportEverywhere || (t || this.raise(this.start, "'import' and 'export' may only appear at the top level"), this.inModule || this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'")), r === Ft._import ? this.parseImport(a) : this.parseExport(a, n);
				default:
					if (this.isAsyncFunction()) return e && this.unexpected(), this.next(), this.parseFunctionStatement(a, !0, !e);
					var c = this.isAwaitUsing(!1) ? "await using" : this.isUsing(!1) ? "using" : null;
					if (c) return t && "script" === this.options.sourceType && this.raise(this.start, "Using declaration cannot appear in the top level when source type is `script`"), "await using" === c && (this.canAwait || this.raise(this.start, "Await using cannot appear outside of async function"), this.next()), this.next(), this.parseVar(a, !1, c), this.semicolon(), this.finishNode(a, "VariableDeclaration");
					var p = this.value, u = this.parseExpression();
					return r === Ft.name && "Identifier" === u.type && this.eat(Ft.colon) ? this.parseLabeledStatement(a, p, u, e) : this.parseExpressionStatement(a, u);
			}
		}, gn.parseBreakContinueStatement = function(e, t) {
			var n = "break" === t;
			this.next(), this.eat(Ft.semi) || this.insertSemicolon() ? e.label = null : this.type !== Ft.name ? this.unexpected() : (e.label = this.parseIdent(), this.semicolon());
			for (var s = 0; s < this.labels.length; ++s) {
				var r = this.labels[s];
				if (null == e.label || r.name === e.label.name) {
					if (null != r.kind && (n || "loop" === r.kind)) break;
					if (e.label && n) break;
				}
			}
			return s === this.labels.length && this.raise(e.start, "Unsyntactic " + t), this.finishNode(e, n ? "BreakStatement" : "ContinueStatement");
		}, gn.parseDebuggerStatement = function(e) {
			return this.next(), this.semicolon(), this.finishNode(e, "DebuggerStatement");
		}, gn.parseDoStatement = function(e) {
			return this.next(), this.labels.push(bn), e.body = this.parseStatement("do"), this.labels.pop(), this.expect(Ft._while), e.test = this.parseParenExpression(), this.options.ecmaVersion >= 6 ? this.eat(Ft.semi) : this.semicolon(), this.finishNode(e, "DoWhileStatement");
		}, gn.parseForStatement = function(e) {
			this.next();
			var t = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
			if (this.labels.push(bn), this.enterScope(0), this.expect(Ft.parenL), this.type === Ft.semi) return t > -1 && this.unexpected(t), this.parseFor(e, null);
			var n = this.isLet();
			if (this.type === Ft._var || this.type === Ft._const || n) {
				var s = this.startNode(), r = n ? "let" : this.value;
				return this.next(), this.parseVar(s, !0, r), this.finishNode(s, "VariableDeclaration"), this.parseForAfterInit(e, s, t);
			}
			var a = this.isContextual("let"), i = !1, o = this.isUsing(!0) ? "using" : this.isAwaitUsing(!0) ? "await using" : null;
			if (o) {
				var l = this.startNode();
				return this.next(), "await using" === o && this.next(), this.parseVar(l, !0, o), this.finishNode(l, "VariableDeclaration"), this.parseForAfterInit(e, l, t);
			}
			var c = this.containsEsc, p = new vn(), u = this.start, d = t > -1 ? this.parseExprSubscripts(p, "await") : this.parseExpression(!0, p);
			return this.type === Ft._in || (i = this.options.ecmaVersion >= 6 && this.isContextual("of")) ? (t > -1 ? (this.type === Ft._in && this.unexpected(t), e.await = !0) : i && this.options.ecmaVersion >= 8 && (d.start !== u || c || "Identifier" !== d.type || "async" !== d.name ? this.options.ecmaVersion >= 9 && (e.await = !1) : this.unexpected()), a && i && this.raise(d.start, "The left-hand side of a for-of loop may not start with 'let'."), this.toAssignable(d, !1, p), this.checkLValPattern(d), this.parseForIn(e, d)) : (this.checkExpressionErrors(p, !0), t > -1 && this.unexpected(t), this.parseFor(e, d));
		}, gn.parseForAfterInit = function(e, t, n) {
			return (this.type === Ft._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && 1 === t.declarations.length ? (this.options.ecmaVersion >= 9 && (this.type === Ft._in ? n > -1 && this.unexpected(n) : e.await = n > -1), this.parseForIn(e, t)) : (n > -1 && this.unexpected(n), this.parseFor(e, t));
		}, gn.parseFunctionStatement = function(e, t, n) {
			return this.next(), this.parseFunction(e, wn | (n ? 0 : kn), !1, t);
		}, gn.parseIfStatement = function(e) {
			return this.next(), e.test = this.parseParenExpression(), e.consequent = this.parseStatement("if"), e.alternate = this.eat(Ft._else) ? this.parseStatement("if") : null, this.finishNode(e, "IfStatement");
		}, gn.parseReturnStatement = function(e) {
			return this.inFunction || this.options.allowReturnOutsideFunction || this.raise(this.start, "'return' outside of function"), this.next(), this.eat(Ft.semi) || this.insertSemicolon() ? e.argument = null : (e.argument = this.parseExpression(), this.semicolon()), this.finishNode(e, "ReturnStatement");
		}, gn.parseSwitchStatement = function(e) {
			var t;
			this.next(), e.discriminant = this.parseParenExpression(), e.cases = [], this.expect(Ft.braceL), this.labels.push(_n), this.enterScope(0);
			for (var n = !1; this.type !== Ft.braceR;) if (this.type === Ft._case || this.type === Ft._default) {
				var s = this.type === Ft._case;
				t && this.finishNode(t, "SwitchCase"), e.cases.push(t = this.startNode()), t.consequent = [], this.next(), s ? t.test = this.parseExpression() : (n && this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"), n = !0, t.test = null), this.expect(Ft.colon);
			} else t || this.unexpected(), t.consequent.push(this.parseStatement(null));
			return this.exitScope(), t && this.finishNode(t, "SwitchCase"), this.next(), this.labels.pop(), this.finishNode(e, "SwitchStatement");
		}, gn.parseThrowStatement = function(e) {
			return this.next(), Vt.test(this.input.slice(this.lastTokEnd, this.start)) && this.raise(this.lastTokEnd, "Illegal newline after throw"), e.argument = this.parseExpression(), this.semicolon(), this.finishNode(e, "ThrowStatement");
		};
		var xn = [];
		gn.parseCatchClauseParam = function() {
			var e = this.parseBindingAtom(), t = "Identifier" === e.type;
			return this.enterScope(t ? 32 : 0), this.checkLValPattern(e, t ? 4 : 2), this.expect(Ft.parenR), e;
		}, gn.parseTryStatement = function(e) {
			if (this.next(), e.block = this.parseBlock(), e.handler = null, this.type === Ft._catch) {
				var t = this.startNode();
				this.next(), this.eat(Ft.parenL) ? t.param = this.parseCatchClauseParam() : (this.options.ecmaVersion < 10 && this.unexpected(), t.param = null, this.enterScope(0)), t.body = this.parseBlock(!1), this.exitScope(), e.handler = this.finishNode(t, "CatchClause");
			}
			return e.finalizer = this.eat(Ft._finally) ? this.parseBlock() : null, e.handler || e.finalizer || this.raise(e.start, "Missing catch or finally clause"), this.finishNode(e, "TryStatement");
		}, gn.parseVarStatement = function(e, t, n) {
			return this.next(), this.parseVar(e, !1, t, n), this.semicolon(), this.finishNode(e, "VariableDeclaration");
		}, gn.parseWhileStatement = function(e) {
			return this.next(), e.test = this.parseParenExpression(), this.labels.push(bn), e.body = this.parseStatement("while"), this.labels.pop(), this.finishNode(e, "WhileStatement");
		}, gn.parseWithStatement = function(e) {
			return this.strict && this.raise(this.start, "'with' in strict mode"), this.next(), e.object = this.parseParenExpression(), e.body = this.parseStatement("with"), this.finishNode(e, "WithStatement");
		}, gn.parseEmptyStatement = function(e) {
			return this.next(), this.finishNode(e, "EmptyStatement");
		}, gn.parseLabeledStatement = function(e, t, n, s) {
			for (var r = 0, a = this.labels; r < a.length; r += 1) a[r].name === t && this.raise(n.start, "Label '" + t + "' is already declared");
			for (var i = this.type.isLoop ? "loop" : this.type === Ft._switch ? "switch" : null, o = this.labels.length - 1; o >= 0; o--) {
				var l = this.labels[o];
				if (l.statementStart !== e.start) break;
				l.statementStart = this.start, l.kind = i;
			}
			return this.labels.push({
				name: t,
				kind: i,
				statementStart: this.start
			}), e.body = this.parseStatement(s ? -1 === s.indexOf("label") ? s + "label" : s : "label"), this.labels.pop(), e.label = n, this.finishNode(e, "LabeledStatement");
		}, gn.parseExpressionStatement = function(e, t) {
			return e.expression = t, this.semicolon(), this.finishNode(e, "ExpressionStatement");
		}, gn.parseBlock = function(e, t, n) {
			for (void 0 === e && (e = !0), void 0 === t && (t = this.startNode()), t.body = [], this.expect(Ft.braceL), e && this.enterScope(0); this.type !== Ft.braceR;) {
				var s = this.parseStatement(null);
				t.body.push(s);
			}
			return n && (this.strict = !1), this.next(), e && this.exitScope(), this.finishNode(t, "BlockStatement");
		}, gn.parseFor = function(e, t) {
			return e.init = t, this.expect(Ft.semi), e.test = this.type === Ft.semi ? null : this.parseExpression(), this.expect(Ft.semi), e.update = this.type === Ft.parenR ? null : this.parseExpression(), this.expect(Ft.parenR), e.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(e, "ForStatement");
		}, gn.parseForIn = function(e, t) {
			var n = this.type === Ft._in;
			return this.next(), "VariableDeclaration" === t.type && null != t.declarations[0].init && (!n || this.options.ecmaVersion < 8 || this.strict || "var" !== t.kind || "Identifier" !== t.declarations[0].id.type) && this.raise(t.start, (n ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"), e.left = t, e.right = n ? this.parseExpression() : this.parseMaybeAssign(), this.expect(Ft.parenR), e.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(e, n ? "ForInStatement" : "ForOfStatement");
		}, gn.parseVar = function(e, t, n, s) {
			for (e.declarations = [], e.kind = n;;) {
				var r = this.startNode();
				if (this.parseVarId(r, n), this.eat(Ft.eq) ? r.init = this.parseMaybeAssign(t) : s || "const" !== n || this.type === Ft._in || this.options.ecmaVersion >= 6 && this.isContextual("of") ? s || "using" !== n && "await using" !== n || !(this.options.ecmaVersion >= 17) || this.type === Ft._in || this.isContextual("of") ? s || "Identifier" === r.id.type || t && (this.type === Ft._in || this.isContextual("of")) ? r.init = null : this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value") : this.raise(this.lastTokEnd, "Missing initializer in " + n + " declaration") : this.unexpected(), e.declarations.push(this.finishNode(r, "VariableDeclarator")), !this.eat(Ft.comma)) break;
			}
			return e;
		}, gn.parseVarId = function(e, t) {
			e.id = "using" === t || "await using" === t ? this.parseIdent() : this.parseBindingAtom(), this.checkLValPattern(e.id, "var" === t ? 1 : 2, !1);
		};
		var wn = 1, kn = 2;
		function Cn(e, t) {
			var n = t.key.name, s = e[n], r = "true";
			return "MethodDefinition" !== t.type || "get" !== t.kind && "set" !== t.kind || (r = (t.static ? "s" : "i") + t.kind), "iget" === s && "iset" === r || "iset" === s && "iget" === r || "sget" === s && "sset" === r || "sset" === s && "sget" === r ? (e[n] = "true", !1) : !!s || (e[n] = r, !1);
		}
		function Sn(e, t) {
			var n = e.computed, s = e.key;
			return !n && ("Identifier" === s.type && s.name === t || "Literal" === s.type && s.value === t);
		}
		gn.parseFunction = function(e, t, n, s, r) {
			this.initFunction(e), (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !s) && (this.type === Ft.star && t & kn && this.unexpected(), e.generator = this.eat(Ft.star)), this.options.ecmaVersion >= 8 && (e.async = !!s), t & wn && (e.id = 4 & t && this.type !== Ft.name ? null : this.parseIdent(), !e.id || t & kn || this.checkLValSimple(e.id, this.strict || e.generator || e.async ? this.treatFunctionsAsVar ? 1 : 2 : 3));
			var a = this.yieldPos, i = this.awaitPos, o = this.awaitIdentPos;
			return this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(dn(e.async, e.generator)), t & wn || (e.id = this.type === Ft.name ? this.parseIdent() : null), this.parseFunctionParams(e), this.parseFunctionBody(e, n, !1, r), this.yieldPos = a, this.awaitPos = i, this.awaitIdentPos = o, this.finishNode(e, t & wn ? "FunctionDeclaration" : "FunctionExpression");
		}, gn.parseFunctionParams = function(e) {
			this.expect(Ft.parenL), e.params = this.parseBindingList(Ft.parenR, !1, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams();
		}, gn.parseClass = function(e, t) {
			this.next();
			var n = this.strict;
			this.strict = !0, this.parseClassId(e, t), this.parseClassSuper(e);
			var s = this.enterClassBody(), r = this.startNode(), a = !1;
			for (r.body = [], this.expect(Ft.braceL); this.type !== Ft.braceR;) {
				var i = this.parseClassElement(null !== e.superClass);
				i && (r.body.push(i), "MethodDefinition" === i.type && "constructor" === i.kind ? (a && this.raiseRecoverable(i.start, "Duplicate constructor in the same class"), a = !0) : i.key && "PrivateIdentifier" === i.key.type && Cn(s, i) && this.raiseRecoverable(i.key.start, "Identifier '#" + i.key.name + "' has already been declared"));
			}
			return this.strict = n, this.next(), e.body = this.finishNode(r, "ClassBody"), this.exitClassBody(), this.finishNode(e, t ? "ClassDeclaration" : "ClassExpression");
		}, gn.parseClassElement = function(e) {
			if (this.eat(Ft.semi)) return null;
			var t = this.options.ecmaVersion, n = this.startNode(), s = "", r = !1, a = !1, i = "method", o = !1;
			if (this.eatContextual("static")) {
				if (t >= 13 && this.eat(Ft.braceL)) return this.parseClassStaticBlock(n), n;
				this.isClassElementNameStart() || this.type === Ft.star ? o = !0 : s = "static";
			}
			if (n.static = o, !s && t >= 8 && this.eatContextual("async") && (!this.isClassElementNameStart() && this.type !== Ft.star || this.canInsertSemicolon() ? s = "async" : a = !0), !s && (t >= 9 || !a) && this.eat(Ft.star) && (r = !0), !s && !a && !r) {
				var l = this.value;
				(this.eatContextual("get") || this.eatContextual("set")) && (this.isClassElementNameStart() ? i = l : s = l);
			}
			if (s ? (n.computed = !1, n.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc), n.key.name = s, this.finishNode(n.key, "Identifier")) : this.parseClassElementName(n), t < 13 || this.type === Ft.parenL || "method" !== i || r || a) {
				var c = !n.static && Sn(n, "constructor"), p = c && e;
				c && "method" !== i && this.raise(n.key.start, "Constructor can't have get/set modifier"), n.kind = c ? "constructor" : i, this.parseClassMethod(n, r, a, p);
			} else this.parseClassField(n);
			return n;
		}, gn.isClassElementNameStart = function() {
			return this.type === Ft.name || this.type === Ft.privateId || this.type === Ft.num || this.type === Ft.string || this.type === Ft.bracketL || this.type.keyword;
		}, gn.parseClassElementName = function(e) {
			this.type === Ft.privateId ? ("constructor" === this.value && this.raise(this.start, "Classes can't have an element named '#constructor'"), e.computed = !1, e.key = this.parsePrivateIdent()) : this.parsePropertyName(e);
		}, gn.parseClassMethod = function(e, t, n, s) {
			var r = e.key;
			"constructor" === e.kind ? (t && this.raise(r.start, "Constructor can't be a generator"), n && this.raise(r.start, "Constructor can't be an async method")) : e.static && Sn(e, "prototype") && this.raise(r.start, "Classes may not have a static property named prototype");
			var a = e.value = this.parseMethod(t, n, s);
			return "get" === e.kind && 0 !== a.params.length && this.raiseRecoverable(a.start, "getter should have no params"), "set" === e.kind && 1 !== a.params.length && this.raiseRecoverable(a.start, "setter should have exactly one param"), "set" === e.kind && "RestElement" === a.params[0].type && this.raiseRecoverable(a.params[0].start, "Setter cannot use rest params"), this.finishNode(e, "MethodDefinition");
		}, gn.parseClassField = function(e) {
			return Sn(e, "constructor") ? this.raise(e.key.start, "Classes can't have a field named 'constructor'") : e.static && Sn(e, "prototype") && this.raise(e.key.start, "Classes can't have a static field named 'prototype'"), this.eat(Ft.eq) ? (this.enterScope(576), e.value = this.parseMaybeAssign(), this.exitScope()) : e.value = null, this.semicolon(), this.finishNode(e, "PropertyDefinition");
		}, gn.parseClassStaticBlock = function(e) {
			e.body = [];
			var t = this.labels;
			for (this.labels = [], this.enterScope(320); this.type !== Ft.braceR;) {
				var n = this.parseStatement(null);
				e.body.push(n);
			}
			return this.next(), this.exitScope(), this.labels = t, this.finishNode(e, "StaticBlock");
		}, gn.parseClassId = function(e, t) {
			this.type === Ft.name ? (e.id = this.parseIdent(), t && this.checkLValSimple(e.id, 2, !1)) : (!0 === t && this.unexpected(), e.id = null);
		}, gn.parseClassSuper = function(e) {
			e.superClass = this.eat(Ft._extends) ? this.parseExprSubscripts(null, !1) : null;
		}, gn.enterClassBody = function() {
			var e = {
				declared: Object.create(null),
				used: []
			};
			return this.privateNameStack.push(e), e.declared;
		}, gn.exitClassBody = function() {
			var e = this.privateNameStack.pop(), t = e.declared, n = e.used;
			if (this.options.checkPrivateFields) for (var s = this.privateNameStack.length, r = 0 === s ? null : this.privateNameStack[s - 1], a = 0; a < n.length; ++a) {
				var i = n[a];
				Yt(t, i.name) || (r ? r.used.push(i) : this.raiseRecoverable(i.start, "Private field '#" + i.name + "' must be declared in an enclosing class"));
			}
		}, gn.parseExportAllDeclaration = function(e, t) {
			return this.options.ecmaVersion >= 11 && (this.eatContextual("as") ? (e.exported = this.parseModuleExportName(), this.checkExport(t, e.exported, this.lastTokStart)) : e.exported = null), this.expectContextual("from"), this.type !== Ft.string && this.unexpected(), e.source = this.parseExprAtom(), this.options.ecmaVersion >= 16 && (e.attributes = this.parseWithClause()), this.semicolon(), this.finishNode(e, "ExportAllDeclaration");
		}, gn.parseExport = function(e, t) {
			if (this.next(), this.eat(Ft.star)) return this.parseExportAllDeclaration(e, t);
			if (this.eat(Ft._default)) return this.checkExport(t, "default", this.lastTokStart), e.declaration = this.parseExportDefaultDeclaration(), this.finishNode(e, "ExportDefaultDeclaration");
			if (this.shouldParseExportStatement()) e.declaration = this.parseExportDeclaration(e), "VariableDeclaration" === e.declaration.type ? this.checkVariableExport(t, e.declaration.declarations) : this.checkExport(t, e.declaration.id, e.declaration.id.start), e.specifiers = [], e.source = null, this.options.ecmaVersion >= 16 && (e.attributes = []);
			else {
				if (e.declaration = null, e.specifiers = this.parseExportSpecifiers(t), this.eatContextual("from")) this.type !== Ft.string && this.unexpected(), e.source = this.parseExprAtom(), this.options.ecmaVersion >= 16 && (e.attributes = this.parseWithClause());
				else {
					for (var n = 0, s = e.specifiers; n < s.length; n += 1) {
						var r = s[n];
						this.checkUnreserved(r.local), this.checkLocalExport(r.local), "Literal" === r.local.type && this.raise(r.local.start, "A string literal cannot be used as an exported binding without `from`.");
					}
					e.source = null, this.options.ecmaVersion >= 16 && (e.attributes = []);
				}
				this.semicolon();
			}
			return this.finishNode(e, "ExportNamedDeclaration");
		}, gn.parseExportDeclaration = function(e) {
			return this.parseStatement(null);
		}, gn.parseExportDefaultDeclaration = function() {
			var e;
			if (this.type === Ft._function || (e = this.isAsyncFunction())) {
				var t = this.startNode();
				return this.next(), e && this.next(), this.parseFunction(t, 4 | wn, !1, e);
			}
			if (this.type === Ft._class) {
				var n = this.startNode();
				return this.parseClass(n, "nullableID");
			}
			var s = this.parseMaybeAssign();
			return this.semicolon(), s;
		}, gn.checkExport = function(e, t, n) {
			e && ("string" != typeof t && (t = "Identifier" === t.type ? t.name : t.value), Yt(e, t) && this.raiseRecoverable(n, "Duplicate export '" + t + "'"), e[t] = !0);
		}, gn.checkPatternExport = function(e, t) {
			var n = t.type;
			if ("Identifier" === n) this.checkExport(e, t, t.start);
			else if ("ObjectPattern" === n) for (var s = 0, r = t.properties; s < r.length; s += 1) {
				var a = r[s];
				this.checkPatternExport(e, a);
			}
			else if ("ArrayPattern" === n) for (var i = 0, o = t.elements; i < o.length; i += 1) {
				var l = o[i];
				l && this.checkPatternExport(e, l);
			}
			else "Property" === n ? this.checkPatternExport(e, t.value) : "AssignmentPattern" === n ? this.checkPatternExport(e, t.left) : "RestElement" === n && this.checkPatternExport(e, t.argument);
		}, gn.checkVariableExport = function(e, t) {
			if (e) for (var n = 0, s = t; n < s.length; n += 1) {
				var r = s[n];
				this.checkPatternExport(e, r.id);
			}
		}, gn.shouldParseExportStatement = function() {
			return "var" === this.type.keyword || "const" === this.type.keyword || "class" === this.type.keyword || "function" === this.type.keyword || this.isLet() || this.isAsyncFunction();
		}, gn.parseExportSpecifier = function(e) {
			var t = this.startNode();
			return t.local = this.parseModuleExportName(), t.exported = this.eatContextual("as") ? this.parseModuleExportName() : t.local, this.checkExport(e, t.exported, t.exported.start), this.finishNode(t, "ExportSpecifier");
		}, gn.parseExportSpecifiers = function(e) {
			var t = [], n = !0;
			for (this.expect(Ft.braceL); !this.eat(Ft.braceR);) {
				if (n) n = !1;
				else if (this.expect(Ft.comma), this.afterTrailingComma(Ft.braceR)) break;
				t.push(this.parseExportSpecifier(e));
			}
			return t;
		}, gn.parseImport = function(e) {
			return this.next(), this.type === Ft.string ? (e.specifiers = xn, e.source = this.parseExprAtom()) : (e.specifiers = this.parseImportSpecifiers(), this.expectContextual("from"), e.source = this.type === Ft.string ? this.parseExprAtom() : this.unexpected()), this.options.ecmaVersion >= 16 && (e.attributes = this.parseWithClause()), this.semicolon(), this.finishNode(e, "ImportDeclaration");
		}, gn.parseImportSpecifier = function() {
			var e = this.startNode();
			return e.imported = this.parseModuleExportName(), this.eatContextual("as") ? e.local = this.parseIdent() : (this.checkUnreserved(e.imported), e.local = e.imported), this.checkLValSimple(e.local, 2), this.finishNode(e, "ImportSpecifier");
		}, gn.parseImportDefaultSpecifier = function() {
			var e = this.startNode();
			return e.local = this.parseIdent(), this.checkLValSimple(e.local, 2), this.finishNode(e, "ImportDefaultSpecifier");
		}, gn.parseImportNamespaceSpecifier = function() {
			var e = this.startNode();
			return this.next(), this.expectContextual("as"), e.local = this.parseIdent(), this.checkLValSimple(e.local, 2), this.finishNode(e, "ImportNamespaceSpecifier");
		}, gn.parseImportSpecifiers = function() {
			var e = [], t = !0;
			if (this.type === Ft.name && (e.push(this.parseImportDefaultSpecifier()), !this.eat(Ft.comma))) return e;
			if (this.type === Ft.star) return e.push(this.parseImportNamespaceSpecifier()), e;
			for (this.expect(Ft.braceL); !this.eat(Ft.braceR);) {
				if (t) t = !1;
				else if (this.expect(Ft.comma), this.afterTrailingComma(Ft.braceR)) break;
				e.push(this.parseImportSpecifier());
			}
			return e;
		}, gn.parseWithClause = function() {
			var e = [];
			if (!this.eat(Ft._with)) return e;
			this.expect(Ft.braceL);
			for (var t = {}, n = !0; !this.eat(Ft.braceR);) {
				if (n) n = !1;
				else if (this.expect(Ft.comma), this.afterTrailingComma(Ft.braceR)) break;
				var s = this.parseImportAttribute(), r = "Identifier" === s.key.type ? s.key.name : s.key.value;
				Yt(t, r) && this.raiseRecoverable(s.key.start, "Duplicate attribute key '" + r + "'"), t[r] = !0, e.push(s);
			}
			return e;
		}, gn.parseImportAttribute = function() {
			var e = this.startNode();
			return e.key = this.type === Ft.string ? this.parseExprAtom() : this.parseIdent("never" !== this.options.allowReserved), this.expect(Ft.colon), this.type !== Ft.string && this.unexpected(), e.value = this.parseExprAtom(), this.finishNode(e, "ImportAttribute");
		}, gn.parseModuleExportName = function() {
			if (this.options.ecmaVersion >= 13 && this.type === Ft.string) {
				var e = this.parseLiteral(this.value);
				return nn.test(e.value) && this.raise(e.start, "An export name cannot include a lone surrogate."), e;
			}
			return this.parseIdent(!0);
		}, gn.adaptDirectivePrologue = function(e) {
			for (var t = 0; t < e.length && this.isDirectiveCandidate(e[t]); ++t) e[t].directive = e[t].expression.raw.slice(1, -1);
		}, gn.isDirectiveCandidate = function(e) {
			return this.options.ecmaVersion >= 5 && "ExpressionStatement" === e.type && "Literal" === e.expression.type && "string" == typeof e.expression.value && ("\"" === this.input[e.start] || "'" === this.input[e.start]);
		};
		var Pn = hn.prototype;
		Pn.toAssignable = function(e, t, n) {
			if (this.options.ecmaVersion >= 6 && e) switch (e.type) {
				case "Identifier":
					this.inAsync && "await" === e.name && this.raise(e.start, "Cannot use 'await' as identifier inside an async function");
					break;
				case "ObjectPattern":
				case "ArrayPattern":
				case "AssignmentPattern":
				case "RestElement": break;
				case "ObjectExpression":
					e.type = "ObjectPattern", n && this.checkPatternErrors(n, !0);
					for (var s = 0, r = e.properties; s < r.length; s += 1) {
						var a = r[s];
						this.toAssignable(a, t), "RestElement" !== a.type || "ArrayPattern" !== a.argument.type && "ObjectPattern" !== a.argument.type || this.raise(a.argument.start, "Unexpected token");
					}
					break;
				case "Property":
					"init" !== e.kind && this.raise(e.key.start, "Object pattern can't contain getter or setter"), this.toAssignable(e.value, t);
					break;
				case "ArrayExpression":
					e.type = "ArrayPattern", n && this.checkPatternErrors(n, !0), this.toAssignableList(e.elements, t);
					break;
				case "SpreadElement":
					e.type = "RestElement", this.toAssignable(e.argument, t), "AssignmentPattern" === e.argument.type && this.raise(e.argument.start, "Rest elements cannot have a default value");
					break;
				case "AssignmentExpression":
					"=" !== e.operator && this.raise(e.left.end, "Only '=' operator can be used for specifying default value."), e.type = "AssignmentPattern", delete e.operator, this.toAssignable(e.left, t);
					break;
				case "ParenthesizedExpression":
					this.toAssignable(e.expression, t, n);
					break;
				case "ChainExpression":
					this.raiseRecoverable(e.start, "Optional chaining cannot appear in left-hand side");
					break;
				case "MemberExpression": if (!t) break;
				default: this.raise(e.start, "Assigning to rvalue");
			}
			else n && this.checkPatternErrors(n, !0);
			return e;
		}, Pn.toAssignableList = function(e, t) {
			for (var n = e.length, s = 0; s < n; s++) {
				var r = e[s];
				r && this.toAssignable(r, t);
			}
			if (n) {
				var a = e[n - 1];
				6 === this.options.ecmaVersion && t && a && "RestElement" === a.type && "Identifier" !== a.argument.type && this.unexpected(a.argument.start);
			}
			return e;
		}, Pn.parseSpread = function(e) {
			var t = this.startNode();
			return this.next(), t.argument = this.parseMaybeAssign(!1, e), this.finishNode(t, "SpreadElement");
		}, Pn.parseRestBinding = function() {
			var e = this.startNode();
			return this.next(), 6 === this.options.ecmaVersion && this.type !== Ft.name && this.unexpected(), e.argument = this.parseBindingAtom(), this.finishNode(e, "RestElement");
		}, Pn.parseBindingAtom = function() {
			if (this.options.ecmaVersion >= 6) switch (this.type) {
				case Ft.bracketL:
					var e = this.startNode();
					return this.next(), e.elements = this.parseBindingList(Ft.bracketR, !0, !0), this.finishNode(e, "ArrayPattern");
				case Ft.braceL: return this.parseObj(!0);
			}
			return this.parseIdent();
		}, Pn.parseBindingList = function(e, t, n, s) {
			for (var r = [], a = !0; !this.eat(e);) if (a ? a = !1 : this.expect(Ft.comma), t && this.type === Ft.comma) r.push(null);
			else {
				if (n && this.afterTrailingComma(e)) break;
				if (this.type === Ft.ellipsis) {
					var i = this.parseRestBinding();
					this.parseBindingListItem(i), r.push(i), this.type === Ft.comma && this.raiseRecoverable(this.start, "Comma is not permitted after the rest element"), this.expect(e);
					break;
				}
				r.push(this.parseAssignableListItem(s));
			}
			return r;
		}, Pn.parseAssignableListItem = function(e) {
			var t = this.parseMaybeDefault(this.start, this.startLoc);
			return this.parseBindingListItem(t), t;
		}, Pn.parseBindingListItem = function(e) {
			return e;
		}, Pn.parseMaybeDefault = function(e, t, n) {
			if (n = n || this.parseBindingAtom(), this.options.ecmaVersion < 6 || !this.eat(Ft.eq)) return n;
			var s = this.startNodeAt(e, t);
			return s.left = n, s.right = this.parseMaybeAssign(), this.finishNode(s, "AssignmentPattern");
		}, Pn.checkLValSimple = function(e, t, n) {
			void 0 === t && (t = 0);
			var s = 0 !== t;
			switch (e.type) {
				case "Identifier":
					this.strict && this.reservedWordsStrictBind.test(e.name) && this.raiseRecoverable(e.start, (s ? "Binding " : "Assigning to ") + e.name + " in strict mode"), s && (2 === t && "let" === e.name && this.raiseRecoverable(e.start, "let is disallowed as a lexically bound name"), n && (Yt(n, e.name) && this.raiseRecoverable(e.start, "Argument name clash"), n[e.name] = !0), 5 !== t && this.declareName(e.name, t, e.start));
					break;
				case "ChainExpression":
					this.raiseRecoverable(e.start, "Optional chaining cannot appear in left-hand side");
					break;
				case "MemberExpression":
					s && this.raiseRecoverable(e.start, "Binding member expression");
					break;
				case "ParenthesizedExpression": return s && this.raiseRecoverable(e.start, "Binding parenthesized expression"), this.checkLValSimple(e.expression, t, n);
				default: this.raise(e.start, (s ? "Binding" : "Assigning to") + " rvalue");
			}
		}, Pn.checkLValPattern = function(e, t, n) {
			switch (void 0 === t && (t = 0), e.type) {
				case "ObjectPattern":
					for (var s = 0, r = e.properties; s < r.length; s += 1) {
						var a = r[s];
						this.checkLValInnerPattern(a, t, n);
					}
					break;
				case "ArrayPattern":
					for (var i = 0, o = e.elements; i < o.length; i += 1) {
						var l = o[i];
						l && this.checkLValInnerPattern(l, t, n);
					}
					break;
				default: this.checkLValSimple(e, t, n);
			}
		}, Pn.checkLValInnerPattern = function(e, t, n) {
			switch (void 0 === t && (t = 0), e.type) {
				case "Property":
					this.checkLValInnerPattern(e.value, t, n);
					break;
				case "AssignmentPattern":
					this.checkLValPattern(e.left, t, n);
					break;
				case "RestElement":
					this.checkLValPattern(e.argument, t, n);
					break;
				default: this.checkLValPattern(e, t, n);
			}
		};
		var En = function(e, t, n, s, r) {
			this.token = e, this.isExpr = !!t, this.preserveSpace = !!n, this.override = s, this.generator = !!r;
		}, Tn = {
			b_stat: new En("{", !1),
			b_expr: new En("{", !0),
			b_tmpl: new En("${", !1),
			p_stat: new En("(", !1),
			p_expr: new En("(", !0),
			q_tmpl: new En("`", !0, !0, (function(e) {
				return e.tryReadTemplateToken();
			})),
			f_stat: new En("function", !1),
			f_expr: new En("function", !0),
			f_expr_gen: new En("function", !0, !1, null, !0),
			f_gen: new En("function", !1, !1, null, !0)
		}, An = hn.prototype;
		An.initialContext = function() {
			return [Tn.b_stat];
		}, An.curContext = function() {
			return this.context[this.context.length - 1];
		}, An.braceIsBlock = function(e) {
			var t = this.curContext();
			return t === Tn.f_expr || t === Tn.f_stat || (e !== Ft.colon || t !== Tn.b_stat && t !== Tn.b_expr ? e === Ft._return || e === Ft.name && this.exprAllowed ? Vt.test(this.input.slice(this.lastTokEnd, this.start)) : e === Ft._else || e === Ft.semi || e === Ft.eof || e === Ft.parenR || e === Ft.arrow || (e === Ft.braceL ? t === Tn.b_stat : e !== Ft._var && e !== Ft._const && e !== Ft.name && !this.exprAllowed) : !t.isExpr);
		}, An.inGeneratorContext = function() {
			for (var e = this.context.length - 1; e >= 1; e--) {
				var t = this.context[e];
				if ("function" === t.token) return t.generator;
			}
			return !1;
		}, An.updateContext = function(e) {
			var t, n = this.type;
			n.keyword && e === Ft.dot ? this.exprAllowed = !1 : (t = n.updateContext) ? t.call(this, e) : this.exprAllowed = n.beforeExpr;
		}, An.overrideContext = function(e) {
			this.curContext() !== e && (this.context[this.context.length - 1] = e);
		}, Ft.parenR.updateContext = Ft.braceR.updateContext = function() {
			if (1 !== this.context.length) {
				var e = this.context.pop();
				e === Tn.b_stat && "function" === this.curContext().token && (e = this.context.pop()), this.exprAllowed = !e.isExpr;
			} else this.exprAllowed = !0;
		}, Ft.braceL.updateContext = function(e) {
			this.context.push(this.braceIsBlock(e) ? Tn.b_stat : Tn.b_expr), this.exprAllowed = !0;
		}, Ft.dollarBraceL.updateContext = function() {
			this.context.push(Tn.b_tmpl), this.exprAllowed = !0;
		}, Ft.parenL.updateContext = function(e) {
			var t = e === Ft._if || e === Ft._for || e === Ft._with || e === Ft._while;
			this.context.push(t ? Tn.p_stat : Tn.p_expr), this.exprAllowed = !0;
		}, Ft.incDec.updateContext = function() {}, Ft._function.updateContext = Ft._class.updateContext = function(e) {
			!e.beforeExpr || e === Ft._else || e === Ft.semi && this.curContext() !== Tn.p_stat || e === Ft._return && Vt.test(this.input.slice(this.lastTokEnd, this.start)) || (e === Ft.colon || e === Ft.braceL) && this.curContext() === Tn.b_stat ? this.context.push(Tn.f_stat) : this.context.push(Tn.f_expr), this.exprAllowed = !1;
		}, Ft.colon.updateContext = function() {
			"function" === this.curContext().token && this.context.pop(), this.exprAllowed = !0;
		}, Ft.backQuote.updateContext = function() {
			this.curContext() === Tn.q_tmpl ? this.context.pop() : this.context.push(Tn.q_tmpl), this.exprAllowed = !1;
		}, Ft.star.updateContext = function(e) {
			if (e === Ft._function) {
				var t = this.context.length - 1;
				this.context[t] === Tn.f_expr ? this.context[t] = Tn.f_expr_gen : this.context[t] = Tn.f_gen;
			}
			this.exprAllowed = !0;
		}, Ft.name.updateContext = function(e) {
			var t = !1;
			this.options.ecmaVersion >= 6 && e !== Ft.dot && ("of" === this.value && !this.exprAllowed || "yield" === this.value && this.inGeneratorContext()) && (t = !0), this.exprAllowed = t;
		};
		var $n = hn.prototype;
		function Rn(e) {
			return "Identifier" === e.type || "ParenthesizedExpression" === e.type && Rn(e.expression);
		}
		function In(e) {
			return "MemberExpression" === e.type && "PrivateIdentifier" === e.property.type || "ChainExpression" === e.type && In(e.expression) || "ParenthesizedExpression" === e.type && In(e.expression);
		}
		$n.checkPropClash = function(e, t, n) {
			if (!(this.options.ecmaVersion >= 9 && "SpreadElement" === e.type || this.options.ecmaVersion >= 6 && (e.computed || e.method || e.shorthand))) {
				var s, r = e.key;
				switch (r.type) {
					case "Identifier":
						s = r.name;
						break;
					case "Literal":
						s = String(r.value);
						break;
					default: return;
				}
				var a = e.kind;
				if (this.options.ecmaVersion >= 6) "__proto__" === s && "init" === a && (t.proto && (n ? n.doubleProto < 0 && (n.doubleProto = r.start) : this.raiseRecoverable(r.start, "Redefinition of __proto__ property")), t.proto = !0);
				else {
					var i = t[s = "$" + s];
					if (i) ("init" === a ? this.strict && i.init || i.get || i.set : i.init || i[a]) && this.raiseRecoverable(r.start, "Redefinition of property");
					else i = t[s] = {
						init: !1,
						get: !1,
						set: !1
					};
					i[a] = !0;
				}
			}
		}, $n.parseExpression = function(e, t) {
			var n = this.start, s = this.startLoc, r = this.parseMaybeAssign(e, t);
			if (this.type === Ft.comma) {
				var a = this.startNodeAt(n, s);
				for (a.expressions = [r]; this.eat(Ft.comma);) a.expressions.push(this.parseMaybeAssign(e, t));
				return this.finishNode(a, "SequenceExpression");
			}
			return r;
		}, $n.parseMaybeAssign = function(e, t, n) {
			if (this.isContextual("yield")) {
				if (this.inGenerator) return this.parseYield(e);
				this.exprAllowed = !1;
			}
			var s = !1, r = -1, a = -1, i = -1;
			t ? (r = t.parenthesizedAssign, a = t.trailingComma, i = t.doubleProto, t.parenthesizedAssign = t.trailingComma = -1) : (t = new vn(), s = !0);
			var o = this.start, l = this.startLoc;
			this.type !== Ft.parenL && this.type !== Ft.name || (this.potentialArrowAt = this.start, this.potentialArrowInForAwait = "await" === e);
			var c = this.parseMaybeConditional(e, t);
			if (n && (c = n.call(this, c, o, l)), this.type.isAssign) {
				var p = this.startNodeAt(o, l);
				return p.operator = this.value, this.type === Ft.eq && (c = this.toAssignable(c, !1, t)), s || (t.parenthesizedAssign = t.trailingComma = t.doubleProto = -1), t.shorthandAssign >= c.start && (t.shorthandAssign = -1), this.type === Ft.eq ? this.checkLValPattern(c) : this.checkLValSimple(c), p.left = c, this.next(), p.right = this.parseMaybeAssign(e), i > -1 && (t.doubleProto = i), this.finishNode(p, "AssignmentExpression");
			}
			return s && this.checkExpressionErrors(t, !0), r > -1 && (t.parenthesizedAssign = r), a > -1 && (t.trailingComma = a), c;
		}, $n.parseMaybeConditional = function(e, t) {
			var n = this.start, s = this.startLoc, r = this.parseExprOps(e, t);
			if (this.checkExpressionErrors(t)) return r;
			if (this.eat(Ft.question)) {
				var a = this.startNodeAt(n, s);
				return a.test = r, a.consequent = this.parseMaybeAssign(), this.expect(Ft.colon), a.alternate = this.parseMaybeAssign(e), this.finishNode(a, "ConditionalExpression");
			}
			return r;
		}, $n.parseExprOps = function(e, t) {
			var n = this.start, s = this.startLoc, r = this.parseMaybeUnary(t, !1, !1, e);
			return this.checkExpressionErrors(t) || r.start === n && "ArrowFunctionExpression" === r.type ? r : this.parseExprOp(r, n, s, -1, e);
		}, $n.parseExprOp = function(e, t, n, s, r) {
			var a = this.type.binop;
			if (null != a && (!r || this.type !== Ft._in) && a > s) {
				var i = this.type === Ft.logicalOR || this.type === Ft.logicalAND, o = this.type === Ft.coalesce;
				o && (a = Ft.logicalAND.binop);
				var l = this.value;
				this.next();
				var c = this.start, p = this.startLoc, u = this.parseExprOp(this.parseMaybeUnary(null, !1, !1, r), c, p, a, r), d = this.buildBinary(t, n, e, u, l, i || o);
				return (i && this.type === Ft.coalesce || o && (this.type === Ft.logicalOR || this.type === Ft.logicalAND)) && this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses"), this.parseExprOp(d, t, n, s, r);
			}
			return e;
		}, $n.buildBinary = function(e, t, n, s, r, a) {
			"PrivateIdentifier" === s.type && this.raise(s.start, "Private identifier can only be left side of binary expression");
			var i = this.startNodeAt(e, t);
			return i.left = n, i.operator = r, i.right = s, this.finishNode(i, a ? "LogicalExpression" : "BinaryExpression");
		}, $n.parseMaybeUnary = function(e, t, n, s) {
			var r, a = this.start, i = this.startLoc;
			if (this.isContextual("await") && this.canAwait) r = this.parseAwait(s), t = !0;
			else if (this.type.prefix) {
				var o = this.startNode(), l = this.type === Ft.incDec;
				o.operator = this.value, o.prefix = !0, this.next(), o.argument = this.parseMaybeUnary(null, !0, l, s), this.checkExpressionErrors(e, !0), l ? this.checkLValSimple(o.argument) : this.strict && "delete" === o.operator && Rn(o.argument) ? this.raiseRecoverable(o.start, "Deleting local variable in strict mode") : "delete" === o.operator && In(o.argument) ? this.raiseRecoverable(o.start, "Private fields can not be deleted") : t = !0, r = this.finishNode(o, l ? "UpdateExpression" : "UnaryExpression");
			} else if (t || this.type !== Ft.privateId) {
				if (r = this.parseExprSubscripts(e, s), this.checkExpressionErrors(e)) return r;
				for (; this.type.postfix && !this.canInsertSemicolon();) {
					var c = this.startNodeAt(a, i);
					c.operator = this.value, c.prefix = !1, c.argument = r, this.checkLValSimple(r), this.next(), r = this.finishNode(c, "UpdateExpression");
				}
			} else (s || 0 === this.privateNameStack.length) && this.options.checkPrivateFields && this.unexpected(), r = this.parsePrivateIdent(), this.type !== Ft._in && this.unexpected();
			return n || !this.eat(Ft.starstar) ? r : t ? void this.unexpected(this.lastTokStart) : this.buildBinary(a, i, r, this.parseMaybeUnary(null, !1, !1, s), "**", !1);
		}, $n.parseExprSubscripts = function(e, t) {
			var n = this.start, s = this.startLoc, r = this.parseExprAtom(e, t);
			if ("ArrowFunctionExpression" === r.type && ")" !== this.input.slice(this.lastTokStart, this.lastTokEnd)) return r;
			var a = this.parseSubscripts(r, n, s, !1, t);
			return e && "MemberExpression" === a.type && (e.parenthesizedAssign >= a.start && (e.parenthesizedAssign = -1), e.parenthesizedBind >= a.start && (e.parenthesizedBind = -1), e.trailingComma >= a.start && (e.trailingComma = -1)), a;
		}, $n.parseSubscripts = function(e, t, n, s, r) {
			for (var a = this.options.ecmaVersion >= 8 && "Identifier" === e.type && "async" === e.name && this.lastTokEnd === e.end && !this.canInsertSemicolon() && e.end - e.start == 5 && this.potentialArrowAt === e.start, i = !1;;) {
				var o = this.parseSubscript(e, t, n, s, a, i, r);
				if (o.optional && (i = !0), o === e || "ArrowFunctionExpression" === o.type) {
					if (i) {
						var l = this.startNodeAt(t, n);
						l.expression = o, o = this.finishNode(l, "ChainExpression");
					}
					return o;
				}
				e = o;
			}
		}, $n.shouldParseAsyncArrow = function() {
			return !this.canInsertSemicolon() && this.eat(Ft.arrow);
		}, $n.parseSubscriptAsyncArrow = function(e, t, n, s) {
			return this.parseArrowExpression(this.startNodeAt(e, t), n, !0, s);
		}, $n.parseSubscript = function(e, t, n, s, r, a, i) {
			var o = this.options.ecmaVersion >= 11, l = o && this.eat(Ft.questionDot);
			s && l && this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
			var c = this.eat(Ft.bracketL);
			if (c || l && this.type !== Ft.parenL && this.type !== Ft.backQuote || this.eat(Ft.dot)) {
				var p = this.startNodeAt(t, n);
				p.object = e, c ? (p.property = this.parseExpression(), this.expect(Ft.bracketR)) : this.type === Ft.privateId && "Super" !== e.type ? p.property = this.parsePrivateIdent() : p.property = this.parseIdent("never" !== this.options.allowReserved), p.computed = !!c, o && (p.optional = l), e = this.finishNode(p, "MemberExpression");
			} else if (!s && this.eat(Ft.parenL)) {
				var u = new vn(), d = this.yieldPos, h = this.awaitPos, m = this.awaitIdentPos;
				this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0;
				var f = this.parseExprList(Ft.parenR, this.options.ecmaVersion >= 8, !1, u);
				if (r && !l && this.shouldParseAsyncArrow()) return this.checkPatternErrors(u, !1), this.checkYieldAwaitInDefaultParams(), this.awaitIdentPos > 0 && this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"), this.yieldPos = d, this.awaitPos = h, this.awaitIdentPos = m, this.parseSubscriptAsyncArrow(t, n, f, i);
				this.checkExpressionErrors(u, !0), this.yieldPos = d || this.yieldPos, this.awaitPos = h || this.awaitPos, this.awaitIdentPos = m || this.awaitIdentPos;
				var y = this.startNodeAt(t, n);
				y.callee = e, y.arguments = f, o && (y.optional = l), e = this.finishNode(y, "CallExpression");
			} else if (this.type === Ft.backQuote) {
				(l || a) && this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
				var v = this.startNodeAt(t, n);
				v.tag = e, v.quasi = this.parseTemplate({ isTagged: !0 }), e = this.finishNode(v, "TaggedTemplateExpression");
			}
			return e;
		}, $n.parseExprAtom = function(e, t, n) {
			this.type === Ft.slash && this.readRegexp();
			var s, r = this.potentialArrowAt === this.start;
			switch (this.type) {
				case Ft._super: return this.allowSuper || this.raise(this.start, "'super' keyword outside a method"), s = this.startNode(), this.next(), this.type !== Ft.parenL || this.allowDirectSuper || this.raise(s.start, "super() call outside constructor of a subclass"), this.type !== Ft.dot && this.type !== Ft.bracketL && this.type !== Ft.parenL && this.unexpected(), this.finishNode(s, "Super");
				case Ft._this: return s = this.startNode(), this.next(), this.finishNode(s, "ThisExpression");
				case Ft.name:
					var a = this.start, i = this.startLoc, o = this.containsEsc, l = this.parseIdent(!1);
					if (this.options.ecmaVersion >= 8 && !o && "async" === l.name && !this.canInsertSemicolon() && this.eat(Ft._function)) return this.overrideContext(Tn.f_expr), this.parseFunction(this.startNodeAt(a, i), 0, !1, !0, t);
					if (r && !this.canInsertSemicolon()) {
						if (this.eat(Ft.arrow)) return this.parseArrowExpression(this.startNodeAt(a, i), [l], !1, t);
						if (this.options.ecmaVersion >= 8 && "async" === l.name && this.type === Ft.name && !o && (!this.potentialArrowInForAwait || "of" !== this.value || this.containsEsc)) return l = this.parseIdent(!1), !this.canInsertSemicolon() && this.eat(Ft.arrow) || this.unexpected(), this.parseArrowExpression(this.startNodeAt(a, i), [l], !0, t);
					}
					return l;
				case Ft.regexp:
					var c = this.value;
					return (s = this.parseLiteral(c.value)).regex = {
						pattern: c.pattern,
						flags: c.flags
					}, s;
				case Ft.num:
				case Ft.string: return this.parseLiteral(this.value);
				case Ft._null:
				case Ft._true:
				case Ft._false: return (s = this.startNode()).value = this.type === Ft._null ? null : this.type === Ft._true, s.raw = this.type.keyword, this.next(), this.finishNode(s, "Literal");
				case Ft.parenL:
					var p = this.start, u = this.parseParenAndDistinguishExpression(r, t);
					return e && (e.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(u) && (e.parenthesizedAssign = p), e.parenthesizedBind < 0 && (e.parenthesizedBind = p)), u;
				case Ft.bracketL: return s = this.startNode(), this.next(), s.elements = this.parseExprList(Ft.bracketR, !0, !0, e), this.finishNode(s, "ArrayExpression");
				case Ft.braceL: return this.overrideContext(Tn.b_expr), this.parseObj(!1, e);
				case Ft._function: return s = this.startNode(), this.next(), this.parseFunction(s, 0);
				case Ft._class: return this.parseClass(this.startNode(), !1);
				case Ft._new: return this.parseNew();
				case Ft.backQuote: return this.parseTemplate();
				case Ft._import: return this.options.ecmaVersion >= 11 ? this.parseExprImport(n) : this.unexpected();
				default: return this.parseExprAtomDefault();
			}
		}, $n.parseExprAtomDefault = function() {
			this.unexpected();
		}, $n.parseExprImport = function(e) {
			var t = this.startNode();
			if (this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword import"), this.next(), this.type === Ft.parenL && !e) return this.parseDynamicImport(t);
			if (this.type === Ft.dot) {
				var n = this.startNodeAt(t.start, t.loc && t.loc.start);
				return n.name = "import", t.meta = this.finishNode(n, "Identifier"), this.parseImportMeta(t);
			}
			this.unexpected();
		}, $n.parseDynamicImport = function(e) {
			if (this.next(), e.source = this.parseMaybeAssign(), this.options.ecmaVersion >= 16) this.eat(Ft.parenR) ? e.options = null : (this.expect(Ft.comma), this.afterTrailingComma(Ft.parenR) ? e.options = null : (e.options = this.parseMaybeAssign(), this.eat(Ft.parenR) || (this.expect(Ft.comma), this.afterTrailingComma(Ft.parenR) || this.unexpected())));
			else if (!this.eat(Ft.parenR)) {
				var t = this.start;
				this.eat(Ft.comma) && this.eat(Ft.parenR) ? this.raiseRecoverable(t, "Trailing comma is not allowed in import()") : this.unexpected(t);
			}
			return this.finishNode(e, "ImportExpression");
		}, $n.parseImportMeta = function(e) {
			this.next();
			var t = this.containsEsc;
			return e.property = this.parseIdent(!0), "meta" !== e.property.name && this.raiseRecoverable(e.property.start, "The only valid meta property for import is 'import.meta'"), t && this.raiseRecoverable(e.start, "'import.meta' must not contain escaped characters"), "module" === this.options.sourceType || this.options.allowImportExportEverywhere || this.raiseRecoverable(e.start, "Cannot use 'import.meta' outside a module"), this.finishNode(e, "MetaProperty");
		}, $n.parseLiteral = function(e) {
			var t = this.startNode();
			return t.value = e, t.raw = this.input.slice(this.start, this.end), 110 === t.raw.charCodeAt(t.raw.length - 1) && (t.bigint = null != t.value ? t.value.toString() : t.raw.slice(0, -1).replace(/_/g, "")), this.next(), this.finishNode(t, "Literal");
		}, $n.parseParenExpression = function() {
			this.expect(Ft.parenL);
			var e = this.parseExpression();
			return this.expect(Ft.parenR), e;
		}, $n.shouldParseArrow = function(e) {
			return !this.canInsertSemicolon();
		}, $n.parseParenAndDistinguishExpression = function(e, t) {
			var n, s = this.start, r = this.startLoc, a = this.options.ecmaVersion >= 8;
			if (this.options.ecmaVersion >= 6) {
				this.next();
				var i, o = this.start, l = this.startLoc, c = [], p = !0, u = !1, d = new vn(), h = this.yieldPos, m = this.awaitPos;
				for (this.yieldPos = 0, this.awaitPos = 0; this.type !== Ft.parenR;) {
					if (p ? p = !1 : this.expect(Ft.comma), a && this.afterTrailingComma(Ft.parenR, !0)) {
						u = !0;
						break;
					}
					if (this.type === Ft.ellipsis) {
						i = this.start, c.push(this.parseParenItem(this.parseRestBinding())), this.type === Ft.comma && this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
						break;
					}
					c.push(this.parseMaybeAssign(!1, d, this.parseParenItem));
				}
				var f = this.lastTokEnd, y = this.lastTokEndLoc;
				if (this.expect(Ft.parenR), e && this.shouldParseArrow(c) && this.eat(Ft.arrow)) return this.checkPatternErrors(d, !1), this.checkYieldAwaitInDefaultParams(), this.yieldPos = h, this.awaitPos = m, this.parseParenArrowList(s, r, c, t);
				c.length && !u || this.unexpected(this.lastTokStart), i && this.unexpected(i), this.checkExpressionErrors(d, !0), this.yieldPos = h || this.yieldPos, this.awaitPos = m || this.awaitPos, c.length > 1 ? ((n = this.startNodeAt(o, l)).expressions = c, this.finishNodeAt(n, "SequenceExpression", f, y)) : n = c[0];
			} else n = this.parseParenExpression();
			if (this.options.preserveParens) {
				var v = this.startNodeAt(s, r);
				return v.expression = n, this.finishNode(v, "ParenthesizedExpression");
			}
			return n;
		}, $n.parseParenItem = function(e) {
			return e;
		}, $n.parseParenArrowList = function(e, t, n, s) {
			return this.parseArrowExpression(this.startNodeAt(e, t), n, !1, s);
		};
		var Mn = [];
		$n.parseNew = function() {
			this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword new");
			var e = this.startNode();
			if (this.next(), this.options.ecmaVersion >= 6 && this.type === Ft.dot) {
				var t = this.startNodeAt(e.start, e.loc && e.loc.start);
				t.name = "new", e.meta = this.finishNode(t, "Identifier"), this.next();
				var n = this.containsEsc;
				return e.property = this.parseIdent(!0), "target" !== e.property.name && this.raiseRecoverable(e.property.start, "The only valid meta property for new is 'new.target'"), n && this.raiseRecoverable(e.start, "'new.target' must not contain escaped characters"), this.allowNewDotTarget || this.raiseRecoverable(e.start, "'new.target' can only be used in functions and class static block"), this.finishNode(e, "MetaProperty");
			}
			var s = this.start, r = this.startLoc;
			return e.callee = this.parseSubscripts(this.parseExprAtom(null, !1, !0), s, r, !0, !1), this.eat(Ft.parenL) ? e.arguments = this.parseExprList(Ft.parenR, this.options.ecmaVersion >= 8, !1) : e.arguments = Mn, this.finishNode(e, "NewExpression");
		}, $n.parseTemplateElement = function(e) {
			var t = e.isTagged, n = this.startNode();
			return this.type === Ft.invalidTemplate ? (t || this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal"), n.value = {
				raw: this.value.replace(/\r\n?/g, "\n"),
				cooked: null
			}) : n.value = {
				raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
				cooked: this.value
			}, this.next(), n.tail = this.type === Ft.backQuote, this.finishNode(n, "TemplateElement");
		}, $n.parseTemplate = function(e) {
			void 0 === e && (e = {});
			var t = e.isTagged;
			void 0 === t && (t = !1);
			var n = this.startNode();
			this.next(), n.expressions = [];
			var s = this.parseTemplateElement({ isTagged: t });
			for (n.quasis = [s]; !s.tail;) this.type === Ft.eof && this.raise(this.pos, "Unterminated template literal"), this.expect(Ft.dollarBraceL), n.expressions.push(this.parseExpression()), this.expect(Ft.braceR), n.quasis.push(s = this.parseTemplateElement({ isTagged: t }));
			return this.next(), this.finishNode(n, "TemplateLiteral");
		}, $n.isAsyncProp = function(e) {
			return !e.computed && "Identifier" === e.key.type && "async" === e.key.name && (this.type === Ft.name || this.type === Ft.num || this.type === Ft.string || this.type === Ft.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === Ft.star) && !Vt.test(this.input.slice(this.lastTokEnd, this.start));
		}, $n.parseObj = function(e, t) {
			var n = this.startNode(), s = !0, r = {};
			for (n.properties = [], this.next(); !this.eat(Ft.braceR);) {
				if (s) s = !1;
				else if (this.expect(Ft.comma), this.options.ecmaVersion >= 5 && this.afterTrailingComma(Ft.braceR)) break;
				var a = this.parseProperty(e, t);
				e || this.checkPropClash(a, r, t), n.properties.push(a);
			}
			return this.finishNode(n, e ? "ObjectPattern" : "ObjectExpression");
		}, $n.parseProperty = function(e, t) {
			var n, s, r, a, i = this.startNode();
			if (this.options.ecmaVersion >= 9 && this.eat(Ft.ellipsis)) return e ? (i.argument = this.parseIdent(!1), this.type === Ft.comma && this.raiseRecoverable(this.start, "Comma is not permitted after the rest element"), this.finishNode(i, "RestElement")) : (i.argument = this.parseMaybeAssign(!1, t), this.type === Ft.comma && t && t.trailingComma < 0 && (t.trailingComma = this.start), this.finishNode(i, "SpreadElement"));
			this.options.ecmaVersion >= 6 && (i.method = !1, i.shorthand = !1, (e || t) && (r = this.start, a = this.startLoc), e || (n = this.eat(Ft.star)));
			var o = this.containsEsc;
			return this.parsePropertyName(i), !e && !o && this.options.ecmaVersion >= 8 && !n && this.isAsyncProp(i) ? (s = !0, n = this.options.ecmaVersion >= 9 && this.eat(Ft.star), this.parsePropertyName(i)) : s = !1, this.parsePropertyValue(i, e, n, s, r, a, t, o), this.finishNode(i, "Property");
		}, $n.parseGetterSetter = function(e) {
			var t = e.key.name;
			this.parsePropertyName(e), e.value = this.parseMethod(!1), e.kind = t;
			var n = "get" === e.kind ? 0 : 1;
			if (e.value.params.length !== n) {
				var s = e.value.start;
				"get" === e.kind ? this.raiseRecoverable(s, "getter should have no params") : this.raiseRecoverable(s, "setter should have exactly one param");
			} else "set" === e.kind && "RestElement" === e.value.params[0].type && this.raiseRecoverable(e.value.params[0].start, "Setter cannot use rest params");
		}, $n.parsePropertyValue = function(e, t, n, s, r, a, i, o) {
			(n || s) && this.type === Ft.colon && this.unexpected(), this.eat(Ft.colon) ? (e.value = t ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(!1, i), e.kind = "init") : this.options.ecmaVersion >= 6 && this.type === Ft.parenL ? (t && this.unexpected(), e.method = !0, e.value = this.parseMethod(n, s), e.kind = "init") : t || o || !(this.options.ecmaVersion >= 5) || e.computed || "Identifier" !== e.key.type || "get" !== e.key.name && "set" !== e.key.name || this.type === Ft.comma || this.type === Ft.braceR || this.type === Ft.eq ? this.options.ecmaVersion >= 6 && !e.computed && "Identifier" === e.key.type ? ((n || s) && this.unexpected(), this.checkUnreserved(e.key), "await" !== e.key.name || this.awaitIdentPos || (this.awaitIdentPos = r), t ? e.value = this.parseMaybeDefault(r, a, this.copyNode(e.key)) : this.type === Ft.eq && i ? (i.shorthandAssign < 0 && (i.shorthandAssign = this.start), e.value = this.parseMaybeDefault(r, a, this.copyNode(e.key))) : e.value = this.copyNode(e.key), e.kind = "init", e.shorthand = !0) : this.unexpected() : ((n || s) && this.unexpected(), this.parseGetterSetter(e));
		}, $n.parsePropertyName = function(e) {
			if (this.options.ecmaVersion >= 6) {
				if (this.eat(Ft.bracketL)) return e.computed = !0, e.key = this.parseMaybeAssign(), this.expect(Ft.bracketR), e.key;
				e.computed = !1;
			}
			return e.key = this.type === Ft.num || this.type === Ft.string ? this.parseExprAtom() : this.parseIdent("never" !== this.options.allowReserved);
		}, $n.initFunction = function(e) {
			e.id = null, this.options.ecmaVersion >= 6 && (e.generator = e.expression = !1), this.options.ecmaVersion >= 8 && (e.async = !1);
		}, $n.parseMethod = function(e, t, n) {
			var s = this.startNode(), r = this.yieldPos, a = this.awaitPos, i = this.awaitIdentPos;
			return this.initFunction(s), this.options.ecmaVersion >= 6 && (s.generator = e), this.options.ecmaVersion >= 8 && (s.async = !!t), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(64 | dn(t, s.generator) | (n ? 128 : 0)), this.expect(Ft.parenL), s.params = this.parseBindingList(Ft.parenR, !1, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams(), this.parseFunctionBody(s, !1, !0, !1), this.yieldPos = r, this.awaitPos = a, this.awaitIdentPos = i, this.finishNode(s, "FunctionExpression");
		}, $n.parseArrowExpression = function(e, t, n, s) {
			var r = this.yieldPos, a = this.awaitPos, i = this.awaitIdentPos;
			return this.enterScope(16 | dn(n, !1)), this.initFunction(e), this.options.ecmaVersion >= 8 && (e.async = !!n), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, e.params = this.toAssignableList(t, !0), this.parseFunctionBody(e, !0, !1, s), this.yieldPos = r, this.awaitPos = a, this.awaitIdentPos = i, this.finishNode(e, "ArrowFunctionExpression");
		}, $n.parseFunctionBody = function(e, t, n, s) {
			var r = t && this.type !== Ft.braceL, a = this.strict, i = !1;
			if (r) e.body = this.parseMaybeAssign(s), e.expression = !0, this.checkParams(e, !1);
			else {
				var o = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(e.params);
				a && !o || (i = this.strictDirective(this.end)) && o && this.raiseRecoverable(e.start, "Illegal 'use strict' directive in function with non-simple parameter list");
				var l = this.labels;
				this.labels = [], i && (this.strict = !0), this.checkParams(e, !a && !i && !t && !n && this.isSimpleParamList(e.params)), this.strict && e.id && this.checkLValSimple(e.id, 5), e.body = this.parseBlock(!1, void 0, i && !a), e.expression = !1, this.adaptDirectivePrologue(e.body.body), this.labels = l;
			}
			this.exitScope();
		}, $n.isSimpleParamList = function(e) {
			for (var t = 0, n = e; t < n.length; t += 1) if ("Identifier" !== n[t].type) return !1;
			return !0;
		}, $n.checkParams = function(e, t) {
			for (var n = Object.create(null), s = 0, r = e.params; s < r.length; s += 1) {
				var a = r[s];
				this.checkLValInnerPattern(a, 1, t ? null : n);
			}
		}, $n.parseExprList = function(e, t, n, s) {
			for (var r = [], a = !0; !this.eat(e);) {
				if (a) a = !1;
				else if (this.expect(Ft.comma), t && this.afterTrailingComma(e)) break;
				var i = void 0;
				n && this.type === Ft.comma ? i = null : this.type === Ft.ellipsis ? (i = this.parseSpread(s), s && this.type === Ft.comma && s.trailingComma < 0 && (s.trailingComma = this.start)) : i = this.parseMaybeAssign(!1, s), r.push(i);
			}
			return r;
		}, $n.checkUnreserved = function(e) {
			var t = e.start, n = e.end, s = e.name;
			(this.inGenerator && "yield" === s && this.raiseRecoverable(t, "Cannot use 'yield' as identifier inside a generator"), this.inAsync && "await" === s && this.raiseRecoverable(t, "Cannot use 'await' as identifier inside an async function"), this.currentThisScope().flags & un || "arguments" !== s || this.raiseRecoverable(t, "Cannot use 'arguments' in class field initializer"), !this.inClassStaticBlock || "arguments" !== s && "await" !== s || this.raise(t, "Cannot use " + s + " in class static initialization block"), this.keywords.test(s) && this.raise(t, "Unexpected keyword '" + s + "'"), this.options.ecmaVersion < 6 && -1 !== this.input.slice(t, n).indexOf("\\")) || (this.strict ? this.reservedWordsStrict : this.reservedWords).test(s) && (this.inAsync || "await" !== s || this.raiseRecoverable(t, "Cannot use keyword 'await' outside an async function"), this.raiseRecoverable(t, "The keyword '" + s + "' is reserved"));
		}, $n.parseIdent = function(e) {
			var t = this.parseIdentNode();
			return this.next(!!e), this.finishNode(t, "Identifier"), e || (this.checkUnreserved(t), "await" !== t.name || this.awaitIdentPos || (this.awaitIdentPos = t.start)), t;
		}, $n.parseIdentNode = function() {
			var e = this.startNode();
			return this.type === Ft.name ? e.name = this.value : this.type.keyword ? (e.name = this.type.keyword, "class" !== e.name && "function" !== e.name || this.lastTokEnd === this.lastTokStart + 1 && 46 === this.input.charCodeAt(this.lastTokStart) || this.context.pop(), this.type = Ft.name) : this.unexpected(), e;
		}, $n.parsePrivateIdent = function() {
			var e = this.startNode();
			return this.type === Ft.privateId ? e.name = this.value : this.unexpected(), this.next(), this.finishNode(e, "PrivateIdentifier"), this.options.checkPrivateFields && (0 === this.privateNameStack.length ? this.raise(e.start, "Private field '#" + e.name + "' must be declared in an enclosing class") : this.privateNameStack[this.privateNameStack.length - 1].used.push(e)), e;
		}, $n.parseYield = function(e) {
			this.yieldPos || (this.yieldPos = this.start);
			var t = this.startNode();
			return this.next(), this.type === Ft.semi || this.canInsertSemicolon() || this.type !== Ft.star && !this.type.startsExpr ? (t.delegate = !1, t.argument = null) : (t.delegate = this.eat(Ft.star), t.argument = this.parseMaybeAssign(e)), this.finishNode(t, "YieldExpression");
		}, $n.parseAwait = function(e) {
			this.awaitPos || (this.awaitPos = this.start);
			var t = this.startNode();
			return this.next(), t.argument = this.parseMaybeUnary(null, !0, !1, e), this.finishNode(t, "AwaitExpression");
		};
		var qn = hn.prototype;
		qn.raise = function(e, t) {
			var n = an(this.input, e);
			t += " (" + n.line + ":" + n.column + ")", this.sourceFile && (t += " in " + this.sourceFile);
			var s = new SyntaxError(t);
			throw s.pos = e, s.loc = n, s.raisedAt = this.pos, s;
		}, qn.raiseRecoverable = qn.raise, qn.curPosition = function() {
			if (this.options.locations) return new sn(this.curLine, this.pos - this.lineStart);
		};
		var Ln = hn.prototype, On = function(e) {
			this.flags = e, this.var = [], this.lexical = [], this.functions = [];
		};
		Ln.enterScope = function(e) {
			this.scopeStack.push(new On(e));
		}, Ln.exitScope = function() {
			this.scopeStack.pop();
		}, Ln.treatFunctionsAsVarInScope = function(e) {
			return 2 & e.flags || !this.inModule && 1 & e.flags;
		}, Ln.declareName = function(e, t, n) {
			var s = !1;
			if (2 === t) {
				var r = this.currentScope();
				s = r.lexical.indexOf(e) > -1 || r.functions.indexOf(e) > -1 || r.var.indexOf(e) > -1, r.lexical.push(e), this.inModule && 1 & r.flags && delete this.undefinedExports[e];
			} else if (4 === t) this.currentScope().lexical.push(e);
			else if (3 === t) {
				var a = this.currentScope();
				s = this.treatFunctionsAsVar ? a.lexical.indexOf(e) > -1 : a.lexical.indexOf(e) > -1 || a.var.indexOf(e) > -1, a.functions.push(e);
			} else for (var i = this.scopeStack.length - 1; i >= 0; --i) {
				var o = this.scopeStack[i];
				if (o.lexical.indexOf(e) > -1 && !(32 & o.flags && o.lexical[0] === e) || !this.treatFunctionsAsVarInScope(o) && o.functions.indexOf(e) > -1) {
					s = !0;
					break;
				}
				if (o.var.push(e), this.inModule && 1 & o.flags && delete this.undefinedExports[e], o.flags & un) break;
			}
			s && this.raiseRecoverable(n, "Identifier '" + e + "' has already been declared");
		}, Ln.checkLocalExport = function(e) {
			-1 === this.scopeStack[0].lexical.indexOf(e.name) && -1 === this.scopeStack[0].var.indexOf(e.name) && (this.undefinedExports[e.name] = e);
		}, Ln.currentScope = function() {
			return this.scopeStack[this.scopeStack.length - 1];
		}, Ln.currentVarScope = function() {
			for (var e = this.scopeStack.length - 1;; e--) {
				var t = this.scopeStack[e];
				if (771 & t.flags) return t;
			}
		}, Ln.currentThisScope = function() {
			for (var e = this.scopeStack.length - 1;; e--) {
				var t = this.scopeStack[e];
				if (771 & t.flags && !(16 & t.flags)) return t;
			}
		};
		var Nn = function(e, t, n) {
			this.type = "", this.start = t, this.end = 0, e.options.locations && (this.loc = new rn(e, n)), e.options.directSourceFile && (this.sourceFile = e.options.directSourceFile), e.options.ranges && (this.range = [t, 0]);
		}, Dn = hn.prototype;
		function jn(e, t, n, s) {
			return e.type = t, e.end = n, this.options.locations && (e.loc.end = s), this.options.ranges && (e.range[1] = n), e;
		}
		Dn.startNode = function() {
			return new Nn(this, this.start, this.startLoc);
		}, Dn.startNodeAt = function(e, t) {
			return new Nn(this, e, t);
		}, Dn.finishNode = function(e, t) {
			return jn.call(this, e, t, this.lastTokEnd, this.lastTokEndLoc);
		}, Dn.finishNodeAt = function(e, t, n, s) {
			return jn.call(this, e, t, n, s);
		}, Dn.copyNode = function(e) {
			var t = new Nn(this, e.start, this.startLoc);
			for (var n in e) t[n] = e[n];
			return t;
		};
		var Bn = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS", Fn = Bn + " Extended_Pictographic", Vn = Fn + " EBase EComp EMod EPres ExtPict", Hn = {
			9: Bn,
			10: Fn,
			11: Fn,
			12: Vn,
			13: Vn,
			14: Vn
		}, Un = {
			9: "",
			10: "",
			11: "",
			12: "",
			13: "",
			14: "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji"
		}, zn = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu", Wn = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb", Gn = Wn + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd", Kn = Gn + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho", Xn = Kn + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi", Qn = Xn + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith", Yn = {
			9: Wn,
			10: Gn,
			11: Kn,
			12: Xn,
			13: Qn,
			14: Qn + " Gara Garay Gukh Gurung_Khema Hrkt Katakana_Or_Hiragana Kawi Kirat_Rai Krai Nag_Mundari Nagm Ol_Onal Onao Sunu Sunuwar Todhri Todr Tulu_Tigalari Tutg Unknown Zzzz"
		}, Jn = {};
		function Zn(e) {
			var t = Jn[e] = {
				binary: en(Hn[e] + " " + zn),
				binaryOfStrings: en(Un[e]),
				nonBinary: {
					General_Category: en(zn),
					Script: en(Yn[e])
				}
			};
			t.nonBinary.Script_Extensions = t.nonBinary.Script, t.nonBinary.gc = t.nonBinary.General_Category, t.nonBinary.sc = t.nonBinary.Script, t.nonBinary.scx = t.nonBinary.Script_Extensions;
		}
		for (var es = 0, ts = [
			9,
			10,
			11,
			12,
			13,
			14
		]; es < ts.length; es += 1) Zn(ts[es]);
		var ns = hn.prototype, ss = function(e, t) {
			this.parent = e, this.base = t || this;
		};
		ss.prototype.separatedFrom = function(e) {
			for (var t = this; t; t = t.parent) for (var n = e; n; n = n.parent) if (t.base === n.base && t !== n) return !0;
			return !1;
		}, ss.prototype.sibling = function() {
			return new ss(this.parent, this.base);
		};
		var rs = function(e) {
			this.parser = e, this.validFlags = "gim" + (e.options.ecmaVersion >= 6 ? "uy" : "") + (e.options.ecmaVersion >= 9 ? "s" : "") + (e.options.ecmaVersion >= 13 ? "d" : "") + (e.options.ecmaVersion >= 15 ? "v" : ""), this.unicodeProperties = Jn[e.options.ecmaVersion >= 14 ? 14 : e.options.ecmaVersion], this.source = "", this.flags = "", this.start = 0, this.switchU = !1, this.switchV = !1, this.switchN = !1, this.pos = 0, this.lastIntValue = 0, this.lastStringValue = "", this.lastAssertionIsQuantifiable = !1, this.numCapturingParens = 0, this.maxBackReference = 0, this.groupNames = Object.create(null), this.backReferenceNames = [], this.branchID = null;
		};
		function as(e) {
			return 105 === e || 109 === e || 115 === e;
		}
		function is(e) {
			return 36 === e || e >= 40 && e <= 43 || 46 === e || 63 === e || e >= 91 && e <= 94 || e >= 123 && e <= 125;
		}
		function os(e) {
			return e >= 65 && e <= 90 || e >= 97 && e <= 122;
		}
		rs.prototype.reset = function(e, t, n) {
			var s = -1 !== n.indexOf("v"), r = -1 !== n.indexOf("u");
			this.start = 0 | e, this.source = t + "", this.flags = n, s && this.parser.options.ecmaVersion >= 15 ? (this.switchU = !0, this.switchV = !0, this.switchN = !0) : (this.switchU = r && this.parser.options.ecmaVersion >= 6, this.switchV = !1, this.switchN = r && this.parser.options.ecmaVersion >= 9);
		}, rs.prototype.raise = function(e) {
			this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + e);
		}, rs.prototype.at = function(e, t) {
			void 0 === t && (t = !1);
			var n = this.source, s = n.length;
			if (e >= s) return -1;
			var r = n.charCodeAt(e);
			if (!t && !this.switchU || r <= 55295 || r >= 57344 || e + 1 >= s) return r;
			var a = n.charCodeAt(e + 1);
			return a >= 56320 && a <= 57343 ? (r << 10) + a - 56613888 : r;
		}, rs.prototype.nextIndex = function(e, t) {
			void 0 === t && (t = !1);
			var n = this.source, s = n.length;
			if (e >= s) return s;
			var r, a = n.charCodeAt(e);
			return !t && !this.switchU || a <= 55295 || a >= 57344 || e + 1 >= s || (r = n.charCodeAt(e + 1)) < 56320 || r > 57343 ? e + 1 : e + 2;
		}, rs.prototype.current = function(e) {
			return void 0 === e && (e = !1), this.at(this.pos, e);
		}, rs.prototype.lookahead = function(e) {
			return void 0 === e && (e = !1), this.at(this.nextIndex(this.pos, e), e);
		}, rs.prototype.advance = function(e) {
			void 0 === e && (e = !1), this.pos = this.nextIndex(this.pos, e);
		}, rs.prototype.eat = function(e, t) {
			return void 0 === t && (t = !1), this.current(t) === e && (this.advance(t), !0);
		}, rs.prototype.eatChars = function(e, t) {
			void 0 === t && (t = !1);
			for (var n = this.pos, s = 0, r = e; s < r.length; s += 1) {
				var a = r[s], i = this.at(n, t);
				if (-1 === i || i !== a) return !1;
				n = this.nextIndex(n, t);
			}
			return this.pos = n, !0;
		}, ns.validateRegExpFlags = function(e) {
			for (var t = e.validFlags, n = e.flags, s = !1, r = !1, a = 0; a < n.length; a++) {
				var i = n.charAt(a);
				-1 === t.indexOf(i) && this.raise(e.start, "Invalid regular expression flag"), n.indexOf(i, a + 1) > -1 && this.raise(e.start, "Duplicate regular expression flag"), "u" === i && (s = !0), "v" === i && (r = !0);
			}
			this.options.ecmaVersion >= 15 && s && r && this.raise(e.start, "Invalid regular expression flag");
		}, ns.validateRegExpPattern = function(e) {
			this.regexp_pattern(e), !e.switchN && this.options.ecmaVersion >= 9 && function(e) {
				for (var t in e) return !0;
				return !1;
			}(e.groupNames) && (e.switchN = !0, this.regexp_pattern(e));
		}, ns.regexp_pattern = function(e) {
			e.pos = 0, e.lastIntValue = 0, e.lastStringValue = "", e.lastAssertionIsQuantifiable = !1, e.numCapturingParens = 0, e.maxBackReference = 0, e.groupNames = Object.create(null), e.backReferenceNames.length = 0, e.branchID = null, this.regexp_disjunction(e), e.pos !== e.source.length && (e.eat(41) && e.raise("Unmatched ')'"), (e.eat(93) || e.eat(125)) && e.raise("Lone quantifier brackets")), e.maxBackReference > e.numCapturingParens && e.raise("Invalid escape");
			for (var t = 0, n = e.backReferenceNames; t < n.length; t += 1) {
				var s = n[t];
				e.groupNames[s] || e.raise("Invalid named capture referenced");
			}
		}, ns.regexp_disjunction = function(e) {
			var t = this.options.ecmaVersion >= 16;
			for (t && (e.branchID = new ss(e.branchID, null)), this.regexp_alternative(e); e.eat(124);) t && (e.branchID = e.branchID.sibling()), this.regexp_alternative(e);
			t && (e.branchID = e.branchID.parent), this.regexp_eatQuantifier(e, !0) && e.raise("Nothing to repeat"), e.eat(123) && e.raise("Lone quantifier brackets");
		}, ns.regexp_alternative = function(e) {
			for (; e.pos < e.source.length && this.regexp_eatTerm(e););
		}, ns.regexp_eatTerm = function(e) {
			return this.regexp_eatAssertion(e) ? (e.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(e) && e.switchU && e.raise("Invalid quantifier"), !0) : !!(e.switchU ? this.regexp_eatAtom(e) : this.regexp_eatExtendedAtom(e)) && (this.regexp_eatQuantifier(e), !0);
		}, ns.regexp_eatAssertion = function(e) {
			var t = e.pos;
			if (e.lastAssertionIsQuantifiable = !1, e.eat(94) || e.eat(36)) return !0;
			if (e.eat(92)) {
				if (e.eat(66) || e.eat(98)) return !0;
				e.pos = t;
			}
			if (e.eat(40) && e.eat(63)) {
				var n = !1;
				if (this.options.ecmaVersion >= 9 && (n = e.eat(60)), e.eat(61) || e.eat(33)) return this.regexp_disjunction(e), e.eat(41) || e.raise("Unterminated group"), e.lastAssertionIsQuantifiable = !n, !0;
			}
			return e.pos = t, !1;
		}, ns.regexp_eatQuantifier = function(e, t) {
			return void 0 === t && (t = !1), !!this.regexp_eatQuantifierPrefix(e, t) && (e.eat(63), !0);
		}, ns.regexp_eatQuantifierPrefix = function(e, t) {
			return e.eat(42) || e.eat(43) || e.eat(63) || this.regexp_eatBracedQuantifier(e, t);
		}, ns.regexp_eatBracedQuantifier = function(e, t) {
			var n = e.pos;
			if (e.eat(123)) {
				var s = 0, r = -1;
				if (this.regexp_eatDecimalDigits(e) && (s = e.lastIntValue, e.eat(44) && this.regexp_eatDecimalDigits(e) && (r = e.lastIntValue), e.eat(125))) return -1 !== r && r < s && !t && e.raise("numbers out of order in {} quantifier"), !0;
				e.switchU && !t && e.raise("Incomplete quantifier"), e.pos = n;
			}
			return !1;
		}, ns.regexp_eatAtom = function(e) {
			return this.regexp_eatPatternCharacters(e) || e.eat(46) || this.regexp_eatReverseSolidusAtomEscape(e) || this.regexp_eatCharacterClass(e) || this.regexp_eatUncapturingGroup(e) || this.regexp_eatCapturingGroup(e);
		}, ns.regexp_eatReverseSolidusAtomEscape = function(e) {
			var t = e.pos;
			if (e.eat(92)) {
				if (this.regexp_eatAtomEscape(e)) return !0;
				e.pos = t;
			}
			return !1;
		}, ns.regexp_eatUncapturingGroup = function(e) {
			var t = e.pos;
			if (e.eat(40)) {
				if (e.eat(63)) {
					if (this.options.ecmaVersion >= 16) {
						var n = this.regexp_eatModifiers(e), s = e.eat(45);
						if (n || s) {
							for (var r = 0; r < n.length; r++) {
								var a = n.charAt(r);
								n.indexOf(a, r + 1) > -1 && e.raise("Duplicate regular expression modifiers");
							}
							if (s) {
								var i = this.regexp_eatModifiers(e);
								n || i || 58 !== e.current() || e.raise("Invalid regular expression modifiers");
								for (var o = 0; o < i.length; o++) {
									var l = i.charAt(o);
									(i.indexOf(l, o + 1) > -1 || n.indexOf(l) > -1) && e.raise("Duplicate regular expression modifiers");
								}
							}
						}
					}
					if (e.eat(58)) {
						if (this.regexp_disjunction(e), e.eat(41)) return !0;
						e.raise("Unterminated group");
					}
				}
				e.pos = t;
			}
			return !1;
		}, ns.regexp_eatCapturingGroup = function(e) {
			if (e.eat(40)) {
				if (this.options.ecmaVersion >= 9 ? this.regexp_groupSpecifier(e) : 63 === e.current() && e.raise("Invalid group"), this.regexp_disjunction(e), e.eat(41)) return e.numCapturingParens += 1, !0;
				e.raise("Unterminated group");
			}
			return !1;
		}, ns.regexp_eatModifiers = function(e) {
			for (var t = "", n = 0; -1 !== (n = e.current()) && as(n);) t += tn(n), e.advance();
			return t;
		}, ns.regexp_eatExtendedAtom = function(e) {
			return e.eat(46) || this.regexp_eatReverseSolidusAtomEscape(e) || this.regexp_eatCharacterClass(e) || this.regexp_eatUncapturingGroup(e) || this.regexp_eatCapturingGroup(e) || this.regexp_eatInvalidBracedQuantifier(e) || this.regexp_eatExtendedPatternCharacter(e);
		}, ns.regexp_eatInvalidBracedQuantifier = function(e) {
			return this.regexp_eatBracedQuantifier(e, !0) && e.raise("Nothing to repeat"), !1;
		}, ns.regexp_eatSyntaxCharacter = function(e) {
			var t = e.current();
			return !!is(t) && (e.lastIntValue = t, e.advance(), !0);
		}, ns.regexp_eatPatternCharacters = function(e) {
			for (var t = e.pos, n = 0; -1 !== (n = e.current()) && !is(n);) e.advance();
			return e.pos !== t;
		}, ns.regexp_eatExtendedPatternCharacter = function(e) {
			var t = e.current();
			return !(-1 === t || 36 === t || t >= 40 && t <= 43 || 46 === t || 63 === t || 91 === t || 94 === t || 124 === t) && (e.advance(), !0);
		}, ns.regexp_groupSpecifier = function(e) {
			if (e.eat(63)) {
				this.regexp_eatGroupName(e) || e.raise("Invalid group");
				var t = this.options.ecmaVersion >= 16, n = e.groupNames[e.lastStringValue];
				if (n) if (t) for (var s = 0, r = n; s < r.length; s += 1) r[s].separatedFrom(e.branchID) || e.raise("Duplicate capture group name");
				else e.raise("Duplicate capture group name");
				t ? (n || (e.groupNames[e.lastStringValue] = [])).push(e.branchID) : e.groupNames[e.lastStringValue] = !0;
			}
		}, ns.regexp_eatGroupName = function(e) {
			if (e.lastStringValue = "", e.eat(60)) {
				if (this.regexp_eatRegExpIdentifierName(e) && e.eat(62)) return !0;
				e.raise("Invalid capture group name");
			}
			return !1;
		}, ns.regexp_eatRegExpIdentifierName = function(e) {
			if (e.lastStringValue = "", this.regexp_eatRegExpIdentifierStart(e)) {
				for (e.lastStringValue += tn(e.lastIntValue); this.regexp_eatRegExpIdentifierPart(e);) e.lastStringValue += tn(e.lastIntValue);
				return !0;
			}
			return !1;
		}, ns.regexp_eatRegExpIdentifierStart = function(e) {
			var t = e.pos, n = this.options.ecmaVersion >= 11, s = e.current(n);
			return e.advance(n), 92 === s && this.regexp_eatRegExpUnicodeEscapeSequence(e, n) && (s = e.lastIntValue), function(e) {
				return Mt(e, !0) || 36 === e || 95 === e;
			}(s) ? (e.lastIntValue = s, !0) : (e.pos = t, !1);
		}, ns.regexp_eatRegExpIdentifierPart = function(e) {
			var t = e.pos, n = this.options.ecmaVersion >= 11, s = e.current(n);
			return e.advance(n), 92 === s && this.regexp_eatRegExpUnicodeEscapeSequence(e, n) && (s = e.lastIntValue), function(e) {
				return qt(e, !0) || 36 === e || 95 === e || 8204 === e || 8205 === e;
			}(s) ? (e.lastIntValue = s, !0) : (e.pos = t, !1);
		}, ns.regexp_eatAtomEscape = function(e) {
			return !!(this.regexp_eatBackReference(e) || this.regexp_eatCharacterClassEscape(e) || this.regexp_eatCharacterEscape(e) || e.switchN && this.regexp_eatKGroupName(e)) || (e.switchU && (99 === e.current() && e.raise("Invalid unicode escape"), e.raise("Invalid escape")), !1);
		}, ns.regexp_eatBackReference = function(e) {
			var t = e.pos;
			if (this.regexp_eatDecimalEscape(e)) {
				var n = e.lastIntValue;
				if (e.switchU) return n > e.maxBackReference && (e.maxBackReference = n), !0;
				if (n <= e.numCapturingParens) return !0;
				e.pos = t;
			}
			return !1;
		}, ns.regexp_eatKGroupName = function(e) {
			if (e.eat(107)) {
				if (this.regexp_eatGroupName(e)) return e.backReferenceNames.push(e.lastStringValue), !0;
				e.raise("Invalid named reference");
			}
			return !1;
		}, ns.regexp_eatCharacterEscape = function(e) {
			return this.regexp_eatControlEscape(e) || this.regexp_eatCControlLetter(e) || this.regexp_eatZero(e) || this.regexp_eatHexEscapeSequence(e) || this.regexp_eatRegExpUnicodeEscapeSequence(e, !1) || !e.switchU && this.regexp_eatLegacyOctalEscapeSequence(e) || this.regexp_eatIdentityEscape(e);
		}, ns.regexp_eatCControlLetter = function(e) {
			var t = e.pos;
			if (e.eat(99)) {
				if (this.regexp_eatControlLetter(e)) return !0;
				e.pos = t;
			}
			return !1;
		}, ns.regexp_eatZero = function(e) {
			return 48 === e.current() && !ps(e.lookahead()) && (e.lastIntValue = 0, e.advance(), !0);
		}, ns.regexp_eatControlEscape = function(e) {
			var t = e.current();
			return 116 === t ? (e.lastIntValue = 9, e.advance(), !0) : 110 === t ? (e.lastIntValue = 10, e.advance(), !0) : 118 === t ? (e.lastIntValue = 11, e.advance(), !0) : 102 === t ? (e.lastIntValue = 12, e.advance(), !0) : 114 === t && (e.lastIntValue = 13, e.advance(), !0);
		}, ns.regexp_eatControlLetter = function(e) {
			var t = e.current();
			return !!os(t) && (e.lastIntValue = t % 32, e.advance(), !0);
		}, ns.regexp_eatRegExpUnicodeEscapeSequence = function(e, t) {
			void 0 === t && (t = !1);
			var n, s = e.pos, r = t || e.switchU;
			if (e.eat(117)) {
				if (this.regexp_eatFixedHexDigits(e, 4)) {
					var a = e.lastIntValue;
					if (r && a >= 55296 && a <= 56319) {
						var i = e.pos;
						if (e.eat(92) && e.eat(117) && this.regexp_eatFixedHexDigits(e, 4)) {
							var o = e.lastIntValue;
							if (o >= 56320 && o <= 57343) return e.lastIntValue = 1024 * (a - 55296) + (o - 56320) + 65536, !0;
						}
						e.pos = i, e.lastIntValue = a;
					}
					return !0;
				}
				if (r && e.eat(123) && this.regexp_eatHexDigits(e) && e.eat(125) && (n = e.lastIntValue) >= 0 && n <= 1114111) return !0;
				r && e.raise("Invalid unicode escape"), e.pos = s;
			}
			return !1;
		}, ns.regexp_eatIdentityEscape = function(e) {
			if (e.switchU) return !!this.regexp_eatSyntaxCharacter(e) || !!e.eat(47) && (e.lastIntValue = 47, !0);
			var t = e.current();
			return !(99 === t || e.switchN && 107 === t) && (e.lastIntValue = t, e.advance(), !0);
		}, ns.regexp_eatDecimalEscape = function(e) {
			e.lastIntValue = 0;
			var t = e.current();
			if (t >= 49 && t <= 57) {
				do
					e.lastIntValue = 10 * e.lastIntValue + (t - 48), e.advance();
				while ((t = e.current()) >= 48 && t <= 57);
				return !0;
			}
			return !1;
		};
		function ls(e) {
			return os(e) || 95 === e;
		}
		function cs(e) {
			return ls(e) || ps(e);
		}
		function ps(e) {
			return e >= 48 && e <= 57;
		}
		function us(e) {
			return e >= 48 && e <= 57 || e >= 65 && e <= 70 || e >= 97 && e <= 102;
		}
		function ds(e) {
			return e >= 65 && e <= 70 ? e - 65 + 10 : e >= 97 && e <= 102 ? e - 97 + 10 : e - 48;
		}
		function hs(e) {
			return e >= 48 && e <= 55;
		}
		ns.regexp_eatCharacterClassEscape = function(e) {
			var t = e.current();
			if (function(e) {
				return 100 === e || 68 === e || 115 === e || 83 === e || 119 === e || 87 === e;
			}(t)) return e.lastIntValue = -1, e.advance(), 1;
			var n = !1;
			if (e.switchU && this.options.ecmaVersion >= 9 && ((n = 80 === t) || 112 === t)) {
				var s;
				if (e.lastIntValue = -1, e.advance(), e.eat(123) && (s = this.regexp_eatUnicodePropertyValueExpression(e)) && e.eat(125)) return n && 2 === s && e.raise("Invalid property name"), s;
				e.raise("Invalid property name");
			}
			return 0;
		}, ns.regexp_eatUnicodePropertyValueExpression = function(e) {
			var t = e.pos;
			if (this.regexp_eatUnicodePropertyName(e) && e.eat(61)) {
				var n = e.lastStringValue;
				if (this.regexp_eatUnicodePropertyValue(e)) {
					var s = e.lastStringValue;
					return this.regexp_validateUnicodePropertyNameAndValue(e, n, s), 1;
				}
			}
			if (e.pos = t, this.regexp_eatLoneUnicodePropertyNameOrValue(e)) {
				var r = e.lastStringValue;
				return this.regexp_validateUnicodePropertyNameOrValue(e, r);
			}
			return 0;
		}, ns.regexp_validateUnicodePropertyNameAndValue = function(e, t, n) {
			Yt(e.unicodeProperties.nonBinary, t) || e.raise("Invalid property name"), e.unicodeProperties.nonBinary[t].test(n) || e.raise("Invalid property value");
		}, ns.regexp_validateUnicodePropertyNameOrValue = function(e, t) {
			return e.unicodeProperties.binary.test(t) ? 1 : e.switchV && e.unicodeProperties.binaryOfStrings.test(t) ? 2 : void e.raise("Invalid property name");
		}, ns.regexp_eatUnicodePropertyName = function(e) {
			var t = 0;
			for (e.lastStringValue = ""; ls(t = e.current());) e.lastStringValue += tn(t), e.advance();
			return "" !== e.lastStringValue;
		}, ns.regexp_eatUnicodePropertyValue = function(e) {
			var t = 0;
			for (e.lastStringValue = ""; cs(t = e.current());) e.lastStringValue += tn(t), e.advance();
			return "" !== e.lastStringValue;
		}, ns.regexp_eatLoneUnicodePropertyNameOrValue = function(e) {
			return this.regexp_eatUnicodePropertyValue(e);
		}, ns.regexp_eatCharacterClass = function(e) {
			if (e.eat(91)) {
				var t = e.eat(94), n = this.regexp_classContents(e);
				return e.eat(93) || e.raise("Unterminated character class"), t && 2 === n && e.raise("Negated character class may contain strings"), !0;
			}
			return !1;
		}, ns.regexp_classContents = function(e) {
			return 93 === e.current() ? 1 : e.switchV ? this.regexp_classSetExpression(e) : (this.regexp_nonEmptyClassRanges(e), 1);
		}, ns.regexp_nonEmptyClassRanges = function(e) {
			for (; this.regexp_eatClassAtom(e);) {
				var t = e.lastIntValue;
				if (e.eat(45) && this.regexp_eatClassAtom(e)) {
					var n = e.lastIntValue;
					!e.switchU || -1 !== t && -1 !== n || e.raise("Invalid character class"), -1 !== t && -1 !== n && t > n && e.raise("Range out of order in character class");
				}
			}
		}, ns.regexp_eatClassAtom = function(e) {
			var t = e.pos;
			if (e.eat(92)) {
				if (this.regexp_eatClassEscape(e)) return !0;
				if (e.switchU) {
					var n = e.current();
					(99 === n || hs(n)) && e.raise("Invalid class escape"), e.raise("Invalid escape");
				}
				e.pos = t;
			}
			var s = e.current();
			return 93 !== s && (e.lastIntValue = s, e.advance(), !0);
		}, ns.regexp_eatClassEscape = function(e) {
			var t = e.pos;
			if (e.eat(98)) return e.lastIntValue = 8, !0;
			if (e.switchU && e.eat(45)) return e.lastIntValue = 45, !0;
			if (!e.switchU && e.eat(99)) {
				if (this.regexp_eatClassControlLetter(e)) return !0;
				e.pos = t;
			}
			return this.regexp_eatCharacterClassEscape(e) || this.regexp_eatCharacterEscape(e);
		}, ns.regexp_classSetExpression = function(e) {
			var t, n = 1;
			if (this.regexp_eatClassSetRange(e));
			else if (t = this.regexp_eatClassSetOperand(e)) {
				2 === t && (n = 2);
				for (var s = e.pos; e.eatChars([38, 38]);) 38 !== e.current() && (t = this.regexp_eatClassSetOperand(e)) ? 2 !== t && (n = 1) : e.raise("Invalid character in character class");
				if (s !== e.pos) return n;
				for (; e.eatChars([45, 45]);) this.regexp_eatClassSetOperand(e) || e.raise("Invalid character in character class");
				if (s !== e.pos) return n;
			} else e.raise("Invalid character in character class");
			for (;;) if (!this.regexp_eatClassSetRange(e)) {
				if (!(t = this.regexp_eatClassSetOperand(e))) return n;
				2 === t && (n = 2);
			}
		}, ns.regexp_eatClassSetRange = function(e) {
			var t = e.pos;
			if (this.regexp_eatClassSetCharacter(e)) {
				var n = e.lastIntValue;
				if (e.eat(45) && this.regexp_eatClassSetCharacter(e)) {
					var s = e.lastIntValue;
					return -1 !== n && -1 !== s && n > s && e.raise("Range out of order in character class"), !0;
				}
				e.pos = t;
			}
			return !1;
		}, ns.regexp_eatClassSetOperand = function(e) {
			return this.regexp_eatClassSetCharacter(e) ? 1 : this.regexp_eatClassStringDisjunction(e) || this.regexp_eatNestedClass(e);
		}, ns.regexp_eatNestedClass = function(e) {
			var t = e.pos;
			if (e.eat(91)) {
				var n = e.eat(94), s = this.regexp_classContents(e);
				if (e.eat(93)) return n && 2 === s && e.raise("Negated character class may contain strings"), s;
				e.pos = t;
			}
			if (e.eat(92)) {
				var r = this.regexp_eatCharacterClassEscape(e);
				if (r) return r;
				e.pos = t;
			}
			return null;
		}, ns.regexp_eatClassStringDisjunction = function(e) {
			var t = e.pos;
			if (e.eatChars([92, 113])) {
				if (e.eat(123)) {
					var n = this.regexp_classStringDisjunctionContents(e);
					if (e.eat(125)) return n;
				} else e.raise("Invalid escape");
				e.pos = t;
			}
			return null;
		}, ns.regexp_classStringDisjunctionContents = function(e) {
			for (var t = this.regexp_classString(e); e.eat(124);) 2 === this.regexp_classString(e) && (t = 2);
			return t;
		}, ns.regexp_classString = function(e) {
			for (var t = 0; this.regexp_eatClassSetCharacter(e);) t++;
			return 1 === t ? 1 : 2;
		}, ns.regexp_eatClassSetCharacter = function(e) {
			var t = e.pos;
			if (e.eat(92)) return !(!this.regexp_eatCharacterEscape(e) && !this.regexp_eatClassSetReservedPunctuator(e)) || (e.eat(98) ? (e.lastIntValue = 8, !0) : (e.pos = t, !1));
			var n = e.current();
			return !(n < 0 || n === e.lookahead() && function(e) {
				return 33 === e || e >= 35 && e <= 38 || e >= 42 && e <= 44 || 46 === e || e >= 58 && e <= 64 || 94 === e || 96 === e || 126 === e;
			}(n)) && !function(e) {
				return 40 === e || 41 === e || 45 === e || 47 === e || e >= 91 && e <= 93 || e >= 123 && e <= 125;
			}(n) && (e.advance(), e.lastIntValue = n, !0);
		}, ns.regexp_eatClassSetReservedPunctuator = function(e) {
			var t = e.current();
			return !!function(e) {
				return 33 === e || 35 === e || 37 === e || 38 === e || 44 === e || 45 === e || e >= 58 && e <= 62 || 64 === e || 96 === e || 126 === e;
			}(t) && (e.lastIntValue = t, e.advance(), !0);
		}, ns.regexp_eatClassControlLetter = function(e) {
			var t = e.current();
			return !(!ps(t) && 95 !== t) && (e.lastIntValue = t % 32, e.advance(), !0);
		}, ns.regexp_eatHexEscapeSequence = function(e) {
			var t = e.pos;
			if (e.eat(120)) {
				if (this.regexp_eatFixedHexDigits(e, 2)) return !0;
				e.switchU && e.raise("Invalid escape"), e.pos = t;
			}
			return !1;
		}, ns.regexp_eatDecimalDigits = function(e) {
			var t = e.pos, n = 0;
			for (e.lastIntValue = 0; ps(n = e.current());) e.lastIntValue = 10 * e.lastIntValue + (n - 48), e.advance();
			return e.pos !== t;
		}, ns.regexp_eatHexDigits = function(e) {
			var t = e.pos, n = 0;
			for (e.lastIntValue = 0; us(n = e.current());) e.lastIntValue = 16 * e.lastIntValue + ds(n), e.advance();
			return e.pos !== t;
		}, ns.regexp_eatLegacyOctalEscapeSequence = function(e) {
			if (this.regexp_eatOctalDigit(e)) {
				var t = e.lastIntValue;
				if (this.regexp_eatOctalDigit(e)) {
					var n = e.lastIntValue;
					t <= 3 && this.regexp_eatOctalDigit(e) ? e.lastIntValue = 64 * t + 8 * n + e.lastIntValue : e.lastIntValue = 8 * t + n;
				} else e.lastIntValue = t;
				return !0;
			}
			return !1;
		}, ns.regexp_eatOctalDigit = function(e) {
			var t = e.current();
			return hs(t) ? (e.lastIntValue = t - 48, e.advance(), !0) : (e.lastIntValue = 0, !1);
		}, ns.regexp_eatFixedHexDigits = function(e, t) {
			var n = e.pos;
			e.lastIntValue = 0;
			for (var s = 0; s < t; ++s) {
				var r = e.current();
				if (!us(r)) return e.pos = n, !1;
				e.lastIntValue = 16 * e.lastIntValue + ds(r), e.advance();
			}
			return !0;
		};
		var ms = function(e) {
			this.type = e.type, this.value = e.value, this.start = e.start, this.end = e.end, e.options.locations && (this.loc = new rn(e, e.startLoc, e.endLoc)), e.options.ranges && (this.range = [e.start, e.end]);
		}, fs = hn.prototype;
		function ys(e) {
			return "function" != typeof BigInt ? null : BigInt(e.replace(/_/g, ""));
		}
		fs.next = function(e) {
			!e && this.type.keyword && this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword), this.options.onToken && this.options.onToken(new ms(this)), this.lastTokEnd = this.end, this.lastTokStart = this.start, this.lastTokEndLoc = this.endLoc, this.lastTokStartLoc = this.startLoc, this.nextToken();
		}, fs.getToken = function() {
			return this.next(), new ms(this);
		}, "undefined" != typeof Symbol && (fs[Symbol.iterator] = function() {
			var e = this;
			return { next: function() {
				var t = e.getToken();
				return {
					done: t.type === Ft.eof,
					value: t
				};
			} };
		}), fs.nextToken = function() {
			var e = this.curContext();
			return e && e.preserveSpace || this.skipSpace(), this.start = this.pos, this.options.locations && (this.startLoc = this.curPosition()), this.pos >= this.input.length ? this.finishToken(Ft.eof) : e.override ? e.override(this) : void this.readToken(this.fullCharCodeAtPos());
		}, fs.readToken = function(e) {
			return Mt(e, this.options.ecmaVersion >= 6) || 92 === e ? this.readWord() : this.getTokenFromCode(e);
		}, fs.fullCharCodeAtPos = function() {
			var e = this.input.charCodeAt(this.pos);
			if (e <= 55295 || e >= 56320) return e;
			var t = this.input.charCodeAt(this.pos + 1);
			return t <= 56319 || t >= 57344 ? e : (e << 10) + t - 56613888;
		}, fs.skipBlockComment = function() {
			var e = this.options.onComment && this.curPosition(), t = this.pos, n = this.input.indexOf("*/", this.pos += 2);
			if (-1 === n && this.raise(this.pos - 2, "Unterminated comment"), this.pos = n + 2, this.options.locations) for (var s = void 0, r = t; (s = zt(this.input, r, this.pos)) > -1;) ++this.curLine, r = this.lineStart = s;
			this.options.onComment && this.options.onComment(!0, this.input.slice(t + 2, n), t, this.pos, e, this.curPosition());
		}, fs.skipLineComment = function(e) {
			for (var t = this.pos, n = this.options.onComment && this.curPosition(), s = this.input.charCodeAt(this.pos += e); this.pos < this.input.length && !Ut(s);) s = this.input.charCodeAt(++this.pos);
			this.options.onComment && this.options.onComment(!1, this.input.slice(t + e, this.pos), t, this.pos, n, this.curPosition());
		}, fs.skipSpace = function() {
			e: for (; this.pos < this.input.length;) {
				var e = this.input.charCodeAt(this.pos);
				switch (e) {
					case 32:
					case 160:
						++this.pos;
						break;
					case 13: 10 === this.input.charCodeAt(this.pos + 1) && ++this.pos;
					case 10:
					case 8232:
					case 8233:
						++this.pos, this.options.locations && (++this.curLine, this.lineStart = this.pos);
						break;
					case 47:
						switch (this.input.charCodeAt(this.pos + 1)) {
							case 42:
								this.skipBlockComment();
								break;
							case 47:
								this.skipLineComment(2);
								break;
							default: break e;
						}
						break;
					default:
						if (!(e > 8 && e < 14 || e >= 5760 && Wt.test(String.fromCharCode(e)))) break e;
						++this.pos;
				}
			}
		}, fs.finishToken = function(e, t) {
			this.end = this.pos, this.options.locations && (this.endLoc = this.curPosition());
			var n = this.type;
			this.type = e, this.value = t, this.updateContext(n);
		}, fs.readToken_dot = function() {
			var e = this.input.charCodeAt(this.pos + 1);
			if (e >= 48 && e <= 57) return this.readNumber(!0);
			var t = this.input.charCodeAt(this.pos + 2);
			return this.options.ecmaVersion >= 6 && 46 === e && 46 === t ? (this.pos += 3, this.finishToken(Ft.ellipsis)) : (++this.pos, this.finishToken(Ft.dot));
		}, fs.readToken_slash = function() {
			var e = this.input.charCodeAt(this.pos + 1);
			return this.exprAllowed ? (++this.pos, this.readRegexp()) : 61 === e ? this.finishOp(Ft.assign, 2) : this.finishOp(Ft.slash, 1);
		}, fs.readToken_mult_modulo_exp = function(e) {
			var t = this.input.charCodeAt(this.pos + 1), n = 1, s = 42 === e ? Ft.star : Ft.modulo;
			return this.options.ecmaVersion >= 7 && 42 === e && 42 === t && (++n, s = Ft.starstar, t = this.input.charCodeAt(this.pos + 2)), 61 === t ? this.finishOp(Ft.assign, n + 1) : this.finishOp(s, n);
		}, fs.readToken_pipe_amp = function(e) {
			var t = this.input.charCodeAt(this.pos + 1);
			if (t === e) {
				if (this.options.ecmaVersion >= 12) {
					if (61 === this.input.charCodeAt(this.pos + 2)) return this.finishOp(Ft.assign, 3);
				}
				return this.finishOp(124 === e ? Ft.logicalOR : Ft.logicalAND, 2);
			}
			return 61 === t ? this.finishOp(Ft.assign, 2) : this.finishOp(124 === e ? Ft.bitwiseOR : Ft.bitwiseAND, 1);
		}, fs.readToken_caret = function() {
			return 61 === this.input.charCodeAt(this.pos + 1) ? this.finishOp(Ft.assign, 2) : this.finishOp(Ft.bitwiseXOR, 1);
		}, fs.readToken_plus_min = function(e) {
			var t = this.input.charCodeAt(this.pos + 1);
			return t === e ? 45 !== t || this.inModule || 62 !== this.input.charCodeAt(this.pos + 2) || 0 !== this.lastTokEnd && !Vt.test(this.input.slice(this.lastTokEnd, this.pos)) ? this.finishOp(Ft.incDec, 2) : (this.skipLineComment(3), this.skipSpace(), this.nextToken()) : 61 === t ? this.finishOp(Ft.assign, 2) : this.finishOp(Ft.plusMin, 1);
		}, fs.readToken_lt_gt = function(e) {
			var t = this.input.charCodeAt(this.pos + 1), n = 1;
			return t === e ? (n = 62 === e && 62 === this.input.charCodeAt(this.pos + 2) ? 3 : 2, 61 === this.input.charCodeAt(this.pos + n) ? this.finishOp(Ft.assign, n + 1) : this.finishOp(Ft.bitShift, n)) : 33 !== t || 60 !== e || this.inModule || 45 !== this.input.charCodeAt(this.pos + 2) || 45 !== this.input.charCodeAt(this.pos + 3) ? (61 === t && (n = 2), this.finishOp(Ft.relational, n)) : (this.skipLineComment(4), this.skipSpace(), this.nextToken());
		}, fs.readToken_eq_excl = function(e) {
			var t = this.input.charCodeAt(this.pos + 1);
			return 61 === t ? this.finishOp(Ft.equality, 61 === this.input.charCodeAt(this.pos + 2) ? 3 : 2) : 61 === e && 62 === t && this.options.ecmaVersion >= 6 ? (this.pos += 2, this.finishToken(Ft.arrow)) : this.finishOp(61 === e ? Ft.eq : Ft.prefix, 1);
		}, fs.readToken_question = function() {
			var e = this.options.ecmaVersion;
			if (e >= 11) {
				var t = this.input.charCodeAt(this.pos + 1);
				if (46 === t) {
					var n = this.input.charCodeAt(this.pos + 2);
					if (n < 48 || n > 57) return this.finishOp(Ft.questionDot, 2);
				}
				if (63 === t) {
					if (e >= 12) {
						if (61 === this.input.charCodeAt(this.pos + 2)) return this.finishOp(Ft.assign, 3);
					}
					return this.finishOp(Ft.coalesce, 2);
				}
			}
			return this.finishOp(Ft.question, 1);
		}, fs.readToken_numberSign = function() {
			var e = 35;
			if (this.options.ecmaVersion >= 13 && (++this.pos, Mt(e = this.fullCharCodeAtPos(), !0) || 92 === e)) return this.finishToken(Ft.privateId, this.readWord1());
			this.raise(this.pos, "Unexpected character '" + tn(e) + "'");
		}, fs.getTokenFromCode = function(e) {
			switch (e) {
				case 46: return this.readToken_dot();
				case 40: return ++this.pos, this.finishToken(Ft.parenL);
				case 41: return ++this.pos, this.finishToken(Ft.parenR);
				case 59: return ++this.pos, this.finishToken(Ft.semi);
				case 44: return ++this.pos, this.finishToken(Ft.comma);
				case 91: return ++this.pos, this.finishToken(Ft.bracketL);
				case 93: return ++this.pos, this.finishToken(Ft.bracketR);
				case 123: return ++this.pos, this.finishToken(Ft.braceL);
				case 125: return ++this.pos, this.finishToken(Ft.braceR);
				case 58: return ++this.pos, this.finishToken(Ft.colon);
				case 96:
					if (this.options.ecmaVersion < 6) break;
					return ++this.pos, this.finishToken(Ft.backQuote);
				case 48:
					var t = this.input.charCodeAt(this.pos + 1);
					if (120 === t || 88 === t) return this.readRadixNumber(16);
					if (this.options.ecmaVersion >= 6) {
						if (111 === t || 79 === t) return this.readRadixNumber(8);
						if (98 === t || 66 === t) return this.readRadixNumber(2);
					}
				case 49:
				case 50:
				case 51:
				case 52:
				case 53:
				case 54:
				case 55:
				case 56:
				case 57: return this.readNumber(!1);
				case 34:
				case 39: return this.readString(e);
				case 47: return this.readToken_slash();
				case 37:
				case 42: return this.readToken_mult_modulo_exp(e);
				case 124:
				case 38: return this.readToken_pipe_amp(e);
				case 94: return this.readToken_caret();
				case 43:
				case 45: return this.readToken_plus_min(e);
				case 60:
				case 62: return this.readToken_lt_gt(e);
				case 61:
				case 33: return this.readToken_eq_excl(e);
				case 63: return this.readToken_question();
				case 126: return this.finishOp(Ft.prefix, 1);
				case 35: return this.readToken_numberSign();
			}
			this.raise(this.pos, "Unexpected character '" + tn(e) + "'");
		}, fs.finishOp = function(e, t) {
			var n = this.input.slice(this.pos, this.pos + t);
			return this.pos += t, this.finishToken(e, n);
		}, fs.readRegexp = function() {
			for (var e, t, n = this.pos;;) {
				this.pos >= this.input.length && this.raise(n, "Unterminated regular expression");
				var s = this.input.charAt(this.pos);
				if (Vt.test(s) && this.raise(n, "Unterminated regular expression"), e) e = !1;
				else {
					if ("[" === s) t = !0;
					else if ("]" === s && t) t = !1;
					else if ("/" === s && !t) break;
					e = "\\" === s;
				}
				++this.pos;
			}
			var r = this.input.slice(n, this.pos);
			++this.pos;
			var a = this.pos, i = this.readWord1();
			this.containsEsc && this.unexpected(a);
			var o = this.regexpState || (this.regexpState = new rs(this));
			o.reset(n, r, i), this.validateRegExpFlags(o), this.validateRegExpPattern(o);
			var l = null;
			try {
				l = new RegExp(r, i);
			} catch (e) {}
			return this.finishToken(Ft.regexp, {
				pattern: r,
				flags: i,
				value: l
			});
		}, fs.readInt = function(e, t, n) {
			for (var s = this.options.ecmaVersion >= 12 && void 0 === t, r = n && 48 === this.input.charCodeAt(this.pos), a = this.pos, i = 0, o = 0, l = 0, c = null == t ? Infinity : t; l < c; ++l, ++this.pos) {
				var p = this.input.charCodeAt(this.pos), u = void 0;
				if (s && 95 === p) r && this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals"), 95 === o && this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore"), 0 === l && this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits"), o = p;
				else {
					if ((u = p >= 97 ? p - 97 + 10 : p >= 65 ? p - 65 + 10 : p >= 48 && p <= 57 ? p - 48 : Infinity) >= e) break;
					o = p, i = i * e + u;
				}
			}
			return s && 95 === o && this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits"), this.pos === a || null != t && this.pos - a !== t ? null : i;
		}, fs.readRadixNumber = function(e) {
			var t = this.pos;
			this.pos += 2;
			var n = this.readInt(e);
			return n ?? this.raise(this.start + 2, "Expected number in radix " + e), this.options.ecmaVersion >= 11 && 110 === this.input.charCodeAt(this.pos) ? (n = ys(this.input.slice(t, this.pos)), ++this.pos) : Mt(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(Ft.num, n);
		}, fs.readNumber = function(e) {
			var t = this.pos;
			e || null !== this.readInt(10, void 0, !0) || this.raise(t, "Invalid number");
			var n = this.pos - t >= 2 && 48 === this.input.charCodeAt(t);
			n && this.strict && this.raise(t, "Invalid number");
			var s = this.input.charCodeAt(this.pos);
			if (!n && !e && this.options.ecmaVersion >= 11 && 110 === s) {
				var r = ys(this.input.slice(t, this.pos));
				return ++this.pos, Mt(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(Ft.num, r);
			}
			n && /[89]/.test(this.input.slice(t, this.pos)) && (n = !1), 46 !== s || n || (++this.pos, this.readInt(10), s = this.input.charCodeAt(this.pos)), 69 !== s && 101 !== s || n || (43 !== (s = this.input.charCodeAt(++this.pos)) && 45 !== s || ++this.pos, null === this.readInt(10) && this.raise(t, "Invalid number")), Mt(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number");
			var a, i = (a = this.input.slice(t, this.pos), n ? parseInt(a, 8) : parseFloat(a.replace(/_/g, "")));
			return this.finishToken(Ft.num, i);
		}, fs.readCodePoint = function() {
			var e;
			if (123 === this.input.charCodeAt(this.pos)) {
				this.options.ecmaVersion < 6 && this.unexpected();
				var t = ++this.pos;
				e = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos), ++this.pos, e > 1114111 && this.invalidStringToken(t, "Code point out of bounds");
			} else e = this.readHexChar(4);
			return e;
		}, fs.readString = function(e) {
			for (var t = "", n = ++this.pos;;) {
				this.pos >= this.input.length && this.raise(this.start, "Unterminated string constant");
				var s = this.input.charCodeAt(this.pos);
				if (s === e) break;
				92 === s ? (t += this.input.slice(n, this.pos), t += this.readEscapedChar(!1), n = this.pos) : 8232 === s || 8233 === s ? (this.options.ecmaVersion < 10 && this.raise(this.start, "Unterminated string constant"), ++this.pos, this.options.locations && (this.curLine++, this.lineStart = this.pos)) : (Ut(s) && this.raise(this.start, "Unterminated string constant"), ++this.pos);
			}
			return t += this.input.slice(n, this.pos++), this.finishToken(Ft.string, t);
		};
		var vs = {};
		fs.tryReadTemplateToken = function() {
			this.inTemplateElement = !0;
			try {
				this.readTmplToken();
			} catch (e) {
				if (e !== vs) throw e;
				this.readInvalidTemplateToken();
			}
			this.inTemplateElement = !1;
		}, fs.invalidStringToken = function(e, t) {
			if (this.inTemplateElement && this.options.ecmaVersion >= 9) throw vs;
			this.raise(e, t);
		}, fs.readTmplToken = function() {
			for (var e = "", t = this.pos;;) {
				this.pos >= this.input.length && this.raise(this.start, "Unterminated template");
				var n = this.input.charCodeAt(this.pos);
				if (96 === n || 36 === n && 123 === this.input.charCodeAt(this.pos + 1)) return this.pos !== this.start || this.type !== Ft.template && this.type !== Ft.invalidTemplate ? (e += this.input.slice(t, this.pos), this.finishToken(Ft.template, e)) : 36 === n ? (this.pos += 2, this.finishToken(Ft.dollarBraceL)) : (++this.pos, this.finishToken(Ft.backQuote));
				if (92 === n) e += this.input.slice(t, this.pos), e += this.readEscapedChar(!0), t = this.pos;
				else if (Ut(n)) {
					switch (e += this.input.slice(t, this.pos), ++this.pos, n) {
						case 13: 10 === this.input.charCodeAt(this.pos) && ++this.pos;
						case 10:
							e += "\n";
							break;
						default: e += String.fromCharCode(n);
					}
					this.options.locations && (++this.curLine, this.lineStart = this.pos), t = this.pos;
				} else ++this.pos;
			}
		}, fs.readInvalidTemplateToken = function() {
			for (; this.pos < this.input.length; this.pos++) switch (this.input[this.pos]) {
				case "\\":
					++this.pos;
					break;
				case "$": if ("{" !== this.input[this.pos + 1]) break;
				case "`": return this.finishToken(Ft.invalidTemplate, this.input.slice(this.start, this.pos));
				case "\r": "\n" === this.input[this.pos + 1] && ++this.pos;
				case "\n":
				case "\u2028":
				case "\u2029": ++this.curLine, this.lineStart = this.pos + 1;
			}
			this.raise(this.start, "Unterminated template");
		}, fs.readEscapedChar = function(e) {
			var t = this.input.charCodeAt(++this.pos);
			switch (++this.pos, t) {
				case 110: return "\n";
				case 114: return "\r";
				case 120: return String.fromCharCode(this.readHexChar(2));
				case 117: return tn(this.readCodePoint());
				case 116: return "	";
				case 98: return "\b";
				case 118: return "\v";
				case 102: return "\f";
				case 13: 10 === this.input.charCodeAt(this.pos) && ++this.pos;
				case 10: return this.options.locations && (this.lineStart = this.pos, ++this.curLine), "";
				case 56:
				case 57: if (this.strict && this.invalidStringToken(this.pos - 1, "Invalid escape sequence"), e) {
					var n = this.pos - 1;
					this.invalidStringToken(n, "Invalid escape sequence in template string");
				}
				default:
					if (t >= 48 && t <= 55) {
						var s = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0], r = parseInt(s, 8);
						return r > 255 && (s = s.slice(0, -1), r = parseInt(s, 8)), this.pos += s.length - 1, t = this.input.charCodeAt(this.pos), "0" === s && 56 !== t && 57 !== t || !this.strict && !e || this.invalidStringToken(this.pos - 1 - s.length, e ? "Octal literal in template string" : "Octal literal in strict mode"), String.fromCharCode(r);
					}
					return Ut(t) ? (this.options.locations && (this.lineStart = this.pos, ++this.curLine), "") : String.fromCharCode(t);
			}
		}, fs.readHexChar = function(e) {
			var t = this.pos, n = this.readInt(16, e);
			return null === n && this.invalidStringToken(t, "Bad character escape sequence"), n;
		}, fs.readWord1 = function() {
			this.containsEsc = !1;
			for (var e = "", t = !0, n = this.pos, s = this.options.ecmaVersion >= 6; this.pos < this.input.length;) {
				var r = this.fullCharCodeAtPos();
				if (qt(r, s)) this.pos += r <= 65535 ? 1 : 2;
				else {
					if (92 !== r) break;
					this.containsEsc = !0, e += this.input.slice(n, this.pos);
					var a = this.pos;
					117 !== this.input.charCodeAt(++this.pos) && this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"), ++this.pos;
					var i = this.readCodePoint();
					(t ? Mt : qt)(i, s) || this.invalidStringToken(a, "Invalid Unicode escape"), e += tn(i), n = this.pos;
				}
				t = !1;
			}
			return e + this.input.slice(n, this.pos);
		}, fs.readWord = function() {
			var e = this.readWord1(), t = Ft.name;
			return this.keywords.test(e) && (t = jt[e]), this.finishToken(t, e);
		};
		var gs = "8.15.0";
		hn.acorn = {
			Parser: hn,
			version: gs,
			defaultOptions: on,
			Position: sn,
			SourceLocation: rn,
			getLineInfo: an,
			Node: Nn,
			TokenType: Lt,
			tokTypes: Ft,
			keywordTypes: jt,
			TokContext: En,
			tokContexts: Tn,
			isIdentifierChar: qt,
			isIdentifierStart: Mt,
			Token: ms,
			isNewLine: Ut,
			lineBreak: Vt,
			lineBreakG: Ht,
			nonASCIIwhitespace: Wt
		};
		var bs = Object.freeze({
			__proto__: null,
			Node: Nn,
			Parser: hn,
			Position: sn,
			SourceLocation: rn,
			TokContext: En,
			Token: ms,
			TokenType: Lt,
			defaultOptions: on,
			getLineInfo: an,
			isIdentifierChar: qt,
			isIdentifierStart: Mt,
			isNewLine: Ut,
			keywordTypes: jt,
			lineBreak: Vt,
			lineBreakG: Ht,
			nonASCIIwhitespace: Wt,
			parse: function(e, t) {
				return hn.parse(e, t);
			},
			parseExpressionAt: function(e, t, n) {
				return hn.parseExpressionAt(e, t, n);
			},
			tokContexts: Tn,
			tokTypes: Ft,
			tokenizer: function(e, t) {
				return hn.tokenizer(e, t);
			},
			version: gs
		}), _s = !0;
		function xs(e, t = {}) {
			return new Lt("name", t);
		}
		var ws = /* @__PURE__ */ new WeakMap();
		function ks(e) {
			const t = e.Parser.acorn || e;
			let n = ws.get(t);
			if (!n) {
				let e = function(e) {
					return [
						Ft.name,
						Ft.string,
						Ft.num,
						...Object.values(jt),
						...Object.values(o)
					].includes(e);
				}, t = function(e) {
					return [
						Ft.name,
						...Object.values(jt),
						...Object.values(o)
					].includes(e);
				}, s = function(e) {
					return [...Object.values(o), Ft.name].includes(e);
				}, r = function(e) {
					return [
						o.abstract,
						o.declare,
						o.enum,
						o.module,
						o.namespace,
						o.interface,
						o.type
					].includes(e);
				}, a = function(e) {
					return [
						o.keyof,
						o.readonly,
						o.unique
					].includes(e);
				}, i = function(e) {
					return e === Ft.invalidTemplate;
				};
				const o = {
					assert: xs(0, { startsExpr: _s }),
					asserts: xs(0, { startsExpr: _s }),
					global: xs(0, { startsExpr: _s }),
					keyof: xs(0, { startsExpr: _s }),
					readonly: xs(0, { startsExpr: _s }),
					unique: xs(0, { startsExpr: _s }),
					abstract: xs(0, { startsExpr: _s }),
					declare: xs(0, { startsExpr: _s }),
					enum: xs(0, { startsExpr: _s }),
					module: xs(0, { startsExpr: _s }),
					namespace: xs(0, { startsExpr: _s }),
					interface: xs(0, { startsExpr: _s }),
					type: xs(0, { startsExpr: _s })
				}, l = {
					at: new Lt("@"),
					jsxName: new Lt("jsxName"),
					jsxText: new Lt("jsxText", { beforeExpr: !0 }),
					jsxTagStart: new Lt("jsxTagStart", { startsExpr: !0 }),
					jsxTagEnd: new Lt("jsxTagEnd")
				}, c = {
					tc_oTag: new En("<tag", !1, !1),
					tc_cTag: new En("</tag", !1, !1),
					tc_expr: new En("<tag>...</tag>", !0, !0)
				}, p = new RegExp(`^(?:${Object.keys(o).join("|")})$`);
				l.jsxTagStart.updateContext = function() {
					this.context.push(c.tc_expr), this.context.push(c.tc_oTag), this.exprAllowed = !1;
				}, l.jsxTagEnd.updateContext = function(e) {
					let t = this.context.pop();
					t === c.tc_oTag && e === Ft.slash || t === c.tc_cTag ? (this.context.pop(), this.exprAllowed = this.curContext() === c.tc_expr) : this.exprAllowed = !0;
				}, n = {
					tokTypes: {
						...o,
						...l
					},
					tokContexts: { ...c },
					keywordsRegExp: p,
					tokenIsLiteralPropertyName: e,
					tokenIsKeywordOrIdentifier: t,
					tokenIsIdentifier: s,
					tokenIsTSDeclarationStart: r,
					tokenIsTSTypeOperator: a,
					tokenIsTemplate: i
				};
			}
			return n;
		}
		var Cs = 1024, Ss = new RegExp("(?=(" + /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/y.source + "))\\1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y"), Ps = class {
			constructor() {
				this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
			}
		};
		function Es(e, t) {
			const n = t.key.name, s = e[n];
			let r = "true";
			return "MethodDefinition" !== t.type || "get" !== t.kind && "set" !== t.kind || (r = (t.static ? "s" : "i") + t.kind), "iget" === s && "iset" === r || "iset" === s && "iget" === r || "sget" === s && "sset" === r || "sset" === s && "sget" === r ? (e[n] = "true", !1) : !!s || (e[n] = r, !1);
		}
		function Ts(e, t) {
			const { computed: n, key: s } = e;
			return !n && ("Identifier" === s.type && s.name === t || "Literal" === s.type && s.value === t);
		}
		var As = {
			AbstractMethodHasImplementation: ({ methodName: e }) => `Method '${e}' cannot have an implementation because it is marked abstract.`,
			AbstractPropertyHasInitializer: ({ propertyName: e }) => `Property '${e}' cannot have an initializer because it is marked abstract.`,
			AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
			AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
			CannotFindName: ({ name: e }) => `Cannot find name '${e}'.`,
			ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
			ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
			ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.",
			ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
			DeclareAccessor: ({ kind: e }) => `'declare' is not allowed in ${e}ters.`,
			DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
			DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
			DuplicateAccessibilityModifier: () => "Accessibility modifier already seen.",
			DuplicateModifier: ({ modifier: e }) => `Duplicate modifier: '${e}'.`,
			EmptyHeritageClauseType: ({ token: e }) => `'${e}' list cannot be empty.`,
			EmptyTypeArguments: "Type argument list cannot be empty.",
			EmptyTypeParameters: "Type parameter list cannot be empty.",
			ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
			ImportAliasHasImportType: "An import alias can not use 'import type'.",
			IncompatibleModifiers: ({ modifiers: e }) => `'${e[0]}' modifier cannot be used with '${e[1]}' modifier.`,
			IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
			IndexSignatureHasAccessibility: ({ modifier: e }) => `Index signatures cannot have an accessibility modifier ('${e}').`,
			IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
			IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
			IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
			InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.",
			InvalidModifierOnTypeMember: ({ modifier: e }) => `'${e}' modifier cannot appear on a type member.`,
			InvalidModifierOnTypeParameter: ({ modifier: e }) => `'${e}' modifier cannot appear on a type parameter.`,
			InvalidModifierOnTypeParameterPositions: ({ modifier: e }) => `'${e}' modifier can only appear on a type parameter of a class, interface or type alias.`,
			InvalidModifiersOrder: ({ orderedModifiers: e }) => `'${e[0]}' modifier must precede '${e[1]}' modifier.`,
			InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.",
			InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
			MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
			MixedLabeledAndUnlabeledElements: "Tuple members must all have names or all not have names.",
			NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
			NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.",
			OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
			OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
			PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
			PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
			PrivateElementHasAccessibility: ({ modifier: e }) => `Private elements cannot have an accessibility modifier ('${e}').`,
			PrivateMethodsHasAccessibility: ({ modifier: e }) => `Private methods cannot have an accessibility modifier ('${e}').`,
			ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
			ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
			ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
			SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
			SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
			SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
			SingleTypeParameterWithoutTrailingComma: ({ typeParameterName: e }) => `Single type parameter ${e} should have a trailing comma. Example usage: <${e},>.`,
			StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
			TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
			TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
			TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.",
			TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.",
			UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
			UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
			GenericsEndWithComma: "Trailing comma is not allowed at the end of generics.",
			UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
			UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
			UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
			UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
			UnsupportedSignatureParameterKind: ({ type: e }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${e}.`,
			LetInLexicalBinding: "'let' is not allowed to be used as a name in 'let' or 'const' declarations."
		}, $s = {
			UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
			DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
			TrailingDecorator: "Decorators must be attached to a class element.",
			SpreadElementDecorator: "Decorators can't be used with SpreadElement"
		};
		var Rs = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
		function Is(e) {
			if (!e) throw new Error("Assert fail");
		}
		function Ms(e) {
			return "accessor" === e;
		}
		function qs(e) {
			return "in" === e || "out" === e;
		}
		var Ls = {
			SCOPE_TOP: 1,
			SCOPE_FUNCTION: 2,
			SCOPE_ASYNC: 4,
			SCOPE_GENERATOR: 8,
			SCOPE_ARROW: 16,
			SCOPE_SIMPLE_CATCH: 32,
			SCOPE_SUPER: 64,
			SCOPE_DIRECT_SUPER: 128,
			BIND_NONE: 0,
			BIND_VAR: 1,
			BIND_LEXICAL: 2,
			BIND_FUNCTION: 3,
			BIND_SIMPLE_CATCH: 4,
			BIND_TS_TYPE: 6,
			BIND_TS_INTERFACE: 7,
			BIND_TS_NAMESPACE: 8,
			BIND_FLAGS_TS_EXPORT_ONLY: 1024,
			BIND_FLAGS_TS_IMPORT: 4096,
			BIND_FLAGS_TS_ENUM: 256,
			BIND_FLAGS_TS_CONST_ENUM: 512,
			BIND_FLAGS_CLASS: 128
		};
		function Os(e, t) {
			return Ls.SCOPE_FUNCTION | (e ? Ls.SCOPE_ASYNC : 0) | (t ? Ls.SCOPE_GENERATOR : 0);
		}
		function Ns(e) {
			if ("MemberExpression" !== e.type) return !1;
			const { computed: t, property: n } = e;
			return (!t || !("TemplateLiteral" !== n.type || n.expressions.length > 0)) && Ds(e.object);
		}
		function Ds(e) {
			return "Identifier" === e.type || "MemberExpression" === e.type && !e.computed && Ds(e.object);
		}
		function js(e) {
			return "private" === e || "public" === e || "protected" === e;
		}
		const Bs = hn.extend(function(e) {
			const { dts: t = !1 } = {};
			return function(e) {
				const n = e.acorn || bs, s = ks(n), r = n.tokTypes, a = n.keywordTypes, i = n.isIdentifierStart, o = n.lineBreak, l = n.isNewLine, c = n.tokContexts, p = n.isIdentifierChar, { tokTypes: u, tokContexts: d, keywordsRegExp: h, tokenIsLiteralPropertyName: m, tokenIsTemplate: f, tokenIsTSDeclarationStart: y, tokenIsIdentifier: v, tokenIsKeywordOrIdentifier: g, tokenIsTSTypeOperator: b } = s;
				function _(e, t, n = e.length) {
					for (let s = t; s < n; s++) {
						let t = e.charCodeAt(s);
						if (l(t)) return s < n - 1 && 13 === t && 10 === e.charCodeAt(s + 1) ? s + 2 : s + 1;
					}
					return -1;
				}
				e = function(e, t, n) {
					const { tokTypes: s } = n, { tokTypes: r } = t;
					return class extends e {
						takeDecorators(e) {
							const t = this.decoratorStack[this.decoratorStack.length - 1];
							t.length && (e.decorators = t, this.resetStartLocationFromNode(e, t[0]), this.decoratorStack[this.decoratorStack.length - 1] = []);
						}
						parseDecorators(e) {
							const t = this.decoratorStack[this.decoratorStack.length - 1];
							for (; this.match(r.at);) {
								const e = this.parseDecorator();
								t.push(e);
							}
							this.match(s._export) ? e || this.unexpected() : this.canHaveLeadingDecorator() || this.raise(this.start, $s.UnexpectedLeadingDecorator);
						}
						parseDecorator() {
							const e = this.startNode();
							this.next(), this.decoratorStack.push([]);
							const t = this.start, n = this.startLoc;
							let r;
							if (this.match(s.parenL)) {
								const e = this.start, t = this.startLoc;
								if (this.next(), r = this.parseExpression(), this.expect(s.parenR), this.options.preserveParens) {
									let n = this.startNodeAt(e, t);
									n.expression = r, r = this.finishNode(n, "ParenthesizedExpression");
								}
							} else for (r = this.parseIdent(!1); this.eat(s.dot);) {
								const e = this.startNodeAt(t, n);
								e.object = r, e.property = this.parseIdent(!0), e.computed = !1, r = this.finishNode(e, "MemberExpression");
							}
							return e.expression = this.parseMaybeDecoratorArguments(r), this.decoratorStack.pop(), this.finishNode(e, "Decorator");
						}
						parseMaybeDecoratorArguments(e) {
							if (this.eat(s.parenL)) {
								const t = this.startNodeAtNode(e);
								return t.callee = e, t.arguments = this.parseExprList(s.parenR, !1), this.finishNode(t, "CallExpression");
							}
							return e;
						}
					};
				}(e, s, n), e = function(e, t, n) {
					const { tokTypes: s } = t, { tokTypes: r } = n;
					return class extends e {
						parseMaybeImportAttributes(e) {
							if (this.type === r._with || this.type === s.assert) {
								this.next();
								const t = this.parseImportAttributes();
								t && (e.attributes = t);
							}
						}
						parseImportAttributes() {
							this.expect(r.braceL);
							const e = this.parseWithEntries();
							return this.expect(r.braceR), e;
						}
						parseWithEntries() {
							const e = [], t = /* @__PURE__ */ new Set();
							do {
								if (this.type === r.braceR) break;
								const n = this.startNode();
								let s;
								s = this.type === r.string ? this.parseLiteral(this.value) : this.parseIdent(!0), this.next(), n.key = s, t.has(n.key.name) && this.raise(this.pos, "Duplicated key in attributes"), t.add(n.key.name), this.type !== r.string && this.raise(this.pos, "Only string is supported as an attribute value"), n.value = this.parseLiteral(this.value), e.push(this.finishNode(n, "ImportAttribute"));
							} while (this.eat(r.comma));
							return e;
						}
					};
				}(e, s, n);
				return class extends e {
					constructor(e, t, n) {
						super(e, t, n), this.preValue = null, this.preToken = null, this.isLookahead = !1, this.isAmbientContext = !1, this.inAbstractClass = !1, this.inType = !1, this.inDisallowConditionalTypesContext = !1, this.maybeInArrowParameters = !1, this.shouldParseArrowReturnType = void 0, this.shouldParseAsyncArrowReturnType = void 0, this.decoratorStack = [[]], this.importsStack = [[]], this.importOrExportOuterKind = void 0, this.tsParseConstModifier = (e) => {
							this.tsParseModifiers({
								modified: e,
								allowedModifiers: ["const"],
								disallowedModifiers: ["in", "out"],
								errorTemplate: As.InvalidModifierOnTypeParameterPositions
							});
						}, this.ecmaVersion = this.options.ecmaVersion;
					}
					static get acornTypeScript() {
						return s;
					}
					get acornTypeScript() {
						return s;
					}
					getTokenFromCodeInType(e) {
						return 62 === e || 60 === e ? this.finishOp(r.relational, 1) : super.getTokenFromCode(e);
					}
					readToken(e) {
						if (!this.inType) {
							let t = this.curContext();
							if (t === d.tc_expr) return this.jsx_readToken();
							if (t === d.tc_oTag || t === d.tc_cTag) {
								if (i(e)) return this.jsx_readWord();
								if (62 == e) return ++this.pos, this.finishToken(u.jsxTagEnd);
								if ((34 === e || 39 === e) && t == d.tc_oTag) return this.jsx_readString(e);
							}
							if (60 === e && this.exprAllowed && 33 !== this.input.charCodeAt(this.pos + 1)) return ++this.pos, this.finishToken(r.relational, "<");
						}
						return super.readToken(e);
					}
					getTokenFromCode(e) {
						return this.inType ? this.getTokenFromCodeInType(e) : 64 === e ? (++this.pos, this.finishToken(u.at)) : super.getTokenFromCode(e);
					}
					isAbstractClass() {
						return this.ts_isContextual(u.abstract) && this.lookahead().type === r._class;
					}
					finishNode(e, t) {
						return "" !== e.type && 0 !== e.end ? e : super.finishNode(e, t);
					}
					tryParse(e, t = this.cloneCurLookaheadState()) {
						const n = { node: null };
						try {
							return {
								node: e(((e = null) => {
									throw n.node = e, n;
								})),
								error: null,
								thrown: !1,
								aborted: !1,
								failState: null
							};
						} catch (e) {
							const s = this.getCurLookaheadState();
							if (this.setLookaheadState(t), e instanceof SyntaxError) return {
								node: null,
								error: e,
								thrown: !0,
								aborted: !1,
								failState: s
							};
							if (e === n) return {
								node: n.node,
								error: null,
								thrown: !1,
								aborted: !0,
								failState: s
							};
							throw e;
						}
					}
					setOptionalParametersError(e, t) {
						e.optionalParametersLoc = t?.loc ?? this.startLoc;
					}
					reScan_lt_gt() {
						this.type === r.relational && (this.pos -= 1, this.readToken_lt_gt(this.fullCharCodeAtPos()));
					}
					reScan_lt() {
						const { type: e } = this;
						return e === r.bitShift ? (this.pos -= 2, this.finishOp(r.relational, 1), r.relational) : e;
					}
					resetEndLocation(e, t = this.lastTokEnd, n = this.lastTokEndLoc) {
						e.end = t, e.loc.end = n, this.options.ranges && (e.range[1] = t);
					}
					startNodeAtNode(e) {
						return super.startNodeAt(e.start, e.loc.start);
					}
					nextTokenStart() {
						return this.nextTokenStartSince(this.pos);
					}
					tsHasSomeModifiers(e, t) {
						return t.some(((t) => js(t) ? e.accessibility === t : !!e[t]));
					}
					tsIsStartOfStaticBlocks() {
						return this.isContextual("static") && 123 === this.lookaheadCharCode();
					}
					tsCheckForInvalidTypeCasts(e) {
						e.forEach(((e) => {
							"TSTypeCastExpression" === e?.type && this.raise(e.typeAnnotation.start, As.UnexpectedTypeAnnotation);
						}));
					}
					atPossibleAsyncArrow(e) {
						return "Identifier" === e.type && "async" === e.name && this.lastTokEndLoc.column === e.end && !this.canInsertSemicolon() && e.end - e.start == 5 && e.start === this.potentialArrowAt;
					}
					tsIsIdentifier() {
						return v(this.type);
					}
					tsTryParseTypeOrTypePredicateAnnotation() {
						return this.match(r.colon) ? this.tsParseTypeOrTypePredicateAnnotation(r.colon) : void 0;
					}
					tsTryParseGenericAsyncArrowFunction(e, t, n) {
						if (!this.tsMatchLeftRelational()) return;
						const s = this.maybeInArrowParameters;
						this.maybeInArrowParameters = !0;
						const a = this.tsTryParseAndCatch((() => {
							const n = this.startNodeAt(e, t);
							return n.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier), super.parseFunctionParams(n), n.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(), this.expect(r.arrow), n;
						}));
						return this.maybeInArrowParameters = s, a ? super.parseArrowExpression(a, null, !0, n) : void 0;
					}
					tsParseTypeArgumentsInExpression() {
						if (this.reScan_lt() === r.relational) return this.tsParseTypeArguments();
					}
					tsInNoContext(e) {
						const t = this.context;
						this.context = [t[0]];
						try {
							return e();
						} finally {
							this.context = t;
						}
					}
					tsTryParseTypeAnnotation() {
						return this.match(r.colon) ? this.tsParseTypeAnnotation() : void 0;
					}
					isUnparsedContextual(e, t) {
						const n = e + t.length;
						if (this.input.slice(e, n) === t) {
							const e = this.input.charCodeAt(n);
							return !(p(e) || 55296 == (64512 & e));
						}
						return !1;
					}
					isAbstractConstructorSignature() {
						return this.ts_isContextual(u.abstract) && this.lookahead().type === r._new;
					}
					nextTokenStartSince(e) {
						return Rs.lastIndex = e, Rs.test(this.input) ? Rs.lastIndex : e;
					}
					lookaheadCharCode() {
						return this.input.charCodeAt(this.nextTokenStart());
					}
					compareLookaheadState(e, t) {
						for (const n of Object.keys(e)) if (e[n] !== t[n]) return !1;
						return !0;
					}
					createLookaheadState() {
						this.value = null, this.context = [this.curContext()];
					}
					getCurLookaheadState() {
						return {
							endLoc: this.endLoc,
							lastTokEnd: this.lastTokEnd,
							lastTokStart: this.lastTokStart,
							lastTokStartLoc: this.lastTokStartLoc,
							pos: this.pos,
							value: this.value,
							type: this.type,
							start: this.start,
							end: this.end,
							context: this.context,
							startLoc: this.startLoc,
							lastTokEndLoc: this.lastTokEndLoc,
							curLine: this.curLine,
							lineStart: this.lineStart,
							curPosition: this.curPosition,
							containsEsc: this.containsEsc
						};
					}
					cloneCurLookaheadState() {
						return {
							pos: this.pos,
							value: this.value,
							type: this.type,
							start: this.start,
							end: this.end,
							context: this.context && this.context.slice(),
							startLoc: this.startLoc,
							lastTokEndLoc: this.lastTokEndLoc,
							endLoc: this.endLoc,
							lastTokEnd: this.lastTokEnd,
							lastTokStart: this.lastTokStart,
							lastTokStartLoc: this.lastTokStartLoc,
							curLine: this.curLine,
							lineStart: this.lineStart,
							curPosition: this.curPosition,
							containsEsc: this.containsEsc
						};
					}
					setLookaheadState(e) {
						this.pos = e.pos, this.value = e.value, this.endLoc = e.endLoc, this.lastTokEnd = e.lastTokEnd, this.lastTokStart = e.lastTokStart, this.lastTokStartLoc = e.lastTokStartLoc, this.type = e.type, this.start = e.start, this.end = e.end, this.context = e.context, this.startLoc = e.startLoc, this.lastTokEndLoc = e.lastTokEndLoc, this.curLine = e.curLine, this.lineStart = e.lineStart, this.curPosition = e.curPosition, this.containsEsc = e.containsEsc;
					}
					tsLookAhead(e) {
						const t = this.getCurLookaheadState(), n = e();
						return this.setLookaheadState(t), n;
					}
					lookahead(e) {
						const t = this.getCurLookaheadState();
						if (this.createLookaheadState(), this.isLookahead = !0, void 0 !== e) for (let t = 0; t < e; t++) this.nextToken();
						else this.nextToken();
						this.isLookahead = !1;
						const n = this.getCurLookaheadState();
						return this.setLookaheadState(t), n;
					}
					readWord() {
						let e = this.readWord1(), t = r.name;
						return this.keywords.test(e) ? t = a[e] : new RegExp(h).test(e) && (t = u[e]), this.finishToken(t, e);
					}
					skipBlockComment() {
						let e;
						this.isLookahead || (e = this.options.onComment && this.curPosition());
						let t = this.pos, n = this.input.indexOf("*/", this.pos += 2);
						if (-1 === n && this.raise(this.pos - 2, "Unterminated comment"), this.pos = n + 2, this.options.locations) for (let e, n = t; (e = _(this.input, n, this.pos)) > -1;) ++this.curLine, n = this.lineStart = e;
						this.isLookahead || this.options.onComment && this.options.onComment(!0, this.input.slice(t + 2, n), t, this.pos, e, this.curPosition());
					}
					skipLineComment(e) {
						let t, n = this.pos;
						this.isLookahead || (t = this.options.onComment && this.curPosition());
						let s = this.input.charCodeAt(this.pos += e);
						for (; this.pos < this.input.length && !l(s);) s = this.input.charCodeAt(++this.pos);
						this.isLookahead || this.options.onComment && this.options.onComment(!1, this.input.slice(n + e, this.pos), n, this.pos, t, this.curPosition());
					}
					finishToken(e, t) {
						this.preValue = this.value, this.preToken = this.type, this.end = this.pos, this.options.locations && (this.endLoc = this.curPosition());
						let n = this.type;
						this.type = e, this.value = t, this.isLookahead || this.updateContext(n);
					}
					resetStartLocation(e, t, n) {
						e.start = t, e.loc.start = n, this.options.ranges && (e.range[0] = t);
					}
					isLineTerminator() {
						return this.eat(r.semi) || super.canInsertSemicolon();
					}
					hasFollowingLineBreak() {
						return Ss.lastIndex = this.end, Ss.test(this.input);
					}
					addExtra(e, t, n, s = !0) {
						if (!e) return;
						const r = e.extra = e.extra || {};
						s ? r[t] = n : Object.defineProperty(r, t, {
							enumerable: s,
							value: n
						});
					}
					isLiteralPropertyName() {
						return m(this.type);
					}
					hasPrecedingLineBreak() {
						return o.test(this.input.slice(this.lastTokEnd, this.start));
					}
					createIdentifier(e, t) {
						return e.name = t, this.finishNode(e, "Identifier");
					}
					resetStartLocationFromNode(e, t) {
						this.resetStartLocation(e, t.start, t.loc.start);
					}
					isThisParam(e) {
						return "Identifier" === e.type && "this" === e.name;
					}
					isLookaheadContextual(e) {
						const t = this.nextTokenStart();
						return this.isUnparsedContextual(t, e);
					}
					ts_type_isContextual(e, t) {
						return e === t && !this.containsEsc;
					}
					ts_isContextual(e) {
						return this.type === e && !this.containsEsc;
					}
					ts_isContextualWithState(e, t) {
						return e.type === t && !e.containsEsc;
					}
					isContextualWithState(e, t) {
						return t.type === r.name && t.value === e && !t.containsEsc;
					}
					tsIsStartOfMappedType() {
						return this.next(), this.eat(r.plusMin) ? this.ts_isContextual(u.readonly) : (this.ts_isContextual(u.readonly) && this.next(), !!this.match(r.bracketL) && (this.next(), !!this.tsIsIdentifier() && (this.next(), this.match(r._in))));
					}
					tsInDisallowConditionalTypesContext(e) {
						const t = this.inDisallowConditionalTypesContext;
						this.inDisallowConditionalTypesContext = !0;
						try {
							return e();
						} finally {
							this.inDisallowConditionalTypesContext = t;
						}
					}
					tsTryParseType() {
						return this.tsEatThenParseType(r.colon);
					}
					match(e) {
						return this.type === e;
					}
					matchJsx(e) {
						return this.type === s.tokTypes[e];
					}
					ts_eatWithState(e, t, n) {
						if (e === n.type) {
							for (let e = 0; e < t; e++) this.next();
							return !0;
						}
						return !1;
					}
					ts_eatContextualWithState(e, t, n) {
						if (h.test(e)) {
							if (this.ts_isContextualWithState(n, u[e])) {
								for (let e = 0; e < t; e++) this.next();
								return !0;
							}
							return !1;
						}
						if (!this.isContextualWithState(e, n)) return !1;
						for (let e = 0; e < t; e++) this.next();
						return !0;
					}
					canHaveLeadingDecorator() {
						return this.match(r._class);
					}
					eatContextual(e) {
						return h.test(e) ? !!this.ts_isContextual(u[e]) && (this.next(), !0) : super.eatContextual(e);
					}
					tsIsExternalModuleReference() {
						return this.isContextual("require") && 40 === this.lookaheadCharCode();
					}
					tsParseExternalModuleReference() {
						const e = this.startNode();
						return this.expectContextual("require"), this.expect(r.parenL), this.match(r.string) || this.unexpected(), e.expression = this.parseExprAtom(), this.expect(r.parenR), this.finishNode(e, "TSExternalModuleReference");
					}
					tsParseEntityName(e = !0) {
						let t = this.parseIdent(e);
						for (; this.eat(r.dot);) {
							const n = this.startNodeAtNode(t);
							n.left = t, n.right = this.parseIdent(e), t = this.finishNode(n, "TSQualifiedName");
						}
						return t;
					}
					tsParseEnumMember() {
						const e = this.startNode();
						return e.id = this.match(r.string) ? this.parseLiteral(this.value) : this.parseIdent(!0), this.eat(r.eq) && (e.initializer = this.parseMaybeAssign()), this.finishNode(e, "TSEnumMember");
					}
					tsParseEnumDeclaration(e, t = {}) {
						return t.const && (e.const = !0), t.declare && (e.declare = !0), this.expectContextual("enum"), e.id = this.parseIdent(), this.checkLValSimple(e.id), this.expect(r.braceL), e.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(r.braceR), this.finishNode(e, "TSEnumDeclaration");
					}
					tsParseModuleBlock() {
						const e = this.startNode();
						for (this.enterScope(512), this.expect(r.braceL), e.body = []; this.type !== r.braceR;) {
							let t = this.parseStatement(null, !0);
							e.body.push(t);
						}
						return this.next(), super.exitScope(), this.finishNode(e, "TSModuleBlock");
					}
					tsParseAmbientExternalModuleDeclaration(e) {
						return this.ts_isContextual(u.global) ? (e.global = !0, e.id = this.parseIdent()) : this.match(r.string) ? e.id = this.parseLiteral(this.value) : this.unexpected(), this.match(r.braceL) ? (this.enterScope(Cs), e.body = this.tsParseModuleBlock(), super.exitScope()) : super.semicolon(), this.finishNode(e, "TSModuleDeclaration");
					}
					tsTryParseDeclare(e) {
						if (this.isLineTerminator()) return;
						let t, n = this.type;
						return this.isContextual("let") && (n = r._var, t = "let"), this.tsInAmbientContext((() => {
							if (n === r._function) return e.declare = !0, this.parseFunctionStatement(e, !1, !0);
							if (n === r._class) return e.declare = !0, this.parseClass(e, !0);
							if (n === u.enum) return this.tsParseEnumDeclaration(e, { declare: !0 });
							if (n === u.global) return this.tsParseAmbientExternalModuleDeclaration(e);
							if (n === r._const || n === r._var) return this.match(r._const) && this.isLookaheadContextual("enum") ? (this.expect(r._const), this.tsParseEnumDeclaration(e, {
								const: !0,
								declare: !0
							})) : (e.declare = !0, this.parseVarStatement(e, t || this.value, !0));
							if (n === u.interface) {
								const t = this.tsParseInterfaceDeclaration(e, { declare: !0 });
								if (t) return t;
							}
							return v(n) ? this.tsParseDeclaration(e, this.value, !0) : void 0;
						}));
					}
					tsIsListTerminator(e) {
						switch (e) {
							case "EnumMembers":
							case "TypeMembers": return this.match(r.braceR);
							case "HeritageClauseElement": return this.match(r.braceL);
							case "TupleElementTypes": return this.match(r.bracketR);
							case "TypeParametersOrArguments": return this.tsMatchRightRelational();
						}
					}
					tsParseDelimitedListWorker(e, t, n, s) {
						const a = [];
						let i = -1;
						for (; !this.tsIsListTerminator(e);) {
							i = -1;
							const s = t();
							if (null == s) return;
							if (a.push(s), !this.eat(r.comma)) {
								if (this.tsIsListTerminator(e)) break;
								n && this.expect(r.comma);
								return;
							}
							i = this.lastTokStart;
						}
						return s && (s.value = i), a;
					}
					tsParseDelimitedList(e, t, n) {
						return function(e) {
							if (null == e) throw new Error(`Unexpected ${e} value.`);
							return e;
						}(this.tsParseDelimitedListWorker(e, t, !0, n));
					}
					tsParseBracketedList(e, t, n, s, a) {
						s || (n ? this.expect(r.bracketL) : this.expect(r.relational));
						const i = this.tsParseDelimitedList(e, t, a);
						return n ? this.expect(r.bracketR) : this.expect(r.relational), i;
					}
					tsParseTypeParameterName() {
						return this.parseIdent().name;
					}
					tsEatThenParseType(e) {
						return this.match(e) ? this.tsNextThenParseType() : void 0;
					}
					tsExpectThenParseType(e) {
						return this.tsDoThenParseType((() => this.expect(e)));
					}
					tsNextThenParseType() {
						return this.tsDoThenParseType((() => this.next()));
					}
					tsDoThenParseType(e) {
						return this.tsInType((() => (e(), this.tsParseType())));
					}
					tsSkipParameterStart() {
						if (v(this.type) || this.match(r._this)) return this.next(), !0;
						if (this.match(r.braceL)) try {
							return this.parseObj(!0), !0;
						} catch {
							return !1;
						}
						if (this.match(r.bracketL)) {
							this.next();
							try {
								return this.parseBindingList(r.bracketR, !0, !0), !0;
							} catch {
								return !1;
							}
						}
						return !1;
					}
					tsIsUnambiguouslyStartOfFunctionType() {
						if (this.next(), this.match(r.parenR) || this.match(r.ellipsis)) return !0;
						if (this.tsSkipParameterStart()) {
							if (this.match(r.colon) || this.match(r.comma) || this.match(r.question) || this.match(r.eq)) return !0;
							if (this.match(r.parenR) && (this.next(), this.match(r.arrow))) return !0;
						}
						return !1;
					}
					tsIsStartOfFunctionType() {
						return !!this.tsMatchLeftRelational() || this.match(r.parenL) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
					}
					tsInAllowConditionalTypesContext(e) {
						const t = this.inDisallowConditionalTypesContext;
						this.inDisallowConditionalTypesContext = !1;
						try {
							return e();
						} finally {
							this.inDisallowConditionalTypesContext = t;
						}
					}
					tsParseBindingListForSignature() {
						return super.parseBindingList(r.parenR, !0, !0).map(((e) => ("Identifier" !== e.type && "RestElement" !== e.type && "ObjectPattern" !== e.type && "ArrayPattern" !== e.type && this.raise(e.start, As.UnsupportedSignatureParameterKind(e.type)), e)));
					}
					tsParseTypePredicateAsserts() {
						if (this.type !== u.asserts) return !1;
						const e = this.containsEsc;
						return this.next(), !(!v(this.type) && !this.match(r._this)) && (e && this.raise(this.lastTokStart, "Escape sequence in keyword asserts"), !0);
					}
					tsParseThisTypeNode() {
						const e = this.startNode();
						return this.next(), this.finishNode(e, "TSThisType");
					}
					tsParseTypeAnnotation(e = !0, t = this.startNode()) {
						return this.tsInType((() => {
							e && this.expect(r.colon), t.typeAnnotation = this.tsParseType();
						})), this.finishNode(t, "TSTypeAnnotation");
					}
					tsParseThisTypePredicate(e) {
						this.next();
						const t = this.startNodeAtNode(e);
						return t.parameterName = e, t.typeAnnotation = this.tsParseTypeAnnotation(!1), t.asserts = !1, this.finishNode(t, "TSTypePredicate");
					}
					tsParseThisTypeOrThisTypePredicate() {
						const e = this.tsParseThisTypeNode();
						return this.isContextual("is") && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(e) : e;
					}
					tsParseTypePredicatePrefix() {
						const e = this.parseIdent();
						if (this.isContextual("is") && !this.hasPrecedingLineBreak()) return this.next(), e;
					}
					tsParseTypeOrTypePredicateAnnotation(e) {
						return this.tsInType((() => {
							const t = this.startNode();
							this.expect(e);
							const n = this.startNode(), s = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
							if (s && this.match(r._this)) {
								let e = this.tsParseThisTypeOrThisTypePredicate();
								return "TSThisType" === e.type ? (n.parameterName = e, n.asserts = !0, n.typeAnnotation = null, e = this.finishNode(n, "TSTypePredicate")) : (this.resetStartLocationFromNode(e, n), e.asserts = !0), t.typeAnnotation = e, this.finishNode(t, "TSTypeAnnotation");
							}
							const a = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
							if (!a) return s ? (n.parameterName = this.parseIdent(), n.asserts = s, n.typeAnnotation = null, t.typeAnnotation = this.finishNode(n, "TSTypePredicate"), this.finishNode(t, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(!1, t);
							const i = this.tsParseTypeAnnotation(!1);
							return n.parameterName = a, n.typeAnnotation = i, n.asserts = s, t.typeAnnotation = this.finishNode(n, "TSTypePredicate"), this.finishNode(t, "TSTypeAnnotation");
						}));
					}
					tsFillSignature(e, t) {
						const n = e === r.arrow, s = "typeAnnotation";
						t.typeParameters = this.tsTryParseTypeParameters(), this.expect(r.parenL), t.parameters = this.tsParseBindingListForSignature(), (n || this.match(e)) && (t[s] = this.tsParseTypeOrTypePredicateAnnotation(e));
					}
					tsTryNextParseConstantContext() {
						if (this.lookahead().type !== r._const) return null;
						this.next();
						const e = this.tsParseTypeReference();
						return (e.typeParameters || e.typeArguments) && this.raise(e.typeName.start, As.CannotFindName({ name: "const" })), e;
					}
					tsParseFunctionOrConstructorType(e, t) {
						const n = this.startNode();
						return "TSConstructorType" === e && (n.abstract = !!t, t && this.next(), this.next()), this.tsInAllowConditionalTypesContext((() => this.tsFillSignature(r.arrow, n))), this.finishNode(n, e);
					}
					tsParseUnionOrIntersectionType(e, t, n) {
						const s = this.startNode(), r = this.eat(n), a = [];
						do
							a.push(t());
						while (this.eat(n));
						return 1 !== a.length || r ? (s.types = a, this.finishNode(s, e)) : a[0];
					}
					tsCheckTypeAnnotationForReadOnly(e) {
						switch (e.typeAnnotation.type) {
							case "TSTupleType":
							case "TSArrayType": return;
							default: this.raise(e.start, As.UnexpectedReadonly);
						}
					}
					tsParseTypeOperator() {
						const e = this.startNode(), t = this.value;
						return this.next(), e.operator = t, e.typeAnnotation = this.tsParseTypeOperatorOrHigher(), "readonly" === t && this.tsCheckTypeAnnotationForReadOnly(e), this.finishNode(e, "TSTypeOperator");
					}
					tsParseConstraintForInferType() {
						if (this.eat(r._extends)) {
							const e = this.tsInDisallowConditionalTypesContext((() => this.tsParseType()));
							if (this.inDisallowConditionalTypesContext || !this.match(r.question)) return e;
						}
					}
					tsParseInferType() {
						const e = this.startNode();
						this.expectContextual("infer");
						const t = this.startNode();
						return t.name = this.tsParseTypeParameterName(), t.constraint = this.tsTryParse((() => this.tsParseConstraintForInferType())), e.typeParameter = this.finishNode(t, "TSTypeParameter"), this.finishNode(e, "TSInferType");
					}
					tsParseLiteralTypeNode() {
						const e = this.startNode();
						return e.literal = (() => {
							switch (this.type) {
								case r.num:
								case r.string:
								case r._true:
								case r._false: return this.parseExprAtom();
								default: this.unexpected();
							}
						})(), this.finishNode(e, "TSLiteralType");
					}
					tsParseImportType() {
						const e = this.startNode();
						return this.expect(r._import), this.expect(r.parenL), this.match(r.string) || this.raise(this.start, As.UnsupportedImportTypeArgument), e.argument = this.parseExprAtom(), this.expect(r.parenR), this.eat(r.dot) && (e.qualifier = this.tsParseEntityName()), this.tsMatchLeftRelational() && (e.typeArguments = this.tsParseTypeArguments()), this.finishNode(e, "TSImportType");
					}
					tsParseTypeQuery() {
						const e = this.startNode();
						return this.expect(r._typeof), this.match(r._import) ? e.exprName = this.tsParseImportType() : e.exprName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.tsMatchLeftRelational() && (e.typeArguments = this.tsParseTypeArguments()), this.finishNode(e, "TSTypeQuery");
					}
					tsParseMappedTypeParameter() {
						const e = this.startNode();
						return e.name = this.tsParseTypeParameterName(), e.constraint = this.tsExpectThenParseType(r._in), this.finishNode(e, "TSTypeParameter");
					}
					tsParseMappedType() {
						const e = this.startNode();
						return this.expect(r.braceL), this.match(r.plusMin) ? (e.readonly = this.value, this.next(), this.expectContextual("readonly")) : this.eatContextual("readonly") && (e.readonly = !0), this.expect(r.bracketL), e.typeParameter = this.tsParseMappedTypeParameter(), e.nameType = this.eatContextual("as") ? this.tsParseType() : null, this.expect(r.bracketR), this.match(r.plusMin) ? (e.optional = this.value, this.next(), this.expect(r.question)) : this.eat(r.question) && (e.optional = !0), e.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(r.braceR), this.finishNode(e, "TSMappedType");
					}
					tsParseTypeLiteral() {
						const e = this.startNode();
						return e.members = this.tsParseObjectTypeMembers(), this.finishNode(e, "TSTypeLiteral");
					}
					tsParseTupleElementType() {
						const e = this.startLoc, t = this.start, n = this.eat(r.ellipsis);
						let s = this.tsParseType();
						const a = this.eat(r.question);
						if (this.eat(r.colon)) {
							const e = this.startNodeAtNode(s);
							e.optional = a, "TSTypeReference" !== s.type || s.typeArguments || "Identifier" !== s.typeName.type ? (this.raise(s.start, As.InvalidTupleMemberLabel), e.label = s) : e.label = s.typeName, e.elementType = this.tsParseType(), s = this.finishNode(e, "TSNamedTupleMember");
						} else if (a) {
							const e = this.startNodeAtNode(s);
							e.typeAnnotation = s, s = this.finishNode(e, "TSOptionalType");
						}
						if (n) {
							const n = this.startNodeAt(t, e);
							n.typeAnnotation = s, s = this.finishNode(n, "TSRestType");
						}
						return s;
					}
					tsParseTupleType() {
						const e = this.startNode();
						e.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), !0, !1);
						let t = !1, n = null;
						return e.elementTypes.forEach(((e) => {
							const { type: s } = e;
							!t || "TSRestType" === s || "TSOptionalType" === s || "TSNamedTupleMember" === s && e.optional || this.raise(e.start, As.OptionalTypeBeforeRequired), t ||= "TSNamedTupleMember" === s && e.optional || "TSOptionalType" === s;
							let r = s;
							"TSRestType" === s && (r = (e = e.typeAnnotation).type);
							const a = "TSNamedTupleMember" === r;
							n ??= a, n !== a && this.raise(e.start, As.MixedLabeledAndUnlabeledElements);
						})), this.finishNode(e, "TSTupleType");
					}
					tsParseTemplateLiteralType() {
						const e = this.startNode();
						return e.literal = this.parseTemplate({ isTagged: !1 }), this.finishNode(e, "TSLiteralType");
					}
					tsParseTypeReference() {
						const e = this.startNode();
						return e.typeName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.tsMatchLeftRelational() && (e.typeArguments = this.tsParseTypeArguments()), this.finishNode(e, "TSTypeReference");
					}
					tsMatchLeftRelational() {
						return this.match(r.relational) && "<" === this.value;
					}
					tsMatchRightRelational() {
						return this.match(r.relational) && ">" === this.value;
					}
					tsParseParenthesizedType() {
						const e = this.startNode();
						return this.expect(r.parenL), e.typeAnnotation = this.tsParseType(), this.expect(r.parenR), this.finishNode(e, "TSParenthesizedType");
					}
					tsParseNonArrayType() {
						switch (this.type) {
							case r.string:
							case r.num:
							case r._true:
							case r._false: return this.tsParseLiteralTypeNode();
							case r.plusMin:
								if ("-" === this.value) {
									const e = this.startNode();
									return this.lookahead().type !== r.num && this.unexpected(), e.literal = this.parseMaybeUnary(), this.finishNode(e, "TSLiteralType");
								}
								break;
							case r._this: return this.tsParseThisTypeOrThisTypePredicate();
							case r._typeof: return this.tsParseTypeQuery();
							case r._import: return this.tsParseImportType();
							case r.braceL: return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
							case r.bracketL: return this.tsParseTupleType();
							case r.parenL: return this.tsParseParenthesizedType();
							case r.backQuote:
							case r.dollarBraceL: return this.tsParseTemplateLiteralType();
							default: {
								const { type: e } = this;
								if (v(e) || e === r._void || e === r._null) {
									const t = e === r._void ? "TSVoidKeyword" : e === r._null ? "TSNullKeyword" : function(e) {
										switch (e) {
											case "any": return "TSAnyKeyword";
											case "boolean": return "TSBooleanKeyword";
											case "bigint": return "TSBigIntKeyword";
											case "never": return "TSNeverKeyword";
											case "number": return "TSNumberKeyword";
											case "object": return "TSObjectKeyword";
											case "string": return "TSStringKeyword";
											case "symbol": return "TSSymbolKeyword";
											case "undefined": return "TSUndefinedKeyword";
											case "unknown": return "TSUnknownKeyword";
											default: return;
										}
									}(this.value);
									if (void 0 !== t && 46 !== this.lookaheadCharCode()) {
										const e = this.startNode();
										return this.next(), this.finishNode(e, t);
									}
									return this.tsParseTypeReference();
								}
							}
						}
						this.unexpected();
					}
					tsParseArrayTypeOrHigher() {
						let e = this.tsParseNonArrayType();
						for (; !this.hasPrecedingLineBreak() && this.eat(r.bracketL);) if (this.match(r.bracketR)) {
							const t = this.startNodeAtNode(e);
							t.elementType = e, this.expect(r.bracketR), e = this.finishNode(t, "TSArrayType");
						} else {
							const t = this.startNodeAtNode(e);
							t.objectType = e, t.indexType = this.tsParseType(), this.expect(r.bracketR), e = this.finishNode(t, "TSIndexedAccessType");
						}
						return e;
					}
					tsParseTypeOperatorOrHigher() {
						return b(this.type) && !this.containsEsc ? this.tsParseTypeOperator() : this.isContextual("infer") ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext((() => this.tsParseArrayTypeOrHigher()));
					}
					tsParseIntersectionTypeOrHigher() {
						return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), r.bitwiseAND);
					}
					tsParseUnionTypeOrHigher() {
						return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), r.bitwiseOR);
					}
					tsParseNonConditionalType() {
						return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(r._new) ? this.tsParseFunctionOrConstructorType("TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", !0) : this.tsParseUnionTypeOrHigher();
					}
					tsParseType() {
						Is(this.inType);
						const e = this.tsParseNonConditionalType();
						if (this.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(r._extends)) return e;
						const t = this.startNodeAtNode(e);
						return t.checkType = e, t.extendsType = this.tsInDisallowConditionalTypesContext((() => this.tsParseNonConditionalType())), this.expect(r.question), t.trueType = this.tsInAllowConditionalTypesContext((() => this.tsParseType())), this.expect(r.colon), t.falseType = this.tsInAllowConditionalTypesContext((() => this.tsParseType())), this.finishNode(t, "TSConditionalType");
					}
					tsIsUnambiguouslyIndexSignature() {
						return this.next(), !!v(this.type) && (this.next(), this.match(r.colon));
					}
					tsInType(e) {
						const t = this.inType;
						this.inType = !0;
						try {
							return e();
						} finally {
							this.inType = t;
						}
					}
					tsTryParseIndexSignature(e) {
						if (!this.match(r.bracketL) || !this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))) return;
						this.expect(r.bracketL);
						const t = this.parseIdent();
						t.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(t), this.expect(r.bracketR), e.parameters = [t];
						const n = this.tsTryParseTypeAnnotation();
						return n && (e.typeAnnotation = n), this.tsParseTypeMemberSemicolon(), this.finishNode(e, "TSIndexSignature");
					}
					tsParseNoneModifiers(e) {
						this.tsParseModifiers({
							modified: e,
							allowedModifiers: [],
							disallowedModifiers: ["in", "out"],
							errorTemplate: As.InvalidModifierOnTypeParameterPositions
						});
					}
					tsParseTypeParameter(e = this.tsParseNoneModifiers.bind(this)) {
						const t = this.startNode();
						return e(t), t.name = this.tsParseTypeParameterName(), t.constraint = this.tsEatThenParseType(r._extends), t.default = this.tsEatThenParseType(r.eq), this.finishNode(t, "TSTypeParameter");
					}
					tsParseTypeParameters(e) {
						const t = this.startNode();
						this.tsMatchLeftRelational() || this.matchJsx("jsxTagStart") ? this.next() : this.unexpected();
						const n = { value: -1 };
						return t.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, e), !1, !0, n), 0 === t.params.length && this.raise(this.start, As.EmptyTypeParameters), -1 !== n.value && this.addExtra(t, "trailingComma", n.value), this.finishNode(t, "TSTypeParameterDeclaration");
					}
					tsTryParseTypeParameters(e) {
						if (this.tsMatchLeftRelational()) return this.tsParseTypeParameters(e);
					}
					tsTryParse(e) {
						const t = this.getCurLookaheadState(), n = e();
						return void 0 !== n && !1 !== n ? n : void this.setLookaheadState(t);
					}
					tsTokenCanFollowModifier() {
						return (this.match(r.bracketL) || this.match(r.braceL) || this.match(r.star) || this.match(r.ellipsis) || this.match(r.privateId) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
					}
					tsNextTokenCanFollowModifier() {
						return this.next(!0), this.tsTokenCanFollowModifier();
					}
					tsParseModifier(e, t) {
						const n = this.value;
						if (-1 !== e.indexOf(n) && !this.containsEsc) {
							if (t && this.tsIsStartOfStaticBlocks()) return;
							if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) return n;
						}
					}
					tsParseModifiersByMap({ modified: e, map: t }) {
						for (const n of Object.keys(t)) e[n] = t[n];
					}
					tsParseModifiers({ modified: e, allowedModifiers: t, disallowedModifiers: n, stopOnStartOfClassStaticBlock: s, errorTemplate: r = As.InvalidModifierOnTypeMember }) {
						const a = {}, i = (t, n, s, r) => {
							n === s && e[r] && this.raise(t.column, As.InvalidModifiersOrder({ orderedModifiers: [s, r] }));
						}, o = (t, n, s, r) => {
							(e[s] && n === r || e[r] && n === s) && this.raise(t.column, As.IncompatibleModifiers({ modifiers: [s, r] }));
						};
						for (;;) {
							const l = this.startLoc, c = this.tsParseModifier(t.concat(n ?? []), s);
							if (!c) break;
							js(c) ? e.accessibility ? this.raise(this.start, As.DuplicateAccessibilityModifier()) : (i(l, c, c, "override"), i(l, c, c, "static"), i(l, c, c, "readonly"), i(l, c, c, "accessor"), a.accessibility = c, e.accessibility = c) : qs(c) ? e[c] ? this.raise(this.start, As.DuplicateModifier({ modifier: c })) : (i(l, c, "in", "out"), a[c] = c, e[c] = !0) : Ms(c) ? e[c] ? this.raise(this.start, As.DuplicateModifier({ modifier: c })) : (o(l, c, "accessor", "readonly"), o(l, c, "accessor", "static"), o(l, c, "accessor", "override"), a[c] = c, e[c] = !0) : "const" === c ? e[c] ? this.raise(this.start, As.DuplicateModifier({ modifier: c })) : (a[c] = c, e[c] = !0) : Object.hasOwnProperty.call(e, c) ? this.raise(this.start, As.DuplicateModifier({ modifier: c })) : (i(l, c, "static", "readonly"), i(l, c, "static", "override"), i(l, c, "override", "readonly"), i(l, c, "abstract", "override"), o(l, c, "declare", "override"), o(l, c, "static", "abstract"), a[c] = c, e[c] = !0), n?.includes(c) && this.raise(this.start, r);
						}
						return a;
					}
					tsParseInOutModifiers(e) {
						this.tsParseModifiers({
							modified: e,
							allowedModifiers: ["in", "out"],
							disallowedModifiers: [
								"public",
								"private",
								"protected",
								"readonly",
								"declare",
								"abstract",
								"override"
							],
							errorTemplate: As.InvalidModifierOnTypeParameter
						});
					}
					parseMaybeUnary(e, t, n, s) {
						return this.tsMatchLeftRelational() ? this.tsParseTypeAssertion() : super.parseMaybeUnary(e, t, n, s);
					}
					tsParseTypeAssertion() {
						const e = this.tryParse((() => {
							const e = this.startNode();
							return e.typeAnnotation = this.tsTryNextParseConstantContext() || this.tsNextThenParseType(), this.expect(r.relational), e.expression = this.parseMaybeUnary(), this.finishNode(e, "TSTypeAssertion");
						}));
						return e.error ? this.tsParseTypeParameters(this.tsParseConstModifier) : e.node;
					}
					tsParseTypeArguments() {
						const e = this.startNode();
						return e.params = this.tsInType((() => this.tsInNoContext((() => (this.expect(r.relational), this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this))))))), 0 === e.params.length && this.raise(this.start, As.EmptyTypeArguments), this.exprAllowed = !1, this.expect(r.relational), this.finishNode(e, "TSTypeParameterInstantiation");
					}
					tsParseHeritageClause(e) {
						const t = this.start, n = this.tsParseDelimitedList("HeritageClauseElement", (() => {
							const e = this.startNode();
							return e.expression = this.tsParseEntityName(), this.tsMatchLeftRelational() && (e.typeParameters = this.tsParseTypeArguments()), this.finishNode(e, "TSExpressionWithTypeArguments");
						}));
						return n.length || this.raise(t, As.EmptyHeritageClauseType({ token: e })), n;
					}
					tsParseTypeMemberSemicolon() {
						this.eat(r.comma) || this.isLineTerminator() || this.expect(r.semi);
					}
					tsTryParseAndCatch(e) {
						const t = this.tryParse(((t) => e() || t()));
						if (!t.aborted && t.node) return t.error && this.setLookaheadState(t.failState), t.node;
					}
					tsParseSignatureMember(e, t) {
						return this.tsFillSignature(r.colon, t), this.tsParseTypeMemberSemicolon(), this.finishNode(t, e);
					}
					tsParsePropertyOrMethodSignature(e, t) {
						this.eat(r.question) && (e.optional = !0);
						const n = e;
						if (this.match(r.parenL) || this.tsMatchLeftRelational()) {
							t && this.raise(e.start, As.ReadonlyForMethodSignature);
							const s = n;
							s.kind && this.tsMatchLeftRelational() && this.raise(this.start, As.AccesorCannotHaveTypeParameters), this.tsFillSignature(r.colon, s), this.tsParseTypeMemberSemicolon();
							const a = "parameters", i = "typeAnnotation";
							if ("get" === s.kind) s[a].length > 0 && (this.raise(this.start, "A 'get' accesor must not have any formal parameters."), this.isThisParam(s[a][0]) && this.raise(this.start, As.AccesorCannotDeclareThisParameter));
							else if ("set" === s.kind) {
								if (1 !== s[a].length) this.raise(this.start, "A 'get' accesor must not have any formal parameters.");
								else {
									const e = s[a][0];
									this.isThisParam(e) && this.raise(this.start, As.AccesorCannotDeclareThisParameter), "Identifier" === e.type && e.optional && this.raise(this.start, As.SetAccesorCannotHaveOptionalParameter), "RestElement" === e.type && this.raise(this.start, As.SetAccesorCannotHaveRestParameter);
								}
								s[i] && this.raise(s[i].start, As.SetAccesorCannotHaveReturnType);
							} else s.kind = "method";
							return this.finishNode(s, "TSMethodSignature");
						}
						{
							const e = n;
							t && (e.readonly = !0);
							const s = this.tsTryParseTypeAnnotation();
							return s && (e.typeAnnotation = s), this.tsParseTypeMemberSemicolon(), this.finishNode(e, "TSPropertySignature");
						}
					}
					tsParseTypeMember() {
						const e = this.startNode();
						if (this.match(r.parenL) || this.tsMatchLeftRelational()) return this.tsParseSignatureMember("TSCallSignatureDeclaration", e);
						if (this.match(r._new)) {
							const t = this.startNode();
							return this.next(), this.match(r.parenL) || this.tsMatchLeftRelational() ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", e) : (e.key = this.createIdentifier(t, "new"), this.tsParsePropertyOrMethodSignature(e, !1));
						}
						this.tsParseModifiers({
							modified: e,
							allowedModifiers: ["readonly"],
							disallowedModifiers: [
								"declare",
								"abstract",
								"private",
								"protected",
								"public",
								"static",
								"override"
							]
						});
						return this.tsTryParseIndexSignature(e) || (this.parsePropertyName(e), e.computed || "Identifier" !== e.key.type || "get" !== e.key.name && "set" !== e.key.name || !this.tsTokenCanFollowModifier() || (e.kind = e.key.name, this.parsePropertyName(e)), this.tsParsePropertyOrMethodSignature(e, !!e.readonly));
					}
					tsParseList(e, t) {
						const n = [];
						for (; !this.tsIsListTerminator(e);) n.push(t());
						return n;
					}
					tsParseObjectTypeMembers() {
						this.expect(r.braceL);
						const e = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
						return this.expect(r.braceR), e;
					}
					tsParseInterfaceDeclaration(e, t = {}) {
						if (this.hasFollowingLineBreak()) return null;
						this.expectContextual("interface"), t.declare && (e.declare = !0), v(this.type) ? (e.id = this.parseIdent(), this.checkLValSimple(e.id, Ls.BIND_TS_INTERFACE)) : (e.id = null, this.raise(this.start, As.MissingInterfaceName)), e.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this)), this.eat(r._extends) && (e.extends = this.tsParseHeritageClause("extends"));
						const n = this.startNode();
						return n.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), e.body = this.finishNode(n, "TSInterfaceBody"), this.finishNode(e, "TSInterfaceDeclaration");
					}
					tsParseAbstractDeclaration(e) {
						if (this.match(r._class)) return e.abstract = !0, this.parseClass(e, !0);
						if (this.ts_isContextual(u.interface)) {
							if (!this.hasFollowingLineBreak()) return e.abstract = !0, this.tsParseInterfaceDeclaration(e);
						} else this.unexpected(e.start);
					}
					tsIsDeclarationStart() {
						return y(this.type);
					}
					tsParseExpressionStatement(e, t) {
						switch (t.name) {
							case "declare": {
								const t = this.tsTryParseDeclare(e);
								if (t) return t.declare = !0, t;
								break;
							}
							case "global":
								if (this.match(r.braceL)) {
									this.enterScope(Cs);
									const n = e;
									return n.global = !0, n.id = t, n.body = this.tsParseModuleBlock(), super.exitScope(), this.finishNode(n, "TSModuleDeclaration");
								}
								break;
							default: return this.tsParseDeclaration(e, t.name, !1);
						}
					}
					tsParseModuleReference() {
						return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(!1);
					}
					tsIsExportDefaultSpecifier() {
						const { type: e } = this, t = this.isAsyncFunction(), n = this.isLet();
						if (v(e)) {
							if (t && !this.containsEsc || n) return !1;
							if ((e === u.type || e === u.interface) && !this.containsEsc) {
								const e = this.lookahead();
								if (v(e.type) && !this.isContextualWithState("from", e) || e.type === r.braceL) return !1;
							}
						} else if (!this.match(r._default)) return !1;
						const s = this.nextTokenStart(), a = this.isUnparsedContextual(s, "from");
						if (44 === this.input.charCodeAt(s) || v(this.type) && a) return !0;
						if (this.match(r._default) && a) {
							const e = this.input.charCodeAt(this.nextTokenStartSince(s + 4));
							return 34 === e || 39 === e;
						}
						return !1;
					}
					tsInAmbientContext(e) {
						const t = this.isAmbientContext;
						this.isAmbientContext = !0;
						try {
							return e();
						} finally {
							this.isAmbientContext = t;
						}
					}
					tsCheckLineTerminator(e) {
						return e ? !this.hasFollowingLineBreak() && (this.next(), !0) : !this.isLineTerminator();
					}
					tsParseModuleOrNamespaceDeclaration(e, t = !1) {
						if (e.id = this.parseIdent(), t || this.checkLValSimple(e.id, Ls.BIND_TS_NAMESPACE), this.eat(r.dot)) {
							const t = this.startNode();
							this.tsParseModuleOrNamespaceDeclaration(t, !0), e.body = t;
						} else this.enterScope(Cs), e.body = this.tsParseModuleBlock(), super.exitScope();
						return this.finishNode(e, "TSModuleDeclaration");
					}
					checkLValSimple(e, t = Ls.BIND_NONE, n) {
						return "TSNonNullExpression" !== e.type && "TSAsExpression" !== e.type || (e = e.expression), super.checkLValSimple(e, t, n);
					}
					tsParseTypeAliasDeclaration(e) {
						return e.id = this.parseIdent(), this.checkLValSimple(e.id, Ls.BIND_TS_TYPE), e.typeAnnotation = this.tsInType((() => {
							if (e.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this)), this.expect(r.eq), this.ts_isContextual(u.interface) && this.lookahead().type !== r.dot) {
								const e = this.startNode();
								return this.next(), this.finishNode(e, "TSIntrinsicKeyword");
							}
							return this.tsParseType();
						})), this.semicolon(), this.finishNode(e, "TSTypeAliasDeclaration");
					}
					tsParseDeclaration(e, t, n) {
						switch (t) {
							case "abstract":
								if (this.tsCheckLineTerminator(n) && (this.match(r._class) || v(this.type))) return this.tsParseAbstractDeclaration(e);
								break;
							case "module":
								if (this.tsCheckLineTerminator(n)) {
									if (this.match(r.string)) return this.tsParseAmbientExternalModuleDeclaration(e);
									if (v(this.type)) return this.tsParseModuleOrNamespaceDeclaration(e);
								}
								break;
							case "namespace":
								if (this.tsCheckLineTerminator(n) && v(this.type)) return this.tsParseModuleOrNamespaceDeclaration(e);
								break;
							case "type": if (this.tsCheckLineTerminator(n) && v(this.type)) return this.tsParseTypeAliasDeclaration(e);
						}
					}
					tsTryParseExportDeclaration() {
						return this.tsParseDeclaration(this.startNode(), this.value, !0);
					}
					tsParseImportEqualsDeclaration(e, t) {
						e.isExport = t || !1, e.id = this.parseIdent(), this.checkLValSimple(e.id, Ls.BIND_LEXICAL), super.expect(r.eq);
						const n = this.tsParseModuleReference();
						return "type" === e.importKind && "TSExternalModuleReference" !== n.type && this.raise(n.start, As.ImportAliasHasImportType), e.moduleReference = n, super.semicolon(), this.finishNode(e, "TSImportEqualsDeclaration");
					}
					isExportDefaultSpecifier() {
						if (this.tsIsDeclarationStart()) return !1;
						const { type: e } = this;
						if (v(e)) {
							if (this.isContextual("async") || this.isContextual("let")) return !1;
							if ((e === u.type || e === u.interface) && !this.containsEsc) {
								const e = this.lookahead();
								if (v(e.type) && !this.isContextualWithState("from", e) || e.type === r.braceL) return !1;
							}
						} else if (!this.match(r._default)) return !1;
						const t = this.nextTokenStart(), n = this.isUnparsedContextual(t, "from");
						if (44 === this.input.charCodeAt(t) || v(this.type) && n) return !0;
						if (this.match(r._default) && n) {
							const e = this.input.charCodeAt(this.nextTokenStartSince(t + 4));
							return 34 === e || 39 === e;
						}
						return !1;
					}
					parseTemplate({ isTagged: e = !1 } = {}) {
						let t = this.startNode();
						this.next(), t.expressions = [];
						let n = this.parseTemplateElement({ isTagged: e });
						for (t.quasis = [n]; !n.tail;) this.type === r.eof && this.raise(this.pos, "Unterminated template literal"), this.expect(r.dollarBraceL), t.expressions.push(this.inType ? this.tsParseType() : this.parseExpression()), this.expect(r.braceR), t.quasis.push(n = this.parseTemplateElement({ isTagged: e }));
						return this.next(), this.finishNode(t, "TemplateLiteral");
					}
					parseFunction(e, t, n, s, a) {
						this.initFunction(e), (this.ecmaVersion >= 9 || this.ecmaVersion >= 6 && !s) && (this.type === r.star && 2 & t && this.unexpected(), e.generator = this.eat(r.star)), this.ecmaVersion >= 8 && (e.async = !!s), 1 & t && (e.id = 4 & t && this.type !== r.name ? null : this.parseIdent());
						let i = this.yieldPos, o = this.awaitPos, l = this.awaitIdentPos;
						const c = this.maybeInArrowParameters;
						this.maybeInArrowParameters = !1, this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(Os(e.async, e.generator)), 1 & t || (e.id = this.type === r.name ? this.parseIdent() : null), this.parseFunctionParams(e);
						const p = 1 & t;
						return this.parseFunctionBody(e, n, !1, a, { isFunctionDeclaration: p }), this.yieldPos = i, this.awaitPos = o, this.awaitIdentPos = l, 1 & t && e.id && !(2 & t) && (e.body ? this.checkLValSimple(e.id, this.strict || e.generator || e.async ? this.treatFunctionsAsVar ? Ls.BIND_VAR : Ls.BIND_LEXICAL : Ls.BIND_FUNCTION) : this.checkLValSimple(e.id, Ls.BIND_NONE)), this.maybeInArrowParameters = c, this.finishNode(e, p ? "FunctionDeclaration" : "FunctionExpression");
					}
					parseFunctionBody(e, t = !1, n = !1, s = !1, a) {
						this.match(r.colon) && (e.returnType = this.tsParseTypeOrTypePredicateAnnotation(r.colon));
						const i = a?.isFunctionDeclaration ? "TSDeclareFunction" : a?.isClassMethod ? "TSDeclareMethod" : void 0;
						return i && !this.match(r.braceL) && this.isLineTerminator() ? this.finishNode(e, i) : "TSDeclareFunction" === i && this.isAmbientContext && (this.raise(e.start, As.DeclareFunctionHasImplementation), e.declare) ? (super.parseFunctionBody(e, t, n, !1), this.finishNode(e, i)) : (super.parseFunctionBody(e, t, n, s), e);
					}
					parseNew() {
						this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword new");
						let e = this.startNode(), t = this.parseIdent(!0);
						if (this.ecmaVersion >= 6 && this.eat(r.dot)) {
							e.meta = t;
							let n = this.containsEsc;
							return e.property = this.parseIdent(!0), "target" !== e.property.name && this.raiseRecoverable(e.property.start, "The only valid meta property for new is 'new.target'"), n && this.raiseRecoverable(e.start, "'new.target' must not contain escaped characters"), this.allowNewDotTarget || this.raiseRecoverable(e.start, "'new.target' can only be used in functions and class static block"), this.finishNode(e, "MetaProperty");
						}
						let n = this.start, s = this.startLoc, a = this.type === r._import;
						e.callee = this.parseSubscripts(this.parseExprAtom(), n, s, !0, !1), a && "ImportExpression" === e.callee.type && this.raise(n, "Cannot use new with import()");
						const { callee: i } = e;
						return "TSInstantiationExpression" !== i.type || i.extra?.parenthesized || (e.typeArguments = i.typeArguments, e.callee = i.expression), this.eat(r.parenL) ? e.arguments = this.parseExprList(r.parenR, this.ecmaVersion >= 8, !1) : e.arguments = [], this.finishNode(e, "NewExpression");
					}
					parseExprOp(e, t, n, s, a) {
						if (r._in.binop > s && !this.hasPrecedingLineBreak()) {
							let r;
							if (this.isContextual("as") && (r = "TSAsExpression"), this.isContextual("satisfies") && (r = "TSSatisfiesExpression"), r) {
								const i = this.startNodeAt(t, n);
								i.expression = e;
								return i.typeAnnotation = this.tsTryNextParseConstantContext() || this.tsNextThenParseType(), this.finishNode(i, r), this.reScan_lt_gt(), this.parseExprOp(i, t, n, s, a);
							}
						}
						return super.parseExprOp(e, t, n, s, a);
					}
					parseImportSpecifiers() {
						let e = [], t = !0;
						if (s.tokenIsIdentifier(this.type) && (e.push(this.parseImportDefaultSpecifier()), !this.eat(r.comma))) return e;
						if (this.type === r.star) return e.push(this.parseImportNamespaceSpecifier()), e;
						for (this.expect(r.braceL); !this.eat(r.braceR);) {
							if (t) t = !1;
							else if (this.expect(r.comma), this.afterTrailingComma(r.braceR)) break;
							e.push(this.parseImportSpecifier());
						}
						return e;
					}
					parseImport(e) {
						let t = this.lookahead();
						if (e.importKind = "value", this.importOrExportOuterKind = "value", v(t.type) || this.match(r.star) || this.match(r.braceL)) {
							let n = this.lookahead(2);
							if (n.type !== r.comma && !this.isContextualWithState("from", n) && n.type !== r.eq && this.ts_eatContextualWithState("type", 1, t) && (this.importOrExportOuterKind = "type", e.importKind = "type", t = this.lookahead(), n = this.lookahead(2)), v(t.type) && n.type === r.eq) {
								this.next();
								const t = this.tsParseImportEqualsDeclaration(e);
								return this.importOrExportOuterKind = "value", t;
							}
						}
						return this.next(), this.type === r.string ? (e.specifiers = [], e.source = this.parseExprAtom()) : (e.specifiers = this.parseImportSpecifiers(), this.expectContextual("from"), e.source = this.type === r.string ? this.parseExprAtom() : this.unexpected()), this.parseMaybeImportAttributes(e), this.semicolon(), this.finishNode(e, "ImportDeclaration"), this.importOrExportOuterKind = "value", "type" === e.importKind && e.specifiers.length > 1 && "ImportDefaultSpecifier" === e.specifiers[0].type && this.raise(e.start, As.TypeImportCannotSpecifyDefaultAndNamed), e;
					}
					parseExportDefaultDeclaration() {
						if (this.isAbstractClass()) {
							const e = this.startNode();
							return this.next(), e.abstract = !0, this.parseClass(e, !0);
						}
						if (this.match(u.interface)) {
							const e = this.tsParseInterfaceDeclaration(this.startNode());
							if (e) return e;
						}
						return super.parseExportDefaultDeclaration();
					}
					parseExportAllDeclaration(e, t) {
						return this.ecmaVersion >= 11 && (this.eatContextual("as") ? (e.exported = this.parseModuleExportName(), this.checkExport(t, e.exported, this.lastTokStart)) : e.exported = null), this.expectContextual("from"), this.type !== r.string && this.unexpected(), e.source = this.parseExprAtom(), this.parseMaybeImportAttributes(e), this.semicolon(), this.finishNode(e, "ExportAllDeclaration");
					}
					parseDynamicImport(e) {
						if (this.next(), e.source = this.parseMaybeAssign(), this.eat(r.comma)) e.arguments = [this.parseExpression()];
						if (!this.eat(r.parenR)) {
							const e = this.start;
							this.eat(r.comma) && this.eat(r.parenR) ? this.raiseRecoverable(e, "Trailing comma is not allowed in import()") : this.unexpected(e);
						}
						return this.finishNode(e, "ImportExpression");
					}
					parseExport(e, t) {
						let n = this.lookahead();
						if (this.ts_eatWithState(r._import, 2, n)) {
							this.ts_isContextual(u.type) && 61 !== this.lookaheadCharCode() ? (e.importKind = "type", this.importOrExportOuterKind = "type", this.next()) : (e.importKind = "value", this.importOrExportOuterKind = "value");
							const t = this.tsParseImportEqualsDeclaration(e, !0);
							return this.importOrExportOuterKind = void 0, t;
						}
						if (this.ts_eatWithState(r.eq, 2, n)) {
							const t = e;
							return t.expression = this.parseExpression(), this.semicolon(), this.importOrExportOuterKind = void 0, this.finishNode(t, "TSExportAssignment");
						}
						if (this.ts_eatContextualWithState("as", 2, n)) {
							const t = e;
							return this.expectContextual("namespace"), t.id = this.parseIdent(), this.semicolon(), this.importOrExportOuterKind = void 0, this.finishNode(t, "TSNamespaceExportDeclaration");
						}
						if (this.ts_isContextualWithState(n, u.type) && this.lookahead(2).type === r.braceL ? (this.next(), this.importOrExportOuterKind = "type", e.exportKind = "type") : (this.importOrExportOuterKind = "value", e.exportKind = "value"), this.next(), this.eat(r.star)) return this.parseExportAllDeclaration(e, t);
						if (this.eat(r._default)) return this.checkExport(t, "default", this.lastTokStart), e.declaration = this.parseExportDefaultDeclaration(), this.finishNode(e, "ExportDefaultDeclaration");
						if (this.shouldParseExportStatement()) e.declaration = this.parseExportDeclaration(e), "VariableDeclaration" === e.declaration.type ? this.checkVariableExport(t, e.declaration.declarations) : this.checkExport(t, e.declaration.id, e.declaration.id.start), e.specifiers = [], e.source = null;
						else {
							if (e.declaration = null, e.specifiers = this.parseExportSpecifiers(t), this.eatContextual("from")) this.type !== r.string && this.unexpected(), e.source = this.parseExprAtom(), this.parseMaybeImportAttributes(e);
							else {
								for (let t of e.specifiers) this.checkUnreserved(t.local), this.checkLocalExport(t.local), "Literal" === t.local.type && this.raise(t.local.start, "A string literal cannot be used as an exported binding without `from`.");
								e.source = null;
							}
							this.semicolon();
						}
						return this.finishNode(e, "ExportNamedDeclaration");
					}
					checkExport(e, t, n) {
						e && ("string" != typeof t && (t = "Identifier" === t.type ? t.name : t.value), e[t] = !0);
					}
					parseMaybeDefault(e, t, n) {
						const s = super.parseMaybeDefault(e, t, n);
						return "AssignmentPattern" === s.type && s.typeAnnotation && s.right.start < s.typeAnnotation.start && this.raise(s.typeAnnotation.start, As.TypeAnnotationAfterAssign), s;
					}
					typeCastToParameter(e) {
						return e.expression.typeAnnotation = e.typeAnnotation, this.resetEndLocation(e.expression, e.typeAnnotation.end, e.typeAnnotation.loc?.end), e.expression;
					}
					toAssignableList(e, t) {
						for (let t = 0; t < e.length; t++) {
							const n = e[t];
							"TSTypeCastExpression" === n?.type && (e[t] = this.typeCastToParameter(n));
						}
						return super.toAssignableList(e, t);
					}
					reportReservedArrowTypeParam(e) {
						1 === e.params.length && e.extra;
					}
					parseExprAtom(e, t, n) {
						if (this.type === u.jsxText) return this.jsx_parseText();
						if (this.type === u.jsxTagStart) return this.jsx_parseElement();
						if (this.type === u.at) return this.parseDecorators(), this.parseExprAtom();
						if (v(this.type)) {
							let e = this.potentialArrowAt === this.start, n = this.start, s = this.startLoc, a = this.containsEsc, i = this.parseIdent(!1);
							if (this.ecmaVersion >= 8 && !a && "async" === i.name && !this.canInsertSemicolon() && this.eat(r._function)) return this.overrideContext(c.f_expr), this.parseFunction(this.startNodeAt(n, s), 0, !1, !0, t);
							if (e && !this.canInsertSemicolon()) {
								if (this.eat(r.arrow)) return this.parseArrowExpression(this.startNodeAt(n, s), [i], !1, t);
								if (this.ecmaVersion >= 8 && "async" === i.name && this.type === r.name && !a && (!this.potentialArrowInForAwait || "of" !== this.value || this.containsEsc)) return i = this.parseIdent(!1), !this.canInsertSemicolon() && this.eat(r.arrow) || this.unexpected(), this.parseArrowExpression(this.startNodeAt(n, s), [i], !0, t);
							}
							return i;
						}
						return super.parseExprAtom(e, t, n);
					}
					parseExprAtomDefault() {
						if (v(this.type)) {
							const e = this.potentialArrowAt === this.start, t = this.containsEsc, n = this.parseIdent();
							if (!t && "async" === n.name && !this.canInsertSemicolon()) {
								const { type: e } = this;
								if (e === r._function) return this.next(), this.parseFunction(this.startNodeAtNode(n), void 0, !0, !0);
								if (v(e)) {
									if (61 === this.lookaheadCharCode()) {
										const e = this.parseIdent(!1);
										return !this.canInsertSemicolon() && this.eat(r.arrow) || this.unexpected(), this.parseArrowExpression(this.startNodeAtNode(n), [e], !0);
									}
									return n;
								}
							}
							return e && this.match(r.arrow) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(n), [n], !1)) : n;
						}
						this.unexpected();
					}
					parseIdentNode() {
						let e = this.startNode();
						return g(this.type) && ("class" !== this.type.keyword && "function" !== this.type.keyword || this.lastTokEnd === this.lastTokStart + 1 && 46 === this.input.charCodeAt(this.lastTokStart)) ? (e.name = this.value, e) : super.parseIdentNode();
					}
					parseVarStatement(e, t, n = !1) {
						const { isAmbientContext: s } = this;
						this.next(), super.parseVar(e, !1, t, n || s), this.semicolon();
						const r = this.finishNode(e, "VariableDeclaration");
						if (!s) return r;
						for (const { id: e, init: n } of r.declarations) n && ("const" !== t || e.typeAnnotation ? this.raise(n.start, As.InitializerNotAllowedInAmbientContext) : "StringLiteral" !== n.type && "BooleanLiteral" !== n.type && "NumericLiteral" !== n.type && "BigIntLiteral" !== n.type && ("TemplateLiteral" !== n.type || n.expressions.length > 0) && !Ns(n) && this.raise(n.start, As.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference));
						return r;
					}
					parseStatement(e, t, n) {
						if (this.match(u.at) && this.parseDecorators(!0), this.match(r._const) && this.isLookaheadContextual("enum")) {
							const e = this.startNode();
							return this.expect(r._const), this.tsParseEnumDeclaration(e, { const: !0 });
						}
						if (this.ts_isContextual(u.enum)) return this.tsParseEnumDeclaration(this.startNode());
						if (this.ts_isContextual(u.interface)) {
							const e = this.tsParseInterfaceDeclaration(this.startNode());
							if (e) return e;
						}
						return super.parseStatement(e, t, n);
					}
					parseAccessModifier() {
						return this.tsParseModifier([
							"public",
							"protected",
							"private"
						]);
					}
					parsePostMemberNameModifiers(e) {
						this.eat(r.question) && (e.optional = !0), e.readonly && this.match(r.parenL) && this.raise(e.start, As.ClassMethodHasReadonly), e.declare && this.match(r.parenL) && this.raise(e.start, As.ClassMethodHasDeclare);
					}
					parseExpressionStatement(e, t) {
						return ("Identifier" === t.type ? this.tsParseExpressionStatement(e, t) : void 0) || super.parseExpressionStatement(e, t);
					}
					shouldParseExportStatement() {
						return !!this.tsIsDeclarationStart() || !!this.match(u.at) || super.shouldParseExportStatement();
					}
					parseConditional(e, t, n, s, a) {
						if (this.eat(r.question)) {
							let a = this.startNodeAt(t, n);
							return a.test = e, a.consequent = this.parseMaybeAssign(), this.expect(r.colon), a.alternate = this.parseMaybeAssign(s), this.finishNode(a, "ConditionalExpression");
						}
						return e;
					}
					parseMaybeConditional(e, t) {
						let n = this.start, s = this.startLoc, a = this.parseExprOps(e, t);
						if (this.checkExpressionErrors(t)) return a;
						if (!this.maybeInArrowParameters || !this.match(r.question)) return this.parseConditional(a, n, s, e, t);
						const i = this.tryParse((() => this.parseConditional(a, n, s, e, t)));
						return i.node ? (i.error && this.setLookaheadState(i.failState), i.node) : (i.error && this.setOptionalParametersError(t, i.error), a);
					}
					parseParenItem(e) {
						const t = this.start, n = this.startLoc;
						if (e = super.parseParenItem(e), this.eat(r.question) && (e.optional = !0, this.resetEndLocation(e)), this.match(r.colon)) {
							const s = this.startNodeAt(t, n);
							return s.expression = e, s.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(s, "TSTypeCastExpression");
						}
						return e;
					}
					parseExportDeclaration(e) {
						if (!this.isAmbientContext && this.ts_isContextual(u.declare)) return this.tsInAmbientContext((() => this.parseExportDeclaration(e)));
						const t = this.start, n = this.startLoc, s = this.eatContextual("declare");
						!s || !this.ts_isContextual(u.declare) && this.shouldParseExportStatement() || this.raise(this.start, As.ExpectedAmbientAfterExportDeclare);
						const r = v(this.type) && this.tsTryParseExportDeclaration() || this.parseStatement(null);
						return r ? (("TSInterfaceDeclaration" === r.type || "TSTypeAliasDeclaration" === r.type || s) && (e.exportKind = "type"), s && (this.resetStartLocation(r, t, n), r.declare = !0), r) : null;
					}
					parseClassId(e, t) {
						if (!t && this.isContextual("implements")) return;
						super.parseClassId(e, t);
						const n = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this));
						n && (e.typeParameters = n);
					}
					parseClassPropertyAnnotation(e) {
						e.optional || ("!" === this.value && this.eat(r.prefix) ? e.definite = !0 : this.eat(r.question) && (e.optional = !0));
						const t = this.tsTryParseTypeAnnotation();
						t && (e.typeAnnotation = t);
					}
					parseClassField(e) {
						if ("PrivateIdentifier" === e.key.type) e.abstract && this.raise(e.start, As.PrivateElementHasAbstract), e.accessibility && this.raise(e.start, As.PrivateElementHasAccessibility({ modifier: e.accessibility })), this.parseClassPropertyAnnotation(e);
						else if (this.parseClassPropertyAnnotation(e), this.isAmbientContext && (!e.readonly || e.typeAnnotation) && this.match(r.eq) && this.raise(this.start, As.DeclareClassFieldHasInitializer), e.abstract && this.match(r.eq)) {
							const { key: t } = e;
							this.raise(this.start, As.AbstractPropertyHasInitializer({ propertyName: "Identifier" !== t.type || e.computed ? `[${this.input.slice(t.start, t.end)}]` : t.name }));
						}
						return super.parseClassField(e);
					}
					parseClassMethod(e, t, n, s) {
						const r = "constructor" === e.kind, a = "PrivateIdentifier" === e.key.type, i = this.tsTryParseTypeParameters(this.tsParseConstModifier);
						a ? (i && (e.typeParameters = i), e.accessibility && this.raise(e.start, As.PrivateMethodsHasAccessibility({ modifier: e.accessibility }))) : i && r && this.raise(i.start, As.ConstructorHasTypeParameters);
						const { declare: o = !1, kind: l } = e;
						!o || "get" !== l && "set" !== l || this.raise(e.start, As.DeclareAccessor({ kind: l })), i && (e.typeParameters = i);
						const c = e.key;
						"constructor" === e.kind ? (t && this.raise(c.start, "Constructor can't be a generator"), n && this.raise(c.start, "Constructor can't be an async method")) : e.static && Ts(e, "prototype") && this.raise(c.start, "Classes may not have a static property named prototype");
						const p = e.value = this.parseMethod(t, n, s, !0, e);
						return "get" === e.kind && 0 !== p.params.length && this.raiseRecoverable(p.start, "getter should have no params"), "set" === e.kind && 1 !== p.params.length && this.raiseRecoverable(p.start, "setter should have exactly one param"), "set" === e.kind && "RestElement" === p.params[0].type && this.raiseRecoverable(p.params[0].start, "Setter cannot use rest params"), this.finishNode(e, "MethodDefinition");
					}
					isClassMethod() {
						return this.match(r.relational);
					}
					parseClassElement(e) {
						if (this.eat(r.semi)) return null;
						let t = this.startNode(), n = "", s = !1, a = !1, i = "method", o = !1;
						const l = [
							"declare",
							"private",
							"public",
							"protected",
							"accessor",
							"override",
							"abstract",
							"readonly",
							"static"
						], c = this.tsParseModifiers({
							modified: t,
							allowedModifiers: l,
							disallowedModifiers: ["in", "out"],
							stopOnStartOfClassStaticBlock: !0,
							errorTemplate: As.InvalidModifierOnTypeParameterPositions
						});
						o = Boolean(c.static);
						const p = () => {
							if (!this.tsIsStartOfStaticBlocks()) {
								const l = this.tsTryParseIndexSignature(t);
								if (l) return t.abstract && this.raise(t.start, As.IndexSignatureHasAbstract), t.accessibility && this.raise(t.start, As.IndexSignatureHasAccessibility({ modifier: t.accessibility })), t.declare && this.raise(t.start, As.IndexSignatureHasDeclare), t.override && this.raise(t.start, As.IndexSignatureHasOverride), l;
								if (!this.inAbstractClass && t.abstract && this.raise(t.start, As.NonAbstractClassHasAbstractMethod), t.override && (e || this.raise(t.start, As.OverrideNotInSubClass)), t.static = o, o && (this.isClassElementNameStart() || this.type === r.star || (n = "static")), !n && this.ecmaVersion >= 8 && this.eatContextual("async") && (!this.isClassElementNameStart() && this.type !== r.star || this.canInsertSemicolon() ? n = "async" : a = !0), !n && (this.ecmaVersion >= 9 || !a) && this.eat(r.star) && (s = !0), !n && !a && !s) {
									const e = this.value;
									(this.eatContextual("get") || this.eatContextual("set")) && (this.isClassElementNameStart() ? i = e : n = e);
								}
								if (n ? (t.computed = !1, t.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc), t.key.name = n, this.finishNode(t.key, "Identifier")) : this.parseClassElementName(t), this.parsePostMemberNameModifiers(t), this.isClassMethod() || this.ecmaVersion < 13 || this.type === r.parenL || "method" !== i || s || a) {
									const n = !t.static && Ts(t, "constructor"), r = n && e;
									n && "method" !== i && this.raise(t.key.start, "Constructor can't have get/set modifier"), t.kind = n ? "constructor" : i, this.parseClassMethod(t, s, a, r);
								} else this.parseClassField(t);
								return t;
							}
							if (this.next(), this.next(), this.tsHasSomeModifiers(t, l) && this.raise(this.start, As.StaticBlockCannotHaveModifier), this.ecmaVersion >= 13) return super.parseClassStaticBlock(t), t;
						};
						return t.declare ? this.tsInAmbientContext(p) : p(), t;
					}
					isClassElementNameStart() {
						return !!this.tsIsIdentifier() || super.isClassElementNameStart();
					}
					parseClassSuper(e) {
						super.parseClassSuper(e), e.superClass && (this.tsMatchLeftRelational() || this.match(r.bitShift)) && (e.superTypeParameters = this.tsParseTypeArgumentsInExpression()), this.eatContextual("implements") && (e.implements = this.tsParseHeritageClause("implements"));
					}
					parseFunctionParams(e) {
						const t = this.tsTryParseTypeParameters(this.tsParseConstModifier);
						t && (e.typeParameters = t), super.parseFunctionParams(e);
					}
					parseVarId(e, t) {
						super.parseVarId(e, t), "Identifier" === e.id.type && !this.hasPrecedingLineBreak() && "!" === this.value && this.eat(r.prefix) && (e.definite = !0);
						const n = this.tsTryParseTypeAnnotation();
						n && (e.id.typeAnnotation = n, this.resetEndLocation(e.id));
					}
					parseArrowExpression(e, t, n, s) {
						this.match(r.colon) && (e.returnType = this.tsParseTypeAnnotation());
						let a = this.yieldPos, i = this.awaitPos, o = this.awaitIdentPos;
						this.enterScope(Os(n, !1) | Ls.SCOPE_ARROW), this.initFunction(e);
						const l = this.maybeInArrowParameters;
						return this.ecmaVersion >= 8 && (e.async = !!n), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.maybeInArrowParameters = !0, e.params = this.toAssignableList(t, !0), this.maybeInArrowParameters = !1, this.parseFunctionBody(e, !0, !1, s), this.yieldPos = a, this.awaitPos = i, this.awaitIdentPos = o, this.maybeInArrowParameters = l, this.finishNode(e, "ArrowFunctionExpression");
					}
					parseMaybeAssignOrigin(e, t, n) {
						if (this.isContextual("yield")) {
							if (this.inGenerator) return this.parseYield(e);
							this.exprAllowed = !1;
						}
						let s = !1, a = -1, i = -1, o = -1;
						t ? (a = t.parenthesizedAssign, i = t.trailingComma, o = t.doubleProto, t.parenthesizedAssign = t.trailingComma = -1) : (t = new Ps(), s = !0);
						let l = this.start, c = this.startLoc;
						(this.type === r.parenL || v(this.type)) && (this.potentialArrowAt = this.start, this.potentialArrowInForAwait = "await" === e);
						let p = this.parseMaybeConditional(e, t);
						if (n && (p = n.call(this, p, l, c)), this.type.isAssign) {
							let n = this.startNodeAt(l, c);
							return n.operator = this.value, this.type === r.eq && (p = this.toAssignable(p, !0, t)), s || (t.parenthesizedAssign = t.trailingComma = t.doubleProto = -1), t.shorthandAssign >= p.start && (t.shorthandAssign = -1), this.maybeInArrowParameters || (this.type === r.eq ? this.checkLValPattern(p) : this.checkLValSimple(p)), n.left = p, this.next(), n.right = this.parseMaybeAssign(e), o > -1 && (t.doubleProto = o), this.finishNode(n, "AssignmentExpression");
						}
						return s && this.checkExpressionErrors(t, !0), a > -1 && (t.parenthesizedAssign = a), i > -1 && (t.trailingComma = i), p;
					}
					parseMaybeAssign(e, t, n) {
						let s, r, a;
						if (!this.tsMatchLeftRelational()) return this.parseMaybeAssignOrigin(e, t, n);
						s && !this.compareLookaheadState(s, this.getCurLookaheadState()) || (s = this.cloneCurLookaheadState());
						const i = this.tryParse(((s) => {
							a = this.tsParseTypeParameters(this.tsParseConstModifier);
							const r = this.parseMaybeAssignOrigin(e, t, n);
							return ("ArrowFunctionExpression" !== r.type || r.extra?.parenthesized) && s(), 0 !== a?.params.length && this.resetStartLocationFromNode(r, a), r.typeParameters = a, r;
						}), s);
						if (!i.error && !i.aborted) return a && this.reportReservedArrowTypeParam(a), i.node;
						if (Is(!0), r = this.tryParse((() => this.parseMaybeAssignOrigin(e, t, n)), s), !r.error) return r.node;
						if (i.node) return this.setLookaheadState(i.failState), a && this.reportReservedArrowTypeParam(a), i.node;
						if (r?.node) return this.setLookaheadState(r.failState), r.node;
						if (i.thrown) throw i.error;
						if (r?.thrown) throw r.error;
						throw i.error || r?.error;
					}
					parseAssignableListItem(e) {
						const t = [];
						for (; this.match(u.at);) t.push(this.parseDecorator());
						const n = this.start, s = this.startLoc;
						let r, a = !1, i = !1;
						if (void 0 !== e) {
							const t = {};
							this.tsParseModifiers({
								modified: t,
								allowedModifiers: [
									"public",
									"private",
									"protected",
									"override",
									"readonly"
								]
							}), r = t.accessibility, i = t.override, a = t.readonly, !1 === e && (r || a || i) && this.raise(s.start, As.UnexpectedParameterModifier);
						}
						const o = this.parseMaybeDefault(n, s);
						this.parseBindingListItem(o);
						const l = this.parseMaybeDefault(o.start, o.loc, o);
						if (t.length && (l.decorators = t), r || a || i) {
							const e = this.startNodeAt(n, s);
							return r && (e.accessibility = r), a && (e.readonly = a), i && (e.override = i), "Identifier" !== l.type && "AssignmentPattern" !== l.type && this.raise(e.start, As.UnsupportedParameterPropertyKind), e.parameter = l, this.finishNode(e, "TSParameterProperty");
						}
						return l;
					}
					checkLValInnerPattern(e, t = Ls.BIND_NONE, n) {
						if ("TSParameterProperty" === e.type) this.checkLValInnerPattern(e.parameter, t, n);
						else super.checkLValInnerPattern(e, t, n);
					}
					parseBindingListItem(e) {
						this.eat(r.question) && ("Identifier" === e.type || this.isAmbientContext || this.inType || this.raise(e.start, As.PatternIsOptional), e.optional = !0);
						const t = this.tsTryParseTypeAnnotation();
						return t && (e.typeAnnotation = t), this.resetEndLocation(e), e;
					}
					isAssignable(e, t) {
						switch (e.type) {
							case "TSTypeCastExpression": return this.isAssignable(e.expression, t);
							case "TSParameterProperty":
							case "Identifier":
							case "ObjectPattern":
							case "ArrayPattern":
							case "AssignmentPattern":
							case "RestElement": return !0;
							case "ObjectExpression": {
								const t = e.properties.length - 1;
								return e.properties.every(((e, n) => "ObjectMethod" !== e.type && (n === t || "SpreadElement" !== e.type) && this.isAssignable(e)));
							}
							case "Property":
							case "ObjectProperty": return this.isAssignable(e.value);
							case "SpreadElement": return this.isAssignable(e.argument);
							case "ArrayExpression": return e.elements.every(((e) => null === e || this.isAssignable(e)));
							case "AssignmentExpression": return "=" === e.operator;
							case "ParenthesizedExpression": return this.isAssignable(e.expression);
							case "MemberExpression":
							case "OptionalMemberExpression": return !t;
							default: return !1;
						}
					}
					toAssignable(e, t = !1, n = new Ps()) {
						switch (e.type) {
							case "ParenthesizedExpression": return this.toAssignableParenthesizedExpression(e, t, n);
							case "TSAsExpression":
							case "TSSatisfiesExpression":
							case "TSNonNullExpression":
							case "TSTypeAssertion": return t || this.raise(e.start, As.UnexpectedTypeCastInParameter), this.toAssignable(e.expression, t, n);
							case "MemberExpression": break;
							case "AssignmentExpression": return t || "TSTypeCastExpression" !== e.left.type || (e.left = this.typeCastToParameter(e.left)), super.toAssignable(e, t, n);
							case "TSTypeCastExpression": return this.typeCastToParameter(e);
							default: return super.toAssignable(e, t, n);
						}
						return e;
					}
					toAssignableParenthesizedExpression(e, t, n) {
						switch (e.expression.type) {
							case "TSAsExpression":
							case "TSSatisfiesExpression":
							case "TSNonNullExpression":
							case "TSTypeAssertion":
							case "ParenthesizedExpression": return this.toAssignable(e.expression, t, n);
							default: return super.toAssignable(e, t, n);
						}
					}
					parseBindingAtom() {
						return this.type === r._this ? this.parseIdent(!0) : super.parseBindingAtom();
					}
					shouldParseArrow(e) {
						let t;
						if (t = this.match(r.colon) ? e.every(((e) => this.isAssignable(e, !0))) : !this.canInsertSemicolon(), t) {
							if (this.match(r.colon)) {
								const e = this.tryParse(((e) => {
									const t = this.tsParseTypeOrTypePredicateAnnotation(r.colon);
									return !this.canInsertSemicolon() && this.match(r.arrow) || e(), t;
								}));
								if (e.aborted) return this.shouldParseArrowReturnType = void 0, !1;
								e.thrown || (e.error && this.setLookaheadState(e.failState), this.shouldParseArrowReturnType = e.node);
							}
							return !!this.match(r.arrow) || (this.shouldParseArrowReturnType = void 0, !1);
						}
						return this.shouldParseArrowReturnType = void 0, t;
					}
					parseParenArrowList(e, t, n, s) {
						const r = this.startNodeAt(e, t);
						return r.returnType = this.shouldParseArrowReturnType, this.shouldParseArrowReturnType = void 0, this.parseArrowExpression(r, n, !1, s);
					}
					parseParenAndDistinguishExpression(e, t) {
						let n, s = this.start, a = this.startLoc, i = this.ecmaVersion >= 8;
						if (this.ecmaVersion >= 6) {
							const o = this.maybeInArrowParameters;
							this.maybeInArrowParameters = !0, this.next();
							let l, c = this.start, p = this.startLoc, u = [], d = !0, h = !1, m = new Ps(), f = this.yieldPos, y = this.awaitPos;
							for (this.yieldPos = 0, this.awaitPos = 0; this.type !== r.parenR;) {
								if (d ? d = !1 : this.expect(r.comma), i && this.afterTrailingComma(r.parenR, !0)) {
									h = !0;
									break;
								}
								if (this.type === r.ellipsis) {
									l = this.start, u.push(this.parseParenItem(this.parseRestBinding())), this.type === r.comma && this.raise(this.start, "Comma is not permitted after the rest element");
									break;
								}
								u.push(this.parseMaybeAssign(t, m, this.parseParenItem));
							}
							let v = this.lastTokEnd, g = this.lastTokEndLoc;
							if (this.expect(r.parenR), this.maybeInArrowParameters = o, e && this.shouldParseArrow(u) && this.eat(r.arrow)) return this.checkPatternErrors(m, !1), this.checkYieldAwaitInDefaultParams(), this.yieldPos = f, this.awaitPos = y, this.parseParenArrowList(s, a, u, t);
							u.length && !h || this.unexpected(this.lastTokStart), l && this.unexpected(l), this.checkExpressionErrors(m, !0), this.yieldPos = f || this.yieldPos, this.awaitPos = y || this.awaitPos, u.length > 1 ? (n = this.startNodeAt(c, p), n.expressions = u, this.finishNodeAt(n, "SequenceExpression", v, g)) : n = u[0];
						} else n = this.parseParenExpression();
						if (this.options.preserveParens) {
							let e = this.startNodeAt(s, a);
							return e.expression = n, this.finishNode(e, "ParenthesizedExpression");
						}
						return n;
					}
					parseTaggedTemplateExpression(e, t, n, s) {
						const r = this.startNodeAt(t, n);
						return r.tag = e, r.quasi = this.parseTemplate({ isTagged: !0 }), s && this.raise(t, "Tagged Template Literals are not allowed in optionalChain."), this.finishNode(r, "TaggedTemplateExpression");
					}
					shouldParseAsyncArrow() {
						if (!this.match(r.colon)) return !this.canInsertSemicolon() && this.eat(r.arrow);
						{
							const e = this.tryParse(((e) => {
								const t = this.tsParseTypeOrTypePredicateAnnotation(r.colon);
								return !this.canInsertSemicolon() && this.match(r.arrow) || e(), t;
							}));
							if (e.aborted) return this.shouldParseAsyncArrowReturnType = void 0, !1;
							if (!e.thrown) return e.error && this.setLookaheadState(e.failState), this.shouldParseAsyncArrowReturnType = e.node, !this.canInsertSemicolon() && this.eat(r.arrow);
						}
					}
					parseSubscriptAsyncArrow(e, t, n, s) {
						const r = this.startNodeAt(e, t);
						return r.returnType = this.shouldParseAsyncArrowReturnType, this.shouldParseAsyncArrowReturnType = void 0, this.parseArrowExpression(r, n, !0, s);
					}
					parseExprList(e, t, n, s) {
						let a = [], i = !0;
						for (; !this.eat(e);) {
							if (i) i = !1;
							else if (this.expect(r.comma), t && this.afterTrailingComma(e)) break;
							let o;
							n && this.type === r.comma ? o = null : this.type === r.ellipsis ? (o = this.parseSpread(s), this.maybeInArrowParameters && this.match(r.colon) && (o.typeAnnotation = this.tsParseTypeAnnotation()), s && this.type === r.comma && s.trailingComma < 0 && (s.trailingComma = this.start)) : o = this.parseMaybeAssign(!1, s, this.parseParenItem), a.push(o);
						}
						return a;
					}
					parseSubscript(e, t, n, s, a, i, o) {
						let l = i;
						if (!this.hasPrecedingLineBreak() && "!" === this.value && this.match(r.prefix)) {
							this.exprAllowed = !1, this.next();
							const s = this.startNodeAt(t, n);
							return s.expression = e, e = this.finishNode(s, "TSNonNullExpression");
						}
						let c = !1;
						if (this.match(r.questionDot) && 60 === this.lookaheadCharCode()) {
							if (s) return e;
							e.optional = !0, l = c = !0, this.next();
						}
						if (this.tsMatchLeftRelational() || this.match(r.bitShift)) {
							let a;
							const i = this.tsTryParseAndCatch((() => {
								if (!s && this.atPossibleAsyncArrow(e)) {
									const s = this.tsTryParseGenericAsyncArrowFunction(t, n, o);
									if (s) return e = s;
								}
								const i = this.tsParseTypeArgumentsInExpression();
								if (!i) return e;
								if (c && !this.match(r.parenL)) return a = this.curPosition(), e;
								if (f(this.type) || this.type === r.backQuote) {
									const s = this.parseTaggedTemplateExpression(e, t, n, l);
									return s.typeArguments = i, s;
								}
								if (!s && this.eat(r.parenL)) {
									let s = new Ps();
									const a = this.startNodeAt(t, n);
									return a.callee = e, a.arguments = this.parseExprList(r.parenR, this.ecmaVersion >= 8, !1, s), this.tsCheckForInvalidTypeCasts(a.arguments), a.typeArguments = i, l && (a.optional = c), this.checkExpressionErrors(s, !0), e = this.finishNode(a, "CallExpression");
								}
								const p = this.type;
								if (this.tsMatchRightRelational() || p === r.bitShift || p !== r.parenL && Boolean(p.startsExpr) && !this.hasPrecedingLineBreak()) return;
								const u = this.startNodeAt(t, n);
								return u.expression = e, u.typeArguments = i, this.finishNode(u, "TSInstantiationExpression");
							}));
							if (a && this.unexpected(a), i) return "TSInstantiationExpression" === i.type && (this.match(r.dot) || this.match(r.questionDot) && 40 !== this.lookaheadCharCode()) && this.raise(this.start, As.InvalidPropertyAccessAfterInstantiationExpression), e = i;
						}
						let p = this.ecmaVersion >= 11, u = p && this.eat(r.questionDot);
						s && u && this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
						let d = this.eat(r.bracketL);
						if (d || u && this.type !== r.parenL && this.type !== r.backQuote || this.eat(r.dot)) {
							let s = this.startNodeAt(t, n);
							s.object = e, d ? (s.property = this.parseExpression(), this.expect(r.bracketR)) : this.type === r.privateId && "Super" !== e.type ? s.property = this.parsePrivateIdent() : s.property = this.parseIdent("never" !== this.options.allowReserved), s.computed = !!d, p && (s.optional = u), e = this.finishNode(s, "MemberExpression");
						} else if (!s && this.eat(r.parenL)) {
							const s = this.maybeInArrowParameters;
							this.maybeInArrowParameters = !0;
							let i = new Ps(), l = this.yieldPos, c = this.awaitPos, d = this.awaitIdentPos;
							this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0;
							let h = this.parseExprList(r.parenR, this.ecmaVersion >= 8, !1, i);
							if (a && !u && this.shouldParseAsyncArrow()) this.checkPatternErrors(i, !1), this.checkYieldAwaitInDefaultParams(), this.awaitIdentPos > 0 && this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"), this.yieldPos = l, this.awaitPos = c, this.awaitIdentPos = d, e = this.parseSubscriptAsyncArrow(t, n, h, o);
							else {
								this.checkExpressionErrors(i, !0), this.yieldPos = l || this.yieldPos, this.awaitPos = c || this.awaitPos, this.awaitIdentPos = d || this.awaitIdentPos;
								let s = this.startNodeAt(t, n);
								s.callee = e, s.arguments = h, p && (s.optional = u), e = this.finishNode(s, "CallExpression");
							}
							this.maybeInArrowParameters = s;
						} else if (this.type === r.backQuote) {
							(u || l) && this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
							let s = this.startNodeAt(t, n);
							s.tag = e, s.quasi = this.parseTemplate({ isTagged: !0 }), e = this.finishNode(s, "TaggedTemplateExpression");
						}
						return e;
					}
					parseGetterSetter(e) {
						e.kind = e.key.name, this.parsePropertyName(e), e.value = this.parseMethod(!1);
						let t = "get" === e.kind ? 0 : 1;
						const n = e.value.params[0];
						if (t = n && this.isThisParam(n) ? t + 1 : t, e.value.params.length !== t) {
							let t = e.value.start;
							"get" === e.kind ? this.raiseRecoverable(t, "getter should have no params") : this.raiseRecoverable(t, "setter should have exactly one param");
						} else "set" === e.kind && "RestElement" === e.value.params[0].type && this.raiseRecoverable(e.value.params[0].start, "Setter cannot use rest params");
					}
					parseProperty(e, t) {
						if (!e) {
							let n = [];
							if (this.match(u.at)) for (; this.match(u.at);) n.push(this.parseDecorator());
							const s = super.parseProperty(e, t);
							return "SpreadElement" === s.type && n.length && this.raise(s.start, $s.SpreadElementDecorator), n.length && (s.decorators = n, n = []), s;
						}
						return super.parseProperty(e, t);
					}
					parseCatchClauseParam() {
						const e = this.parseBindingAtom();
						let t = "Identifier" === e.type;
						this.enterScope(t ? Ls.SCOPE_SIMPLE_CATCH : 0), this.checkLValPattern(e, t ? Ls.BIND_SIMPLE_CATCH : Ls.BIND_LEXICAL);
						const n = this.tsTryParseTypeAnnotation();
						return n && (e.typeAnnotation = n, this.resetEndLocation(e)), this.expect(r.parenR), e;
					}
					parseClass(e, t) {
						const n = this.inAbstractClass;
						this.inAbstractClass = !!e.abstract;
						try {
							this.next(), this.takeDecorators(e);
							const n = this.strict;
							this.strict = !0, this.parseClassId(e, t), this.parseClassSuper(e);
							const s = this.enterClassBody(), a = this.startNode();
							let i = !1;
							a.body = [];
							let o = [];
							for (this.expect(r.braceL); this.type !== r.braceR;) {
								if (this.match(u.at)) {
									o.push(this.parseDecorator());
									continue;
								}
								const t = this.parseClassElement(null !== e.superClass);
								o.length && (t.decorators = o, this.resetStartLocationFromNode(t, o[0]), o = []), t && (a.body.push(t), "MethodDefinition" === t.type && "constructor" === t.kind && "FunctionExpression" === t.value.type ? (i && this.raiseRecoverable(t.start, "Duplicate constructor in the same class"), i = !0, t.decorators && t.decorators.length > 0 && this.raise(t.start, $s.DecoratorConstructor)) : t.key && "PrivateIdentifier" === t.key.type && Es(s, t) && this.raiseRecoverable(t.key.start, `Identifier '#${t.key.name}' has already been declared`));
							}
							return this.strict = n, this.next(), o.length && this.raise(this.start, $s.TrailingDecorator), e.body = this.finishNode(a, "ClassBody"), this.exitClassBody(), this.finishNode(e, t ? "ClassDeclaration" : "ClassExpression");
						} finally {
							this.inAbstractClass = n;
						}
					}
					parseClassFunctionParams() {
						const e = this.tsTryParseTypeParameters();
						let t = this.parseBindingList(r.parenR, !1, this.ecmaVersion >= 8, !0);
						return e && (t.typeParameters = e), t;
					}
					parseMethod(e, t, n, s, a) {
						let i = this.startNode(), o = this.yieldPos, l = this.awaitPos, c = this.awaitIdentPos;
						if (this.initFunction(i), this.ecmaVersion >= 6 && (i.generator = e), this.ecmaVersion >= 8 && (i.async = !!t), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(Os(t, i.generator) | Ls.SCOPE_SUPER | (n ? Ls.SCOPE_DIRECT_SUPER : 0)), this.expect(r.parenL), i.params = this.parseClassFunctionParams(), this.checkYieldAwaitInDefaultParams(), this.parseFunctionBody(i, !1, !0, !1, { isClassMethod: s }), this.yieldPos = o, this.awaitPos = l, this.awaitIdentPos = c, a && a.abstract) {
							if (!!i.body) {
								const { key: e } = a;
								this.raise(a.start, As.AbstractMethodHasImplementation({ methodName: "Identifier" !== e.type || a.computed ? `[${this.input.slice(e.start, e.end)}]` : e.name }));
							}
						}
						return this.finishNode(i, "FunctionExpression");
					}
					static parse(e, n) {
						if (!1 === n.locations) throw new Error("You have to enable options.locations while using acorn-typescript");
						n.locations = !0;
						const s = new this(n, e);
						return t && (s.isAmbientContext = !0), s.parse();
					}
					static parseExpressionAt(e, n, s) {
						if (!1 === s.locations) throw new Error("You have to enable options.locations while using acorn-typescript");
						s.locations = !0;
						const r = new this(s, e, n);
						return t && (r.isAmbientContext = !0), r.nextToken(), r.parseExpression();
					}
					parseImportSpecifier() {
						if (this.ts_isContextual(u.type)) {
							let e = this.startNode();
							return e.imported = this.parseModuleExportName(), this.parseTypeOnlyImportExportSpecifier(e, !0, "type" === this.importOrExportOuterKind), this.finishNode(e, "ImportSpecifier");
						}
						{
							const e = super.parseImportSpecifier();
							return e.importKind = "value", e;
						}
					}
					parseExportSpecifier(e) {
						const t = this.ts_isContextual(u.type);
						if (!this.match(r.string) && t) {
							let t = this.startNode();
							return t.local = this.parseModuleExportName(), this.parseTypeOnlyImportExportSpecifier(t, !1, "type" === this.importOrExportOuterKind), this.finishNode(t, "ExportSpecifier"), this.checkExport(e, t.exported, t.exported.start), t;
						}
						{
							const t = super.parseExportSpecifier(e);
							return t.exportKind = "value", t;
						}
					}
					parseTypeOnlyImportExportSpecifier(e, t, n) {
						const s = t ? "imported" : "local", r = t ? "local" : "exported";
						let a, i = e[s], o = !1, l = !0;
						const c = i.start;
						if (this.isContextual("as")) {
							const e = this.parseIdent();
							if (this.isContextual("as")) {
								const n = this.parseIdent();
								g(this.type) ? (o = !0, i = e, a = t ? this.parseIdent() : this.parseModuleExportName(), l = !1) : (a = n, l = !1);
							} else g(this.type) ? (l = !1, a = t ? this.parseIdent() : this.parseModuleExportName()) : (o = !0, i = e);
						} else g(this.type) && (o = !0, t ? (i = super.parseIdent(!0), this.isContextual("as") || this.checkUnreserved(i)) : i = this.parseModuleExportName());
						o && n && this.raise(c, t ? As.TypeModifierIsUsedInTypeImports : As.TypeModifierIsUsedInTypeExports), e[s] = i, e[r] = a;
						e[t ? "importKind" : "exportKind"] = o ? "type" : "value", l && this.eatContextual("as") && (e[r] = t ? this.parseIdent() : this.parseModuleExportName()), e[r] || (e[r] = this.copyNode(e[s])), t && this.checkLValSimple(e[r], Ls.BIND_LEXICAL);
					}
					raiseCommonCheck(e, t, n) {
						return "Comma is not permitted after the rest element" === t ? this.isAmbientContext && this.match(r.comma) && 41 === this.lookaheadCharCode() ? void this.next() : super.raise(e, t) : n ? super.raiseRecoverable(e, t) : super.raise(e, t);
					}
					raiseRecoverable(e, t) {
						return this.raiseCommonCheck(e, t, !0);
					}
					raise(e, t) {
						return this.raiseCommonCheck(e, t, !0);
					}
					updateContext(e) {
						const { type: t } = this;
						if (t == r.braceL) {
							var n = this.curContext();
							n == d.tc_oTag ? this.context.push(c.b_expr) : n == d.tc_expr ? this.context.push(c.b_tmpl) : super.updateContext(e), this.exprAllowed = !0;
						} else {
							if (t !== r.slash || e !== u.jsxTagStart) return super.updateContext(e);
							this.context.length -= 2, this.context.push(d.tc_cTag), this.exprAllowed = !1;
						}
					}
					jsx_parseOpeningElementAt(e, t) {
						let n = this.startNodeAt(e, t), s = this.jsx_parseElementName();
						if (s && (n.name = s), this.match(r.relational) || this.match(r.bitShift)) {
							const e = this.tsTryParseAndCatch((() => this.tsParseTypeArgumentsInExpression()));
							e && (n.typeArguments = e);
						}
						for (n.attributes = []; this.type !== r.slash && this.type !== u.jsxTagEnd;) n.attributes.push(this.jsx_parseAttribute());
						return n.selfClosing = this.eat(r.slash), this.expect(u.jsxTagEnd), this.finishNode(n, s ? "JSXOpeningElement" : "JSXOpeningFragment");
					}
					enterScope(e) {
						e === Cs && this.importsStack.push([]), super.enterScope(e);
						const t = super.currentScope();
						t.types = [], t.enums = [], t.constEnums = [], t.classes = [], t.exportOnlyBindings = [];
					}
					exitScope() {
						super.currentScope().flags === Cs && this.importsStack.pop(), super.exitScope();
					}
					hasImport(e, t) {
						const n = this.importsStack.length;
						if (this.importsStack[n - 1].indexOf(e) > -1) return !0;
						if (!t && n > 1) {
							for (let t = 0; t < n - 1; t++) if (this.importsStack[t].indexOf(e) > -1) return !0;
						}
						return !1;
					}
					maybeExportDefined(e, t) {
						this.inModule && e.flags & Ls.SCOPE_TOP && this.undefinedExports.delete(t);
					}
					declareName(e, t, n) {
						if (t & Ls.BIND_FLAGS_TS_IMPORT) return this.hasImport(e, !0) && this.raise(n, `Identifier '${e}' has already been declared.`), void this.importsStack[this.importsStack.length - 1].push(e);
						const s = this.currentScope();
						if (t & Ls.BIND_FLAGS_TS_EXPORT_ONLY) return this.maybeExportDefined(s, e), void s.exportOnlyBindings.push(e);
						t === Ls.BIND_TS_TYPE || t === Ls.BIND_TS_INTERFACE ? (t === Ls.BIND_TS_TYPE && s.types.includes(e) && this.raise(n, `type '${e}' has already been declared.`), s.types.push(e)) : super.declareName(e, t, n), t & Ls.BIND_FLAGS_TS_ENUM && s.enums.push(e), t & Ls.BIND_FLAGS_TS_CONST_ENUM && s.constEnums.push(e), t & Ls.BIND_FLAGS_CLASS && s.classes.push(e);
					}
					checkLocalExport(e) {
						const { name: t } = e;
						if (this.hasImport(t)) return;
						for (let e = this.scopeStack.length - 1; e >= 0; e--) {
							const n = this.scopeStack[e];
							if (n.types.indexOf(t) > -1 || n.exportOnlyBindings.indexOf(t) > -1) return;
						}
						super.checkLocalExport(e);
					}
				};
			};
		}());
		function Fs(e, t, n, s) {
			const r = n ? Bs : hn, { onComment: a, add_comments: i } = Hs(e, t), o = r.prototype.parseStatement;
			let l;
			s && (r.prototype.parseStatement = function(...e) {
				const t = o.call(this, ...e);
				return this.undefinedExports = {}, t;
			});
			try {
				l = r.parse(e, {
					onComment: a,
					sourceType: "module",
					ecmaVersion: 16,
					locations: !0
				});
			} finally {
				s && (r.prototype.parseStatement = o);
			}
			return i(l), l;
		}
		function Vs(e, t, n, s) {
			const r = n ? Bs : hn, { onComment: a, add_comments: i } = Hs(e, t, s), o = r.parseExpressionAt(e, s, {
				onComment: a,
				sourceType: "module",
				ecmaVersion: 16,
				locations: !0
			});
			return i(o), o;
		}
		function Hs(e, n, s = 0) {
			return {
				onComment: (t, s, r, a, i, o) => {
					if (t && /\n/.test(s)) {
						let t = r;
						for (; t > 0 && "\n" !== e[t - 1];) t -= 1;
						let n = t;
						for (; /[ \t]/.test(e[n]);) n += 1;
						const a = e.slice(t, n);
						s = s.replace(new RegExp(`^${a}`, "gm"), "");
					}
					n.push({
						type: t ? "Block" : "Line",
						value: s,
						start: r,
						end: a,
						loc: {
							start: i,
							end: o
						}
					});
				},
				add_comments(r) {
					0 !== n.length && (n = n.filter(((e) => e.start >= s)).map((({ type: e, value: t, start: n, end: s }) => ({
						type: e,
						value: t,
						start: n,
						end: s
					}))), t(r, null, { _(t, { next: s, path: r }) {
						let a;
						for (; n[0] && n[0].start < t.start;) a = n.shift(), (t.leadingComments ||= []).push(a);
						if (s(), n[0]) {
							const s = r.at(-1);
							if (void 0 === s || t.end !== s.end) {
								const r = e.slice(t.end, n[0].start);
								if (("BlockStatement" === s?.type || "Program" === s?.type) && s.body.indexOf(t) === s.body.length - 1 || "ArrayExpression" === s?.type && s.elements.indexOf(t) === s.elements.length - 1 || "ObjectExpression" === s?.type && s.properties.indexOf(t) === s.properties.length - 1) for (t.end; n.length;) {
									const e = n[0];
									if (s && e.start >= s.end) break;
									(t.trailingComments ||= []).push(e), n.shift(), e.end;
								}
								else t.end <= n[0].start && /^[,) \t]*$/.test(r) && (t.trailingComments = [n.shift()]);
							}
						}
					} }), n.length > 0 && (n[0].start >= r.end || "Program" === r.type) && (r.trailingComments ||= []).push(...n.splice(0)));
				}
			};
		}
		class Us extends Error {
			message = "";
			#e;
			constructor(e, t, n) {
				super(t), this.stack = "", this.#e = new Ie(e, t, n), Object.assign(this, this.#e), this.name = "CompileError";
			}
			toString() {
				return this.#e.toString();
			}
			toJSON() {
				return this.#e.toJSON();
			}
		}
		function zs(e, t, n) {
			const s = "number" == typeof e ? e : e?.start;
			throw new Us(t, n, void 0 !== s ? [s, ("number" == typeof e ? e : e?.end) ?? s] : void 0);
		}
		function Ws(e, t) {
			zs(e, "options_unrecognised", `Unrecognised compiler option ${t}\nhttps://svelte.dev/e/options_unrecognised`);
		}
		function Gs(e, t) {
			zs(e, "constant_assignment", `Cannot assign to ${t}\nhttps://svelte.dev/e/constant_assignment`);
		}
		function Ks(e) {
			zs(e, "declaration_duplicate_module_import", "Cannot declare a variable with the same name as an import inside `<script module>`\nhttps://svelte.dev/e/declaration_duplicate_module_import");
		}
		function Xs(e) {
			zs(e, "derived_invalid_export", "Cannot export derived state from a module. To expose the current derived value, export a function returning its value\nhttps://svelte.dev/e/derived_invalid_export");
		}
		function Qs(e, t) {
			zs(e, "duplicate_class_field", `\`${t}\` has already been declared\nhttps://svelte.dev/e/duplicate_class_field`);
		}
		function Ys(e, t) {
			zs(e, "export_undefined", `\`${t}\` is not defined\nhttps://svelte.dev/e/export_undefined`);
		}
		function Js(e, t) {
			zs(e, "global_reference_invalid", `\`${t}\` is an illegal variable name. To reference a global variable called \`${t}\`, use \`globalThis.${t}\`\nhttps://svelte.dev/e/global_reference_invalid`);
		}
		function Zs(e) {
			zs(e, "module_illegal_default_export", "A component cannot have a default export\nhttps://svelte.dev/e/module_illegal_default_export");
		}
		function er(e, t) {
			zs(e, "props_duplicate", `Cannot use \`${t}()\` more than once\nhttps://svelte.dev/e/props_duplicate`);
		}
		function tr(e) {
			zs(e, "props_illegal_name", "Declaring or accessing a prop starting with `$$` is illegal (they are reserved for Svelte internals)\nhttps://svelte.dev/e/props_illegal_name");
		}
		function nr(e) {
			zs(e, "props_invalid_pattern", "`$props()` assignment must not contain nested properties or computed keys\nhttps://svelte.dev/e/props_invalid_pattern");
		}
		function sr(e, t) {
			zs(e, "rune_invalid_arguments", `\`${t}\` cannot be called with arguments\nhttps://svelte.dev/e/rune_invalid_arguments`);
		}
		function rr(e, t, n) {
			zs(e, "rune_invalid_arguments_length", `\`${t}\` must be called with ${n}\nhttps://svelte.dev/e/rune_invalid_arguments_length`);
		}
		function ar(e) {
			zs(e, "rune_invalid_computed_property", "Cannot access a computed property of a rune\nhttps://svelte.dev/e/rune_invalid_computed_property");
		}
		function ir(e, t) {
			zs(e, "rune_invalid_name", `\`${t}\` is not a valid rune\nhttps://svelte.dev/e/rune_invalid_name`);
		}
		function or(e, t) {
			zs(e, "rune_invalid_spread", `\`${t}\` cannot be called with a spread argument\nhttps://svelte.dev/e/rune_invalid_spread`);
		}
		function lr(e, t) {
			zs(e, "rune_removed", `The \`${t}\` rune has been removed\nhttps://svelte.dev/e/rune_removed`);
		}
		function cr(e, t, n) {
			zs(e, "rune_renamed", `\`${t}\` is now \`${n}\`\nhttps://svelte.dev/e/rune_renamed`);
		}
		function pr(e, t) {
			zs(e, "runes_mode_invalid_import", `${t} cannot be used in runes mode\nhttps://svelte.dev/e/runes_mode_invalid_import`);
		}
		function ur(e) {
			zs(e, "snippet_invalid_export", "An exported snippet can only reference things declared in a `<script module>`, or other exportable snippets\nhttps://svelte.dev/e/snippet_invalid_export");
		}
		function dr(e) {
			zs(e, "state_field_invalid_assignment", "Cannot assign to a state field before its declaration\nhttps://svelte.dev/e/state_field_invalid_assignment");
		}
		function hr(e) {
			zs(e, "state_invalid_export", "Cannot export state from a module if it is reassigned. Either export a function returning the state value or only mutate the state value's properties\nhttps://svelte.dev/e/state_invalid_export");
		}
		function mr(e, t) {
			zs(e, "state_invalid_placement", `\`${t}(...)\` can only be used as a variable declaration initializer, a class field declaration, or the first assignment to a class field at the top level of the constructor.\nhttps://svelte.dev/e/state_invalid_placement`);
		}
		function fr(e) {
			zs(e, "store_invalid_subscription", "Cannot reference store value inside `<script module>`\nhttps://svelte.dev/e/store_invalid_subscription");
		}
		function yr(e, t) {
			zs(e, "typescript_invalid_feature", `TypeScript language features like ${t} are not natively supported, and their use is generally discouraged. Outside of \`<script>\` tags, these features are not supported. For use within \`<script>\` tags, you will need to use a preprocessor to convert it to JavaScript before it gets passed to the Svelte compiler. If you are using \`vitePreprocess\`, make sure to specifically enable preprocessing script tags (\`vitePreprocess({ script: true })\`)\nhttps://svelte.dev/e/typescript_invalid_feature`);
		}
		function vr(e) {
			zs(e, "css_expected_identifier", "Expected a valid CSS identifier\nhttps://svelte.dev/e/css_expected_identifier");
		}
		function gr(e, t) {
			zs(e, "css_global_block_invalid_combinator", `A \`:global\` selector cannot follow a \`${t}\` combinator\nhttps://svelte.dev/e/css_global_block_invalid_combinator`);
		}
		function br(e) {
			zs(e, "css_global_block_invalid_declaration", "A top-level `:global {...}` block can only contain rules, not declarations\nhttps://svelte.dev/e/css_global_block_invalid_declaration");
		}
		function _r(e) {
			zs(e, "css_global_block_invalid_list", "A `:global` selector cannot be part of a selector list with entries that don't contain `:global`\nhttps://svelte.dev/e/css_global_block_invalid_list");
		}
		function xr(e) {
			zs(e, "css_global_block_invalid_modifier", "A `:global` selector cannot modify an existing selector\nhttps://svelte.dev/e/css_global_block_invalid_modifier");
		}
		function wr(e) {
			zs(e, "css_global_block_invalid_modifier_start", "A `:global` selector can only be modified if it is a descendant of other selectors\nhttps://svelte.dev/e/css_global_block_invalid_modifier_start");
		}
		function kr(e) {
			zs(e, "css_global_invalid_placement", "`:global(...)` can be at the start or end of a selector sequence, but not in the middle\nhttps://svelte.dev/e/css_global_invalid_placement");
		}
		function Cr(e) {
			zs(e, "css_global_invalid_selector", "`:global(...)` must contain exactly one selector\nhttps://svelte.dev/e/css_global_invalid_selector");
		}
		function Sr(e) {
			zs(e, "css_global_invalid_selector_list", "`:global(...)` must not contain type or universal selectors when used in a compound selector\nhttps://svelte.dev/e/css_global_invalid_selector_list");
		}
		function Pr(e) {
			zs(e, "css_selector_invalid", "Invalid selector\nhttps://svelte.dev/e/css_selector_invalid");
		}
		function Er(e) {
			zs(e, "css_type_selector_invalid_placement", "`:global(...)` must not be followed by a type selector\nhttps://svelte.dev/e/css_type_selector_invalid_placement");
		}
		function Tr(e) {
			zs(e, "animation_duplicate", "An element can only have one 'animate' directive\nhttps://svelte.dev/e/animation_duplicate");
		}
		function Ar(e) {
			zs(e, "animation_invalid_placement", "An element that uses the `animate:` directive must be the only child of a keyed `{#each ...}` block\nhttps://svelte.dev/e/animation_invalid_placement");
		}
		function $r(e) {
			zs(e, "animation_missing_key", "An element that uses the `animate:` directive must be the only child of a keyed `{#each ...}` block. Did you forget to add a key to your each block?\nhttps://svelte.dev/e/animation_missing_key");
		}
		function Rr(e) {
			zs(e, "attribute_duplicate", "Attributes need to be unique\nhttps://svelte.dev/e/attribute_duplicate");
		}
		function Ir(e) {
			zs(e, "attribute_invalid_event_handler", "Event attribute must be a JavaScript expression, not a string\nhttps://svelte.dev/e/attribute_invalid_event_handler");
		}
		function Mr(e, t) {
			zs(e, "attribute_invalid_name", `'${t}' is not a valid attribute name\nhttps://svelte.dev/e/attribute_invalid_name`);
		}
		function qr(e) {
			zs(e, "attribute_invalid_sequence_expression", "Sequence expressions are not allowed as attribute/directive values in runes mode, unless wrapped in parentheses\nhttps://svelte.dev/e/attribute_invalid_sequence_expression");
		}
		function Lr(e) {
			zs(e, "bind_invalid_expression", "Can only bind to an Identifier or MemberExpression or a `{get, set}` pair\nhttps://svelte.dev/e/bind_invalid_expression");
		}
		function Or(e, t, n) {
			zs(e, "bind_invalid_name", (n ? `\`bind:${t}\` is not a valid binding. ${n}` : `\`bind:${t}\` is not a valid binding`) + "\nhttps://svelte.dev/e/bind_invalid_name");
		}
		function Nr(e, t) {
			zs(e, "bind_invalid_parens", `\`bind:${t}={get, set}\` must not have surrounding parentheses\nhttps://svelte.dev/e/bind_invalid_parens`);
		}
		function Dr(e, t, n) {
			zs(e, "bind_invalid_target", `\`bind:${t}\` can only be used with ${n}\nhttps://svelte.dev/e/bind_invalid_target`);
		}
		function jr(e, t) {
			zs(e, "block_duplicate_clause", `${t} cannot appear more than once within a block\nhttps://svelte.dev/e/block_duplicate_clause`);
		}
		function Br(e, t, n) {
			zs(e, "block_invalid_placement", `{#${t} ...} block cannot be ${n}\nhttps://svelte.dev/e/block_invalid_placement`);
		}
		function Fr(e, t) {
			zs(e, "block_unexpected_character", `Expected a \`${t}\` character immediately following the opening bracket\nhttps://svelte.dev/e/block_unexpected_character`);
		}
		function Vr(e) {
			zs(e, "block_unexpected_close", "Unexpected block closing tag\nhttps://svelte.dev/e/block_unexpected_close");
		}
		function Hr(e) {
			zs(e, "component_invalid_directive", "This type of directive is not valid on components\nhttps://svelte.dev/e/component_invalid_directive");
		}
		function Ur(e, t) {
			zs(e, "const_tag_invalid_reference", `The \`{@const ${t} = ...}\` declaration is not available in this snippet\nhttps://svelte.dev/e/const_tag_invalid_reference`);
		}
		function zr(e, t) {
			zs(e, "element_invalid_closing_tag", `\`</${t}>\` attempted to close an element that was not open\nhttps://svelte.dev/e/element_invalid_closing_tag`);
		}
		function Wr(e, t, n) {
			zs(e, "element_invalid_closing_tag_autoclosed", `\`</${t}>\` attempted to close element that was already automatically closed by \`<${n}>\` (cannot nest \`<${n}>\` inside \`<${t}>\`)\nhttps://svelte.dev/e/element_invalid_closing_tag_autoclosed`);
		}
		function Gr(e, t) {
			zs(e, "element_unclosed", `\`<${t}>\` was left open\nhttps://svelte.dev/e/element_unclosed`);
		}
		function Kr(e) {
			zs(e, "event_handler_invalid_component_modifier", "Event modifiers other than 'once' can only be used on DOM elements\nhttps://svelte.dev/e/event_handler_invalid_component_modifier");
		}
		function Xr(e, t) {
			zs(e, "event_handler_invalid_modifier", `Valid event modifiers are ${t}\nhttps://svelte.dev/e/event_handler_invalid_modifier`);
		}
		function Qr(e, t, n) {
			zs(e, "event_handler_invalid_modifier_combination", `The '${t}' and '${n}' modifiers cannot be used together\nhttps://svelte.dev/e/event_handler_invalid_modifier_combination`);
		}
		function Yr(e) {
			zs(e, "expected_attribute_value", "Expected attribute value\nhttps://svelte.dev/e/expected_attribute_value");
		}
		function Jr(e) {
			zs(e, "expected_identifier", "Expected an identifier\nhttps://svelte.dev/e/expected_identifier");
		}
		function Zr(e, t) {
			zs(e, "expected_token", `Expected token ${t}\nhttps://svelte.dev/e/expected_token`);
		}
		function ea(e) {
			zs(e, "illegal_await_expression", "`use:`, `transition:` and `animate:` directives, attachments and bindings do not support await expressions\nhttps://svelte.dev/e/illegal_await_expression");
		}
		function ta(e, t) {
			zs(e, "illegal_element_attribute", `\`<${t}>\` does not support non-event attributes or spread attributes\nhttps://svelte.dev/e/illegal_element_attribute`);
		}
		function na(e, t) {
			zs(e, "node_invalid_placement", `${t}. The browser will 'repair' the HTML (by moving, removing, or inserting elements) which breaks Svelte's assumptions about the structure of your components.\nhttps://svelte.dev/e/node_invalid_placement`);
		}
		function sa(e) {
			zs(e, "render_tag_invalid_spread_argument", "cannot use spread arguments in `{@render ...}` tags\nhttps://svelte.dev/e/render_tag_invalid_spread_argument");
		}
		function ra(e) {
			zs(e, "script_duplicate", "A component can have a single top-level `<script>` element and/or a single top-level `<script module>` element\nhttps://svelte.dev/e/script_duplicate");
		}
		function aa(e, t) {
			zs(e, "script_invalid_attribute_value", `If the \`${t}\` attribute is supplied, it must be a boolean attribute\nhttps://svelte.dev/e/script_invalid_attribute_value`);
		}
		function ia(e) {
			zs(e, "script_invalid_context", "If the context attribute is supplied, its value must be \"module\"\nhttps://svelte.dev/e/script_invalid_context");
		}
		function oa(e) {
			zs(e, "slot_attribute_invalid", "slot attribute must be a static value\nhttps://svelte.dev/e/slot_attribute_invalid");
		}
		function la(e) {
			zs(e, "slot_attribute_invalid_placement", "Element with a slot='...' attribute must be a child of a component or a descendant of a custom element\nhttps://svelte.dev/e/slot_attribute_invalid_placement");
		}
		function ca(e) {
			zs(e, "slot_default_duplicate", "Found default slot content alongside an explicit slot=\"default\"\nhttps://svelte.dev/e/slot_default_duplicate");
		}
		function pa(e) {
			zs(e, "slot_element_invalid_attribute", "`<slot>` can only receive attributes and (optionally) let directives\nhttps://svelte.dev/e/slot_element_invalid_attribute");
		}
		function ua(e) {
			zs(e, "slot_element_invalid_name", "slot attribute must be a static value\nhttps://svelte.dev/e/slot_element_invalid_name");
		}
		function da(e) {
			zs(e, "slot_element_invalid_name_default", "`default` is a reserved word — it cannot be used as a slot name\nhttps://svelte.dev/e/slot_element_invalid_name_default");
		}
		function ha(e) {
			zs(e, "snippet_invalid_rest_parameter", "Snippets do not support rest parameters; use an array instead\nhttps://svelte.dev/e/snippet_invalid_rest_parameter");
		}
		function ma(e) {
			zs(e, "svelte_body_illegal_attribute", "`<svelte:body>` does not support non-event attributes or spread attributes\nhttps://svelte.dev/e/svelte_body_illegal_attribute");
		}
		function fa(e) {
			zs(e, "svelte_boundary_invalid_attribute", "Valid attributes on `<svelte:boundary>` are `onerror` and `failed`\nhttps://svelte.dev/e/svelte_boundary_invalid_attribute");
		}
		function ya(e) {
			zs(e, "svelte_boundary_invalid_attribute_value", "Attribute value must be a non-string expression\nhttps://svelte.dev/e/svelte_boundary_invalid_attribute_value");
		}
		function va(e) {
			zs(e, "svelte_element_missing_this", "`<svelte:element>` must have a 'this' attribute with a value\nhttps://svelte.dev/e/svelte_element_missing_this");
		}
		function ga(e) {
			zs(e, "svelte_fragment_invalid_attribute", "`<svelte:fragment>` can only have a slot attribute and (optionally) a let: directive\nhttps://svelte.dev/e/svelte_fragment_invalid_attribute");
		}
		function ba(e) {
			zs(e, "svelte_head_illegal_attribute", "`<svelte:head>` cannot have attributes nor directives\nhttps://svelte.dev/e/svelte_head_illegal_attribute");
		}
		function _a(e) {
			zs(e, "svelte_options_deprecated_tag", "\"tag\" option is deprecated — use \"customElement\" instead\nhttps://svelte.dev/e/svelte_options_deprecated_tag");
		}
		function xa(e) {
			zs(e, "svelte_options_invalid_attribute", "`<svelte:options>` can only receive static attributes\nhttps://svelte.dev/e/svelte_options_invalid_attribute");
		}
		function wa(e, t) {
			zs(e, "svelte_options_invalid_attribute_value", `Value must be ${t}, if specified\nhttps://svelte.dev/e/svelte_options_invalid_attribute_value`);
		}
		function ka(e) {
			zs(e, "svelte_options_invalid_customelement", "\"customElement\" must be a string literal defining a valid custom element name or an object of the form { tag?: string; shadow?: \"open\" | \"none\" | `ShadowRootInit`; props?: { [key: string]: { attribute?: string; reflect?: boolean; type: .. } } }\nhttps://svelte.dev/e/svelte_options_invalid_customelement");
		}
		function Ca(e) {
			zs(e, "svelte_options_invalid_customelement_props", "\"props\" must be a statically analyzable object literal of the form \"{ [key: string]: { attribute?: string; reflect?: boolean; type?: \"String\" | \"Boolean\" | \"Number\" | \"Array\" | \"Object\" }\"\nhttps://svelte.dev/e/svelte_options_invalid_customelement_props");
		}
		function Sa(e) {
			zs(e, "svelte_options_invalid_customelement_shadow", "\"shadow\" must be either \"open\", \"none\" or `ShadowRootInit` object.\nhttps://svelte.dev/e/svelte_options_invalid_customelement_shadow");
		}
		function Pa(e) {
			zs(e, "svelte_options_invalid_tagname", "Tag name must be lowercase and hyphenated\nhttps://svelte.dev/e/svelte_options_invalid_tagname");
		}
		function Ea(e, t) {
			zs(e, "svelte_options_unknown_attribute", `\`<svelte:options>\` unknown attribute '${t}'\nhttps://svelte.dev/e/svelte_options_unknown_attribute`);
		}
		function Ta(e, t, n) {
			zs(e, "tag_invalid_placement", `{@${t} ...} tag cannot be ${n}\nhttps://svelte.dev/e/tag_invalid_placement`);
		}
		function Aa(e) {
			zs(e, "textarea_invalid_content", "A `<textarea>` can have either a value attribute or (equivalently) child content, but not both\nhttps://svelte.dev/e/textarea_invalid_content");
		}
		function $a(e) {
			zs(e, "title_illegal_attribute", "`<title>` cannot have attributes nor directives\nhttps://svelte.dev/e/title_illegal_attribute");
		}
		function Ra(e) {
			zs(e, "title_invalid_content", "`<title>` can only contain text and {tags}\nhttps://svelte.dev/e/title_invalid_content");
		}
		function Ia(e, t, n) {
			zs(e, "transition_conflict", `Cannot use \`${t}:\` alongside existing \`${n}:\` directive\nhttps://svelte.dev/e/transition_conflict`);
		}
		function Ma(e, t) {
			zs(e, "transition_duplicate", `Cannot use multiple \`${t}:\` directives on a single element\nhttps://svelte.dev/e/transition_duplicate`);
		}
		function qa(e) {
			zs(e, "unexpected_eof", "Unexpected end of input\nhttps://svelte.dev/e/unexpected_eof");
		}
		function La(e) {
			return e < 0 ? Infinity : e;
		}
		function Oa(e, t, n) {
			let s;
			return s = "`" === n ? e : e.slice(0, La(e.indexOf("\n", t))), Da(s, t, n);
		}
		function Na(e, t) {
			return Da(e, t, "/");
		}
		function Da(e, t, n) {
			let s = t;
			for (;;) {
				const t = e.indexOf(n, s);
				if (-1 === t) return Infinity;
				if (ja(e, t - 1) % 2 == 0) return t;
				s = t + 1;
			}
		}
		function ja(e, t) {
			let n = t, s = 0;
			for (; "\\" === e[n];) s++, n--;
			return s;
		}
		const Ba = {
			"{": "}",
			"(": ")",
			"[": "]"
		};
		function Fa(e, t, n = Ba) {
			const s = Object.values(n), r = [];
			let a = t;
			for (; a < e.template.length;) {
				let t = e.template[a++];
				if ("'" !== t && "\"" !== t && "`" !== t) {
					if (t in n) r.push(t);
					else if (s.includes(t)) {
						const e = n[r.pop()];
						if (t !== e && Zr(a - 1, e), 0 === r.length) return a;
					}
				} else a = Va(e, a, t);
			}
			qa(e.template.length);
		}
		function Va(e, t, n) {
			let s = !1, r = t;
			for (; r < e.template.length;) {
				const t = e.template[r++];
				if (s) s = !1;
				else {
					if (t === n) return r;
					"\\" === t && (s = !0), "`" === n && "$" === t && "{" === e.template[r] && (r = Fa(e, r));
				}
			}
			zs(t, "unterminated_string_constant", "Unterminated string constant\nhttps://svelte.dev/e/unterminated_string_constant");
		}
		function Ha(e, t) {
			const n = function(e, t, n) {
				const s = Ba[n];
				let r = 1, a = t;
				for (; r > 0 && a < e.length;) {
					const t = e[a];
					switch (t) {
						case "'":
						case "\"":
						case "`":
							a = Oa(e, a + 1, t) + 1;
							continue;
						case "/": {
							const t = e[a + 1];
							if (!t) continue;
							if ("/" === t) {
								a = La(e.indexOf("\n", a + 1)) + 1;
								continue;
							}
							if ("*" === t) {
								a = La(e.indexOf("*/", a + 1)) + 2;
								continue;
							}
							a = Na(e, a + 1) + 1;
							continue;
						}
						default: {
							const t = e[a];
							if (t === n ? r++ : t === s && r--, 0 === r) return a;
							a++;
						}
					}
				}
			}(e.template, e.index, t ?? "{");
			if (n) {
				const t = e.index;
				return e.index = n, {
					type: "Identifier",
					start: t,
					end: n,
					name: ""
				};
			}
		}
		function Ua(e, t, n) {
			try {
				let t = e.root.comments.length;
				const n = Vs(e.template, e.root.comments, e.ts, e.index);
				let r = 0, a = e.root.comments.length;
				for (; a-- > t;) {
					const t = e.root.comments[a];
					if (t.end < n.start) {
						e.index = t.end;
						break;
					}
				}
				for (let t = e.index; t < n.start; t += 1) "(" === e.template[t] && (r += 1);
				let i = n.end;
				const o = e.root.comments.at(-1);
				for (o && o.end > i && (i = o.end); r > 0;) {
					const t = e.template[i];
					")" === t ? r -= 1 : s.test(t) || Zr(i, ")"), i += 1;
				}
				return e.index = i, n;
			} catch (s) {
				if (e.loose && !n) {
					const n = Ha(e, t);
					if (n) return n;
				}
				e.acorn_error(s);
			}
		}
		function za(e) {
			return e.replace(/(`|\${|\\)/g, "\\$1");
		}
		function Wa(e = []) {
			return {
				type: "ArrayExpression",
				elements: e
			};
		}
		function Ga(e) {
			return {
				type: "ArrayPattern",
				elements: e
			};
		}
		function Ka(e, t) {
			return {
				type: "AssignmentPattern",
				left: e,
				right: t
			};
		}
		function Xa(e, t, n = !1) {
			return {
				type: "ArrowFunctionExpression",
				params: e,
				body: t,
				expression: "BlockStatement" !== t.type,
				generator: !1,
				async: n
			};
		}
		function Qa(e, t, n) {
			return {
				type: "AssignmentExpression",
				operator: e,
				left: t,
				right: n
			};
		}
		function Ya(e) {
			return {
				type: "AwaitExpression",
				argument: e
			};
		}
		function Ja(e, t, n) {
			return {
				type: "BinaryExpression",
				operator: e,
				left: t,
				right: n
			};
		}
		function Za(e) {
			return {
				type: "BlockStatement",
				body: e
			};
		}
		function ei(e, ...t) {
			"string" == typeof e && (e = ui(e));
			let n = (t = t.slice()).length, s = !0;
			for (; n--;) t[n] ? s = !1 : s ? t.pop() : t[n] = si;
			return {
				type: "CallExpression",
				callee: e,
				arguments: t,
				optional: !1
			};
		}
		function ti(e, ...t) {
			const n = ei(e, ...t);
			return n.optional = !0, {
				type: "ChainExpression",
				expression: n
			};
		}
		function ni(e, t) {
			return {
				type: "UnaryExpression",
				argument: t,
				operator: e,
				prefix: !0
			};
		}
		const si = ni("void", mi(0));
		function ri(e, t, n) {
			return {
				type: "LogicalExpression",
				operator: e,
				left: t,
				right: n
			};
		}
		function ai(e, t) {
			return {
				type: "VariableDeclaration",
				kind: e,
				declarations: t
			};
		}
		function ii(e, t) {
			return "string" == typeof e && (e = ui(e)), {
				type: "VariableDeclarator",
				id: e,
				init: t
			};
		}
		const oi = { type: "EmptyStatement" };
		function li(e) {
			return {
				type: "ExportDefaultDeclaration",
				declaration: e
			};
		}
		function ci(e, t, n, s = !1) {
			return {
				type: "FunctionDeclaration",
				id: e,
				params: t,
				body: n,
				generator: !1,
				async: s
			};
		}
		function pi(e, t) {
			return bi("get", Gi(e), Vi(null, [], Za(t)));
		}
		function ui(e, t) {
			const n = {
				type: "Identifier",
				name: e
			};
			return t && (n.loc = t), n;
		}
		function di(e) {
			return {
				type: "PrivateIdentifier",
				name: e
			};
		}
		function hi(e, t) {
			return bi("init", Gi(e), t);
		}
		function mi(e) {
			return {
				type: "Literal",
				value: e
			};
		}
		function fi(e, t, n = !1, s = !1) {
			return "string" == typeof t && (t = ui(t)), {
				type: "MemberExpression",
				object: e,
				property: t,
				computed: n,
				optional: s
			};
		}
		function yi(e) {
			const t = e.split(".");
			let n = ui(t[0]);
			for (let e = 1; e < t.length; e += 1) n = fi(n, ui(t[e]));
			return n;
		}
		function vi(e) {
			return {
				type: "ObjectExpression",
				properties: e
			};
		}
		function gi(e) {
			return {
				type: "ObjectPattern",
				properties: e
			};
		}
		function bi(e, t, n, s = !1) {
			return {
				type: "Property",
				kind: e,
				key: t,
				value: n,
				method: !1,
				shorthand: !1,
				computed: s
			};
		}
		function _i(e, t, n = !1, s = !1) {
			return {
				type: "PropertyDefinition",
				decorators: [],
				key: e,
				value: t,
				computed: n,
				static: s
			};
		}
		function xi(e, t = !1) {
			return {
				type: "TemplateElement",
				value: {
					raw: za(e),
					cooked: e
				},
				tail: t
			};
		}
		function wi(e) {
			return {
				type: "RestElement",
				argument: e
			};
		}
		function ki(e) {
			return {
				type: "SequenceExpression",
				expressions: e
			};
		}
		function Ci(e, t) {
			return bi("set", Gi(e), Vi(null, [ui("$$value")], Za(t)));
		}
		function Si(e) {
			return {
				type: "SpreadElement",
				argument: e
			};
		}
		function Pi(e) {
			return {
				type: "ExpressionStatement",
				expression: e
			};
		}
		function Ei(e, t) {
			return {
				type: "TemplateLiteral",
				quasis: e,
				expressions: t
			};
		}
		function Ti(e, t = !1) {
			return Ai(Xa([], e, t));
		}
		function Ai(e) {
			return e.async && "AwaitExpression" === e.body.type && !ho(e.body.argument) ? Ai(Xa(e.params, e.body.argument)) : !1 === e.async && "CallExpression" === e.body.type && "Identifier" === e.body.callee.type && e.params.length === e.body.arguments.length && e.params.every(((t, n) => {
				const s = e.body.arguments[n];
				return "Identifier" === t.type && "Identifier" === s.type && t.name === s.name;
			})) ? e.body.callee : e;
		}
		function $i(e, ...t) {
			return "string" == typeof e && (e = ui(e)), {
				callee: e,
				arguments: t,
				type: "NewExpression"
			};
		}
		function Ri(e, t, n = !1) {
			return {
				type: "UpdateExpression",
				operator: e,
				argument: t,
				prefix: n
			};
		}
		function Ii(e, t) {
			return {
				type: "DoWhileStatement",
				test: e,
				body: t
			};
		}
		const Mi = mi(!0), qi = mi(!1), Li = mi(null), Oi = { type: "DebuggerStatement" }, Ni = { type: "ThisExpression" };
		function Di(e, t) {
			return ai("let", [ii(e, t)]);
		}
		function ji(e, t) {
			return ai("const", [ii(e, t)]);
		}
		function Bi(e, t) {
			return ai("var", [ii(e, t)]);
		}
		function Fi(e, t, n, s, r = !1, a = !1) {
			return {
				type: "MethodDefinition",
				decorators: [],
				key: t,
				kind: e,
				value: Vi(null, n, Za(s)),
				computed: r,
				static: a
			};
		}
		function Vi(e, t, n, s = !1) {
			return {
				type: "FunctionExpression",
				id: e,
				params: t,
				body: n,
				generator: !1,
				async: s
			};
		}
		function Hi(e, t, n) {
			return {
				type: "IfStatement",
				test: e,
				consequent: t,
				alternate: n
			};
		}
		function Ui(e, t) {
			return {
				type: "ImportDeclaration",
				attributes: [],
				source: mi(t),
				specifiers: [(n = e, {
					type: "ImportNamespaceSpecifier",
					local: ui(n)
				})]
			};
			var n;
		}
		function zi(e, t) {
			return {
				type: "ImportDeclaration",
				attributes: [],
				source: mi(t),
				specifiers: e.map(((e) => ({
					type: "ImportSpecifier",
					imported: ui(e[0]),
					local: ui(e[1])
				})))
			};
		}
		function Wi(e = null) {
			return {
				type: "ReturnStatement",
				argument: e
			};
		}
		function Gi(e) {
			return m.test(e) ? ui(e) : mi(e);
		}
		function Ki(e) {
			for (; "MemberExpression" === e.type;) e = e.object;
			return "Identifier" !== e.type ? null : e;
		}
		function Xi(e) {
			return Array.isArray(e.value) && 1 === e.value.length && "Text" === e.value[0].type;
		}
		function Qi(e) {
			return !0 !== e.value && !Array.isArray(e.value) || Array.isArray(e.value) && 1 === e.value.length && "ExpressionTag" === e.value[0].type;
		}
		function Yi(e) {
			return Array.isArray(e.value) ? e.value[0].expression : e.value.expression;
		}
		function Ji(e) {
			return Array.isArray(e) ? e : "boolean" == typeof e ? [] : [e];
		}
		function Zi(e) {
			return Qi(e) && e.name.startsWith("on");
		}
		function eo(e, t = []) {
			switch (e.type) {
				case "Identifier":
				case "MemberExpression":
					t.push(e);
					break;
				case "ObjectPattern":
					for (const n of e.properties) "RestElement" === n.type ? eo(n.argument, t) : eo(n.value, t);
					break;
				case "ArrayPattern":
					for (const n of e.elements) n && eo(n, t);
					break;
				case "RestElement":
					eo(e.argument, t);
					break;
				case "AssignmentPattern": eo(e.left, t);
			}
			return t;
		}
		function to(e) {
			return eo(e, []).filter(((e) => "Identifier" === e.type));
		}
		function no(e) {
			let n = [], s = [];
			return t(e, {}, {
				Identifier(e, { path: t }) {
					const r = t.at(-1);
					("MemberExpression" !== r?.type || r.property !== e || r.computed) && n.push(e), "MemberExpression" === r?.type && r.computed && r.property === e ? s.push(`[${e.name}]`) : s.push(e.name);
				},
				Literal(e, { path: t }) {
					const n = "string" == typeof e.value ? `"${e.value}"` : String(e.value), r = t.at(-1);
					"MemberExpression" === r?.type && r.computed && r.property === e ? s.push(`[${n}]`) : s.push(n);
				},
				ThisExpression(e, { next: t }) {
					s.push("this"), t();
				}
			}), [s.join("."), n];
		}
		function so(e, t = []) {
			switch (e.type) {
				case "Identifier":
					t.push(e);
					break;
				case "ObjectExpression":
					for (const n of e.properties) "Property" === n.type ? so(n.value, t) : so(n.argument, t);
					break;
				case "ArrayExpression": for (const n of e.elements) n && so(n, t);
			}
			return t;
		}
		function ro(e, t) {
			const n = [], s = [];
			return ao(s, n, e, t, t, !1), {
				inserts: n,
				paths: s
			};
		}
		function ao(e, t, n, s, r, a) {
			switch (n.type) {
				case "Identifier":
				case "MemberExpression":
					e.push({
						node: n,
						is_rest: !1,
						has_default_value: a,
						expression: s,
						update_expression: r
					});
					break;
				case "ObjectPattern":
					for (const r of n.properties) if ("RestElement" === r.type) {
						const i = [];
						for (const e of n.properties) "Property" === e.type && "PrivateIdentifier" !== e.key.type && ("Identifier" !== e.key.type || e.computed ? "Literal" === e.key.type ? i.push(mi(String(e.key.value))) : i.push(ei("String", e.key)) : i.push(mi(e.key.name)));
						const o = ei("$.exclude_from_object", s, Wa(i));
						"Identifier" === r.argument.type ? e.push({
							node: r.argument,
							is_rest: !0,
							has_default_value: a,
							expression: o,
							update_expression: o
						}) : ao(e, t, r.argument, o, o, a);
					} else {
						const n = fi(s, r.key, r.computed || "Identifier" !== r.key.type);
						ao(e, t, r.value, n, n, a);
					}
					break;
				case "ArrayPattern": {
					const r = ui("#"), i = ei("$.to_array", s, "RestElement" === n.elements.at(-1)?.type ? void 0 : mi(n.elements.length));
					t.push({
						id: r,
						value: i
					});
					for (let s = 0; s < n.elements.length; s += 1) {
						const i = n.elements[s];
						if (i) if ("RestElement" === i.type) {
							const n = ei(fi(r, "slice"), mi(s));
							"Identifier" === i.argument.type ? e.push({
								node: i.argument,
								is_rest: !0,
								has_default_value: a,
								expression: n,
								update_expression: n
							}) : ao(e, t, i.argument, n, n, a);
						} else {
							const n = fi(r, mi(s), !0);
							ao(e, t, i, n, n, a);
						}
					}
					break;
				}
				case "AssignmentPattern": {
					const a = po(s, n.right);
					"Identifier" === n.left.type ? e.push({
						node: n.left,
						is_rest: !1,
						has_default_value: !0,
						expression: a,
						update_expression: r
					}) : ao(e, t, n.left, a, r, !0);
					break;
				}
			}
			return e;
		}
		function io(e, t) {
			let n = e.at(t);
			return "TSNonNullExpression" === n.type || "TSAsExpression" === n.type ? e.at(t < 0 ? t - 1 : t + 1) : n;
		}
		function oo(e) {
			return "Literal" === e.type || "Identifier" === e.type || "ArrowFunctionExpression" === e.type || "FunctionExpression" === e.type || ("ConditionalExpression" === e.type ? oo(e.test) && oo(e.consequent) && oo(e.alternate) : ("BinaryExpression" === e.type || "LogicalExpression" === e.type) && "PrivateIdentifier" !== e.left.type && oo(e.left) && oo(e.right));
		}
		function lo(e) {
			return "ChainExpression" === e.type ? e.expression : e;
		}
		function co(e) {
			switch (e.type) {
				case "AwaitExpression": return !0;
				case "ArrayPattern": return e.elements.some(((e) => e && co(e)));
				case "ArrayExpression": return e.elements.some(((e) => !!e && ("SpreadElement" === e.type ? co(e.argument) : co(e))));
				case "AssignmentPattern":
				case "AssignmentExpression":
				case "BinaryExpression":
				case "LogicalExpression": return "PrivateIdentifier" !== e.left.type && co(e.left) || co(e.right);
				case "CallExpression":
				case "NewExpression": return "Super" !== e.callee.type && co(e.callee) || e.arguments.some(((e) => "SpreadElement" === e.type ? co(e.argument) : co(e)));
				case "ChainExpression": return co(e.expression);
				case "ConditionalExpression": return co(e.test) || co(e.alternate) || co(e.consequent);
				case "ImportExpression": return co(e.source);
				case "MemberExpression": return "Super" !== e.object.type && co(e.object) || "PrivateIdentifier" !== e.property.type && co(e.property);
				case "ObjectPattern":
				case "ObjectExpression": return e.properties.some(((e) => "SpreadElement" === e.type ? co(e.argument) : "Property" === e.type ? "PrivateIdentifier" !== e.key.type && co(e.key) || co(e.value) : void 0));
				case "RestElement":
				case "UnaryExpression":
				case "UpdateExpression": return co(e.argument);
				case "SequenceExpression":
				case "TemplateLiteral": return e.expressions.some(((e) => co(e)));
				case "TaggedTemplateExpression": return co(e.tag) || co(e.quasi);
				case "YieldExpression": return !!e.argument && co(e.argument);
				default: return !1;
			}
		}
		function po(e, t) {
			return oo(t) ? ei("$.fallback", e, t) : "AwaitExpression" === t.type && oo(t.argument) ? Ya(ei("$.fallback", e, t.argument)) : co(t) ? Ya(ei("$.fallback", e, Ti(t, !0), Mi)) : ei("$.fallback", e, Ti(t), Mi);
		}
		function uo(e, t, n) {
			return "=" === e ? n : [
				"||=",
				"&&=",
				"??="
			].includes(e) ? ri(e.slice(0, -1), t, n) : Ja(e.slice(0, -1), t, n);
		}
		function ho(e) {
			let n = !1;
			return t(e, null, {
				AwaitExpression(e, t) {
					n = !0, t.stop();
				},
				FunctionDeclaration() {},
				FunctionExpression() {},
				ArrowFunctionExpression() {}
			}), n;
		}
		function mo(e) {
			return ei(Ya(ei("$.save", e)));
		}
		const fo = /<\/script\s*>/, yo = /^<\/script\s*>/, vo = [
			"server",
			"client",
			"worker",
			"test",
			"default"
		], go = [
			"context",
			"generics",
			"lang",
			"module"
		];
		const bo = /^[~^$*|]?=/, _o = /[\s\]]/, xo = /^[a-zA-Z]+/, wo = /^(\+|~|>|\|\|)/, ko = /^\d+(\.\d+)?%/, Co = /^(even|odd|\+?(\d+|\d*n(\s*[+-]\s*\d+)?)|-\d*n(\s*\+\s*\d+))((?=\s*[,)])|\s+of\s+)/, So = /[\s:]/, Po = /-?\d/, Eo = /[a-zA-Z0-9_-]/, To = /^\\[0-9a-fA-F]{1,6}(\r\n|\s)?/, Ao = /\*\//, $o = /-->/;
		function Ro(e, t) {
			const n = [];
			for (; Vo(e), !t(e);) e.match("@") ? n.push(Io(e)) : n.push(Mo(e));
			return n;
		}
		function Io(e) {
			const t = e.index;
			e.eat("@", !0);
			const n = Fo(e), s = jo(e);
			let r = null;
			return e.match("{") ? r = No(e) : e.eat(";", !0), {
				type: "Atrule",
				start: t,
				end: e.index,
				name: n,
				prelude: s,
				block: r
			};
		}
		function Mo(e) {
			const t = e.index;
			return {
				type: "Rule",
				prelude: qo(e),
				block: No(e),
				start: t,
				end: e.index,
				metadata: {
					parent_rule: null,
					has_local_selectors: !1,
					has_global_selectors: !1,
					is_global_block: !1
				}
			};
		}
		function qo(e, t = !1) {
			const n = [];
			Vo(e);
			const s = e.index;
			for (; e.index < e.template.length;) {
				n.push(Lo(e, t));
				const r = e.index;
				if (Vo(e), t ? e.match(")") : e.match("{")) return {
					type: "SelectorList",
					start: s,
					end: r,
					children: n
				};
				e.eat(",", !0), Vo(e);
			}
			qa(e.template.length);
		}
		function Lo(e, t = !1) {
			const n = e.index, s = [];
			function r(e, t) {
				return {
					type: "RelativeSelector",
					combinator: e,
					selectors: [],
					start: t,
					end: -1,
					metadata: {
						is_global: !1,
						is_global_like: !1,
						scoped: !1
					}
				};
			}
			let a = r(null, e.index);
			for (; e.index < e.template.length;) {
				let i = e.index;
				if (e.eat("&")) a.selectors.push({
					type: "NestingSelector",
					name: "&",
					start: i,
					end: e.index
				});
				else if (e.eat("*")) {
					let t = "*";
					e.eat("|") && (t = Fo(e)), a.selectors.push({
						type: "TypeSelector",
						name: t,
						start: i,
						end: e.index
					});
				} else if (e.eat("#")) a.selectors.push({
					type: "IdSelector",
					name: Fo(e),
					start: i,
					end: e.index
				});
				else if (e.eat(".")) a.selectors.push({
					type: "ClassSelector",
					name: Fo(e),
					start: i,
					end: e.index
				});
				else if (e.eat("::")) a.selectors.push({
					type: "PseudoElementSelector",
					name: Fo(e),
					start: i,
					end: e.index
				}), e.eat("(") && (qo(e, !0), e.eat(")", !0));
				else if (e.eat(":")) {
					const t = Fo(e);
					let n = null;
					e.eat("(") && (n = qo(e, !0), e.eat(")", !0)), a.selectors.push({
						type: "PseudoClassSelector",
						name: t,
						args: n,
						start: i,
						end: e.index
					});
				} else if (e.eat("[")) {
					e.allow_whitespace();
					const t = Fo(e);
					e.allow_whitespace();
					let n = null;
					const s = e.read(bo);
					s && (e.allow_whitespace(), n = Bo(e)), e.allow_whitespace();
					const r = e.read(xo);
					e.allow_whitespace(), e.eat("]", !0), a.selectors.push({
						type: "AttributeSelector",
						start: i,
						end: e.index,
						name: t,
						matcher: s,
						value: n,
						flags: r
					});
				} else if (t && e.match_regex(Co)) a.selectors.push({
					type: "Nth",
					value: e.read(Co),
					start: i,
					end: e.index
				});
				else if (e.match_regex(ko)) a.selectors.push({
					type: "Percentage",
					value: e.read(ko),
					start: i,
					end: e.index
				});
				else if (!e.match_regex(wo)) {
					let t = Fo(e);
					e.eat("|") && (t = Fo(e)), a.selectors.push({
						type: "TypeSelector",
						name: t,
						start: i,
						end: e.index
					});
				}
				const o = e.index;
				if (Vo(e), e.match(",") || (t ? e.match(")") : e.match("{"))) return e.index = o, a.end = o, s.push(a), {
					type: "ComplexSelector",
					start: n,
					end: o,
					children: s,
					metadata: {
						rule: null,
						is_global: !1,
						used: !1
					}
				};
				e.index = o;
				const l = Oo(e);
				l && (a.selectors.length > 0 && (a.end = o, s.push(a)), a = r(l, l.start), e.allow_whitespace(), (e.match(",") || (t ? e.match(")") : e.match("{"))) && Pr(e.index));
			}
			qa(e.template.length);
		}
		function Oo(e) {
			const t = e.index;
			e.allow_whitespace();
			const n = e.index, s = e.read(wo);
			if (s) {
				const t = e.index;
				return e.allow_whitespace(), {
					type: "Combinator",
					name: s,
					start: n,
					end: t
				};
			}
			return e.index !== t ? {
				type: "Combinator",
				name: " ",
				start: t,
				end: e.index
			} : null;
		}
		function No(e) {
			const t = e.index;
			e.eat("{", !0);
			const n = [];
			for (; e.index < e.template.length && (Vo(e), !e.match("}"));) n.push(Do(e));
			return e.eat("}", !0), {
				type: "Block",
				start: t,
				end: e.index,
				children: n
			};
		}
		function Do(e) {
			if (e.match("@")) return Io(e);
			const t = e.index;
			jo(e);
			const n = e.template[e.index];
			return e.index = t, "{" === n ? Mo(e) : function(e) {
				const t = e.index, n = e.read_until(So);
				e.allow_whitespace(), e.eat(":");
				let s = e.index;
				e.allow_whitespace();
				const r = jo(e);
				r || n.startsWith("--") || zs({
					start: t,
					end: s
				}, "css_empty_declaration", "Declaration cannot be empty\nhttps://svelte.dev/e/css_empty_declaration");
				const a = e.index;
				e.match("}") || e.eat(";", !0);
				return {
					type: "Declaration",
					start: t,
					end: a,
					property: n,
					value: r
				};
			}(e);
		}
		function jo(e) {
			let t = "", n = !1, s = !1, r = null;
			for (; e.index < e.template.length;) {
				const a = e.template[e.index];
				if (n) t += "\\" + a, n = !1, e.index++;
				else if ("\\" !== a) {
					if (a === r) r = null;
					else if (")" === a) s = !1;
					else if (null !== r || "\"" !== a && "'" !== a) {
						if ("(" === a && "url" === t.slice(-3)) s = !0;
						else if (!(";" !== a && "{" !== a && "}" !== a || s || r)) return t.trim();
					} else r = a;
					t += a, e.index++;
				} else n = !0, e.index++;
			}
			qa(e.template.length);
		}
		function Bo(e) {
			let t = "", n = !1;
			const s = e.eat("\"") ? "\"" : e.eat("'") ? "'" : null;
			for (; e.index < e.template.length;) {
				const r = e.template[e.index];
				if (n) t += "\\" + r, n = !1;
				else if ("\\" === r) n = !0;
				else {
					if (s ? r === s : _o.test(r)) return s && e.eat(s, !0), t.trim();
					t += r;
				}
				e.index++;
			}
			qa(e.template.length);
		}
		function Fo(e) {
			const t = e.index;
			let n = "";
			for (e.match_regex(Po) && vr(t); e.index < e.template.length;) {
				const t = e.template[e.index];
				if ("\\" === t) {
					const t = e.match_regex(To);
					t ? (n += String.fromCodePoint(parseInt(t.slice(1), 16)), e.index += t.length) : (n += "\\" + e.template[e.index + 1], e.index += 2);
				} else {
					if (!(t.codePointAt(0) >= 160 || Eo.test(t))) break;
					n += t, e.index++;
				}
			}
			return "" === n && vr(t), n;
		}
		function Vo(e) {
			for (e.allow_whitespace(); e.match("/*") || e.match("<!--");) e.eat("/*") && (e.read_until(Ao), e.eat("*/", !0)), e.eat("<!--") && (e.read_until($o), e.eat("-->", !0)), e.allow_whitespace();
		}
		var Ho = {
			"CounterClockwiseContourIntegral;": 8755,
			"ClockwiseContourIntegral;": 8754,
			"DoubleLongLeftRightArrow;": 10234,
			"NotNestedGreaterGreater;": 10914,
			"DiacriticalDoubleAcute;": 733,
			"NotSquareSupersetEqual;": 8931,
			"CloseCurlyDoubleQuote;": 8221,
			"DoubleContourIntegral;": 8751,
			"FilledVerySmallSquare;": 9642,
			"NegativeVeryThinSpace;": 8203,
			"NotPrecedesSlantEqual;": 8928,
			"NotRightTriangleEqual;": 8941,
			"NotSucceedsSlantEqual;": 8929,
			"CapitalDifferentialD;": 8517,
			"DoubleLeftRightArrow;": 8660,
			"DoubleLongRightArrow;": 10233,
			"EmptyVerySmallSquare;": 9643,
			"NestedGreaterGreater;": 8811,
			"NotDoubleVerticalBar;": 8742,
			"NotGreaterSlantEqual;": 10878,
			"NotLeftTriangleEqual;": 8940,
			"NotSquareSubsetEqual;": 8930,
			"OpenCurlyDoubleQuote;": 8220,
			"ReverseUpEquilibrium;": 10607,
			"DoubleLongLeftArrow;": 10232,
			"DownLeftRightVector;": 10576,
			"LeftArrowRightArrow;": 8646,
			"NegativeMediumSpace;": 8203,
			"NotGreaterFullEqual;": 8807,
			"NotRightTriangleBar;": 10704,
			"RightArrowLeftArrow;": 8644,
			"SquareSupersetEqual;": 8850,
			"leftrightsquigarrow;": 8621,
			"DownRightTeeVector;": 10591,
			"DownRightVectorBar;": 10583,
			"LongLeftRightArrow;": 10231,
			"Longleftrightarrow;": 10234,
			"NegativeThickSpace;": 8203,
			"NotLeftTriangleBar;": 10703,
			"PrecedesSlantEqual;": 8828,
			"ReverseEquilibrium;": 8651,
			"RightDoubleBracket;": 10215,
			"RightDownTeeVector;": 10589,
			"RightDownVectorBar;": 10581,
			"RightTriangleEqual;": 8885,
			"SquareIntersection;": 8851,
			"SucceedsSlantEqual;": 8829,
			"blacktriangleright;": 9656,
			"longleftrightarrow;": 10231,
			"DoubleUpDownArrow;": 8661,
			"DoubleVerticalBar;": 8741,
			"DownLeftTeeVector;": 10590,
			"DownLeftVectorBar;": 10582,
			"FilledSmallSquare;": 9724,
			"GreaterSlantEqual;": 10878,
			"LeftDoubleBracket;": 10214,
			"LeftDownTeeVector;": 10593,
			"LeftDownVectorBar;": 10585,
			"LeftTriangleEqual;": 8884,
			"NegativeThinSpace;": 8203,
			"NotGreaterGreater;": 8811,
			"NotLessSlantEqual;": 10877,
			"NotNestedLessLess;": 10913,
			"NotReverseElement;": 8716,
			"NotSquareSuperset;": 8848,
			"NotTildeFullEqual;": 8775,
			"RightAngleBracket;": 10217,
			"RightUpDownVector;": 10575,
			"SquareSubsetEqual;": 8849,
			"VerticalSeparator;": 10072,
			"blacktriangledown;": 9662,
			"blacktriangleleft;": 9666,
			"leftrightharpoons;": 8651,
			"rightleftharpoons;": 8652,
			"twoheadrightarrow;": 8608,
			"DiacriticalAcute;": 180,
			"DiacriticalGrave;": 96,
			"DiacriticalTilde;": 732,
			"DoubleRightArrow;": 8658,
			"DownArrowUpArrow;": 8693,
			"EmptySmallSquare;": 9723,
			"GreaterEqualLess;": 8923,
			"GreaterFullEqual;": 8807,
			"LeftAngleBracket;": 10216,
			"LeftUpDownVector;": 10577,
			"LessEqualGreater;": 8922,
			"NonBreakingSpace;": 160,
			"NotPrecedesEqual;": 10927,
			"NotRightTriangle;": 8939,
			"NotSucceedsEqual;": 10928,
			"NotSucceedsTilde;": 8831,
			"NotSupersetEqual;": 8841,
			"RightTriangleBar;": 10704,
			"RightUpTeeVector;": 10588,
			"RightUpVectorBar;": 10580,
			"UnderParenthesis;": 9181,
			"UpArrowDownArrow;": 8645,
			"circlearrowright;": 8635,
			"downharpoonright;": 8642,
			"ntrianglerighteq;": 8941,
			"rightharpoondown;": 8641,
			"rightrightarrows;": 8649,
			"twoheadleftarrow;": 8606,
			"vartriangleright;": 8883,
			"CloseCurlyQuote;": 8217,
			"ContourIntegral;": 8750,
			"DoubleDownArrow;": 8659,
			"DoubleLeftArrow;": 8656,
			"DownRightVector;": 8641,
			"LeftRightVector;": 10574,
			"LeftTriangleBar;": 10703,
			"LeftUpTeeVector;": 10592,
			"LeftUpVectorBar;": 10584,
			"LowerRightArrow;": 8600,
			"NotGreaterEqual;": 8817,
			"NotGreaterTilde;": 8821,
			"NotHumpDownHump;": 8782,
			"NotLeftTriangle;": 8938,
			"NotSquareSubset;": 8847,
			"OverParenthesis;": 9180,
			"RightDownVector;": 8642,
			"ShortRightArrow;": 8594,
			"UpperRightArrow;": 8599,
			"bigtriangledown;": 9661,
			"circlearrowleft;": 8634,
			"curvearrowright;": 8631,
			"downharpoonleft;": 8643,
			"leftharpoondown;": 8637,
			"leftrightarrows;": 8646,
			"nLeftrightarrow;": 8654,
			"nleftrightarrow;": 8622,
			"ntrianglelefteq;": 8940,
			"rightleftarrows;": 8644,
			"rightsquigarrow;": 8605,
			"rightthreetimes;": 8908,
			"straightepsilon;": 1013,
			"trianglerighteq;": 8885,
			"vartriangleleft;": 8882,
			"DiacriticalDot;": 729,
			"DoubleRightTee;": 8872,
			"DownLeftVector;": 8637,
			"GreaterGreater;": 10914,
			"HorizontalLine;": 9472,
			"InvisibleComma;": 8291,
			"InvisibleTimes;": 8290,
			"LeftDownVector;": 8643,
			"LeftRightArrow;": 8596,
			"Leftrightarrow;": 8660,
			"LessSlantEqual;": 10877,
			"LongRightArrow;": 10230,
			"Longrightarrow;": 10233,
			"LowerLeftArrow;": 8601,
			"NestedLessLess;": 8810,
			"NotGreaterLess;": 8825,
			"NotLessGreater;": 8824,
			"NotSubsetEqual;": 8840,
			"NotVerticalBar;": 8740,
			"OpenCurlyQuote;": 8216,
			"ReverseElement;": 8715,
			"RightTeeVector;": 10587,
			"RightVectorBar;": 10579,
			"ShortDownArrow;": 8595,
			"ShortLeftArrow;": 8592,
			"SquareSuperset;": 8848,
			"TildeFullEqual;": 8773,
			"UpperLeftArrow;": 8598,
			"ZeroWidthSpace;": 8203,
			"curvearrowleft;": 8630,
			"doublebarwedge;": 8966,
			"downdownarrows;": 8650,
			"hookrightarrow;": 8618,
			"leftleftarrows;": 8647,
			"leftrightarrow;": 8596,
			"leftthreetimes;": 8907,
			"longrightarrow;": 10230,
			"looparrowright;": 8620,
			"nshortparallel;": 8742,
			"ntriangleright;": 8939,
			"rightarrowtail;": 8611,
			"rightharpoonup;": 8640,
			"trianglelefteq;": 8884,
			"upharpoonright;": 8638,
			"ApplyFunction;": 8289,
			"DifferentialD;": 8518,
			"DoubleLeftTee;": 10980,
			"DoubleUpArrow;": 8657,
			"LeftTeeVector;": 10586,
			"LeftVectorBar;": 10578,
			"LessFullEqual;": 8806,
			"LongLeftArrow;": 10229,
			"Longleftarrow;": 10232,
			"NotEqualTilde;": 8770,
			"NotTildeEqual;": 8772,
			"NotTildeTilde;": 8777,
			"Poincareplane;": 8460,
			"PrecedesEqual;": 10927,
			"PrecedesTilde;": 8830,
			"RightArrowBar;": 8677,
			"RightTeeArrow;": 8614,
			"RightTriangle;": 8883,
			"RightUpVector;": 8638,
			"SucceedsEqual;": 10928,
			"SucceedsTilde;": 8831,
			"SupersetEqual;": 8839,
			"UpEquilibrium;": 10606,
			"VerticalTilde;": 8768,
			"VeryThinSpace;": 8202,
			"bigtriangleup;": 9651,
			"blacktriangle;": 9652,
			"divideontimes;": 8903,
			"fallingdotseq;": 8786,
			"hookleftarrow;": 8617,
			"leftarrowtail;": 8610,
			"leftharpoonup;": 8636,
			"longleftarrow;": 10229,
			"looparrowleft;": 8619,
			"measuredangle;": 8737,
			"ntriangleleft;": 8938,
			"shortparallel;": 8741,
			"smallsetminus;": 8726,
			"triangleright;": 9657,
			"upharpoonleft;": 8639,
			"varsubsetneqq;": 10955,
			"varsupsetneqq;": 10956,
			"DownArrowBar;": 10515,
			"DownTeeArrow;": 8615,
			"ExponentialE;": 8519,
			"GreaterEqual;": 8805,
			"GreaterTilde;": 8819,
			"HilbertSpace;": 8459,
			"HumpDownHump;": 8782,
			"Intersection;": 8898,
			"LeftArrowBar;": 8676,
			"LeftTeeArrow;": 8612,
			"LeftTriangle;": 8882,
			"LeftUpVector;": 8639,
			"NotCongruent;": 8802,
			"NotHumpEqual;": 8783,
			"NotLessEqual;": 8816,
			"NotLessTilde;": 8820,
			"Proportional;": 8733,
			"RightCeiling;": 8969,
			"RoundImplies;": 10608,
			"ShortUpArrow;": 8593,
			"SquareSubset;": 8847,
			"UnderBracket;": 9141,
			"VerticalLine;": 124,
			"blacklozenge;": 10731,
			"exponentiale;": 8519,
			"risingdotseq;": 8787,
			"triangledown;": 9663,
			"triangleleft;": 9667,
			"varsubsetneq;": 8842,
			"varsupsetneq;": 8843,
			"CircleMinus;": 8854,
			"CircleTimes;": 8855,
			"Equilibrium;": 8652,
			"GreaterLess;": 8823,
			"LeftCeiling;": 8968,
			"LessGreater;": 8822,
			"MediumSpace;": 8287,
			"NotLessLess;": 8810,
			"NotPrecedes;": 8832,
			"NotSucceeds;": 8833,
			"NotSuperset;": 8835,
			"OverBracket;": 9140,
			"RightVector;": 8640,
			"Rrightarrow;": 8667,
			"RuleDelayed;": 10740,
			"SmallCircle;": 8728,
			"SquareUnion;": 8852,
			"SubsetEqual;": 8838,
			"UpDownArrow;": 8597,
			"Updownarrow;": 8661,
			"VerticalBar;": 8739,
			"backepsilon;": 1014,
			"blacksquare;": 9642,
			"circledcirc;": 8858,
			"circleddash;": 8861,
			"curlyeqprec;": 8926,
			"curlyeqsucc;": 8927,
			"diamondsuit;": 9830,
			"eqslantless;": 10901,
			"expectation;": 8496,
			"nRightarrow;": 8655,
			"nrightarrow;": 8603,
			"preccurlyeq;": 8828,
			"precnapprox;": 10937,
			"quaternions;": 8461,
			"straightphi;": 981,
			"succcurlyeq;": 8829,
			"succnapprox;": 10938,
			"thickapprox;": 8776,
			"updownarrow;": 8597,
			"Bernoullis;": 8492,
			"CirclePlus;": 8853,
			"EqualTilde;": 8770,
			"Fouriertrf;": 8497,
			"ImaginaryI;": 8520,
			"Laplacetrf;": 8466,
			"LeftVector;": 8636,
			"Lleftarrow;": 8666,
			"NotElement;": 8713,
			"NotGreater;": 8815,
			"Proportion;": 8759,
			"RightArrow;": 8594,
			"RightFloor;": 8971,
			"Rightarrow;": 8658,
			"ThickSpace;": 8287,
			"TildeEqual;": 8771,
			"TildeTilde;": 8776,
			"UnderBrace;": 9183,
			"UpArrowBar;": 10514,
			"UpTeeArrow;": 8613,
			"circledast;": 8859,
			"complement;": 8705,
			"curlywedge;": 8911,
			"eqslantgtr;": 10902,
			"gtreqqless;": 10892,
			"lessapprox;": 10885,
			"lesseqqgtr;": 10891,
			"lmoustache;": 9136,
			"longmapsto;": 10236,
			"mapstodown;": 8615,
			"mapstoleft;": 8612,
			"nLeftarrow;": 8653,
			"nleftarrow;": 8602,
			"nsubseteqq;": 10949,
			"nsupseteqq;": 10950,
			"precapprox;": 10935,
			"rightarrow;": 8594,
			"rmoustache;": 9137,
			"sqsubseteq;": 8849,
			"sqsupseteq;": 8850,
			"subsetneqq;": 10955,
			"succapprox;": 10936,
			"supsetneqq;": 10956,
			"upuparrows;": 8648,
			"varepsilon;": 1013,
			"varnothing;": 8709,
			"Backslash;": 8726,
			"CenterDot;": 183,
			"CircleDot;": 8857,
			"Congruent;": 8801,
			"Coproduct;": 8720,
			"DoubleDot;": 168,
			"DownArrow;": 8595,
			"DownBreve;": 785,
			"Downarrow;": 8659,
			"HumpEqual;": 8783,
			"LeftArrow;": 8592,
			"LeftFloor;": 8970,
			"Leftarrow;": 8656,
			"LessTilde;": 8818,
			"Mellintrf;": 8499,
			"MinusPlus;": 8723,
			"NotCupCap;": 8813,
			"NotExists;": 8708,
			"NotSubset;": 8834,
			"OverBrace;": 9182,
			"PlusMinus;": 177,
			"Therefore;": 8756,
			"ThinSpace;": 8201,
			"TripleDot;": 8411,
			"UnionPlus;": 8846,
			"backprime;": 8245,
			"backsimeq;": 8909,
			"bigotimes;": 10754,
			"centerdot;": 183,
			"checkmark;": 10003,
			"complexes;": 8450,
			"dotsquare;": 8865,
			"downarrow;": 8595,
			"gtrapprox;": 10886,
			"gtreqless;": 8923,
			"gvertneqq;": 8809,
			"heartsuit;": 9829,
			"leftarrow;": 8592,
			"lesseqgtr;": 8922,
			"lvertneqq;": 8808,
			"ngeqslant;": 10878,
			"nleqslant;": 10877,
			"nparallel;": 8742,
			"nshortmid;": 8740,
			"nsubseteq;": 8840,
			"nsupseteq;": 8841,
			"pitchfork;": 8916,
			"rationals;": 8474,
			"spadesuit;": 9824,
			"subseteqq;": 10949,
			"subsetneq;": 8842,
			"supseteqq;": 10950,
			"supsetneq;": 8843,
			"therefore;": 8756,
			"triangleq;": 8796,
			"varpropto;": 8733,
			"DDotrahd;": 10513,
			"DotEqual;": 8784,
			"Integral;": 8747,
			"LessLess;": 10913,
			"NotEqual;": 8800,
			"NotTilde;": 8769,
			"PartialD;": 8706,
			"Precedes;": 8826,
			"RightTee;": 8866,
			"Succeeds;": 8827,
			"SuchThat;": 8715,
			"Superset;": 8835,
			"Uarrocir;": 10569,
			"UnderBar;": 95,
			"andslope;": 10840,
			"angmsdaa;": 10664,
			"angmsdab;": 10665,
			"angmsdac;": 10666,
			"angmsdad;": 10667,
			"angmsdae;": 10668,
			"angmsdaf;": 10669,
			"angmsdag;": 10670,
			"angmsdah;": 10671,
			"angrtvbd;": 10653,
			"approxeq;": 8778,
			"awconint;": 8755,
			"backcong;": 8780,
			"barwedge;": 8965,
			"bbrktbrk;": 9142,
			"bigoplus;": 10753,
			"bigsqcup;": 10758,
			"biguplus;": 10756,
			"bigwedge;": 8896,
			"boxminus;": 8863,
			"boxtimes;": 8864,
			"bsolhsub;": 10184,
			"capbrcup;": 10825,
			"circledR;": 174,
			"circledS;": 9416,
			"cirfnint;": 10768,
			"clubsuit;": 9827,
			"cupbrcap;": 10824,
			"curlyvee;": 8910,
			"cwconint;": 8754,
			"doteqdot;": 8785,
			"dotminus;": 8760,
			"drbkarow;": 10512,
			"dzigrarr;": 10239,
			"elinters;": 9191,
			"emptyset;": 8709,
			"eqvparsl;": 10725,
			"fpartint;": 10765,
			"geqslant;": 10878,
			"gesdotol;": 10884,
			"gnapprox;": 10890,
			"hksearow;": 10533,
			"hkswarow;": 10534,
			"imagline;": 8464,
			"imagpart;": 8465,
			"infintie;": 10717,
			"integers;": 8484,
			"intercal;": 8890,
			"intlarhk;": 10775,
			"laemptyv;": 10676,
			"ldrushar;": 10571,
			"leqslant;": 10877,
			"lesdotor;": 10883,
			"llcorner;": 8990,
			"lnapprox;": 10889,
			"lrcorner;": 8991,
			"lurdshar;": 10570,
			"mapstoup;": 8613,
			"multimap;": 8888,
			"naturals;": 8469,
			"ncongdot;": 10861,
			"notindot;": 8949,
			"otimesas;": 10806,
			"parallel;": 8741,
			"plusacir;": 10787,
			"pointint;": 10773,
			"precneqq;": 10933,
			"precnsim;": 8936,
			"profalar;": 9006,
			"profline;": 8978,
			"profsurf;": 8979,
			"raemptyv;": 10675,
			"realpart;": 8476,
			"rppolint;": 10770,
			"rtriltri;": 10702,
			"scpolint;": 10771,
			"setminus;": 8726,
			"shortmid;": 8739,
			"smeparsl;": 10724,
			"sqsubset;": 8847,
			"sqsupset;": 8848,
			"subseteq;": 8838,
			"succneqq;": 10934,
			"succnsim;": 8937,
			"supseteq;": 8839,
			"thetasym;": 977,
			"thicksim;": 8764,
			"timesbar;": 10801,
			"triangle;": 9653,
			"triminus;": 10810,
			"trpezium;": 9186,
			"ulcorner;": 8988,
			"urcorner;": 8989,
			"varkappa;": 1008,
			"varsigma;": 962,
			"vartheta;": 977,
			"Because;": 8757,
			"Cayleys;": 8493,
			"Cconint;": 8752,
			"Cedilla;": 184,
			"Diamond;": 8900,
			"DownTee;": 8868,
			"Element;": 8712,
			"Epsilon;": 917,
			"Implies;": 8658,
			"LeftTee;": 8867,
			"NewLine;": 10,
			"NoBreak;": 8288,
			"NotLess;": 8814,
			"Omicron;": 927,
			"OverBar;": 8254,
			"Product;": 8719,
			"UpArrow;": 8593,
			"Uparrow;": 8657,
			"Upsilon;": 933,
			"alefsym;": 8501,
			"angrtvb;": 8894,
			"angzarr;": 9084,
			"asympeq;": 8781,
			"backsim;": 8765,
			"because;": 8757,
			"bemptyv;": 10672,
			"between;": 8812,
			"bigcirc;": 9711,
			"bigodot;": 10752,
			"bigstar;": 9733,
			"bnequiv;": 8801,
			"boxplus;": 8862,
			"ccupssm;": 10832,
			"cemptyv;": 10674,
			"cirscir;": 10690,
			"coloneq;": 8788,
			"congdot;": 10861,
			"cudarrl;": 10552,
			"cudarrr;": 10549,
			"cularrp;": 10557,
			"curarrm;": 10556,
			"dbkarow;": 10511,
			"ddagger;": 8225,
			"ddotseq;": 10871,
			"demptyv;": 10673,
			"diamond;": 8900,
			"digamma;": 989,
			"dotplus;": 8724,
			"dwangle;": 10662,
			"epsilon;": 949,
			"eqcolon;": 8789,
			"equivDD;": 10872,
			"gesdoto;": 10882,
			"gtquest;": 10876,
			"gtrless;": 8823,
			"harrcir;": 10568,
			"intprod;": 10812,
			"isindot;": 8949,
			"larrbfs;": 10527,
			"larrsim;": 10611,
			"lbrksld;": 10639,
			"lbrkslu;": 10637,
			"ldrdhar;": 10599,
			"lesdoto;": 10881,
			"lessdot;": 8918,
			"lessgtr;": 8822,
			"lesssim;": 8818,
			"lotimes;": 10804,
			"lozenge;": 9674,
			"ltquest;": 10875,
			"luruhar;": 10598,
			"maltese;": 10016,
			"minusdu;": 10794,
			"napprox;": 8777,
			"natural;": 9838,
			"nearrow;": 8599,
			"nexists;": 8708,
			"notinva;": 8713,
			"notinvb;": 8951,
			"notinvc;": 8950,
			"notniva;": 8716,
			"notnivb;": 8958,
			"notnivc;": 8957,
			"npolint;": 10772,
			"npreceq;": 10927,
			"nsqsube;": 8930,
			"nsqsupe;": 8931,
			"nsubset;": 8834,
			"nsucceq;": 10928,
			"nsupset;": 8835,
			"nvinfin;": 10718,
			"nvltrie;": 8884,
			"nvrtrie;": 8885,
			"nwarrow;": 8598,
			"olcross;": 10683,
			"omicron;": 959,
			"orderof;": 8500,
			"orslope;": 10839,
			"pertenk;": 8241,
			"planckh;": 8462,
			"pluscir;": 10786,
			"plussim;": 10790,
			"plustwo;": 10791,
			"precsim;": 8830,
			"quatint;": 10774,
			"questeq;": 8799,
			"rarrbfs;": 10528,
			"rarrsim;": 10612,
			"rbrksld;": 10638,
			"rbrkslu;": 10640,
			"rdldhar;": 10601,
			"realine;": 8475,
			"rotimes;": 10805,
			"ruluhar;": 10600,
			"searrow;": 8600,
			"simplus;": 10788,
			"simrarr;": 10610,
			"subedot;": 10947,
			"submult;": 10945,
			"subplus;": 10943,
			"subrarr;": 10617,
			"succsim;": 8831,
			"supdsub;": 10968,
			"supedot;": 10948,
			"suphsol;": 10185,
			"suphsub;": 10967,
			"suplarr;": 10619,
			"supmult;": 10946,
			"supplus;": 10944,
			"swarrow;": 8601,
			"topfork;": 10970,
			"triplus;": 10809,
			"tritime;": 10811,
			"uparrow;": 8593,
			"upsilon;": 965,
			"uwangle;": 10663,
			"vzigzag;": 10650,
			"zigrarr;": 8669,
			"Aacute;": 193,
			"Abreve;": 258,
			"Agrave;": 192,
			"Assign;": 8788,
			"Atilde;": 195,
			"Barwed;": 8966,
			"Bumpeq;": 8782,
			"Cacute;": 262,
			"Ccaron;": 268,
			"Ccedil;": 199,
			"Colone;": 10868,
			"Conint;": 8751,
			"CupCap;": 8781,
			"Dagger;": 8225,
			"Dcaron;": 270,
			"DotDot;": 8412,
			"Dstrok;": 272,
			"Eacute;": 201,
			"Ecaron;": 282,
			"Egrave;": 200,
			"Exists;": 8707,
			"ForAll;": 8704,
			"Gammad;": 988,
			"Gbreve;": 286,
			"Gcedil;": 290,
			"HARDcy;": 1066,
			"Hstrok;": 294,
			"Iacute;": 205,
			"Igrave;": 204,
			"Itilde;": 296,
			"Jsercy;": 1032,
			"Kcedil;": 310,
			"Lacute;": 313,
			"Lambda;": 923,
			"Lcaron;": 317,
			"Lcedil;": 315,
			"Lmidot;": 319,
			"Lstrok;": 321,
			"Nacute;": 323,
			"Ncaron;": 327,
			"Ncedil;": 325,
			"Ntilde;": 209,
			"Oacute;": 211,
			"Odblac;": 336,
			"Ograve;": 210,
			"Oslash;": 216,
			"Otilde;": 213,
			"Otimes;": 10807,
			"Racute;": 340,
			"Rarrtl;": 10518,
			"Rcaron;": 344,
			"Rcedil;": 342,
			"SHCHcy;": 1065,
			"SOFTcy;": 1068,
			"Sacute;": 346,
			"Scaron;": 352,
			"Scedil;": 350,
			"Square;": 9633,
			"Subset;": 8912,
			"Supset;": 8913,
			"Tcaron;": 356,
			"Tcedil;": 354,
			"Tstrok;": 358,
			"Uacute;": 218,
			"Ubreve;": 364,
			"Udblac;": 368,
			"Ugrave;": 217,
			"Utilde;": 360,
			"Vdashl;": 10982,
			"Verbar;": 8214,
			"Vvdash;": 8874,
			"Yacute;": 221,
			"Zacute;": 377,
			"Zcaron;": 381,
			"aacute;": 225,
			"abreve;": 259,
			"agrave;": 224,
			"andand;": 10837,
			"angmsd;": 8737,
			"angsph;": 8738,
			"apacir;": 10863,
			"approx;": 8776,
			"atilde;": 227,
			"barvee;": 8893,
			"barwed;": 8965,
			"becaus;": 8757,
			"bernou;": 8492,
			"bigcap;": 8898,
			"bigcup;": 8899,
			"bigvee;": 8897,
			"bkarow;": 10509,
			"bottom;": 8869,
			"bowtie;": 8904,
			"boxbox;": 10697,
			"bprime;": 8245,
			"brvbar;": 166,
			"bullet;": 8226,
			"bumpeq;": 8783,
			"cacute;": 263,
			"capand;": 10820,
			"capcap;": 10827,
			"capcup;": 10823,
			"capdot;": 10816,
			"ccaron;": 269,
			"ccedil;": 231,
			"circeq;": 8791,
			"cirmid;": 10991,
			"colone;": 8788,
			"commat;": 64,
			"compfn;": 8728,
			"conint;": 8750,
			"coprod;": 8720,
			"copysr;": 8471,
			"cularr;": 8630,
			"cupcap;": 10822,
			"cupcup;": 10826,
			"cupdot;": 8845,
			"curarr;": 8631,
			"curren;": 164,
			"cylcty;": 9005,
			"dagger;": 8224,
			"daleth;": 8504,
			"dcaron;": 271,
			"dfisht;": 10623,
			"divide;": 247,
			"divonx;": 8903,
			"dlcorn;": 8990,
			"dlcrop;": 8973,
			"dollar;": 36,
			"drcorn;": 8991,
			"drcrop;": 8972,
			"dstrok;": 273,
			"eacute;": 233,
			"easter;": 10862,
			"ecaron;": 283,
			"ecolon;": 8789,
			"egrave;": 232,
			"egsdot;": 10904,
			"elsdot;": 10903,
			"emptyv;": 8709,
			"emsp13;": 8196,
			"emsp14;": 8197,
			"eparsl;": 10723,
			"eqcirc;": 8790,
			"equals;": 61,
			"equest;": 8799,
			"female;": 9792,
			"ffilig;": 64259,
			"ffllig;": 64260,
			"forall;": 8704,
			"frac12;": 189,
			"frac13;": 8531,
			"frac14;": 188,
			"frac15;": 8533,
			"frac16;": 8537,
			"frac18;": 8539,
			"frac23;": 8532,
			"frac25;": 8534,
			"frac34;": 190,
			"frac35;": 8535,
			"frac38;": 8540,
			"frac45;": 8536,
			"frac56;": 8538,
			"frac58;": 8541,
			"frac78;": 8542,
			"gacute;": 501,
			"gammad;": 989,
			"gbreve;": 287,
			"gesdot;": 10880,
			"gesles;": 10900,
			"gtlPar;": 10645,
			"gtrarr;": 10616,
			"gtrdot;": 8919,
			"gtrsim;": 8819,
			"hairsp;": 8202,
			"hamilt;": 8459,
			"hardcy;": 1098,
			"hearts;": 9829,
			"hellip;": 8230,
			"hercon;": 8889,
			"homtht;": 8763,
			"horbar;": 8213,
			"hslash;": 8463,
			"hstrok;": 295,
			"hybull;": 8259,
			"hyphen;": 8208,
			"iacute;": 237,
			"igrave;": 236,
			"iiiint;": 10764,
			"iinfin;": 10716,
			"incare;": 8453,
			"inodot;": 305,
			"intcal;": 8890,
			"iquest;": 191,
			"isinsv;": 8947,
			"itilde;": 297,
			"jsercy;": 1112,
			"kappav;": 1008,
			"kcedil;": 311,
			"kgreen;": 312,
			"lAtail;": 10523,
			"lacute;": 314,
			"lagran;": 8466,
			"lambda;": 955,
			"langle;": 10216,
			"larrfs;": 10525,
			"larrhk;": 8617,
			"larrlp;": 8619,
			"larrpl;": 10553,
			"larrtl;": 8610,
			"latail;": 10521,
			"lbrace;": 123,
			"lbrack;": 91,
			"lcaron;": 318,
			"lcedil;": 316,
			"ldquor;": 8222,
			"lesdot;": 10879,
			"lesges;": 10899,
			"lfisht;": 10620,
			"lfloor;": 8970,
			"lharul;": 10602,
			"llhard;": 10603,
			"lmidot;": 320,
			"lmoust;": 9136,
			"loplus;": 10797,
			"lowast;": 8727,
			"lowbar;": 95,
			"lparlt;": 10643,
			"lrhard;": 10605,
			"lsaquo;": 8249,
			"lsquor;": 8218,
			"lstrok;": 322,
			"lthree;": 8907,
			"ltimes;": 8905,
			"ltlarr;": 10614,
			"ltrPar;": 10646,
			"mapsto;": 8614,
			"marker;": 9646,
			"mcomma;": 10793,
			"midast;": 42,
			"midcir;": 10992,
			"middot;": 183,
			"minusb;": 8863,
			"minusd;": 8760,
			"mnplus;": 8723,
			"models;": 8871,
			"mstpos;": 8766,
			"nVDash;": 8879,
			"nVdash;": 8878,
			"nacute;": 324,
			"nbumpe;": 8783,
			"ncaron;": 328,
			"ncedil;": 326,
			"nearhk;": 10532,
			"nequiv;": 8802,
			"nesear;": 10536,
			"nexist;": 8708,
			"nltrie;": 8940,
			"notinE;": 8953,
			"nparsl;": 11005,
			"nprcue;": 8928,
			"nrarrc;": 10547,
			"nrarrw;": 8605,
			"nrtrie;": 8941,
			"nsccue;": 8929,
			"nsimeq;": 8772,
			"ntilde;": 241,
			"numero;": 8470,
			"nvDash;": 8877,
			"nvHarr;": 10500,
			"nvdash;": 8876,
			"nvlArr;": 10498,
			"nvrArr;": 10499,
			"nwarhk;": 10531,
			"nwnear;": 10535,
			"oacute;": 243,
			"odblac;": 337,
			"odsold;": 10684,
			"ograve;": 242,
			"ominus;": 8854,
			"origof;": 8886,
			"oslash;": 248,
			"otilde;": 245,
			"otimes;": 8855,
			"parsim;": 10995,
			"percnt;": 37,
			"period;": 46,
			"permil;": 8240,
			"phmmat;": 8499,
			"planck;": 8463,
			"plankv;": 8463,
			"plusdo;": 8724,
			"plusdu;": 10789,
			"plusmn;": 177,
			"preceq;": 10927,
			"primes;": 8473,
			"prnsim;": 8936,
			"propto;": 8733,
			"prurel;": 8880,
			"puncsp;": 8200,
			"qprime;": 8279,
			"rAtail;": 10524,
			"racute;": 341,
			"rangle;": 10217,
			"rarrap;": 10613,
			"rarrfs;": 10526,
			"rarrhk;": 8618,
			"rarrlp;": 8620,
			"rarrpl;": 10565,
			"rarrtl;": 8611,
			"ratail;": 10522,
			"rbrace;": 125,
			"rbrack;": 93,
			"rcaron;": 345,
			"rcedil;": 343,
			"rdquor;": 8221,
			"rfisht;": 10621,
			"rfloor;": 8971,
			"rharul;": 10604,
			"rmoust;": 9137,
			"roplus;": 10798,
			"rpargt;": 10644,
			"rsaquo;": 8250,
			"rsquor;": 8217,
			"rthree;": 8908,
			"rtimes;": 8906,
			"sacute;": 347,
			"scaron;": 353,
			"scedil;": 351,
			"scnsim;": 8937,
			"searhk;": 10533,
			"seswar;": 10537,
			"sfrown;": 8994,
			"shchcy;": 1097,
			"sigmaf;": 962,
			"sigmav;": 962,
			"simdot;": 10858,
			"smashp;": 10803,
			"softcy;": 1100,
			"solbar;": 9023,
			"spades;": 9824,
			"sqcaps;": 8851,
			"sqcups;": 8852,
			"sqsube;": 8849,
			"sqsupe;": 8850,
			"square;": 9633,
			"squarf;": 9642,
			"ssetmn;": 8726,
			"ssmile;": 8995,
			"sstarf;": 8902,
			"subdot;": 10941,
			"subset;": 8834,
			"subsim;": 10951,
			"subsub;": 10965,
			"subsup;": 10963,
			"succeq;": 10928,
			"supdot;": 10942,
			"supset;": 8835,
			"supsim;": 10952,
			"supsub;": 10964,
			"supsup;": 10966,
			"swarhk;": 10534,
			"swnwar;": 10538,
			"target;": 8982,
			"tcaron;": 357,
			"tcedil;": 355,
			"telrec;": 8981,
			"there4;": 8756,
			"thetav;": 977,
			"thinsp;": 8201,
			"thksim;": 8764,
			"timesb;": 8864,
			"timesd;": 10800,
			"topbot;": 9014,
			"topcir;": 10993,
			"tprime;": 8244,
			"tridot;": 9708,
			"tstrok;": 359,
			"uacute;": 250,
			"ubreve;": 365,
			"udblac;": 369,
			"ufisht;": 10622,
			"ugrave;": 249,
			"ulcorn;": 8988,
			"ulcrop;": 8975,
			"urcorn;": 8989,
			"urcrop;": 8974,
			"utilde;": 361,
			"vangrt;": 10652,
			"varphi;": 981,
			"varrho;": 1009,
			"veebar;": 8891,
			"vellip;": 8942,
			"verbar;": 124,
			"vsubnE;": 10955,
			"vsubne;": 8842,
			"vsupnE;": 10956,
			"vsupne;": 8843,
			"wedbar;": 10847,
			"wedgeq;": 8793,
			"weierp;": 8472,
			"wreath;": 8768,
			"xoplus;": 10753,
			"xotime;": 10754,
			"xsqcup;": 10758,
			"xuplus;": 10756,
			"xwedge;": 8896,
			"yacute;": 253,
			"zacute;": 378,
			"zcaron;": 382,
			"zeetrf;": 8488,
			"AElig;": 198,
			Aacute: 193,
			"Acirc;": 194,
			Agrave: 192,
			"Alpha;": 913,
			"Amacr;": 256,
			"Aogon;": 260,
			"Aring;": 197,
			Atilde: 195,
			"Breve;": 728,
			Ccedil: 199,
			"Ccirc;": 264,
			"Colon;": 8759,
			"Cross;": 10799,
			"Dashv;": 10980,
			"Delta;": 916,
			Eacute: 201,
			"Ecirc;": 202,
			Egrave: 200,
			"Emacr;": 274,
			"Eogon;": 280,
			"Equal;": 10869,
			"Gamma;": 915,
			"Gcirc;": 284,
			"Hacek;": 711,
			"Hcirc;": 292,
			"IJlig;": 306,
			Iacute: 205,
			"Icirc;": 206,
			Igrave: 204,
			"Imacr;": 298,
			"Iogon;": 302,
			"Iukcy;": 1030,
			"Jcirc;": 308,
			"Jukcy;": 1028,
			"Kappa;": 922,
			Ntilde: 209,
			"OElig;": 338,
			Oacute: 211,
			"Ocirc;": 212,
			Ograve: 210,
			"Omacr;": 332,
			"Omega;": 937,
			Oslash: 216,
			Otilde: 213,
			"Prime;": 8243,
			"RBarr;": 10512,
			"Scirc;": 348,
			"Sigma;": 931,
			"THORN;": 222,
			"TRADE;": 8482,
			"TSHcy;": 1035,
			"Theta;": 920,
			"Tilde;": 8764,
			Uacute: 218,
			"Ubrcy;": 1038,
			"Ucirc;": 219,
			Ugrave: 217,
			"Umacr;": 362,
			"Union;": 8899,
			"Uogon;": 370,
			"UpTee;": 8869,
			"Uring;": 366,
			"VDash;": 8875,
			"Vdash;": 8873,
			"Wcirc;": 372,
			"Wedge;": 8896,
			Yacute: 221,
			"Ycirc;": 374,
			aacute: 225,
			"acirc;": 226,
			"acute;": 180,
			"aelig;": 230,
			agrave: 224,
			"aleph;": 8501,
			"alpha;": 945,
			"amacr;": 257,
			"amalg;": 10815,
			"angle;": 8736,
			"angrt;": 8735,
			"angst;": 197,
			"aogon;": 261,
			"aring;": 229,
			"asymp;": 8776,
			atilde: 227,
			"awint;": 10769,
			"bcong;": 8780,
			"bdquo;": 8222,
			"bepsi;": 1014,
			"blank;": 9251,
			"blk12;": 9618,
			"blk14;": 9617,
			"blk34;": 9619,
			"block;": 9608,
			"boxDL;": 9559,
			"boxDR;": 9556,
			"boxDl;": 9558,
			"boxDr;": 9555,
			"boxHD;": 9574,
			"boxHU;": 9577,
			"boxHd;": 9572,
			"boxHu;": 9575,
			"boxUL;": 9565,
			"boxUR;": 9562,
			"boxUl;": 9564,
			"boxUr;": 9561,
			"boxVH;": 9580,
			"boxVL;": 9571,
			"boxVR;": 9568,
			"boxVh;": 9579,
			"boxVl;": 9570,
			"boxVr;": 9567,
			"boxdL;": 9557,
			"boxdR;": 9554,
			"boxdl;": 9488,
			"boxdr;": 9484,
			"boxhD;": 9573,
			"boxhU;": 9576,
			"boxhd;": 9516,
			"boxhu;": 9524,
			"boxuL;": 9563,
			"boxuR;": 9560,
			"boxul;": 9496,
			"boxur;": 9492,
			"boxvH;": 9578,
			"boxvL;": 9569,
			"boxvR;": 9566,
			"boxvh;": 9532,
			"boxvl;": 9508,
			"boxvr;": 9500,
			"breve;": 728,
			brvbar: 166,
			"bsemi;": 8271,
			"bsime;": 8909,
			"bsolb;": 10693,
			"bumpE;": 10926,
			"bumpe;": 8783,
			"caret;": 8257,
			"caron;": 711,
			"ccaps;": 10829,
			ccedil: 231,
			"ccirc;": 265,
			"ccups;": 10828,
			"cedil;": 184,
			"check;": 10003,
			"clubs;": 9827,
			"colon;": 58,
			"comma;": 44,
			"crarr;": 8629,
			"cross;": 10007,
			"csube;": 10961,
			"csupe;": 10962,
			"ctdot;": 8943,
			"cuepr;": 8926,
			"cuesc;": 8927,
			"cupor;": 10821,
			curren: 164,
			"cuvee;": 8910,
			"cuwed;": 8911,
			"cwint;": 8753,
			"dashv;": 8867,
			"dblac;": 733,
			"ddarr;": 8650,
			"delta;": 948,
			"dharl;": 8643,
			"dharr;": 8642,
			"diams;": 9830,
			"disin;": 8946,
			divide: 247,
			"doteq;": 8784,
			"dtdot;": 8945,
			"dtrif;": 9662,
			"duarr;": 8693,
			"duhar;": 10607,
			"eDDot;": 10871,
			eacute: 233,
			"ecirc;": 234,
			"efDot;": 8786,
			egrave: 232,
			"emacr;": 275,
			"empty;": 8709,
			"eogon;": 281,
			"eplus;": 10865,
			"epsiv;": 1013,
			"eqsim;": 8770,
			"equiv;": 8801,
			"erDot;": 8787,
			"erarr;": 10609,
			"esdot;": 8784,
			"exist;": 8707,
			"fflig;": 64256,
			"filig;": 64257,
			"fjlig;": 102,
			"fllig;": 64258,
			"fltns;": 9649,
			"forkv;": 10969,
			frac12: 189,
			frac14: 188,
			frac34: 190,
			"frasl;": 8260,
			"frown;": 8994,
			"gamma;": 947,
			"gcirc;": 285,
			"gescc;": 10921,
			"gimel;": 8503,
			"gneqq;": 8809,
			"gnsim;": 8935,
			"grave;": 96,
			"gsime;": 10894,
			"gsiml;": 10896,
			"gtcir;": 10874,
			"gtdot;": 8919,
			"harrw;": 8621,
			"hcirc;": 293,
			"hoarr;": 8703,
			iacute: 237,
			"icirc;": 238,
			"iexcl;": 161,
			igrave: 236,
			"iiint;": 8749,
			"iiota;": 8489,
			"ijlig;": 307,
			"imacr;": 299,
			"image;": 8465,
			"imath;": 305,
			"imped;": 437,
			"infin;": 8734,
			"iogon;": 303,
			"iprod;": 10812,
			iquest: 191,
			"isinE;": 8953,
			"isins;": 8948,
			"isinv;": 8712,
			"iukcy;": 1110,
			"jcirc;": 309,
			"jmath;": 567,
			"jukcy;": 1108,
			"kappa;": 954,
			"lAarr;": 8666,
			"lBarr;": 10510,
			"langd;": 10641,
			"laquo;": 171,
			"larrb;": 8676,
			"lates;": 10925,
			"lbarr;": 10508,
			"lbbrk;": 10098,
			"lbrke;": 10635,
			"lceil;": 8968,
			"ldquo;": 8220,
			"lescc;": 10920,
			"lhard;": 8637,
			"lharu;": 8636,
			"lhblk;": 9604,
			"llarr;": 8647,
			"lltri;": 9722,
			"lneqq;": 8808,
			"lnsim;": 8934,
			"loang;": 10220,
			"loarr;": 8701,
			"lobrk;": 10214,
			"lopar;": 10629,
			"lrarr;": 8646,
			"lrhar;": 8651,
			"lrtri;": 8895,
			"lsime;": 10893,
			"lsimg;": 10895,
			"lsquo;": 8216,
			"ltcir;": 10873,
			"ltdot;": 8918,
			"ltrie;": 8884,
			"ltrif;": 9666,
			"mDDot;": 8762,
			"mdash;": 8212,
			"micro;": 181,
			middot: 183,
			"minus;": 8722,
			"mumap;": 8888,
			"nabla;": 8711,
			"napid;": 8779,
			"napos;": 329,
			"natur;": 9838,
			"nbump;": 8782,
			"ncong;": 8775,
			"ndash;": 8211,
			"neArr;": 8663,
			"nearr;": 8599,
			"nedot;": 8784,
			"nesim;": 8770,
			"ngeqq;": 8807,
			"ngsim;": 8821,
			"nhArr;": 8654,
			"nharr;": 8622,
			"nhpar;": 10994,
			"nlArr;": 8653,
			"nlarr;": 8602,
			"nleqq;": 8806,
			"nless;": 8814,
			"nlsim;": 8820,
			"nltri;": 8938,
			"notin;": 8713,
			"notni;": 8716,
			"npart;": 8706,
			"nprec;": 8832,
			"nrArr;": 8655,
			"nrarr;": 8603,
			"nrtri;": 8939,
			"nsime;": 8772,
			"nsmid;": 8740,
			"nspar;": 8742,
			"nsubE;": 10949,
			"nsube;": 8840,
			"nsucc;": 8833,
			"nsupE;": 10950,
			"nsupe;": 8841,
			ntilde: 241,
			"numsp;": 8199,
			"nvsim;": 8764,
			"nwArr;": 8662,
			"nwarr;": 8598,
			oacute: 243,
			"ocirc;": 244,
			"odash;": 8861,
			"oelig;": 339,
			"ofcir;": 10687,
			ograve: 242,
			"ohbar;": 10677,
			"olarr;": 8634,
			"olcir;": 10686,
			"oline;": 8254,
			"omacr;": 333,
			"omega;": 969,
			"operp;": 10681,
			"oplus;": 8853,
			"orarr;": 8635,
			"order;": 8500,
			oslash: 248,
			otilde: 245,
			"ovbar;": 9021,
			"parsl;": 11005,
			"phone;": 9742,
			"plusb;": 8862,
			"pluse;": 10866,
			plusmn: 177,
			"pound;": 163,
			"prcue;": 8828,
			"prime;": 8242,
			"prnap;": 10937,
			"prsim;": 8830,
			"quest;": 63,
			"rAarr;": 8667,
			"rBarr;": 10511,
			"radic;": 8730,
			"rangd;": 10642,
			"range;": 10661,
			"raquo;": 187,
			"rarrb;": 8677,
			"rarrc;": 10547,
			"rarrw;": 8605,
			"ratio;": 8758,
			"rbarr;": 10509,
			"rbbrk;": 10099,
			"rbrke;": 10636,
			"rceil;": 8969,
			"rdquo;": 8221,
			"reals;": 8477,
			"rhard;": 8641,
			"rharu;": 8640,
			"rlarr;": 8644,
			"rlhar;": 8652,
			"rnmid;": 10990,
			"roang;": 10221,
			"roarr;": 8702,
			"robrk;": 10215,
			"ropar;": 10630,
			"rrarr;": 8649,
			"rsquo;": 8217,
			"rtrie;": 8885,
			"rtrif;": 9656,
			"sbquo;": 8218,
			"sccue;": 8829,
			"scirc;": 349,
			"scnap;": 10938,
			"scsim;": 8831,
			"sdotb;": 8865,
			"sdote;": 10854,
			"seArr;": 8664,
			"searr;": 8600,
			"setmn;": 8726,
			"sharp;": 9839,
			"sigma;": 963,
			"simeq;": 8771,
			"simgE;": 10912,
			"simlE;": 10911,
			"simne;": 8774,
			"slarr;": 8592,
			"smile;": 8995,
			"smtes;": 10924,
			"sqcap;": 8851,
			"sqcup;": 8852,
			"sqsub;": 8847,
			"sqsup;": 8848,
			"srarr;": 8594,
			"starf;": 9733,
			"strns;": 175,
			"subnE;": 10955,
			"subne;": 8842,
			"supnE;": 10956,
			"supne;": 8843,
			"swArr;": 8665,
			"swarr;": 8601,
			"szlig;": 223,
			"theta;": 952,
			"thkap;": 8776,
			"thorn;": 254,
			"tilde;": 732,
			"times;": 215,
			"trade;": 8482,
			"trisb;": 10701,
			"tshcy;": 1115,
			"twixt;": 8812,
			uacute: 250,
			"ubrcy;": 1118,
			"ucirc;": 251,
			"udarr;": 8645,
			"udhar;": 10606,
			ugrave: 249,
			"uharl;": 8639,
			"uharr;": 8638,
			"uhblk;": 9600,
			"ultri;": 9720,
			"umacr;": 363,
			"uogon;": 371,
			"uplus;": 8846,
			"upsih;": 978,
			"uring;": 367,
			"urtri;": 9721,
			"utdot;": 8944,
			"utrif;": 9652,
			"uuarr;": 8648,
			"vBarv;": 10985,
			"vDash;": 8872,
			"varpi;": 982,
			"vdash;": 8866,
			"veeeq;": 8794,
			"vltri;": 8882,
			"vnsub;": 8834,
			"vnsup;": 8835,
			"vprop;": 8733,
			"vrtri;": 8883,
			"wcirc;": 373,
			"wedge;": 8743,
			"xcirc;": 9711,
			"xdtri;": 9661,
			"xhArr;": 10234,
			"xharr;": 10231,
			"xlArr;": 10232,
			"xlarr;": 10229,
			"xodot;": 10752,
			"xrArr;": 10233,
			"xrarr;": 10230,
			"xutri;": 9651,
			yacute: 253,
			"ycirc;": 375,
			AElig: 198,
			Acirc: 194,
			"Aopf;": 120120,
			Aring: 197,
			"Ascr;": 119964,
			"Auml;": 196,
			"Barv;": 10983,
			"Beta;": 914,
			"Bopf;": 120121,
			"Bscr;": 8492,
			"CHcy;": 1063,
			"COPY;": 169,
			"Cdot;": 266,
			"Copf;": 8450,
			"Cscr;": 119966,
			"DJcy;": 1026,
			"DScy;": 1029,
			"DZcy;": 1039,
			"Darr;": 8609,
			"Dopf;": 120123,
			"Dscr;": 119967,
			Ecirc: 202,
			"Edot;": 278,
			"Eopf;": 120124,
			"Escr;": 8496,
			"Esim;": 10867,
			"Euml;": 203,
			"Fopf;": 120125,
			"Fscr;": 8497,
			"GJcy;": 1027,
			"Gdot;": 288,
			"Gopf;": 120126,
			"Gscr;": 119970,
			"Hopf;": 8461,
			"Hscr;": 8459,
			"IEcy;": 1045,
			"IOcy;": 1025,
			Icirc: 206,
			"Idot;": 304,
			"Iopf;": 120128,
			"Iota;": 921,
			"Iscr;": 8464,
			"Iuml;": 207,
			"Jopf;": 120129,
			"Jscr;": 119973,
			"KHcy;": 1061,
			"KJcy;": 1036,
			"Kopf;": 120130,
			"Kscr;": 119974,
			"LJcy;": 1033,
			"Lang;": 10218,
			"Larr;": 8606,
			"Lopf;": 120131,
			"Lscr;": 8466,
			"Mopf;": 120132,
			"Mscr;": 8499,
			"NJcy;": 1034,
			"Nopf;": 8469,
			"Nscr;": 119977,
			Ocirc: 212,
			"Oopf;": 120134,
			"Oscr;": 119978,
			"Ouml;": 214,
			"Popf;": 8473,
			"Pscr;": 119979,
			"QUOT;": 34,
			"Qopf;": 8474,
			"Qscr;": 119980,
			"Rang;": 10219,
			"Rarr;": 8608,
			"Ropf;": 8477,
			"Rscr;": 8475,
			"SHcy;": 1064,
			"Sopf;": 120138,
			"Sqrt;": 8730,
			"Sscr;": 119982,
			"Star;": 8902,
			THORN: 222,
			"TScy;": 1062,
			"Topf;": 120139,
			"Tscr;": 119983,
			"Uarr;": 8607,
			Ucirc: 219,
			"Uopf;": 120140,
			"Upsi;": 978,
			"Uscr;": 119984,
			"Uuml;": 220,
			"Vbar;": 10987,
			"Vert;": 8214,
			"Vopf;": 120141,
			"Vscr;": 119985,
			"Wopf;": 120142,
			"Wscr;": 119986,
			"Xopf;": 120143,
			"Xscr;": 119987,
			"YAcy;": 1071,
			"YIcy;": 1031,
			"YUcy;": 1070,
			"Yopf;": 120144,
			"Yscr;": 119988,
			"Yuml;": 376,
			"ZHcy;": 1046,
			"Zdot;": 379,
			"Zeta;": 918,
			"Zopf;": 8484,
			"Zscr;": 119989,
			acirc: 226,
			acute: 180,
			aelig: 230,
			"andd;": 10844,
			"andv;": 10842,
			"ange;": 10660,
			"aopf;": 120146,
			"apid;": 8779,
			"apos;": 39,
			aring: 229,
			"ascr;": 119990,
			"auml;": 228,
			"bNot;": 10989,
			"bbrk;": 9141,
			"beta;": 946,
			"beth;": 8502,
			"bnot;": 8976,
			"bopf;": 120147,
			"boxH;": 9552,
			"boxV;": 9553,
			"boxh;": 9472,
			"boxv;": 9474,
			"bscr;": 119991,
			"bsim;": 8765,
			"bsol;": 92,
			"bull;": 8226,
			"bump;": 8782,
			"caps;": 8745,
			"cdot;": 267,
			cedil: 184,
			"cent;": 162,
			"chcy;": 1095,
			"cirE;": 10691,
			"circ;": 710,
			"cire;": 8791,
			"comp;": 8705,
			"cong;": 8773,
			"copf;": 120148,
			"copy;": 169,
			"cscr;": 119992,
			"csub;": 10959,
			"csup;": 10960,
			"cups;": 8746,
			"dArr;": 8659,
			"dHar;": 10597,
			"darr;": 8595,
			"dash;": 8208,
			"diam;": 8900,
			"djcy;": 1106,
			"dopf;": 120149,
			"dscr;": 119993,
			"dscy;": 1109,
			"dsol;": 10742,
			"dtri;": 9663,
			"dzcy;": 1119,
			"eDot;": 8785,
			"ecir;": 8790,
			ecirc: 234,
			"edot;": 279,
			"emsp;": 8195,
			"ensp;": 8194,
			"eopf;": 120150,
			"epar;": 8917,
			"epsi;": 949,
			"escr;": 8495,
			"esim;": 8770,
			"euml;": 235,
			"euro;": 8364,
			"excl;": 33,
			"flat;": 9837,
			"fnof;": 402,
			"fopf;": 120151,
			"fork;": 8916,
			"fscr;": 119995,
			"gdot;": 289,
			"geqq;": 8807,
			"gesl;": 8923,
			"gjcy;": 1107,
			"gnap;": 10890,
			"gneq;": 10888,
			"gopf;": 120152,
			"gscr;": 8458,
			"gsim;": 8819,
			"gtcc;": 10919,
			"gvnE;": 8809,
			"hArr;": 8660,
			"half;": 189,
			"harr;": 8596,
			"hbar;": 8463,
			"hopf;": 120153,
			"hscr;": 119997,
			icirc: 238,
			"iecy;": 1077,
			iexcl: 161,
			"imof;": 8887,
			"iocy;": 1105,
			"iopf;": 120154,
			"iota;": 953,
			"iscr;": 119998,
			"isin;": 8712,
			"iuml;": 239,
			"jopf;": 120155,
			"jscr;": 119999,
			"khcy;": 1093,
			"kjcy;": 1116,
			"kopf;": 120156,
			"kscr;": 12e4,
			"lArr;": 8656,
			"lHar;": 10594,
			"lang;": 10216,
			laquo: 171,
			"larr;": 8592,
			"late;": 10925,
			"lcub;": 123,
			"ldca;": 10550,
			"ldsh;": 8626,
			"leqq;": 8806,
			"lesg;": 8922,
			"ljcy;": 1113,
			"lnap;": 10889,
			"lneq;": 10887,
			"lopf;": 120157,
			"lozf;": 10731,
			"lpar;": 40,
			"lscr;": 120001,
			"lsim;": 8818,
			"lsqb;": 91,
			"ltcc;": 10918,
			"ltri;": 9667,
			"lvnE;": 8808,
			"macr;": 175,
			"male;": 9794,
			"malt;": 10016,
			micro: 181,
			"mlcp;": 10971,
			"mldr;": 8230,
			"mopf;": 120158,
			"mscr;": 120002,
			"nGtv;": 8811,
			"nLtv;": 8810,
			"nang;": 8736,
			"napE;": 10864,
			"nbsp;": 160,
			"ncap;": 10819,
			"ncup;": 10818,
			"ngeq;": 8817,
			"nges;": 10878,
			"ngtr;": 8815,
			"nisd;": 8954,
			"njcy;": 1114,
			"nldr;": 8229,
			"nleq;": 8816,
			"nles;": 10877,
			"nmid;": 8740,
			"nopf;": 120159,
			"npar;": 8742,
			"npre;": 10927,
			"nsce;": 10928,
			"nscr;": 120003,
			"nsim;": 8769,
			"nsub;": 8836,
			"nsup;": 8837,
			"ntgl;": 8825,
			"ntlg;": 8824,
			"nvap;": 8781,
			"nvge;": 8805,
			"nvgt;": 62,
			"nvle;": 8804,
			"nvlt;": 60,
			"oast;": 8859,
			"ocir;": 8858,
			ocirc: 244,
			"odiv;": 10808,
			"odot;": 8857,
			"ogon;": 731,
			"oint;": 8750,
			"omid;": 10678,
			"oopf;": 120160,
			"opar;": 10679,
			"ordf;": 170,
			"ordm;": 186,
			"oror;": 10838,
			"oscr;": 8500,
			"osol;": 8856,
			"ouml;": 246,
			"para;": 182,
			"part;": 8706,
			"perp;": 8869,
			"phiv;": 981,
			"plus;": 43,
			"popf;": 120161,
			pound: 163,
			"prap;": 10935,
			"prec;": 8826,
			"prnE;": 10933,
			"prod;": 8719,
			"prop;": 8733,
			"pscr;": 120005,
			"qint;": 10764,
			"qopf;": 120162,
			"qscr;": 120006,
			"quot;": 34,
			"rArr;": 8658,
			"rHar;": 10596,
			"race;": 8765,
			"rang;": 10217,
			raquo: 187,
			"rarr;": 8594,
			"rcub;": 125,
			"rdca;": 10551,
			"rdsh;": 8627,
			"real;": 8476,
			"rect;": 9645,
			"rhov;": 1009,
			"ring;": 730,
			"ropf;": 120163,
			"rpar;": 41,
			"rscr;": 120007,
			"rsqb;": 93,
			"rtri;": 9657,
			"scap;": 10936,
			"scnE;": 10934,
			"sdot;": 8901,
			"sect;": 167,
			"semi;": 59,
			"sext;": 10038,
			"shcy;": 1096,
			"sime;": 8771,
			"simg;": 10910,
			"siml;": 10909,
			"smid;": 8739,
			"smte;": 10924,
			"solb;": 10692,
			"sopf;": 120164,
			"spar;": 8741,
			"squf;": 9642,
			"sscr;": 120008,
			"star;": 9734,
			"subE;": 10949,
			"sube;": 8838,
			"succ;": 8827,
			"sung;": 9834,
			"sup1;": 185,
			"sup2;": 178,
			"sup3;": 179,
			"supE;": 10950,
			"supe;": 8839,
			szlig: 223,
			"tbrk;": 9140,
			"tdot;": 8411,
			thorn: 254,
			times: 215,
			"tint;": 8749,
			"toea;": 10536,
			"topf;": 120165,
			"tosa;": 10537,
			"trie;": 8796,
			"tscr;": 120009,
			"tscy;": 1094,
			"uArr;": 8657,
			"uHar;": 10595,
			"uarr;": 8593,
			ucirc: 251,
			"uopf;": 120166,
			"upsi;": 965,
			"uscr;": 120010,
			"utri;": 9653,
			"uuml;": 252,
			"vArr;": 8661,
			"vBar;": 10984,
			"varr;": 8597,
			"vert;": 124,
			"vopf;": 120167,
			"vscr;": 120011,
			"wopf;": 120168,
			"wscr;": 120012,
			"xcap;": 8898,
			"xcup;": 8899,
			"xmap;": 10236,
			"xnis;": 8955,
			"xopf;": 120169,
			"xscr;": 120013,
			"xvee;": 8897,
			"yacy;": 1103,
			"yicy;": 1111,
			"yopf;": 120170,
			"yscr;": 120014,
			"yucy;": 1102,
			"yuml;": 255,
			"zdot;": 380,
			"zeta;": 950,
			"zhcy;": 1078,
			"zopf;": 120171,
			"zscr;": 120015,
			"zwnj;": 8204,
			"AMP;": 38,
			"Acy;": 1040,
			"Afr;": 120068,
			"And;": 10835,
			Auml: 196,
			"Bcy;": 1041,
			"Bfr;": 120069,
			COPY: 169,
			"Cap;": 8914,
			"Cfr;": 8493,
			"Chi;": 935,
			"Cup;": 8915,
			"Dcy;": 1044,
			"Del;": 8711,
			"Dfr;": 120071,
			"Dot;": 168,
			"ENG;": 330,
			"ETH;": 208,
			"Ecy;": 1069,
			"Efr;": 120072,
			"Eta;": 919,
			Euml: 203,
			"Fcy;": 1060,
			"Ffr;": 120073,
			"Gcy;": 1043,
			"Gfr;": 120074,
			"Hat;": 94,
			"Hfr;": 8460,
			"Icy;": 1048,
			"Ifr;": 8465,
			"Int;": 8748,
			Iuml: 207,
			"Jcy;": 1049,
			"Jfr;": 120077,
			"Kcy;": 1050,
			"Kfr;": 120078,
			"Lcy;": 1051,
			"Lfr;": 120079,
			"Lsh;": 8624,
			"Map;": 10501,
			"Mcy;": 1052,
			"Mfr;": 120080,
			"Ncy;": 1053,
			"Nfr;": 120081,
			"Not;": 10988,
			"Ocy;": 1054,
			"Ofr;": 120082,
			Ouml: 214,
			"Pcy;": 1055,
			"Pfr;": 120083,
			"Phi;": 934,
			"Psi;": 936,
			QUOT: 34,
			"Qfr;": 120084,
			"REG;": 174,
			"Rcy;": 1056,
			"Rfr;": 8476,
			"Rho;": 929,
			"Rsh;": 8625,
			"Scy;": 1057,
			"Sfr;": 120086,
			"Sub;": 8912,
			"Sum;": 8721,
			"Sup;": 8913,
			"Tab;": 9,
			"Tau;": 932,
			"Tcy;": 1058,
			"Tfr;": 120087,
			"Ucy;": 1059,
			"Ufr;": 120088,
			Uuml: 220,
			"Vcy;": 1042,
			"Vee;": 8897,
			"Vfr;": 120089,
			"Wfr;": 120090,
			"Xfr;": 120091,
			"Ycy;": 1067,
			"Yfr;": 120092,
			"Zcy;": 1047,
			"Zfr;": 8488,
			"acE;": 8766,
			"acd;": 8767,
			"acy;": 1072,
			"afr;": 120094,
			"amp;": 38,
			"and;": 8743,
			"ang;": 8736,
			"apE;": 10864,
			"ape;": 8778,
			"ast;": 42,
			auml: 228,
			"bcy;": 1073,
			"bfr;": 120095,
			"bne;": 61,
			"bot;": 8869,
			"cap;": 8745,
			cent: 162,
			"cfr;": 120096,
			"chi;": 967,
			"cir;": 9675,
			copy: 169,
			"cup;": 8746,
			"dcy;": 1076,
			"deg;": 176,
			"dfr;": 120097,
			"die;": 168,
			"div;": 247,
			"dot;": 729,
			"ecy;": 1101,
			"efr;": 120098,
			"egs;": 10902,
			"ell;": 8467,
			"els;": 10901,
			"eng;": 331,
			"eta;": 951,
			"eth;": 240,
			euml: 235,
			"fcy;": 1092,
			"ffr;": 120099,
			"gEl;": 10892,
			"gap;": 10886,
			"gcy;": 1075,
			"gel;": 8923,
			"geq;": 8805,
			"ges;": 10878,
			"gfr;": 120100,
			"ggg;": 8921,
			"glE;": 10898,
			"gla;": 10917,
			"glj;": 10916,
			"gnE;": 8809,
			"gne;": 10888,
			"hfr;": 120101,
			"icy;": 1080,
			"iff;": 8660,
			"ifr;": 120102,
			"int;": 8747,
			iuml: 239,
			"jcy;": 1081,
			"jfr;": 120103,
			"kcy;": 1082,
			"kfr;": 120104,
			"lEg;": 10891,
			"lap;": 10885,
			"lat;": 10923,
			"lcy;": 1083,
			"leg;": 8922,
			"leq;": 8804,
			"les;": 10877,
			"lfr;": 120105,
			"lgE;": 10897,
			"lnE;": 8808,
			"lne;": 10887,
			"loz;": 9674,
			"lrm;": 8206,
			"lsh;": 8624,
			macr: 175,
			"map;": 8614,
			"mcy;": 1084,
			"mfr;": 120106,
			"mho;": 8487,
			"mid;": 8739,
			"nGg;": 8921,
			"nGt;": 8811,
			"nLl;": 8920,
			"nLt;": 8810,
			"nap;": 8777,
			nbsp: 160,
			"ncy;": 1085,
			"nfr;": 120107,
			"ngE;": 8807,
			"nge;": 8817,
			"ngt;": 8815,
			"nis;": 8956,
			"niv;": 8715,
			"nlE;": 8806,
			"nle;": 8816,
			"nlt;": 8814,
			"not;": 172,
			"npr;": 8832,
			"nsc;": 8833,
			"num;": 35,
			"ocy;": 1086,
			"ofr;": 120108,
			"ogt;": 10689,
			"ohm;": 937,
			"olt;": 10688,
			"ord;": 10845,
			ordf: 170,
			ordm: 186,
			"orv;": 10843,
			ouml: 246,
			"par;": 8741,
			para: 182,
			"pcy;": 1087,
			"pfr;": 120109,
			"phi;": 966,
			"piv;": 982,
			"prE;": 10931,
			"pre;": 10927,
			"psi;": 968,
			"qfr;": 120110,
			quot: 34,
			"rcy;": 1088,
			"reg;": 174,
			"rfr;": 120111,
			"rho;": 961,
			"rlm;": 8207,
			"rsh;": 8625,
			"scE;": 10932,
			"sce;": 10928,
			"scy;": 1089,
			sect: 167,
			"sfr;": 120112,
			"shy;": 173,
			"sim;": 8764,
			"smt;": 10922,
			"sol;": 47,
			"squ;": 9633,
			"sub;": 8834,
			"sum;": 8721,
			sup1: 185,
			sup2: 178,
			sup3: 179,
			"sup;": 8835,
			"tau;": 964,
			"tcy;": 1090,
			"tfr;": 120113,
			"top;": 8868,
			"ucy;": 1091,
			"ufr;": 120114,
			"uml;": 168,
			uuml: 252,
			"vcy;": 1074,
			"vee;": 8744,
			"vfr;": 120115,
			"wfr;": 120116,
			"xfr;": 120117,
			"ycy;": 1099,
			"yen;": 165,
			"yfr;": 120118,
			yuml: 255,
			"zcy;": 1079,
			"zfr;": 120119,
			"zwj;": 8205,
			AMP: 38,
			"DD;": 8517,
			ETH: 208,
			"GT;": 62,
			"Gg;": 8921,
			"Gt;": 8811,
			"Im;": 8465,
			"LT;": 60,
			"Ll;": 8920,
			"Lt;": 8810,
			"Mu;": 924,
			"Nu;": 925,
			"Or;": 10836,
			"Pi;": 928,
			"Pr;": 10939,
			REG: 174,
			"Re;": 8476,
			"Sc;": 10940,
			"Xi;": 926,
			"ac;": 8766,
			"af;": 8289,
			amp: 38,
			"ap;": 8776,
			"dd;": 8518,
			deg: 176,
			"ee;": 8519,
			"eg;": 10906,
			"el;": 10905,
			eth: 240,
			"gE;": 8807,
			"ge;": 8805,
			"gg;": 8811,
			"gl;": 8823,
			"gt;": 62,
			"ic;": 8291,
			"ii;": 8520,
			"in;": 8712,
			"it;": 8290,
			"lE;": 8806,
			"le;": 8804,
			"lg;": 8822,
			"ll;": 8810,
			"lt;": 60,
			"mp;": 8723,
			"mu;": 956,
			"ne;": 8800,
			"ni;": 8715,
			not: 172,
			"nu;": 957,
			"oS;": 9416,
			"or;": 8744,
			"pi;": 960,
			"pm;": 177,
			"pr;": 8826,
			reg: 174,
			"rx;": 8478,
			"sc;": 8827,
			shy: 173,
			uml: 168,
			"wp;": 8472,
			"wr;": 8768,
			"xi;": 958,
			yen: 165,
			GT: 62,
			LT: 60,
			gt: 62,
			lt: 60
		};
		const Uo = [
			8364,
			129,
			8218,
			402,
			8222,
			8230,
			8224,
			8225,
			710,
			8240,
			352,
			8249,
			338,
			141,
			381,
			143,
			144,
			8216,
			8217,
			8220,
			8221,
			8226,
			8211,
			8212,
			732,
			8482,
			353,
			8250,
			339,
			157,
			382,
			376
		];
		function zo(e) {
			const t = Object.keys(Ho).map(((t) => function(e, t) {
				return t && !e.endsWith(";") ? `${e}\\b(?!=)` : e;
			}(t, e)));
			return new RegExp(`&(#(?:x[a-fA-F\\d]+|\\d+)(?:;)?|${t.join("|")})`, "g");
		}
		const Wo = zo(!1), Go = zo(!0);
		function Ko(e, t) {
			const n = t ? Go : Wo;
			return e.replace(n, ((e, t) => {
				let n;
				return n = "#" !== t[0] ? Ho[t] : "x" === t[1] ? parseInt(t.substring(2), 16) : parseInt(t.substring(1), 10), n ? String.fromCodePoint(function(e) {
					if (10 === e) return 32;
					if (e < 128) return e;
					if (e <= 159) return Uo[e - 128];
					if (e < 55296) return e;
					if (e <= 57343) return Xo;
					if (e <= 65535) return e;
					if (e >= 65536 && e <= 131071) return e;
					if (e >= 131072 && e <= 196607) return e;
					if (e >= 917504 && e <= 917631 || e >= 917760 && e <= 917999) return e;
					return Xo;
				}(n)) : e;
			}));
		}
		const Xo = 0;
		function Qo(e = !1) {
			return {
				type: "Fragment",
				nodes: [],
				metadata: {
					transparent: e,
					dynamic: !1
				}
			};
		}
		const Yo = [
			"SvelteElement",
			"RegularElement",
			"SvelteFragment",
			"Component",
			"SvelteComponent",
			"SvelteSelf",
			"SlotElement"
		];
		function Jo(e) {
			return Yo.includes(e.type);
		}
		function Zo(e) {
			return [
				"Component",
				"SvelteComponent",
				"SvelteSelf"
			].includes(e.type);
		}
		function el(e) {
			return "RegularElement" === e.type && (e.name.includes("-") || e.attributes.some(((e) => "Attribute" === e.type && "is" === e.name)));
		}
		function tl(e, t, n, s, r) {
			return {
				type: "Attribute",
				start: n,
				end: s,
				name: e,
				name_loc: t,
				value: r,
				metadata: {
					delegated: !1,
					needs_clsx: !1
				}
			};
		}
		class nl {
			has_state = !1;
			has_call = !1;
			has_await = !1;
			has_member_expression = !1;
			has_assignment = !1;
			dependencies = /* @__PURE__ */ new Set();
			references = /* @__PURE__ */ new Set();
			#t = null;
			#n() {
				if (!this.#t) {
					this.#t = /* @__PURE__ */ new Set();
					for (const e of this.dependencies) e.blocker && this.#t.add(e.blocker);
				}
				return this.#t;
			}
			blockers() {
				return Wa([...this.#n()]);
			}
			has_blockers() {
				return this.#n().size > 0;
			}
			has_more_blockers_than(e) {
				for (const t of this.#n()) if (!e.#n().has(t)) return !0;
				return !1;
			}
			is_async() {
				return this.has_await || this.#n().size > 0;
			}
			merge(e) {
				this.has_state ||= e.has_state, this.has_call ||= e.has_call, this.has_await ||= e.has_await, this.has_member_expression ||= e.has_member_expression, this.has_assignment ||= e.has_assignment, this.#t = null;
				for (const t of e.references) this.references.add(t);
				for (const t of e.dependencies) this.dependencies.add(t);
			}
		}
		function sl(e) {
			return "Literal" === e.type ? String(e.value) : "PrivateIdentifier" === e.type ? "#" + e.name : "Identifier" === e.type ? e.name : null;
		}
		function rl(e) {
			if ("select" === e.name || "optgroup" === e.name || "option" === e.name) for (const t of al(e.fragment)) if ("RegularElement" === t.type) {
				if ("select" === e.name && "option" !== t.name && "optgroup" !== t.name) return !0;
				if ("optgroup" === e.name && "option" !== t.name) return !0;
				if ("option" === e.name) return !0;
			} else {
				if ("Text" !== t.type) return !0;
				if ("select" === e.name || "optgroup" === e.name) return !0;
			}
			return !1;
		}
		function* al(e) {
			if (null !== e) for (const t of e.nodes) switch (t.type) {
				case "SnippetBlock":
				case "DebugTag":
				case "ConstTag":
				case "Comment":
				case "ExpressionTag": break;
				case "Text":
					"" !== t.data.trim() && (yield t);
					break;
				case "IfBlock":
					yield* al(t.consequent), yield* al(t.alternate);
					break;
				case "EachBlock":
					yield* al(t.body), yield* al(t.fallback ?? null);
					break;
				case "KeyBlock":
				case "SvelteBoundary":
					yield* al(t.fragment);
					break;
				case "AwaitBlock":
					yield* al(t.pending), yield* al(t.then), yield* al(t.catch);
					break;
				default: yield t;
			}
		}
		const il = {
			li: { direct: ["li"] },
			dt: {
				descendant: ["dt", "dd"],
				reset_by: ["dl"]
			},
			dd: {
				descendant: ["dt", "dd"],
				reset_by: ["dl"]
			},
			p: { descendant: [
				"address",
				"article",
				"aside",
				"blockquote",
				"div",
				"dl",
				"fieldset",
				"footer",
				"form",
				"h1",
				"h2",
				"h3",
				"h4",
				"h5",
				"h6",
				"header",
				"hgroup",
				"hr",
				"main",
				"menu",
				"nav",
				"ol",
				"p",
				"pre",
				"section",
				"table",
				"ul"
			] },
			rt: { descendant: ["rt", "rp"] },
			rp: { descendant: ["rt", "rp"] },
			optgroup: { descendant: ["optgroup"] },
			option: { descendant: ["option", "optgroup"] },
			thead: { direct: ["tbody", "tfoot"] },
			tbody: { direct: ["tbody", "tfoot"] },
			tfoot: { direct: ["tbody"] },
			tr: { direct: ["tr", "tbody"] },
			td: { direct: [
				"td",
				"th",
				"tr"
			] },
			th: { direct: [
				"td",
				"th",
				"tr"
			] }
		};
		const ol = {
			...il,
			form: { descendant: ["form"] },
			a: { descendant: ["a"] },
			button: { descendant: ["button"] },
			h1: { descendant: [
				"h1",
				"h2",
				"h3",
				"h4",
				"h5",
				"h6"
			] },
			h2: { descendant: [
				"h1",
				"h2",
				"h3",
				"h4",
				"h5",
				"h6"
			] },
			h3: { descendant: [
				"h1",
				"h2",
				"h3",
				"h4",
				"h5",
				"h6"
			] },
			h4: { descendant: [
				"h1",
				"h2",
				"h3",
				"h4",
				"h5",
				"h6"
			] },
			h5: { descendant: [
				"h1",
				"h2",
				"h3",
				"h4",
				"h5",
				"h6"
			] },
			h6: { descendant: [
				"h1",
				"h2",
				"h3",
				"h4",
				"h5",
				"h6"
			] },
			tr: { only: [
				"th",
				"td",
				"style",
				"script",
				"template"
			] },
			tbody: { only: [
				"tr",
				"style",
				"script",
				"template"
			] },
			thead: { only: [
				"tr",
				"style",
				"script",
				"template"
			] },
			tfoot: { only: [
				"tr",
				"style",
				"script",
				"template"
			] },
			colgroup: { only: ["col", "template"] },
			table: { only: [
				"caption",
				"colgroup",
				"tbody",
				"thead",
				"tfoot",
				"style",
				"script",
				"template"
			] },
			head: { only: [
				"base",
				"basefont",
				"bgsound",
				"link",
				"meta",
				"title",
				"noscript",
				"noframes",
				"style",
				"script",
				"template"
			] },
			html: { only: [
				"head",
				"body",
				"frameset"
			] },
			frameset: { only: ["frame"] },
			"#document": { only: ["html"] }
		};
		function ll(e, t, n, s) {
			if (e.includes("-")) return null;
			const r = t[t.length - 1], a = ol[r];
			if (!a) return null;
			if ("reset_by" in a && a.reset_by) for (let e = t.length - 2; e >= 0; e--) {
				if (t[e].includes("-")) return null;
				if (a.reset_by.includes(t[e])) return null;
			}
			if ("descendant" in a && a.descendant.includes(e)) return `${`\`<${e}>\``} cannot be a descendant of ${`\`<${r}>\``}`;
			return null;
		}
		function cl(e, t, n, s) {
			if (e.includes("-") || t?.includes("-")) return null;
			if ("template" === t) return null;
			const r = ol[t], a = `\`<${e}>\``, i = `\`<${t}>\``;
			if (r) {
				if ("direct" in r && r.direct.includes(e)) return `${a} cannot be a direct child of ${i}`;
				if ("descendant" in r && r.descendant.includes(e)) return `${a} cannot be a child of ${i}`;
				if ("only" in r && r.only) return r.only.includes(e) ? null : `${a} cannot be a child of ${i}. \`<${t}>\` only allows these children: ${r.only.map(((e) => `\`<${e}>\``)).join(", ")}`;
			}
			switch (e) {
				case "body":
				case "caption":
				case "col":
				case "colgroup":
				case "frameset":
				case "frame":
				case "head":
				case "html": return `${a} cannot be a child of ${i}`;
				case "thead":
				case "tbody":
				case "tfoot": return `${a} must be the child of a \`<table>\`, not a ${i}`;
				case "td":
				case "th": return `${a} must be the child of a \`<tr>\`, not a ${i}`;
				case "tr": return `\`<tr>\` must be the child of a \`<thead>\`, \`<tbody>\`, or \`<tfoot>\`, not a ${i}`;
			}
			return null;
		}
		function pl(e, t = "or") {
			return 1 === e.length ? e[0] : 2 === e.length ? `${e[0]} ${t} ${e[1]}` : `${e.slice(0, -1).join(", ")} ${t} ${e[e.length - 1]}`;
		}
		const ul = /^(\/>|[\s"'=<>`])/, dl = /^<\/textarea(\s[^>]*)?>/i, hl = /-->/, ml = /(\s|\/|>)/, fl = /[\s=/>"']/, yl = /^["']/, vl = /^(?:"([^"]*)"|'([^'])*'|([^>\s]+))/;
		const gl = /^(?:\p{Lu}[$\u200c\u200d\p{ID_Continue}.]*|\p{ID_Start}[$\u200c\u200d\p{ID_Continue}]*(?:\.[$\u200c\u200d\p{ID_Continue}]+)+)$/u, bl = new Map([
			["svelte:head", "SvelteHead"],
			["svelte:options", "SvelteOptions"],
			["svelte:window", "SvelteWindow"],
			["svelte:document", "SvelteDocument"],
			["svelte:body", "SvelteBody"]
		]), _l = new Map([
			...bl,
			["svelte:element", "SvelteElement"],
			["svelte:component", "SvelteComponent"],
			["svelte:self", "SvelteSelf"],
			["svelte:fragment", "SvelteFragment"],
			["svelte:boundary", "SvelteBoundary"]
		]);
		function xl(e) {
			const t = e.index++;
			let n = e.current();
			if (e.eat("!--")) {
				const n = e.read_until(hl);
				e.eat("-->", !0), e.append({
					type: "Comment",
					start: t,
					end: e.index,
					data: n
				});
				return;
			}
			if (e.eat("/")) {
				const s = e.read_until(ml);
				for (e.allow_whitespace(), e.eat(">", !0), z(s) && zs(t, "void_element_invalid_content", "Void elements cannot have children or closing tags\nhttps://svelte.dev/e/void_element_invalid_content"); n.name !== s;) {
					if (e.loose && Jo(n)) {
						const t = n.attributes.at(-1);
						if ("Attribute" === t?.type && t.name === `<${s}`) {
							e.index = t.start, n.attributes.pop();
							break;
						}
					}
					if ("RegularElement" === n.type) {
						if (!e.last_auto_closed_tag || e.last_auto_closed_tag.tag !== s) {
							const e = n.fragment.nodes[0]?.start ?? t;
							mt({
								start: n.start,
								end: e
							}, `</${s}>`, `</${n.name}>`);
						}
					} else e.loose || (e.last_auto_closed_tag && e.last_auto_closed_tag.tag === s ? Wr(t, s, e.last_auto_closed_tag.reason) : zr(t, s));
					n.end = t, e.pop(), n = e.current();
				}
				n.end = e.index, e.pop(), e.last_auto_closed_tag && e.stack.length < e.last_auto_closed_tag.depth && (e.last_auto_closed_tag = void 0);
				return;
			}
			const s = Pl(e, ml);
			if (s.name.startsWith("svelte:") && !_l.has(s.name)) (function(e, t) {
				zs(e, "svelte_meta_invalid_tag", `Valid \`<svelte:...>\` tag names are ${t}\nhttps://svelte.dev/e/svelte_meta_invalid_tag`);
			})({
				start: t + 1,
				end: t + 1 + s.name.length
			}, pl(Array.from(_l.keys())));
			if (!(r = s.name, /^![a-zA-Z]+$/.test(r) || /^[a-zA-Z][a-zA-Z0-9]*:[a-zA-Z][a-zA-Z0-9-]*[a-zA-Z0-9]$/.test(r) || he.test(r) || gl.test(s.name) || e.loose && s.name.endsWith("."))) (function(e) {
				zs(e, "tag_invalid_name", "Expected a valid element or component name. Components must have a valid variable name or dot notation expression\nhttps://svelte.dev/e/tag_invalid_name");
			})({
				start: t + 1,
				end: t + 1 + s.name.length
			});
			var r;
			bl.has(s.name) && (s.name in e.meta_tags && function(e, t) {
				zs(e, "svelte_meta_duplicate", `A component can only have one \`<${t}>\` element\nhttps://svelte.dev/e/svelte_meta_duplicate`);
			}(t, s.name), "Root" !== n.type && function(e, t) {
				zs(e, "svelte_meta_invalid_placement", `\`<${t}>\` tags cannot be inside elements or blocks\nhttps://svelte.dev/e/svelte_meta_invalid_placement`);
			}(t, s.name), e.meta_tags[s.name] = !0);
			const a = _l.has(s.name) ? _l.get(s.name) : gl.test(s.name) || e.loose && s.name.endsWith(".") ? "Component" : "title" === s.name && function(e) {
				let t = e.length;
				for (; t--;) {
					const { type: n } = e[t];
					if ("SvelteHead" === n) return !0;
					if ("RegularElement" === n || "Component" === n) return !1;
				}
				return !1;
			}(e.stack) ? "TitleElement" : "slot" !== s.name || function(e) {
				let t = e.length;
				for (; t--;) if ("RegularElement" === e[t].type && e[t].attributes.some(((e) => "Attribute" === e.type && "shadowrootmode" === e.name))) return !0;
				return !1;
			}(e.stack) ? "RegularElement" : "SlotElement", i = "RegularElement" === a ? {
				type: a,
				start: t,
				end: -1,
				name: s.name,
				name_loc: s.loc,
				attributes: [],
				fragment: Qo(!0),
				metadata: {
					svg: !1,
					mathml: !1,
					scoped: !1,
					has_spread: !1,
					path: [],
					synthetic_value_node: null
				}
			} : {
				type: a,
				start: t,
				end: -1,
				name: s.name,
				name_loc: s.loc,
				attributes: [],
				fragment: Qo(!0),
				metadata: {}
			};
			if (e.allow_whitespace(), "RegularElement" === n.type && function(e, t) {
				const n = il[e];
				return !(!n || t && !("direct" in n ? n.direct : n.descendant).includes(t));
			}(n.name, s.name)) {
				const r = n.fragment.nodes[0]?.start ?? t;
				mt({
					start: n.start,
					end: r
				}, `<${s.name}>`, `</${n.name}>`), n.end = t, e.pop(), e.last_auto_closed_tag = {
					tag: n.name,
					reason: s.name,
					depth: e.stack.length
				};
			}
			const o = [], l = e.current(), c = ("script" === s.name || "style" === s.name) && "Root" === l.type, p = c ? wl : kl;
			let u;
			for (; u = p(e);) {
				if ("Attribute" === u.type || "BindDirective" === u.type || "StyleDirective" === u.type || "ClassDirective" === u.type) {
					const e = "BindDirective" === u.type ? "Attribute" : u.type;
					o.includes(e + u.name) ? Rr(u) : "this" !== u.name && o.push(e + u.name);
				}
				i.attributes.push(u), e.allow_whitespace();
			}
			if ("Component" === i.type && (i.metadata.expression = new nl()), "SvelteComponent" === i.type) {
				const e = i.attributes.findIndex(((e) => "Attribute" === e.type && "this" === e.name));
				-1 === e && function(e) {
					zs(e, "svelte_component_missing_this", "`<svelte:component>` must have a 'this' attribute\nhttps://svelte.dev/e/svelte_component_missing_this");
				}(t);
				const n = i.attributes.splice(e, 1)[0];
				Qi(n) || function(e) {
					zs(e, "svelte_component_invalid_this", "Invalid component definition — must be an `{expression}`\nhttps://svelte.dev/e/svelte_component_invalid_this");
				}(n.start), i.expression = Yi(n), i.metadata.expression = new nl();
			}
			if ("SvelteElement" === i.type) {
				const e = i.attributes.findIndex(((e) => "Attribute" === e.type && "this" === e.name));
				-1 === e && va(t);
				const n = i.attributes.splice(e, 1)[0];
				if (!0 === n.value && va(n), Qi(n)) i.tag = Yi(n);
				else {
					(function(e) {
						qe(e, "svelte_element_invalid_this", "`this` should be an `{expression}`. Using a string attribute value will cause an error in future versions of Svelte\nhttps://svelte.dev/e/svelte_element_invalid_this");
					})(n);
					const e = n.value[0];
					i.tag = "Text" === e.type ? {
						type: "Literal",
						value: e.data,
						raw: `'${e.raw}'`,
						start: e.start,
						end: e.end
					} : e.expression;
				}
				i.metadata.expression = new nl();
			}
			if (c) {
				e.eat(">", !0);
				let n = null;
				for (let e = l.fragment.nodes.length - 1; e >= 0; e--) {
					const s = l.fragment.nodes[e];
					if (e === l.fragment.nodes.length - 1 && s.end !== t) break;
					if ("Comment" === s.type) {
						n = s;
						break;
					}
					if ("Text" !== s.type || s.data.trim()) break;
				}
				if ("script" === s.name) {
					const s = function(e, t, n) {
						const s = e.index, r = e.read_until(fo);
						e.index >= e.template.length && Gr(e.template.length, "script");
						const a = e.template.slice(0, s).replace(h, " ") + r;
						let i;
						e.read(yo);
						try {
							i = Fs(a, e.root.comments, e.ts, !0);
						} catch (t) {
							e.acorn_error(t);
						}
						i.start = s, i.loc && ({line: i.loc.start.line, column: i.loc.start.column} = be(t), {line: i.loc.end.line, column: i.loc.end.column} = be(e.index));
						let o = "default";
						for (const e of n) vo.includes(e.name) && (l = e, c = e.name, zs(l, "script_reserved_attribute", `The \`${c}\` attribute is reserved and cannot be used\nhttps://svelte.dev/e/script_reserved_attribute`)), go.includes(e.name) || yt(e), "module" === e.name && (!0 !== e.value && aa(e, e.name), o = "module"), "context" === e.name && (!0 !== e.value && Xi(e) || ia(e), "module" !== e.value[0].data && ia(e), o = "module");
						var l, c;
						return {
							type: "Script",
							start: t,
							end: e.index,
							context: o,
							content: i,
							attributes: n
						};
					}(e, t, i.attributes);
					n && (s.content.leadingComments = [{
						type: "Line",
						value: n.data
					}]), "module" === s.context ? (l.module && ra(t), l.module = s) : (l.instance && ra(t), l.instance = s);
				} else {
					const s = function(e, t, n) {
						const s = e.index, r = Ro(e, ((e) => e.match("</style") || e.index >= e.template.length)), a = e.index;
						return e.eat("</style", !0), e.read(/^\s*>/), {
							type: "StyleSheet",
							start: t,
							end: e.index,
							attributes: n,
							children: r,
							content: {
								start: s,
								end: a,
								styles: e.template.slice(s, a),
								comment: null
							}
						};
					}(e, t, i.attributes);
					s.content.comment = n, l.css && function(e) {
						zs(e, "style_duplicate", "A component can have a single top-level `<style>` element\nhttps://svelte.dev/e/style_duplicate");
					}(t), l.css = s;
				}
				return;
			}
			e.append(i);
			const d = e.eat("/") || z(s.name), m = e.eat(">", !0, !1);
			if (!m) {
				const t = i.attributes.at(-1);
				if ("Attribute" === t?.type && "<" === t.name) e.index = t.start, i.attributes.pop();
				else {
					const t = e.template[e.index - 1], n = e.template[e.index - 2], s = e.template[e.index];
					"{" === n && "/" === t ? e.index -= 2 : "{" !== t || "#" !== s && "@" !== s && ":" !== s ? e.allow_whitespace() : e.index -= 1;
				}
			}
			if (d || !m) i.end = e.index;
			else if ("textarea" === s.name) i.fragment.nodes = Sl(e, (() => dl.test(e.template.slice(e.index))), "inside <textarea>"), e.read(dl), i.end = e.index;
			else if ("script" === s.name || "style" === s.name) {
				const t = e.index, n = e.read_until(new RegExp(`</${s.name}>`)), r = {
					start: t,
					end: e.index,
					type: "Text",
					data: n,
					raw: n
				};
				i.fragment.nodes.push(r), e.eat(`</${s.name}>`, !0), i.end = e.index;
			} else e.stack.push(i), e.fragments.push(i.fragment);
		}
		function wl(e) {
			const t = e.index, n = Pl(e, fl);
			if (!n.name) return null;
			let s = !0;
			if (e.eat("=")) {
				e.allow_whitespace();
				let t = e.match_regex(vl);
				t || Yr(e.index), e.index += t.length;
				const n = "\"" === t[0] || "'" === t[0];
				n && (t = t.slice(1, -1)), s = [{
					start: e.index - t.length - (n ? 1 : 0),
					end: n ? e.index - 1 : e.index,
					type: "Text",
					raw: t,
					data: Ko(t, !0)
				}];
			}
			return e.match_regex(yl) && Zr(e.index, "="), tl(n.name, n.loc, t, e.index, s);
		}
		function kl(e) {
			let t = null;
			for (; t = Cl(e);) e.root.comments.push(t), e.allow_whitespace();
			const n = e.index;
			if (e.eat("{")) {
				if (e.allow_whitespace(), e.eat("@attach")) {
					e.require_whitespace();
					const t = Ua(e);
					e.allow_whitespace(), e.eat("}", !0);
					return {
						type: "AttachTag",
						start: n,
						end: e.index,
						expression: t,
						metadata: { expression: new nl() }
					};
				}
				if (e.eat("...")) {
					const t = Ua(e);
					e.allow_whitespace(), e.eat("}", !0);
					return {
						type: "SpreadAttribute",
						start: n,
						end: e.index,
						expression: t,
						metadata: { expression: new nl() }
					};
				}
				{
					const t = e.read_identifier();
					if ("" === t.name) {
						if (e.loose && (e.match("#") || e.match("/") || e.match("@") || e.match(":"))) return null;
						e.loose && e.match("}") || zs(n, "attribute_empty_shorthand", "Attribute shorthand cannot be empty\nhttps://svelte.dev/e/attribute_empty_shorthand");
					}
					e.allow_whitespace(), e.eat("}", !0);
					const s = {
						type: "ExpressionTag",
						start: t.start,
						end: t.end,
						expression: t,
						metadata: { expression: new nl() }
					};
					return tl(t.name, t.loc, n, e.index, s);
				}
			}
			const s = Pl(e, fl);
			if (!s.name) return null;
			let r = e.index;
			e.allow_whitespace();
			const a = s.name.indexOf(":"), i = -1 !== a && ("use" === (o = s.name.slice(0, a)) ? "UseDirective" : "animate" === o ? "AnimateDirective" : "bind" === o ? "BindDirective" : "class" === o ? "ClassDirective" : "style" === o ? "StyleDirective" : "on" === o ? "OnDirective" : "let" === o ? "LetDirective" : ("in" === o || "out" === o || "transition" === o) && "TransitionDirective");
			var o;
			let l = !0;
			if (e.eat("=")) if (e.allow_whitespace(), "/" === e.template[e.index] && ">" === e.template[e.index + 1]) {
				const t = e.index;
				e.index++, l = [{
					start: t,
					end: t + 1,
					type: "Text",
					raw: "/",
					data: "/"
				}], r = e.index;
			} else l = function(e) {
				const t = e.eat("'") ? "'" : e.eat("\"") ? "\"" : null;
				if (t && e.eat(t)) return [{
					start: e.index - 1,
					end: e.index - 1,
					type: "Text",
					raw: "",
					data: ""
				}];
				let n;
				try {
					n = Sl(e, (() => t ? e.match(t) : !!e.match_regex(ul)), "in attribute value");
				} catch (n) {
					if ("js_parse_error" === n.code) {
						const s = n.position?.[0];
						void 0 !== s && "/>" === e.template.slice(s - 1, s + 1) && (e.index = s, Zr(s, t || "}"));
					}
					throw n;
				}
				0 !== n.length || t || Yr(e.index);
				t && (e.index += 1);
				return t || n.length > 1 || "Text" === n[0].type ? n : n[0];
			}(e), r = e.index;
			else e.match_regex(yl) && Zr(e.index, "=");
			if (i) {
				const [e, ...t] = s.name.slice(a + 1).split("|");
				if ("" === e && function(e, t) {
					zs(e, "directive_missing_name", `\`${t}\` name cannot be empty\nhttps://svelte.dev/e/directive_missing_name`);
				}({
					start: n,
					end: n + a + 1
				}, s.name), "StyleDirective" === i) return {
					start: n,
					end: r,
					type: i,
					name: e,
					name_loc: s.loc,
					modifiers: t,
					value: l,
					metadata: { expression: new nl() }
				};
				const o = !0 === l ? void 0 : Array.isArray(l) ? l[0] : l;
				let c = null;
				if (o) l.length > 1 || "Text" === o.type ? function(e) {
					zs(e, "directive_invalid_value", "Directive value must be a JavaScript expression enclosed in curly braces\nhttps://svelte.dev/e/directive_invalid_value");
				}(o.start) : c = o.expression;
				const p = {
					start: n,
					end: r,
					type: i,
					name: e,
					name_loc: s.loc,
					expression: c,
					metadata: { expression: new nl() }
				};
				if (p.modifiers = t, "TransitionDirective" === p.type) {
					const e = s.name.slice(0, a);
					p.intro = "in" === e || "transition" === e, p.outro = "out" === e || "transition" === e;
				}
				return "BindDirective" !== p.type && "ClassDirective" !== p.type || p.expression || (p.expression = {
					start: n + a + 1,
					end: r,
					type: "Identifier",
					name: p.name
				}), p;
			}
			return tl(s.name, s.loc, n, r, l);
		}
		function Cl(e) {
			const t = e.index;
			if (e.eat("//")) {
				const n = e.read_until(/\n/), s = e.index;
				return {
					type: "Line",
					start: t,
					end: s,
					value: n,
					loc: {
						start: be(t),
						end: be(s)
					}
				};
			}
			if (e.eat("/*")) {
				const n = e.read_until(/\*\//);
				e.eat("*/");
				const s = e.index;
				return {
					type: "Block",
					start: t,
					end: s,
					value: n,
					loc: {
						start: be(t),
						end: be(s)
					}
				};
			}
			return null;
		}
		function Sl(e, t, n) {
			let s = {
				start: e.index,
				end: -1,
				type: "Text",
				raw: "",
				data: ""
			};
			const r = [];
			function a(e) {
				s.raw && (s.data = Ko(s.raw, !0), s.end = e, r.push(s));
			}
			for (; e.index < e.template.length;) {
				const i = e.index;
				if (t()) return a(e.index), r;
				if (e.eat("{")) {
					if (e.match("#")) {
						const t = e.index - 1;
						e.eat("#");
						Br(t, e.read_until(/[^a-z]/), n);
					} else if (e.match("@")) {
						const t = e.index - 1;
						e.eat("@");
						Ta(t, e.read_until(/[^a-z]/), n);
					}
					a(e.index - 1), e.allow_whitespace();
					const t = Ua(e);
					e.allow_whitespace(), e.eat("}", !0);
					const o = {
						type: "ExpressionTag",
						start: i,
						end: e.index,
						expression: t,
						metadata: { expression: new nl() }
					};
					r.push(o), s = {
						start: e.index,
						end: -1,
						type: "Text",
						raw: "",
						data: ""
					};
				} else s.raw += e.template[e.index++];
			}
			if (e.loose) return r;
			qa(e.template.length);
		}
		function Pl(e, t) {
			const n = e.index, s = e.read_until(t), r = e.index;
			return {
				type: "Identifier",
				name: s,
				start: n,
				end: r,
				loc: {
					start: be(n),
					end: be(r)
				}
			};
		}
		function El(e) {
			const t = e.index;
			let n = e.index;
			const s = e.read_identifier();
			if ("" !== s.name) {
				const t = Tl(e);
				return {
					...s,
					typeAnnotation: t
				};
			}
			const r = e.template[n];
			"{" !== r && "[" !== r && zs(n, "expected_pattern", "Expected identifier or destructure pattern\nhttps://svelte.dev/e/expected_pattern"), n = Fa(e, t), e.index = n;
			const a = e.template.slice(t, n);
			try {
				let n = e.template.slice(0, t).replace(h, " ");
				const s = n.indexOf(" ");
				n = n.slice(0, s) + n.slice(s + 1);
				const r = Vs(`${n}(${a} = 1)`, e.root.comments, e.ts, t - 1).left;
				return r.typeAnnotation = Tl(e), r.typeAnnotation && (r.end = r.typeAnnotation.end), r;
			} catch (t) {
				e.acorn_error(t);
			}
		}
		function Tl(e) {
			const t = e.index;
			if (e.allow_whitespace(), !e.eat(":")) return void (e.index = t);
			const n = "_ as ";
			let s = e.index - 5;
			const r = e.template.slice(0, s).replace(/[^\n]/g, " ") + n + e.template.slice(e.index).replace(/\?\s*:/g, ":");
			let a = Vs(r, e.root.comments, e.ts, s);
			if ("AssignmentExpression" === a.type) {
				let t = a.right.start;
				for (; "=" !== r[t];) t -= 1;
				a = Vs(r.slice(0, t), e.root.comments, e.ts, s);
			}
			return "SequenceExpression" === a.type && (a = a.expressions[0]), e.index = a.end, {
				type: "TSTypeAnnotation",
				start: t,
				end: e.index,
				typeAnnotation: a.typeAnnotation
			};
		}
		const Al = /^\s*}/, $l = { "<": ">" };
		function Rl(e) {
			const n = e.index;
			if (e.index += 1, e.allow_whitespace(), e.eat("#")) return function(e) {
				let n = e.index - 2;
				for (; "{" !== e.template[n];) n -= 1;
				if (e.eat("if")) {
					e.require_whitespace();
					const t = e.append({
						type: "IfBlock",
						elseif: !1,
						start: n,
						end: -1,
						test: Ua(e),
						consequent: Qo(),
						alternate: null,
						metadata: { expression: new nl() }
					});
					e.allow_whitespace(), e.eat("}", !0), e.stack.push(t), e.fragments.push(t.consequent);
					return;
				}
				if (e.eat("each")) {
					e.require_whitespace();
					const s = e.template;
					let r, a = e.template.length;
					for (; !r;) try {
						r = Ua(e, void 0, !0);
					} catch (t) {
						for (a = t.position[0] - 2; a > n && "as" !== e.template.slice(a, a + 2);) a -= 1;
						if (a <= n) {
							if (e.loose && (r = Ha(e), r)) break;
							throw t;
						}
						e.template = s.slice(0, a);
					}
					if (e.template = s, e.allow_whitespace(), !e.match("as")) {
						"SequenceExpression" === r.type && (r = r.expressions[0]);
						let n = null, s = r.end;
						if (r = t(r, null, { TSAsExpression(e, t) {
							if (e.end === r.end) return n = e, s = e.expression.end, e.expression;
							t.next();
						} }), r.end = s, n) {
							let t = n.typeAnnotation.start - 2;
							for (; "as" !== e.template.slice(t, t + 2);) t -= 1;
							e.index = t;
						}
					}
					let i, o, l = null;
					e.eat("as") ? (e.require_whitespace(), l = El(e)) : e.index = r.end, e.allow_whitespace(), e.eat(",") && (e.allow_whitespace(), i = e.read_identifier().name, i || Jr(e.index), e.allow_whitespace()), e.eat("(") && (e.allow_whitespace(), o = Ua(e, "("), e.allow_whitespace(), e.eat(")", !0), e.allow_whitespace());
					if (!e.eat("}", !0, !1)) if (" as " === e.template.slice(e.index - 4, e.index)) {
						const t = e.index;
						l = El(e), e.eat("}", !0), r = {
							type: "Identifier",
							name: "",
							start: r.start,
							end: t - 4
						};
					} else e.eat("}", !0);
					const c = e.append({
						type: "EachBlock",
						start: n,
						end: -1,
						expression: r,
						body: Qo(),
						context: l,
						index: i,
						key: o,
						metadata: null
					});
					e.stack.push(c), e.fragments.push(c.body);
					return;
				}
				if (e.eat("await")) {
					e.require_whitespace();
					const t = Ua(e);
					e.allow_whitespace();
					const s = e.append({
						type: "AwaitBlock",
						start: n,
						end: -1,
						expression: t,
						value: null,
						error: null,
						pending: null,
						then: null,
						catch: null,
						metadata: { expression: new nl() }
					});
					e.eat("then") ? (e.match_regex(Al) || (e.require_whitespace(), s.value = El(e)), e.allow_whitespace(), s.then = Qo(), e.fragments.push(s.then)) : e.eat("catch") ? (e.match_regex(Al) || (e.require_whitespace(), s.error = El(e)), e.allow_whitespace(), s.catch = Qo(), e.fragments.push(s.catch)) : (s.pending = Qo(), e.fragments.push(s.pending));
					if (!e.eat("}", !0, !1)) if (" then " === e.template.slice(e.index - 6, e.index)) {
						const n = e.index;
						s.value = El(e), e.eat("}", !0), s.expression = {
							type: "Identifier",
							name: "",
							start: t.start,
							end: n - 6
						}, s.then = s.pending, s.pending = null;
					} else if (" catch " === e.template.slice(e.index - 7, e.index)) {
						const n = e.index;
						s.error = El(e), e.eat("}", !0), s.expression = {
							type: "Identifier",
							name: "",
							start: t.start,
							end: n - 7
						}, s.catch = s.pending, s.pending = null;
					} else e.eat("}", !0);
					e.stack.push(s);
					return;
				}
				if (e.eat("key")) {
					e.require_whitespace();
					const t = Ua(e);
					e.allow_whitespace(), e.eat("}", !0);
					const s = e.append({
						type: "KeyBlock",
						start: n,
						end: -1,
						expression: t,
						fragment: Qo(),
						metadata: { expression: new nl() }
					});
					e.stack.push(s), e.fragments.push(s.fragment);
					return;
				}
				if (e.eat("snippet")) {
					e.require_whitespace();
					const t = e.read_identifier();
					"" !== t.name || e.loose || Jr(e.index), e.allow_whitespace();
					const s = e.index;
					let r;
					if (e.ts && e.match("<")) {
						const t = e.index, n = Fa(e, t, $l);
						r = e.template.slice(t + 1, n - 1), e.index = n;
					}
					e.allow_whitespace();
					const a = e.eat("(", !0, !1);
					if (a) {
						let t = 1;
						for (; e.index < e.template.length && (!e.match(")") || 1 !== t);) e.match("(") && t++, e.match(")") && t--, e.index += 1;
						e.eat(")", !0);
					}
					const i = e.template.slice(0, s).replace(/\S/g, " "), o = e.template.slice(s, e.index);
					let l = a ? Vs(i + `${o} => {}`, e.root.comments, e.ts, s) : { params: [] };
					e.allow_whitespace(), e.eat("}", !0);
					const c = e.append({
						type: "SnippetBlock",
						start: n,
						end: -1,
						expression: t,
						typeParams: r,
						parameters: l.params,
						body: Qo(),
						metadata: {
							can_hoist: !1,
							sites: /* @__PURE__ */ new Set()
						}
					});
					e.stack.push(c), e.fragments.push(c.body);
					return;
				}
				s = e.index, zs(s, "expected_block_type", "Expected 'if', 'each', 'await', 'key' or 'snippet'\nhttps://svelte.dev/e/expected_block_type");
				var s;
			}(e);
			if (e.eat(":")) return function(e) {
				const t = e.index - 1, n = e.current();
				if ("IfBlock" === n.type) {
					if (e.eat("else") || Zr(t, "{:else} or {:else if}"), e.eat("if") && zs(t, "block_invalid_elseif", "'elseif' should be 'else if'\nhttps://svelte.dev/e/block_invalid_elseif"), e.allow_whitespace(), e.fragments.pop(), n.alternate = Qo(), e.fragments.push(n.alternate), e.eat("if")) {
						e.require_whitespace();
						const n = Ua(e);
						e.allow_whitespace(), e.eat("}", !0);
						let s = t - 1;
						for (; "{" !== e.template[s];) s -= 1;
						const r = e.append({
							start: s,
							end: -1,
							type: "IfBlock",
							elseif: !0,
							test: n,
							consequent: Qo(),
							alternate: null,
							metadata: { expression: new nl() }
						});
						e.stack.push(r), e.fragments.pop(), e.fragments.push(r.consequent);
					} else e.allow_whitespace(), e.eat("}", !0);
					return;
				}
				if ("EachBlock" === n.type) return e.eat("else") || Zr(t, "{:else}"), e.allow_whitespace(), e.eat("}", !0), n.fallback = Qo(), e.fragments.pop(), void e.fragments.push(n.fallback);
				if ("AwaitBlock" === n.type) {
					if (e.eat("then")) return n.then && jr(t, "{:then}"), e.eat("}") || (e.require_whitespace(), n.value = El(e), e.allow_whitespace(), e.eat("}", !0)), n.then = Qo(), e.fragments.pop(), void e.fragments.push(n.then);
					if (e.eat("catch")) return n.catch && jr(t, "{:catch}"), e.eat("}") || (e.require_whitespace(), n.error = El(e), e.allow_whitespace(), e.eat("}", !0)), n.catch = Qo(), e.fragments.pop(), void e.fragments.push(n.catch);
					Zr(t, "{:then ...} or {:catch ...}");
				}
				(function(e) {
					zs(e, "block_invalid_continuation_placement", "{:...} block is invalid at this position (did you forget to close the preceding element or block?)\nhttps://svelte.dev/e/block_invalid_continuation_placement");
				})(t);
			}(e);
			if (e.eat("@")) return function(e) {
				let t = e.index;
				for (; "{" !== e.template[t];) t -= 1;
				if (e.eat("html")) {
					e.require_whitespace();
					const n = Ua(e);
					e.allow_whitespace(), e.eat("}", !0), e.append({
						type: "HtmlTag",
						start: t,
						end: e.index,
						expression: n,
						metadata: { expression: new nl() }
					});
					return;
				}
				if (e.eat("debug")) {
					let n;
					if (e.read(Al)) n = [];
					else {
						const t = Ua(e);
						n = "SequenceExpression" === t.type ? t.expressions : [t], n.forEach(((e) => {
							"Identifier" !== e.type && function(e) {
								zs(e, "debug_tag_invalid_arguments", "{@debug ...} arguments must be identifiers, not arbitrary expressions\nhttps://svelte.dev/e/debug_tag_invalid_arguments");
							}(e.start);
						})), e.allow_whitespace(), e.eat("}", !0);
					}
					e.append({
						type: "DebugTag",
						start: t,
						end: e.index,
						identifiers: n
					});
					return;
				}
				if (e.eat("const")) {
					e.require_whitespace();
					const n = El(e);
					e.allow_whitespace(), e.eat("=", !0), e.allow_whitespace();
					const s = e.index, r = Ua(e);
					"SequenceExpression" !== r.type || e.template.substring(s, r.start).includes("(") || zs(r, "const_tag_invalid_expression", "{@const ...} must consist of a single variable declaration\nhttps://svelte.dev/e/const_tag_invalid_expression"), e.allow_whitespace(), e.eat("}", !0), e.append({
						type: "ConstTag",
						start: t,
						end: e.index,
						declaration: {
							type: "VariableDeclaration",
							kind: "const",
							declarations: [{
								type: "VariableDeclarator",
								id: n,
								init: r,
								start: n.start,
								end: r.end
							}],
							start: t + 2,
							end: e.index - 1
						},
						metadata: { expression: new nl() }
					});
					return;
				}
				if (e.eat("render")) {
					e.require_whitespace();
					const n = Ua(e);
					"CallExpression" === n.type || "ChainExpression" === n.type && "CallExpression" === n.expression.type || function(e) {
						zs(e, "render_tag_invalid_expression", "`{@render ...}` tags can only contain call expressions\nhttps://svelte.dev/e/render_tag_invalid_expression");
					}(n), e.allow_whitespace(), e.eat("}", !0), e.append({
						type: "RenderTag",
						start: t,
						end: e.index,
						expression: n,
						metadata: {
							expression: new nl(),
							dynamic: !1,
							arguments: [],
							path: [],
							snippets: /* @__PURE__ */ new Set()
						}
					});
					return;
				}
				(function(e) {
					zs(e, "expected_tag", "Expected 'html', 'render', 'attach', 'const', or 'debug'\nhttps://svelte.dev/e/expected_tag");
				})(e.index);
			}(e);
			if (e.match("/") && !e.match("/*") && !e.match("//")) return e.eat("/"), Il(e);
			const s = Ua(e);
			e.allow_whitespace(), e.eat("}", !0), e.append({
				type: "ExpressionTag",
				start: n,
				end: e.index,
				expression: s,
				metadata: { expression: new nl() }
			});
		}
		function Il(e) {
			const t = e.index - 1;
			let n, s = e.current();
			switch (s.type) {
				case "IfBlock":
					if (n = e.eat("if", !0, !1), !n) return s.end = t - 1, e.pop(), void Il(e);
					for (e.allow_whitespace(), e.eat("}", !0); s.elseif;) s.end = e.index, e.stack.pop(), s = e.current();
					s.end = e.index, e.pop();
					return;
				case "EachBlock":
					n = e.eat("each", !0, !1);
					break;
				case "KeyBlock":
					n = e.eat("key", !0, !1);
					break;
				case "AwaitBlock":
					n = e.eat("await", !0, !1);
					break;
				case "SnippetBlock":
					n = e.eat("snippet", !0, !1);
					break;
				case "RegularElement":
					e.loose ? n = !1 : Vr(t);
					break;
				default: Vr(t);
			}
			if (!n) return s.end = t - 1, e.pop(), void Il(e);
			e.allow_whitespace(), e.eat("}", !0), s.end = e.index, e.pop();
		}
		function Ml(e) {
			const t = e.index;
			let n = "";
			for (; e.index < e.template.length && !e.match("<") && !e.match("{");) n += e.template[e.index++];
			e.append({
				type: "Text",
				start: t,
				end: e.index,
				raw: n,
				data: Ko(n, !1)
			});
		}
		function ql(e) {
			return e.match("<") ? xl : e.match("{") ? Rl : Ml;
		}
		function Ll(e) {
			const { value: t } = e;
			if (!0 === t) return !0;
			const n = Array.isArray(t) ? t[0] : t;
			return !n || (t.length > 1 ? null : "Text" === n.type ? n.data : "Literal" !== n.expression.type ? null : n.expression.value);
		}
		function Ol(e) {
			const t = Ll(e);
			return "boolean" != typeof t && wa(e, "true or false"), t;
		}
		const Nl = "[a-z0-9_.·À-ÖØ-öø-ͽͿ-῿‌-‍‿-⁀⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�𐀀-󯿿-]", Dl = new RegExp(`^[a-z]${Nl}*-${Nl}*$`, "u"), jl = [
			"annotation-xml",
			"color-profile",
			"font-face",
			"font-face-src",
			"font-face-uri",
			"font-face-format",
			"font-face-name",
			"missing-glyph"
		];
		function Bl(e, t) {
			"string" != typeof t && Pa(e), t && (Dl.test(t) ? jl.includes(t) && zs(e, "svelte_options_reserved_tagname", "Tag name is reserved\nhttps://svelte.dev/e/svelte_options_reserved_tagname") : Pa(e));
		}
		function Fl(e) {
			const { nodes: t } = e.fragment;
			if (t.length > 0) {
				const n = t[0], s = t[t.length - 1];
				(function(e, t) {
					zs(e, "svelte_meta_invalid_content", `<${t}> cannot have children\nhttps://svelte.dev/e/svelte_meta_invalid_content`);
				})({
					start: n.start,
					end: s.end
				}, e.name);
			}
		}
		const Vl = / \(\d+:\d+\)$/, Hl = /<!--[^]*?-->|<script\s+(?:[^>]*|(?:[^=>'"/]+=(?:"[^"]*"|'[^']*'|[^>\s]+)\s+)*)lang=(["'])?([^"' >]+)\1[^>]*>/g;
		class Ul {
			template;
			loose;
			index = 0;
			static forCss(e) {
				const t = Object.create(Ul.prototype);
				return t.template = e, t.index = 0, t.loose = !1, t;
			}
			ts = !1;
			stack = [];
			fragments = [];
			root;
			meta_tags = {};
			last_auto_closed_tag;
			constructor(e, t) {
				if ("string" != typeof e) throw new TypeError("Template must be a string");
				let n;
				this.loose = t, this.template = e.trimEnd();
				do
					n = Hl.exec(e);
				while (n && "s" !== n[0][1]);
				Hl.lastIndex = 0, this.ts = "ts" === n?.[2], this.root = {
					css: null,
					js: [],
					start: null,
					end: null,
					type: "Root",
					fragment: Qo(),
					options: null,
					comments: [],
					metadata: { ts: this.ts }
				}, this.stack.push(this.root), this.fragments.push(this.root.fragment);
				let s = ql;
				for (; this.index < this.template.length;) s = s(this) || ql;
				if (this.stack.length > 1) {
					const e = this.current();
					this.loose ? e.end = this.template.length : "RegularElement" === e.type ? (e.end = e.start + 1, Gr(e, e.name)) : (e.end = e.start + 1, zs(e, "block_unclosed", "Block was left open\nhttps://svelte.dev/e/block_unclosed"));
				}
				s !== ql && qa(this.index), this.root.start = 0, this.root.end = e.length;
				const r = this.root.fragment.nodes.findIndex(((e) => "SvelteOptions" === e.type));
				if (-1 !== r) {
					const e = this.root.fragment.nodes[r];
					this.root.fragment.nodes.splice(r, 1), this.root.options = function(e) {
						const t = {
							start: e.start,
							end: e.end,
							attributes: e.attributes
						};
						if (!e) return t;
						for (const n of e.attributes) {
							"Attribute" !== n.type && xa(n);
							const { name: e } = n;
							switch (e) {
								case "runes":
									t.runes = Ol(n);
									break;
								case "tag":
									_a(n);
									break;
								case "customElement": {
									const e = {}, { value: s } = n, r = !0 === s || Array.isArray(s) ? s : [s];
									if (!0 === r) ka(n);
									else {
										if ("Text" === r[0].type) {
											const s = Ll(n);
											Bl(n, s), e.tag = s, t.customElement = e;
											break;
										}
										if ("ObjectExpression" !== r[0].expression.type) {
											if ("Literal" === r[0].expression.type && null === r[0].expression.value) break;
											ka(n);
										}
									}
									const a = [];
									for (const e of r[0].expression.properties) ("Property" !== e.type || e.computed || "Identifier" !== e.key.type) && ka(n), a.push([e.key.name, e.value]);
									const i = a.find((([e]) => "tag" === e));
									if (i) {
										const t = i[1]?.value;
										Bl(i, t), e.tag = t;
									}
									const o = a.find((([e]) => "props" === e))?.[1];
									if (o) {
										"ObjectExpression" !== o.type && Ca(n), e.props = {};
										for (const t of o.properties) {
											("Property" !== t.type || t.computed || "Identifier" !== t.key.type || "ObjectExpression" !== t.value.type) && Ca(n), e.props[t.key.name] = {};
											for (const s of t.value.properties) ("Property" !== s.type || s.computed || "Identifier" !== s.key.type || "Literal" !== s.value.type) && Ca(n), "type" === s.key.name ? (-1 === [
												"String",
												"Number",
												"Boolean",
												"Array",
												"Object"
											].indexOf(s.value.value) && Ca(n), e.props[t.key.name].type = s.value.value) : "reflect" === s.key.name ? ("boolean" != typeof s.value.value && Ca(n), e.props[t.key.name].reflect = s.value.value) : "attribute" === s.key.name ? ("string" != typeof s.value.value && Ca(n), e.props[t.key.name].attribute = s.value.value) : Ca(n);
										}
									}
									const l = a.find((([e]) => "shadow" === e))?.[1];
									l && ("Literal" !== l.type || "open" !== l.value && "none" !== l.value ? "ObjectExpression" === l.type ? e.shadow = l : Sa(n) : e.shadow = l.value);
									const c = a.find((([e]) => "extend" === e))?.[1];
									c && (e.extend = c), t.customElement = e;
									break;
								}
								case "namespace": {
									const e = Ll(n);
									e === I ? t.namespace = "svg" : e === M ? t.namespace = "mathml" : "html" === e || "mathml" === e || "svg" === e ? t.namespace = e : wa(n, "\"html\", \"mathml\" or \"svg\"");
									break;
								}
								case "css": {
									const e = Ll(n);
									"injected" === e ? t.css = e : wa(n, "\"injected\"");
									break;
								}
								case "immutable":
									t.immutable = Ol(n);
									break;
								case "preserveWhitespace":
									t.preserveWhitespace = Ol(n);
									break;
								case "accessors":
									t.accessors = Ol(n);
									break;
								default: Ea(n, e);
							}
						}
						return t;
					}(e), Fl(e), Object.defineProperty(this.root.options, "__raw__", {
						value: e,
						enumerable: !1
					});
				}
			}
			current() {
				return this.stack[this.stack.length - 1];
			}
			acorn_error(e) {
				var t = e.pos;
				zs(t, "js_parse_error", `${e.message.replace(Vl, "")}\nhttps://svelte.dev/e/js_parse_error`);
			}
			eat(e, t = !1, n = !0) {
				return this.match(e) ? (this.index += e.length, !0) : (!t || this.loose && !n || Zr(this.index, e), !1);
			}
			match(e) {
				const t = e.length;
				return 1 === t ? this.template[this.index] === e : this.template.slice(this.index, this.index + t) === e;
			}
			match_regex(e) {
				const t = e.exec(this.template.slice(this.index));
				return t && 0 === t.index ? t[0] : null;
			}
			allow_whitespace() {
				for (; this.index < this.template.length && s.test(this.template[this.index]);) this.index++;
			}
			read(e) {
				const t = this.match_regex(e);
				return t && (this.index += t.length), t;
			}
			read_identifier() {
				const e = this.index;
				let t = e, n = "";
				const s = this.template.codePointAt(this.index);
				if (Mt(s, !0)) {
					for (this.index, t += s <= 65535 ? 1 : 2; t < this.template.length;) {
						const e = this.template.codePointAt(t);
						if (!qt(e, !0)) break;
						t += e <= 65535 ? 1 : 2;
					}
					n = this.template.slice(e, t), this.index = t, G(n) && zs(e, "unexpected_reserved_word", `'${n}' is a reserved word in JavaScript and cannot be used here\nhttps://svelte.dev/e/unexpected_reserved_word`);
				}
				return {
					type: "Identifier",
					name: n,
					start: e,
					end: t,
					loc: {
						start: be(e),
						end: be(t)
					}
				};
			}
			read_until(e) {
				if (this.index >= this.template.length) {
					if (this.loose) return "";
					qa(this.template.length);
				}
				const t = this.index, n = e.exec(this.template.slice(t));
				return n ? (this.index = t + n.index, this.template.slice(t, this.index)) : (this.index = this.template.length, this.template.slice(t));
			}
			require_whitespace() {
				s.test(this.template[this.index]) || zs(this.index, "expected_whitespace", "Expected whitespace\nhttps://svelte.dev/e/expected_whitespace"), this.allow_whitespace();
			}
			pop() {
				return this.fragments.pop(), this.stack.pop();
			}
			append(e) {
				return this.fragments.at(-1)?.nodes.push(e), e;
			}
		}
		function zl(e, t = !1) {
			ke(e);
			return new Ul(e, t).root;
		}
		function Wl(e, t) {
			return "Identifier" === e.params[0]?.type && "this" === e.params[0].name && e.params.shift(), t.next();
		}
		const Gl = {
			_(e, t) {
				const n = t.next() ?? e;
				delete n.typeAnnotation, delete n.typeParameters, delete n.typeArguments, delete n.returnType, delete n.accessibility, delete n.readonly, delete n.definite, delete n.override;
			},
			Decorator(e) {
				yr(e, "decorators (related TSC proposal is not stage 4 yet)");
			},
			ImportDeclaration(e) {
				if ("type" === e.importKind) return oi;
				if (e.specifiers?.length > 0) {
					const t = e.specifiers.filter(((e) => "type" !== e.importKind));
					return 0 === t.length ? oi : {
						...e,
						specifiers: t
					};
				}
				return e;
			},
			ExportNamedDeclaration(e, t) {
				if ("type" === e.exportKind) return oi;
				if (e.declaration) {
					const e = t.next();
					return "EmptyStatement" === e?.declaration?.type ? oi : e;
				}
				if (e.specifiers) {
					const t = e.specifiers.filter(((e) => "type" !== e.exportKind));
					return 0 === t.length ? oi : {
						...e,
						specifiers: t
					};
				}
				return e;
			},
			ExportDefaultDeclaration: (e) => "type" === e.exportKind ? oi : e,
			ExportAllDeclaration: (e) => "type" === e.exportKind ? oi : e,
			PropertyDefinition: (e, { next: t }) => (e.accessor && yr(e, "accessor fields (related TSC proposal is not stage 4 yet)"), t()),
			TSAsExpression: (e, t) => t.visit(e.expression),
			TSSatisfiesExpression: (e, t) => t.visit(e.expression),
			TSNonNullExpression: (e, t) => t.visit(e.expression),
			TSInterfaceDeclaration: () => oi,
			TSTypeAliasDeclaration: () => oi,
			TSTypeAssertion: (e, t) => t.visit(e.expression),
			TSEnumDeclaration(e) {
				yr(e, "enums");
			},
			TSParameterProperty: (e, t) => ((e.readonly || e.accessibility) && "constructor" === t.path.at(-2)?.kind && yr(e, "accessibility modifiers on constructor parameters"), t.visit(e.parameter)),
			TSInstantiationExpression: (e, t) => t.visit(e.expression),
			FunctionExpression: Wl,
			FunctionDeclaration: Wl,
			TSDeclareFunction: () => oi,
			ClassBody(e, t) {
				const n = [];
				for (const s of e.body) {
					const e = t.visit(s);
					"PropertyDefinition" === e.type && e.declare || n.push(e);
				}
				return {
					...e,
					body: n
				};
			},
			ClassDeclaration: (e, t) => e.declare ? oi : (delete e.abstract, delete e.implements, delete e.superTypeArguments, t.next()),
			ClassExpression: (e, t) => (delete e.implements, delete e.superTypeArguments, t.next()),
			MethodDefinition: (e, t) => e.abstract ? oi : t.next(),
			VariableDeclaration: (e, t) => e.declare ? oi : t.next(),
			TSModuleDeclaration(e, t) {
				if (!e.body) return oi;
				return e.body.body.map(((e) => t.visit(e))).some(((e) => e !== oi)) && yr(e, "namespaces with non-type nodes"), oi;
			}
		};
		function Kl(e) {
			return t(e, null, Gl);
		}
		function Xl(e, t) {
			if ("MemberExpression" === e.type) return !e.computed && Xl(e.object, e);
			if ("Identifier" !== e.type) return !1;
			switch (t?.type) {
				case "MemberExpression": return t.computed || e === t.object;
				case "MethodDefinition": return t.computed;
				case "MetaProperty": return t.meta === e;
				case "PropertyDefinition":
				case "Property": return t.computed || e === t.value;
				case "ExportSpecifier":
				case "ImportSpecifier": return e === t.local;
				case "LabeledStatement":
				case "BreakStatement":
				case "ContinueStatement": return !1;
				default: return !0;
			}
		}
		function Ql(e) {
			if (!Jo(e)) return null;
			for (const t of e.attributes) if ("Attribute" === t.type && "slot" === t.name && Xi(t)) return t.value[0].data;
			return null;
		}
		function Yl(e, t, n) {
			if (Jl(e, t, n.state.scope, "BindDirective" === e.type), "Identifier" === t.type) {
				const s = n.state.scope.get(t.name);
				n.state.analysis.runes && (null != n.state.analysis.props_id && s?.node === n.state.analysis.props_id && Gs(e, "$props.id()"), "each" === s?.kind && function(e) {
					zs(e, "each_item_invalid_assignment", "Cannot reassign or bind to each block argument in runes mode. Use the array and index variables instead (e.g. `array[i] = value` instead of `entry = value`, or `bind:value={array[i]}` instead of `bind:value={entry}`)\nhttps://svelte.dev/e/each_item_invalid_assignment");
				}(e)), "snippet" === s?.kind && function(e) {
					zs(e, "snippet_parameter_assignment", "Cannot reassign or bind to snippet parameter\nhttps://svelte.dev/e/snippet_parameter_assignment");
				}(e);
			}
			if ("MemberExpression" === t.type && "ThisExpression" === t.object.type) {
				const s = t.computed && "Literal" !== t.property.type ? null : sl(t.property), r = null !== s && n.state.state_fields?.get(s);
				if (r && "AssignmentExpression" === r.node.type && e !== r.node) {
					let t = n.path.length;
					for (; t--;) {
						const s = n.path[t];
						if ("FunctionDeclaration" === s.type || "FunctionExpression" === s.type || "ArrowFunctionExpression" === s.type) {
							const s = io(n.path, t - 1);
							"MethodDefinition" === s.type && "constructor" === s.kind && e.start < r.node.start && dr(e);
							break;
						}
					}
				}
			}
		}
		function Jl(e, t, n, s) {
			if ("ArrayPattern" === t.type) for (const r of t.elements) r && Jl(e, r, n, s);
			else if ("ObjectPattern" === t.type) for (const r of t.properties) "Property" === r.type && Jl(e, r.value, n, s);
			else if ("Identifier" === t.type) {
				const r = n.get(t.name);
				if ("import" === r?.declaration_kind || "const" === r?.declaration_kind && "each" !== r.kind) {
					const t = "import" === r.declaration_kind ? "import" : "constant";
					s ? function(e, t) {
						zs(e, "constant_binding", `Cannot bind to ${t}\nhttps://svelte.dev/e/constant_binding`);
					}(e, t) : Gs(e, t);
				}
			}
		}
		function Zl(e, t, n) {
			t.analysis.source[e.start + 1] !== n && Fr({
				start: e.start,
				end: e.start + 5
			}, n);
		}
		function ec(e, t) {
			e && (1 !== e.nodes.length || "Text" !== e.nodes[0].type || e.nodes[0].raw.trim() || function(e) {
				qe(e, "block_empty", "Empty block\nhttps://svelte.dev/e/block_empty");
			}(e.nodes[0]));
		}
		function tc(e, t) {
			let n = e;
			for (; "MemberExpression" === n.type;) n = n.object;
			if ("Identifier" !== n.type) return !1;
			const s = t.get(n.name);
			return !s || ("store_sub" === s.kind ? tc({
				name: n.name.slice(1),
				type: "Identifier"
			}, t) : "import" !== s.declaration_kind && "prop" !== s.kind && "bindable_prop" !== s.kind && "rest_prop" !== s.kind);
		}
		function nc(e, t) {
			if ("Literal" === e.type) return !0;
			if ("CallExpression" === e.type) {
				if (!nc(e.callee, t)) return !1;
				for (let n of e.arguments) if (!nc("SpreadElement" === n.type ? n.argument : n, t)) return !1;
				return !0;
			}
			if ("Identifier" !== e.type && "MemberExpression" !== e.type) return !1;
			if ("$effect.tracking" === xc(ei(e), t.state.scope)) return !1;
			let n = e;
			for (; "MemberExpression" === n.type;) n = n.object;
			if (!n) return !1;
			if ("Identifier" === n.type) {
				if (null === t.state.scope.get(n.name)) return !0;
			} else if (nc(n, t)) return !0;
			return !1;
		}
		function sc(e, t) {
			if (!e) return;
			const n = e.declaration_kind;
			if ("synthetic" !== n && "param" !== n && "rest_param" !== n && (!t || t <= 1)) {
				const t = e.node;
				"$" === t.name ? function(e) {
					zs(e, "dollar_binding_invalid", "The $ name is reserved, and cannot be used for variables and imports\nhttps://svelte.dev/e/dollar_binding_invalid");
				}(t) : !t.name.startsWith("$") || "ImportDeclaration" === e.initial?.type && "type" === e.initial.importKind || function(e) {
					zs(e, "dollar_prefix_invalid", "The $ prefix is reserved, and cannot be used for variables and imports\nhttps://svelte.dev/e/dollar_prefix_invalid");
				}(t);
			}
		}
		function rc(e, t, n) {
			const s = t.get(n);
			s && ("derived" === s.kind && Xs(e), "state" !== s.kind && "raw_state" !== s.kind || !s.reassigned || hr(e));
		}
		const ac = Symbol("unknown"), ic = Symbol("number"), oc = Symbol("string"), lc = Symbol("string"), cc = {
			BigInt: [ic],
			"Math.min": [ic, Math.min],
			"Math.max": [ic, Math.max],
			"Math.random": [ic],
			"Math.floor": [ic, Math.floor],
			"Math.f16round": [ic, Math.f16round],
			"Math.round": [ic, Math.round],
			"Math.abs": [ic, Math.abs],
			"Math.acos": [ic, Math.acos],
			"Math.asin": [ic, Math.asin],
			"Math.atan": [ic, Math.atan],
			"Math.atan2": [ic, Math.atan2],
			"Math.ceil": [ic, Math.ceil],
			"Math.cos": [ic, Math.cos],
			"Math.sin": [ic, Math.sin],
			"Math.tan": [ic, Math.tan],
			"Math.exp": [ic, Math.exp],
			"Math.log": [ic, Math.log],
			"Math.pow": [ic, Math.pow],
			"Math.sqrt": [ic, Math.sqrt],
			"Math.clz32": [ic, Math.clz32],
			"Math.imul": [ic, Math.imul],
			"Math.sign": [ic, Math.sign],
			"Math.log10": [ic, Math.log10],
			"Math.log2": [ic, Math.log2],
			"Math.log1p": [ic, Math.log1p],
			"Math.expm1": [ic, Math.expm1],
			"Math.cosh": [ic, Math.cosh],
			"Math.sinh": [ic, Math.sinh],
			"Math.tanh": [ic, Math.tanh],
			"Math.acosh": [ic, Math.acosh],
			"Math.asinh": [ic, Math.asinh],
			"Math.atanh": [ic, Math.atanh],
			"Math.trunc": [ic, Math.trunc],
			"Math.fround": [ic, Math.fround],
			"Math.cbrt": [ic, Math.cbrt],
			Number: [ic, Number],
			"Number.isInteger": [ic, Number.isInteger],
			"Number.isFinite": [ic, Number.isFinite],
			"Number.isNaN": [ic, Number.isNaN],
			"Number.isSafeInteger": [ic, Number.isSafeInteger],
			"Number.parseFloat": [ic, Number.parseFloat],
			"Number.parseInt": [ic, Number.parseInt],
			String: [oc, String],
			"String.fromCharCode": [oc, String.fromCharCode],
			"String.fromCodePoint": [oc, String.fromCodePoint]
		}, pc = {
			"Math.PI": Math.PI,
			"Math.E": Math.E,
			"Math.LN10": Math.LN10,
			"Math.LN2": Math.LN2,
			"Math.LOG10E": Math.LOG10E,
			"Math.LOG2E": Math.LOG2E,
			"Math.SQRT2": Math.SQRT2,
			"Math.SQRT1_2": Math.SQRT1_2
		};
		class uc {
			scope;
			node;
			kind;
			declaration_kind;
			initial = null;
			references = [];
			assignments = [];
			legacy_dependencies = [];
			legacy_indirect_bindings = /* @__PURE__ */ new Set();
			prop_alias = null;
			metadata = null;
			mutated = !1;
			reassigned = !1;
			blocker = null;
			constructor(e, t, n, s, r) {
				this.scope = e, this.node = t, this.initial = r, this.kind = n, this.declaration_kind = s, r && this.assignments.push({
					value: r,
					scope: e
				});
			}
			get updated() {
				return this.mutated || this.reassigned;
			}
			is_function() {
				if (this.updated) return !1;
				const e = this.initial?.type;
				return "ArrowFunctionExpression" === e || "FunctionExpression" === e || "FunctionDeclaration" === e;
			}
		}
		class dc {
			values;
			is_known = !0;
			has_unknown = !1;
			is_defined = !0;
			is_string = !0;
			is_number = !0;
			is_primitive = !0;
			is_function = !0;
			value = void 0;
			constructor(e, t, n) {
				switch (mc.set(t, this), this.values = n, t.type) {
					case "Literal":
						this.values.add(t.value);
						break;
					case "Identifier": {
						const n = e.get(t.name);
						if (n) {
							if ("CallExpression" === n.initial?.type && "$props.id" === xc(n.initial, e)) {
								this.values.add(oc);
								break;
							}
							const s = "prop" === n.kind || "rest_prop" === n.kind || "bindable_prop" === n.kind;
							if ("EachBlock" === n.initial?.type && n.initial.index === t.name) {
								this.values.add(ic);
								break;
							}
							if ("SnippetBlock" === n.initial?.type) {
								this.is_defined = !0, this.is_known = !1, this.values.add(ac);
								break;
							}
							if (!n.updated && null !== n.initial && !s) {
								n.scope.evaluate(n.initial, this.values);
								break;
							}
						} else if ("undefined" === t.name) {
							this.values.add(void 0);
							break;
						}
						this.values.add(ac);
						break;
					}
					case "BinaryExpression": {
						const n = e.evaluate(t.left), s = e.evaluate(t.right);
						if (n.is_known && s.is_known) {
							this.values.add(fc[t.operator](n.value, s.value));
							break;
						}
						switch (t.operator) {
							case "!=":
							case "!==":
							case "<":
							case "<=":
							case ">":
							case ">=":
							case "==":
							case "===":
							case "in":
							case "instanceof":
								this.values.add(!0), this.values.add(!1);
								break;
							case "%":
							case "&":
							case "*":
							case "**":
							case "-":
							case "/":
							case "<<":
							case ">>":
							case ">>>":
							case "^":
							case "|":
								this.values.add(ic);
								break;
							case "+":
								n.is_string || s.is_string ? this.values.add(oc) : (n.is_number && s.is_number || this.values.add(oc), this.values.add(ic));
								break;
							default: this.values.add(ac);
						}
						break;
					}
					case "ConditionalExpression": {
						const n = e.evaluate(t.test), s = e.evaluate(t.consequent), r = e.evaluate(t.alternate);
						if (n.is_known) for (const e of (n.value ? s : r).values) this.values.add(e);
						else {
							for (const e of s.values) this.values.add(e);
							for (const e of r.values) this.values.add(e);
						}
						break;
					}
					case "LogicalExpression": {
						const n = e.evaluate(t.left), s = e.evaluate(t.right);
						if (n.is_known) {
							if (s.is_known) {
								this.values.add(vc[t.operator](n.value, s.value));
								break;
							}
							if ("&&" === t.operator && !n.value || "||" === t.operator && n.value || "??" === t.operator && null != n.value) this.values.add(n.value);
							else for (const e of s.values) this.values.add(e);
							break;
						}
						for (const e of n.values) this.values.add(e);
						for (const e of s.values) this.values.add(e);
						break;
					}
					case "UnaryExpression": {
						const n = e.evaluate(t.argument);
						if (n.is_known) {
							this.values.add(yc[t.operator](n.value));
							break;
						}
						switch (t.operator) {
							case "!":
							case "delete":
								this.values.add(!1), this.values.add(!0);
								break;
							case "+":
							case "-":
							case "~":
								this.values.add(ic);
								break;
							case "typeof":
								this.values.add(oc);
								break;
							case "void":
								this.values.add(void 0);
								break;
							default: this.values.add(ac);
						}
						break;
					}
					case "CallExpression": {
						const n = wc(t.callee, e);
						if (n) {
							if (de(n)) {
								const s = t.arguments[0];
								switch (n) {
									case "$state":
									case "$state.raw":
									case "$derived":
										s ? e.evaluate(s, this.values) : this.values.add(void 0);
										break;
									case "$props.id":
										this.values.add(oc);
										break;
									case "$effect.tracking":
										this.values.add(!1), this.values.add(!0);
										break;
									case "$derived.by":
										if ("ArrowFunctionExpression" === s?.type && "BlockStatement" !== s.body.type) {
											e.evaluate(s.body, this.values);
											break;
										}
										this.values.add(ac);
										break;
									default: this.values.add(ac);
								}
								break;
							}
							if (Object.hasOwn(cc, n) && t.arguments.every(((e) => "SpreadElement" !== e.type))) {
								const [s, r] = cc[n], a = t.arguments.map(((t) => e.evaluate(t)));
								r && a.every(((e) => e.is_known)) ? this.values.add(r(...a.map(((e) => e.value)))) : this.values.add(s);
								break;
							}
						}
						this.values.add(ac);
						break;
					}
					case "TemplateLiteral": {
						let n = t.quasis[0].value.cooked;
						for (let s = 0; s < t.expressions.length; s += 1) {
							const r = e.evaluate(t.expressions[s]);
							if (!r.is_known) {
								this.values.add(oc);
								break;
							}
							n += r.value + t.quasis[s + 1].value.cooked;
						}
						this.values.add(n);
						break;
					}
					case "MemberExpression": {
						const n = wc(t, e);
						if (n && Object.hasOwn(pc, n)) {
							this.values.add(pc[n]);
							break;
						}
						this.values.add(ac);
						break;
					}
					case "ArrowFunctionExpression":
					case "FunctionExpression":
					case "FunctionDeclaration":
						this.values.add(lc);
						break;
					default: this.values.add(ac);
				}
				for (const e of this.values) this.value = e, e !== oc && "string" != typeof e && (this.is_string = !1), e !== ic && "number" != typeof e && (this.is_number = !1), e !== lc && (this.is_function = !1), null != e && e !== ac || (this.is_defined = !1), e === ac && (this.has_unknown = !0, this.is_primitive = !1);
				(this.values.size > 1 || "symbol" == typeof this.value) && (this.is_known = !1), mc.delete(t);
			}
		}
		class hc {
			root;
			parent;
			#s;
			declarations = /* @__PURE__ */ new Map();
			declarators = /* @__PURE__ */ new Map();
			references = /* @__PURE__ */ new Map();
			function_depth = 0;
			tracing = null;
			constructor(e, t, n) {
				this.root = e, this.parent = t, this.#s = n, this.function_depth = t ? t.function_depth + (n ? 0 : 1) : 0;
			}
			declare(e, t, n, s = null) {
				if (this.parent) {
					if ("var" === n && this.#s) return this.parent.declare(e, t, n);
					if ("import" === n) return this.parent.declare(e, t, n, s);
				}
				if (this.declarations.has(e.name)) {
					const t = this.declarations.get(e.name);
					t && "var" !== t.declaration_kind && "var" !== n && function(e, t) {
						zs(e, "declaration_duplicate", `\`${t}\` has already been declared\nhttps://svelte.dev/e/declaration_duplicate`);
					}(e, e.name);
				}
				const r = new uc(this, e, t, n, s);
				return sc(r, this.function_depth), this.declarations.set(e.name, r), this.root.conflicts.add(e.name), r;
			}
			child(e = !1) {
				return new hc(this.root, this, e);
			}
			generate(e) {
				if (this.#s) return this.parent.generate(e);
				let t = e = e.replace(/[^a-zA-Z0-9_$]/g, "_").replace(/^[0-9]/, "_"), n = 1;
				for (; this.references.has(t) || this.declarations.has(t) || this.root.conflicts.has(t) || G(t);) t = `${e}_${n++}`;
				return this.references.set(t, []), this.root.conflicts.add(t), t;
			}
			get(e) {
				return this.declarations.get(e) ?? this.parent?.get(e) ?? null;
			}
			get_bindings(e) {
				const t = this.declarators.get(e);
				if (!t) throw new Error("No binding found for declarator");
				return t;
			}
			owner(e) {
				return this.declarations.has(e) ? this : this.parent && this.parent.owner(e);
			}
			reference(e, t) {
				t = [...t];
				let n = this.references.get(e.name);
				n || this.references.set(e.name, n = []), n.push({
					node: e,
					path: t
				});
				const s = this.declarations.get(e.name);
				s ? s.references.push({
					node: e,
					path: t
				}) : this.parent ? this.parent.reference(e, t) : this.root.conflicts.add(e.name);
			}
			evaluate(e, t = /* @__PURE__ */ new Set()) {
				return mc.get(e) || new dc(this, e, t);
			}
		}
		const mc = /* @__PURE__ */ new Map(), fc = {
			"!=": (e, t) => e != t,
			"!==": (e, t) => e !== t,
			"<": (e, t) => e < t,
			"<=": (e, t) => e <= t,
			">": (e, t) => e > t,
			">=": (e, t) => e >= t,
			"==": (e, t) => e == t,
			"===": (e, t) => e === t,
			in: (e, t) => e in t,
			instanceof: (e, t) => e instanceof t,
			"%": (e, t) => e % t,
			"&": (e, t) => e & t,
			"*": (e, t) => e * t,
			"**": (e, t) => e ** t,
			"+": (e, t) => e + t,
			"-": (e, t) => e - t,
			"/": (e, t) => e / t,
			"<<": (e, t) => e << t,
			">>": (e, t) => e >> t,
			">>>": (e, t) => e >>> t,
			"^": (e, t) => e ^ t,
			"|": (e, t) => e | t
		}, yc = {
			"-": (e) => -e,
			"+": (e) => +e,
			"!": (e) => !e,
			"~": (e) => ~e,
			typeof: (e) => typeof e,
			void: () => {},
			delete: () => !0
		}, vc = {
			"||": (e, t) => e || t,
			"&&": (e, t) => e && t,
			"??": (e, t) => e ?? t
		};
		class gc {
			conflicts = /* @__PURE__ */ new Set();
			unique(e) {
				let t = e = e.replace(/[^a-zA-Z0-9_$]/g, "_"), n = 1;
				for (; this.conflicts.has(t);) t = `${e}_${n++}`;
				this.conflicts.add(t);
				return ui(t);
			}
		}
		function bc(e, n, s, r) {
			const a = /* @__PURE__ */ new Map(), i = new hc(n, r, !1);
			a.set(e, i);
			const o = { scope: i }, l = [], c = [], p = [];
			function u(e, t) {
				for (const n of t) for (const t of to(n)) e.declare(t, "normal", "RestElement" === n.type ? "rest_param" : "param");
			}
			const d = (e, { state: t, next: n }) => {
				const s = t.scope.child(!0);
				a.set(e, s), n({ scope: s });
			}, h = (e, { state: t, next: n }) => {
				const s = t.scope.child();
				a.set(e, s), n({ scope: s });
			}, m = (e, t) => {
				e.metadata.scopes = { default: t.state.scope.child() }, "SvelteComponent" === e.type && t.visit(e.expression);
				const n = Ql(e) ? t.state : { scope: e.metadata.scopes.default };
				for (const s of e.attributes) "LetDirective" === s.type ? t.visit(s, n) : t.visit(s);
				for (const s of e.fragment.nodes) {
					let r = n;
					const a = Ql(s);
					null !== a && (e.metadata.scopes[a] = t.state.scope.child(), r = { scope: e.metadata.scopes[a] }), t.visit(s, r);
				}
			}, f = (e, { state: t, path: n, visit: s }) => {
				t.scope.reference(ui(e.name.split(".")[0]), n), e.expression && s(e.expression);
			};
			let y = !1;
			t(e, o, {
				AwaitExpression(e, t) {
					y ||= t.path.every((({ type: e }) => "ArrowFunctionExpression" !== e && "FunctionExpression" !== e && "FunctionDeclaration" !== e)), t.next();
				},
				Identifier(e, { path: t, state: n }) {
					const s = t.at(-1);
					s && Xl(e, s) && !s.type.startsWith("TS") && l.push([n.scope, {
						node: e,
						path: t.slice()
					}]);
				},
				LabeledStatement(e, { path: t, next: n }) {
					if (t.length > 1 || !s) return n();
					if ("$" !== e.label.name) return n();
					const r = o.scope.child();
					if (a.set(e, r), "ExpressionStatement" === e.body.type && "AssignmentExpression" === e.body.expression.type) for (const t of to(e.body.expression.left)) t.name.startsWith("$") || p.push(t);
					n({ scope: r });
				},
				SvelteFragment: h,
				SlotElement: h,
				SvelteElement: h,
				RegularElement: h,
				LetDirective(e, t) {
					const n = t.state.scope, s = [];
					if (n.declarators.set(e, s), e.expression) for (const r of so(e.expression)) {
						const a = n.declare(r, "template", "const");
						n.reference(r, [t.path[t.path.length - 1], e]), s.push(a);
					}
					else {
						const r = {
							name: e.name,
							type: "Identifier",
							start: e.start,
							end: e.end
						}, a = n.declare(r, "template", "const");
						n.reference(r, [t.path[t.path.length - 1], e]), s.push(a);
					}
				},
				Component: (e, t) => {
					t.state.scope.reference(ui(e.name.split(".")[0]), t.path), m(e, t);
				},
				SvelteSelf: m,
				SvelteComponent: m,
				AssignmentExpression(e, { state: t, next: n }) {
					c.push([
						t.scope,
						e.left,
						e.right
					]), n();
				},
				UpdateExpression(e, { state: t, next: n }) {
					const s = e.argument;
					c.push([
						t.scope,
						s,
						s
					]), n();
				},
				ImportDeclaration(e, { state: t }) {
					for (const n of e.specifiers) t.scope.declare(n.local, "normal", "import", e);
				},
				FunctionExpression(e, { state: t, next: n }) {
					const s = t.scope.child(!0);
					a.set(e, s), e.id && s.declare(e.id, "normal", "function"), u(s, e.params), n({ scope: s });
				},
				FunctionDeclaration(e, { state: t, next: n }) {
					e.id && t.scope.declare(e.id, "normal", "function", e);
					const s = t.scope.child(!0);
					a.set(e, s), u(s, e.params), n({ scope: s });
				},
				ArrowFunctionExpression(e, { state: t, next: n }) {
					const s = t.scope.child(!0);
					a.set(e, s), u(s, e.params), n({ scope: s });
				},
				ForStatement: d,
				ForInStatement: d,
				ForOfStatement: d,
				SwitchStatement: d,
				BlockStatement(e, t) {
					const n = t.path.at(-1);
					if ("FunctionDeclaration" === n?.type || "FunctionExpression" === n?.type || "ArrowFunctionExpression" === n?.type) {
						const n = t.state.scope.child();
						a.set(e, n), t.next({ scope: n });
					} else d(e, t);
				},
				ClassDeclaration(e, { state: t, next: n }) {
					e.id && t.scope.declare(e.id, "normal", "let", e), n();
				},
				VariableDeclaration(e, { state: t, path: n, next: s }) {
					const r = "ConstTag" === n.at(-1)?.type;
					for (const n of e.declarations) {
						const s = [];
						t.scope.declarators.set(n, s);
						for (const a of to(n.id)) {
							const i = t.scope.declare(a, r ? "template" : "normal", e.kind, n.init);
							i.metadata = { is_template_declaration: !0 }, s.push(i);
						}
					}
					s();
				},
				CatchClause(e, { state: t, next: n }) {
					if (e.param) {
						const s = t.scope.child(!0);
						a.set(e, s);
						for (const t of to(e.param)) s.declare(t, "normal", "let");
						n({ scope: s });
					} else n();
				},
				EachBlock(e, { state: n, visit: s }) {
					s(e.expression);
					const r = n.scope.child();
					if (a.set(e, r), e.context) {
						for (const n of to(e.context)) {
							const s = r.declare(n, "each", "const");
							let a = !1, i = !1;
							t(e.context, null, {
								Identifier(e) {
									a && e === n && (i = !0);
								},
								RestElement(e, { next: t }) {
									const n = a;
									a = !0, t(), a = n;
								}
							}), s.metadata = { inside_rest: i };
						}
						s(e.context, { scope: r });
					}
					if (e.index) {
						const t = e.key && ("Identifier" !== e.key.type || !e.index || e.key.name !== e.index);
						r.declare(ui(e.index), t ? "template" : "static", "const", e);
					}
					e.key && s(e.key, { scope: r });
					for (const t of e.body.nodes) s(t, { scope: r });
					e.fallback && s(e.fallback, { scope: r }), e.metadata = {
						expression: new nl(),
						keyed: !1,
						contains_group_binding: !1,
						index: r.root.unique("$$index"),
						declarations: r.declarations,
						is_controlled: !1,
						transitive_deps: /* @__PURE__ */ new Set()
					};
				},
				AwaitBlock(e, t) {
					if (t.visit(e.expression), e.pending && t.visit(e.pending), e.then && (t.visit(e.then), e.value)) {
						const n = a.get(e.then), s = t.state.scope.child();
						a.set(e.value, s), t.visit(e.value, { scope: s });
						for (const t of to(e.value)) n.declare(t, "template", "const"), s.declare(t, "normal", "const");
					}
					if (e.catch && (t.visit(e.catch), e.error)) {
						const n = a.get(e.catch), s = t.state.scope.child();
						a.set(e.error, s), t.visit(e.error, { scope: s });
						for (const t of to(e.error)) n.declare(t, "template", "const"), s.declare(t, "normal", "const");
					}
				},
				SnippetBlock(e, t) {
					const n = t.state;
					n.scope.declare(e.expression, "normal", "function", e);
					const s = n.scope.child();
					a.set(e, s);
					for (const t of e.parameters) for (const e of to(t)) s.declare(e, "snippet", "let");
					t.next({ scope: s });
				},
				Fragment: (e, t) => {
					const n = t.state.scope.child(e.metadata.transparent);
					a.set(e, n), t.next({ scope: n });
				},
				BindDirective(e, t) {
					if ("SequenceExpression" !== e.expression.type) {
						const n = e.expression;
						c.push([
							t.state.scope,
							n,
							n
						]);
					}
					t.next();
				},
				TransitionDirective: f,
				AnimateDirective: f,
				UseDirective: f,
				StyleDirective(e, { path: t, state: n, next: s }) {
					!0 === e.value && n.scope.reference(ui(e.name), t.concat(e)), s();
				}
			});
			for (const e of p) i.get(e.name) || i.declare(e, "legacy_reactive", "let");
			for (const [e, { node: t, path: n }] of l) e.reference(t, n);
			for (const [e, t, n] of c) for (const s of eo(t)) {
				const t = Ki(s), r = t && e.get(t.name);
				null !== r && t !== r.node && (t === s ? (r.reassigned = !0, r.assignments.push({
					value: n,
					scope: e
				})) : r.mutated = !0);
			}
			return {
				has_await: y,
				scope: i,
				scopes: a
			};
		}
		function _c(e, { next: t, state: n }) {
			const s = n.scopes.get(e);
			t(void 0 !== s && s !== n.scope ? {
				...n,
				scope: s
			} : n);
		}
		function xc(e, t) {
			if (!e) return null;
			if ("CallExpression" !== e.type) return null;
			const n = wc(e.callee, t);
			return n && de(n) ? n : null;
		}
		function wc(e, t) {
			let n = e, s = "";
			for (; "MemberExpression" === n.type;) {
				if (n.computed) return null;
				if ("Identifier" !== n.property.type) return null;
				s = "." + n.property.name + s, n = n.object;
			}
			if ("CallExpression" === n.type && "Identifier" === n.callee.type && (s = "()" + s, n = n.callee), "Identifier" !== n.type) return null;
			return null !== t.get(n.name) ? null : n.name + s;
		}
		function kc(e) {
			const t = e.reduce(((e, t) => {
				const [n, s] = t;
				return e.has(n) || e.set(n, []), e.has(s) || e.set(s, []), e.get(n).push(s), e;
			}), /* @__PURE__ */ new Map()), n = /* @__PURE__ */ new Set(), s = /* @__PURE__ */ new Set(), r = [];
			function a(e) {
				n.add(e), s.add(e), t.get(e)?.forEach(((e) => {
					n.has(e) ? s.has(e) && r.push([...s, e]) : a(e);
				})), s.delete(e);
			}
			return t.forEach(((e, t) => {
				n.has(t) || a(t);
			})), r[0];
		}
		const Cc = /^-((webkit)|(moz)|(o)|(ms))-/, Sc = /^[\s,;}]$/;
		function Pc(e) {
			return e.replace(Cc, "");
		}
		const Ec = (e) => "keyframes" === Pc(e.name), Tc = {};
		function Ac(e, t, n, s = !1) {
			if (!n.has(Tc)) if ("Literal" === e.type) n.add(String(e.value));
			else if ("ConditionalExpression" === e.type) Ac(e.consequent, t, n, s), Ac(e.alternate, t, n, s);
			else if ("LogicalExpression" === e.type) if ("&&" === e.operator) {
				const r = /* @__PURE__ */ new Set();
				if (Ac(e.left, t, r, s), r.has(Tc)) t && s || (n.add(""), n.add(!1), n.add(NaN), n.add(0));
				else for (const e of r) e || null == e || t && s || n.add(e);
				Ac(e.right, t, n, s);
			} else Ac(e.left, t, n, s), Ac(e.right, t, n, s);
			else if (t && "ArrayExpression" === e.type) for (const s of e.elements) s && Ac(s, t, n, !0);
			else if (t && "ObjectExpression" === e.type) for (const t of e.properties) "Property" !== t.type || t.computed || "Identifier" !== t.key.type && "Literal" !== t.key.type ? n.add(Tc) : n.add("Identifier" === t.key.type ? t.key.name : String(t.key.value));
			else n.add(Tc);
		}
		function $c(e, t) {
			const n = /* @__PURE__ */ new Set();
			return "Text" === e.type ? n.add(e.data) : Ac(e.expression, t, n), n.has(Tc) ? null : [...n].map(((e) => String(e)));
		}
		function Rc(e) {
			const t = e.selectors[0];
			return "PseudoClassSelector" === t.type && "global" === t.name && (null === t.args || e.selectors.every(((e) => Ic(e) || "PseudoElementSelector" === e.type)));
		}
		function Ic(e) {
			return "PseudoClassSelector" === e.type && ("has" !== e.name && "is" !== e.name && "where" !== e.name && ("not" !== e.name || null === e.args || e.args.children.every(((e) => 1 === e.children.length))) || null === e.args || e.args.children.every(((e) => e.children.every(((e) => Rc(e))))));
		}
		function Mc(e) {
			return "PseudoClassSelector" === e.type && "global" === e.name && null === e.args;
		}
		function qc(e) {
			return e.filter(((e) => "Rule" === e.type)).every(((e) => e.metadata.has_global_selectors));
		}
		const Lc = {
			Atrule(e, t) {
				Ec(e) && (e.prelude.startsWith("-global-") || t.path.some(((e) => "Rule" === e.type && e.metadata.is_global_block)) ? e.prelude.startsWith("-global-") && (t.state.analysis.css.has_global ||= qc(t.path)) : t.state.keyframes.push(e.prelude)), t.next();
			},
			ComplexSelector(e, t) {
				t.next();
				{
					const n = e.children.find(Rc);
					if (n) {
						"PseudoClassSelector" === t.path.at(-2)?.type && !n.selectors[0].args && function(e) {
							zs(e, "css_global_block_invalid_placement", "A `:global` selector cannot be inside a pseudoclass\nhttps://svelte.dev/e/css_global_block_invalid_placement");
						}(n.selectors[0]);
						const s = e.children.indexOf(n);
						if (null !== n.selectors[0].args && 0 !== s && s !== e.children.length - 1) for (let t = s + 1; t < e.children.length; t++) Rc(e.children[t]) || kr(n.selectors[0]);
					}
				}
				for (const t of e.children) for (let n = 0; n < t.selectors.length; n++) {
					const s = t.selectors[n];
					if ("PseudoClassSelector" === s.type && "global" === s.name) "TypeSelector" === (s.args?.children[0].children[0])?.selectors[0].type && 0 !== n && Sr(s), "TypeSelector" === t.selectors[n + 1]?.type && Er(t.selectors[n + 1]), null !== s.args && s.args.children.length > 1 && (e.children.length > 1 || t.selectors.length > 1) && Cr(s);
				}
				if (e.metadata.rule = t.state.rule, e.metadata.is_global = e.children.every((({ metadata: e }) => e.is_global || e.is_global_like)), e.metadata.used ||= e.metadata.is_global, e.metadata.rule?.metadata.parent_rule && "NestingSelector" === e.children[0]?.selectors[0]?.type) {
					const t = e.children[0]?.selectors[1], n = "PseudoClassSelector" !== t?.type || Ic(t), s = e.metadata.rule.metadata.parent_rule.prelude.children.some(((e) => 1 === e.children.length && e.children[0].metadata.is_global));
					n && s && (e.metadata.used = !0);
				}
			},
			RelativeSelector(e, n) {
				const s = n.path.at(-1);
				if (null == e.combinator || n.state.rule?.metadata.parent_rule || s.children[0] !== e || "PseudoClassSelector" === n.path.at(-3)?.type || Pr(e.combinator), e.metadata.is_global = e.selectors.length >= 1 && Rc(e), e.selectors.length >= 1 && e.selectors.every(((e) => "PseudoClassSelector" === e.type || "PseudoElementSelector" === e.type))) {
					const t = e.selectors[0];
					e.metadata.is_global_like ||= "PseudoClassSelector" === t.type && "host" === t.name || "PseudoElementSelector" === t.type && [
						"view-transition",
						"view-transition-group",
						"view-transition-old",
						"view-transition-new",
						"view-transition-image-pair"
					].includes(t.name);
				}
				if (e.metadata.is_global_like ||= e.selectors.some(((e) => "PseudoClassSelector" === e.type && "root" === e.name)) && !e.selectors.some(((e) => "PseudoClassSelector" === e.type && "has" === e.name)), e.metadata.is_global_like || e.metadata.is_global) for (const n of e.selectors) t(n, null, { ComplexSelector(e, t) {
					e.metadata.used = !0, t.next();
				} });
				n.next();
			},
			Rule(e, n) {
				e.metadata.parent_rule = n.state.rule;
				for (const n of e.prelude.children) {
					let s = !1;
					for (let r = 0; r < n.children.length; r++) {
						const a = n.children[r], i = a.selectors.findIndex(Mc);
						if (s && (a.metadata.is_global_like = !0), 0 === i) if (a.selectors.length > 1 && 0 === r && null === e.metadata.parent_rule) wr(a.selectors[1]);
						else {
							e.metadata.is_global_block = s = !0;
							for (let e = 1; e < a.selectors.length; e++) t(a.selectors[e], null, { ComplexSelector(e) {
								e.metadata.used = !0;
							} });
							a.combinator && " " !== a.combinator.name && gr(a, a.combinator.name);
							const r = e.block.children.find(((e) => "Declaration" === e.type)), i = 1 === n.children.length && 1 === n.children[0].selectors.length;
							i && e.prelude.children.length > 1 && _r(e.prelude), r && 1 === e.prelude.children.length && i && br(r);
						}
						else -1 !== i && xr(a.selectors[i]);
					}
					e.metadata.is_global_block && !s && _r(e.prelude);
				}
				const s = {
					...n.state,
					rule: e
				};
				n.visit(e.prelude, s);
				for (const t of e.prelude.children) e.metadata.has_global_selectors ||= t.metadata.is_global, e.metadata.has_local_selectors ||= !t.metadata.is_global;
				n.state.analysis.css.has_global ||= e.metadata.has_global_selectors && e.block.children.filter(((e) => "Declaration" === e.type)).length > 0 && qc(n.path), n.visit(e.block, s);
			},
			NestingSelector(e, t) {
				const n = t.state.rule, s = n.metadata.parent_rule;
				if (s) s.metadata.is_global_block && !s.metadata.parent_rule && 1 === s.prelude.children[0].children.length && 1 === s.prelude.children[0].children[0].selectors.length && wr(e);
				else {
					const t = n.prelude.children, s = t[0].children[0].selectors;
					(t.length > 1 || s.length > 1 || "PseudoClassSelector" !== s[0].type || "global" !== s[0].name || s[0].args?.children[0]?.children[0].selectors[0] !== e) && function(e) {
						zs(e, "css_nesting_selector_invalid_placement", "Nesting selectors can only be used inside a rule or as the first selector inside a lone `:global(...)`\nhttps://svelte.dev/e/css_nesting_selector_invalid_placement");
					}(e);
				}
				t.next();
			}
		};
		const Oc = 0, Nc = 1, Dc = 0, jc = 1, Bc = new Map([["details", ["open"]], ["dialog", ["open"]]]), Fc = new Set([
			"accept-charset",
			"autocapitalize",
			"autocomplete",
			"behavior",
			"charset",
			"crossorigin",
			"decoding",
			"dir",
			"direction",
			"draggable",
			"enctype",
			"enterkeyhint",
			"fetchpriority",
			"formenctype",
			"formmethod",
			"formtarget",
			"hidden",
			"http-equiv",
			"inputmode",
			"kind",
			"loading",
			"method",
			"preload",
			"referrerpolicy",
			"rel",
			"rev",
			"role",
			"rules",
			"scope",
			"shape",
			"spellcheck",
			"target",
			"translate",
			"type",
			"valign",
			"wrap"
		]), Vc = {
			type: "Combinator",
			name: " ",
			start: -1,
			end: -1
		}, Hc = {
			type: "RelativeSelector",
			start: -1,
			end: -1,
			combinator: null,
			selectors: [{
				type: "NestingSelector",
				name: "&",
				start: -1,
				end: -1
			}],
			metadata: {
				is_global: !1,
				is_global_like: !1,
				scoped: !1
			}
		}, Uc = {
			type: "RelativeSelector",
			start: -1,
			end: -1,
			combinator: null,
			selectors: [{
				type: "TypeSelector",
				name: "*",
				start: -1,
				end: -1
			}],
			metadata: {
				is_global: !1,
				is_global_like: !1,
				scoped: !1
			}
		}, zc = /* @__PURE__ */ new Set();
		function Wc(e, n) {
			t(e, null, {
				Rule(e, t) {
					e.metadata.is_global_block ? t.visit(e.prelude) : t.next();
				},
				ComplexSelector(e) {
					const t = Gc(e);
					zc.clear(), Xc(t, e.metadata.rule, n, jc) && (e.metadata.used = !0);
				}
			});
		}
		function Gc(e) {
			const n = Kc(e);
			if (e.metadata.rule?.metadata.parent_rule && n.length > 0) {
				let e = !1;
				for (let s of n) if (t(s, null, { NestingSelector() {
					e = !0;
				} }), e) break;
				e || (null === n[0].combinator && (n[0] = {
					...n[0],
					combinator: Vc
				}), n.unshift(Hc));
			}
			return n;
		}
		function Kc(e) {
			const t = e.children.findLastIndex((({ metadata: e, selectors: t }) => {
				const n = t[0];
				return !(e.is_global_like || "PseudoClassSelector" === n.type && "global" === n.name && null === n.args || e.is_global);
			}));
			return e.children.slice(0, t + 1).map(((e) => !e.selectors.find(((e) => "PseudoClassSelector" === e.type && "root" === e.name)) || e.metadata.is_global_like ? e : {
				...e,
				selectors: e.selectors.filter(((e) => "PseudoClassSelector" === e.type && "has" === e.name))
			}));
		}
		function Xc(e, n, s, r) {
			const a = e.slice(), i = r === Dc ? a.shift() : a.pop(), o = !!i && function(e, n, s, r) {
				const a = [], i = [];
				for (const t of e.selectors) "PseudoClassSelector" === t.type && "has" === t.name && t.args ? a.push(t) : i.push(t);
				if (a.length > 0) {
					const e = function(e) {
						const t = [];
						for (; e;) t.push(e), e = e.metadata.parent_rule;
						return t;
					}(n), t = e.some(((e) => e.prelude.children.some(((t) => t.children.some(((t) => Qc(t, e))))))) || e[e.length - 1].prelude.children.some(((e) => e.children.some(((e) => e.selectors.some(((e) => "PseudoClassSelector" === e.type && ("root" === e.name || "global" === e.name && e.args)))))));
					for (const e of a) {
						const r = e.args.children;
						let a = !1;
						for (const e of r) {
							const [r, ...i] = Kc(e);
							if (!r) {
								e.metadata.used = !0, a = !0;
								continue;
							}
							if (t) Xc([r.combinator ? {
								...r,
								combinator: null
							} : r, ...i], n, s, Dc) && (e.metadata.used = !0, a = !0);
							Xc([
								Uc,
								r.combinator ? r : {
									...r,
									combinator: Vc
								},
								...i
							], n, s, Dc) && (e.metadata.used = !0, a = !0);
						}
						if (!a) return !1;
					}
				}
				for (const a of i) {
					if ("Percentage" === a.type || "Nth" === a.type) continue;
					const i = a.name.replace(Yc, "$1");
					switch (a.type) {
						case "PseudoClassSelector":
							if ("host" === i || "root" === i) return !1;
							if ("global" === i && null !== a.args && 1 === e.selectors.length) return Xc(a.args.children[0].children, n, s, jc);
							if ("global" === i && null === a.args) return !0;
							if ("not" === i && a.args) {
								for (const e of a.args.children) {
									t(e, null, { ComplexSelector(e, t) {
										e.metadata.used = !0, t.next();
									} });
									const n = Kc(e);
									if (e.children.length > 1) {
										for (const e of n) e.metadata.scoped = !0;
										let e = s;
										for (; e;) e.metadata.scoped = !0, e = np(e);
									}
								}
								break;
							}
							if (("is" === i || "where" === i) && a.args) {
								let e = !1;
								for (const t of a.args.children) {
									const r = Kc(t);
									if (0 === r.length) t.metadata.used = !0, e = !0;
									else if (Xc(r, n, s, jc)) t.metadata.used = !0, e = !0;
									else if (t.children.length > 1 && ("is" == i || "where" == i)) {
										t.metadata.used = !0, e = !0;
										for (const e of r) e.metadata.scoped = !0;
									}
								}
								if (!e) return !1;
							}
							break;
						case "PseudoElementSelector": break;
						case "AttributeSelector":
							if (!Bc.get(s.name.toLowerCase())?.includes(a.name.toLowerCase()) && !Zc(s, a.name, a.value && ep(a.value), a.matcher, (a.flags?.includes("i") ?? !1) || !a.flags?.includes("s") && Fc.has(a.name.toLowerCase()))) return !1;
							break;
						case "ClassSelector":
							if (!Zc(s, "class", i, "~=", !1)) return !1;
							break;
						case "IdSelector":
							if (!Zc(s, "id", i, "=", !1)) return !1;
							break;
						case "TypeSelector":
							if (s.name.toLowerCase() !== i.toLowerCase() && "*" !== i && "SvelteElement" !== s.type) return !1;
							break;
						case "NestingSelector": {
							let e = !1;
							const t = n.metadata.parent_rule;
							for (const n of t.prelude.children) (Xc(Gc(n), t, s, r) || n.children.every(((e) => Qc(e, t)))) && (n.metadata.used = !0, e = !0);
							if (!e) return !1;
							break;
						}
					}
				}
				return !0;
			}(i, n, s, r) && function(e, n, s, r, a) {
				const i = a == Dc ? n[0]?.combinator : e.combinator;
				if (!i) return !0;
				switch (i.name) {
					case " ":
					case ">": {
						const e = ">" === i.name, o = a === Dc ? function(e, n, s = /* @__PURE__ */ new Set()) {
							const r = [];
							function a(e) {
								t(e, null, { _(e, t) {
									if ("RegularElement" === e.type || "SvelteElement" === e.type) r.push(e), n || t.next();
									else if ("RenderTag" === e.type) for (const t of e.metadata.snippets) s.has(t) || (s.add(t), a(t.body));
									else t.next();
								} });
							}
							if (a("RenderTag" === e.type ? e : e.fragment), "RegularElement" === e.type && "selectedcontent" === e.name) {
								const n = e.metadata.path.findLast(((e) => "RegularElement" === e.type && "select" === e.name));
								n && t(n, { inside_option: !1 }, { _(e, t) {
									"RegularElement" === e.type && "option" === e.name ? t.next({ inside_option: !0 }) : t.state.inside_option ? a(e) : t.next();
								} });
							}
							return r;
						}(r, e) : tp(r, e);
						let l = !1;
						for (const e of o) Xc(n, s, e, a) && (l = !0);
						return l || a === jc && (!e || 0 === o.length) && n.every(((e) => Qc(e, s)));
					}
					case "+":
					case "~": {
						const e = sp(r, a, "+" === i.name);
						let t = !1;
						for (const r of e.keys()) "RenderTag" === r.type || "SlotElement" === r.type || "Component" === r.type ? 1 === n.length && n[0].metadata.is_global && (t = !0) : Xc(n, s, r, a) && (t = !0);
						return t || a === jc && null === np(r) && n.every(((e) => Qc(e, s)));
					}
					default: return !0;
				}
			}(i, a, n, s, r);
			return o && (function(e) {
				const t = e.selectors[0];
				return "PseudoClassSelector" === t.type && "global" === t.name && (null === t.args || e.selectors.every(((e) => "PseudoClassSelector" === e.type || "PseudoElementSelector" === e.type)));
			}(i) || (i.metadata.scoped = !0), s.metadata.scoped = !0), o;
		}
		function Qc(e, t) {
			if (e.metadata.is_global || e.metadata.is_global_like) return !0;
			let n = !1;
			for (const s of e.selectors) {
				let e = null, r = !1, a = t;
				"PseudoClassSelector" === s.type && ("is" !== s.name && "where" !== s.name || !s.args ? r = Ic(s) : e = s.args), "NestingSelector" === s.type && (a = t.metadata.parent_rule, e = a.prelude);
				const i = !!e?.children.some(((e) => e.children.every(((e) => Qc(e, a)))));
				if (n ||= i, !i && !r) return !1;
			}
			return n || 0 === e.selectors.length;
		}
		const Yc = /\\(.)/g;
		function Jc(e, t, n, s) {
			switch (n && (t = t.toLowerCase(), s = s.toLowerCase()), e) {
				case "=": return s === t;
				case "~=": return s.split(/\s/).includes(t);
				case "|=": return `${s}-`.startsWith(`${t}-`);
				case "^=": return s.startsWith(t);
				case "$=": return s.endsWith(t);
				case "*=": return s.includes(t);
				default: throw new Error("this shouldn't happen");
			}
		}
		function Zc(e, t, n, s, r) {
			for (const a of e.attributes) {
				if ("SpreadAttribute" === a.type) return !0;
				if ("BindDirective" === a.type && a.name === t) return !0;
				const e = t.toLowerCase();
				if ("StyleDirective" === a.type && "style" === e) return !0;
				if ("ClassDirective" === a.type && "class" === e) {
					if ("~=" !== s) return !0;
					if (a.name === n) return !0;
				}
				if ("Attribute" !== a.type) continue;
				if (a.name.toLowerCase() !== e) continue;
				if (!0 === a.value) return null === s;
				if (null === n) return !0;
				if (Xi(a)) {
					const t = Jc(s, n, r, a.value[0].data);
					if (!t && ("class" === e || "style" === e)) continue;
					return t;
				}
				const o = Ji(a.value), c = /* @__PURE__ */ new Set();
				let p = [];
				for (const t of o) {
					const n = $c(t, "class" === e);
					if (!n) return !0;
					if (p.length > 0) {
						const e = [], t = [];
						if (n.forEach(((n) => {
							i.test(n) ? e.push(n) : t.push(n);
						})), t.length > 0) {
							e.length > 0 && p.forEach(((e) => c.add(e)));
							const n = [];
							p.forEach(((e) => {
								t.forEach(((t) => {
									n.push(e + t);
								}));
							})), p = n, e.forEach(((e) => {
								l.test(e) ? c.add(e) : p.push(e);
							}));
							continue;
						}
						p.forEach(((e) => c.add(e))), p = [];
					}
					if (n.forEach(((e) => {
						l.test(e) ? c.add(e) : p.push(e);
					})), p.length < n.length && p.push(" "), p.length > 20) return !0;
				}
				p.forEach(((e) => c.add(e)));
				for (const e of c) if (Jc(s, n, r, e)) return !0;
			}
			return !1;
		}
		function ep(e) {
			return e[0] === e[e.length - 1] && "'" === e[0] || "\"" === e[0] ? e.slice(1, e.length - 1) : e;
		}
		function tp(e, n, s = /* @__PURE__ */ new Set()) {
			const r = [], a = e.metadata.path;
			let i = a.length;
			for (; i--;) {
				const e = a[i];
				if ("SnippetBlock" === e.type) {
					if (!s.has(e)) {
						s.add(e);
						for (const t of e.metadata.sites) r.push(...tp(t, n, s));
					}
					break;
				}
				if ("RegularElement" === e.type || "SvelteElement" === e.type) {
					if ("RegularElement" === e.type && "option" === e.name) {
						const s = 0 === r.length, o = a.findLast(((e, t) => "RegularElement" === e.type && "select" === e.name && t < i));
						if (o && (!n || s)) {
							let a = null;
							if (t(o, null, { RegularElement(e, t) {
								if ("selectedcontent" === e.name) return a = e, void t.stop();
								t.next();
							} }), n && s && a) return [a, e];
							a && r.push(a);
						}
					}
					if (r.push(e), n) break;
				}
			}
			return r;
		}
		function np(e) {
			let t = e.metadata.path, n = t.length;
			for (; n--;) {
				const e = t[n];
				if ("RegularElement" === e.type || "SvelteElement" === e.type) return e;
			}
			return null;
		}
		function sp(e, t, n, s = /* @__PURE__ */ new Set()) {
			const r = /* @__PURE__ */ new Map(), a = e.metadata.path;
			let i = e, o = a.length;
			for (; o--;) {
				const e = a[o--];
				let l = e.nodes.indexOf(i) + (t === Dc ? 1 : -1);
				for (; l >= 0 && l < e.nodes.length;) {
					const s = e.nodes[l];
					if ("RegularElement" === s.type) {
						if (!s.attributes.some(((e) => "Attribute" === e.type && "slot" === e.name.toLowerCase())) && (r.set(s, Nc), n)) return r;
					} else if (lp(s) || "Component" === s.type) {
						"SlotElement" !== s.type && "Component" !== s.type || r.set(s, Oc);
						const e = rp(s, t, n);
						if (ip(e, r), n && "Component" !== s.type && ap(e)) return r;
					} else if ("SvelteElement" === s.type) r.set(s, Oc);
					else if ("RenderTag" === s.type) {
						r.set(s, Oc);
						for (const e of s.metadata.snippets) ip(rp(e, t, n), r);
					}
					l = t === Dc ? l + 1 : l - 1;
				}
				if (i = a[o], !i) break;
				if ("Component" !== i.type && "SvelteComponent" !== i.type && "SvelteSelf" !== i.type) {
					if ("SnippetBlock" === i.type) {
						if (s.has(i)) break;
						s.add(i);
						for (const e of i.metadata.sites) {
							const a = sp(e, t, n, s);
							if (ip(a, r), n && 1 === i.metadata.sites.size && ap(a)) return r;
						}
					}
					if (!lp(i)) break;
					"EachBlock" === i.type && e === i.body && ip(rp(i, t, n), r);
				}
			}
			return r;
		}
		function rp(e, t, n, s = /* @__PURE__ */ new Set()) {
			let r = [];
			switch (e.type) {
				case "EachBlock":
					r.push(e.body, e.fallback);
					break;
				case "IfBlock":
					r.push(e.consequent, e.alternate);
					break;
				case "AwaitBlock":
					r.push(e.pending, e.then, e.catch);
					break;
				case "KeyBlock":
				case "SlotElement":
					r.push(e.fragment);
					break;
				case "SnippetBlock":
					if (s.has(e)) return /* @__PURE__ */ new Map();
					s.add(e), r.push(e.body);
					break;
				case "Component": r.push(e.fragment, ...[...e.metadata.snippets].map(((e) => e.body)));
			}
			const a = /* @__PURE__ */ new Map();
			let i = "SlotElement" !== e.type && "SnippetBlock" !== e.type;
			for (const e of r) {
				if (null == e) {
					i = !1;
					continue;
				}
				const r = op(e.nodes, t, n, s);
				i &&= ap(r), ip(r, a);
			}
			if (!i) for (const e of a.keys()) a.set(e, Oc);
			return a;
		}
		function ap(e) {
			if (0 === e.size) return !1;
			for (const t of e.values()) if (t === Nc) return !0;
			return !1;
		}
		function ip(e, t) {
			e.forEach(((e, n) => {
				var s, r;
				t.set(n, (s = e, void 0 === (r = t.get(n)) || s > r ? s : r));
			}));
		}
		function op(e, t, n, s) {
			const r = /* @__PURE__ */ new Map();
			let a = t === Dc ? 0 : e.length - 1;
			for (; a >= 0 && a < e.length;) {
				const i = e[a];
				if ("RegularElement" === i.type) {
					if (r.set(i, Nc), n) break;
				} else if ("SvelteElement" === i.type) r.set(i, Oc);
				else if ("RenderTag" === i.type) for (const e of i.metadata.snippets) ip(rp(e, t, n, s), r);
				else if (lp(i)) {
					const e = rp(i, t, n, s);
					if (ip(e, r), n && ap(e)) break;
				}
				a = t === Dc ? a + 1 : a - 1;
			}
			return r;
		}
		function lp(e) {
			return "IfBlock" === e.type || "EachBlock" === e.type || "AwaitBlock" === e.type || "KeyBlock" === e.type || "SlotElement" === e.type;
		}
		const cp = {
			Atrule(e, t) {
				Ec(e) || t.next();
			},
			PseudoClassSelector(e, t) {
				"is" !== e.name && "where" !== e.name || t.next();
			},
			ComplexSelector(e, t) {
				if (!e.metadata.used && ("PseudoClassSelector" !== t.path.at(-2)?.type || t.path.at(-4)?.metadata.used)) {
					const n = t.state.stylesheet.content;
					(function(e, t) {
						qe(e, "css_unused_selector", `Unused CSS selector "${t}"\nhttps://svelte.dev/e/css_unused_selector`);
					})(e, n.styles.substring(e.start - n.start, e.end - n.start));
				}
				t.next();
			},
			Rule(e, t) {
				e.metadata.is_global_block ? t.visit(e.prelude) : t.next();
			}
		};
		function pp(e, t) {
			if (t.state.expression) for (const [e] of t.state.scope.references) {
				const n = t.state.scope.get(e);
				n && n.scope.function_depth < t.state.scope.function_depth && t.state.expression.references.add(n);
			}
			t.next({
				...t.state,
				function_depth: t.state.function_depth + 1,
				expression: null
			});
		}
		function up(e) {
			let t = e.length;
			for (; t--;) {
				const n = e[t];
				if ("Fragment" === n.type) {
					if (n.metadata.dynamic) return;
					n.metadata.dynamic = !0;
				}
			}
		}
		const dp = {
			currentTime: {
				valid_elements: ["audio", "video"],
				omit_in_ssr: !0,
				bidirectional: !0
			},
			duration: {
				valid_elements: ["audio", "video"],
				event: "durationchange",
				omit_in_ssr: !0
			},
			focused: {},
			paused: {
				valid_elements: ["audio", "video"],
				omit_in_ssr: !0,
				bidirectional: !0
			},
			buffered: {
				valid_elements: ["audio", "video"],
				omit_in_ssr: !0
			},
			seekable: {
				valid_elements: ["audio", "video"],
				omit_in_ssr: !0
			},
			played: {
				valid_elements: ["audio", "video"],
				omit_in_ssr: !0
			},
			volume: {
				valid_elements: ["audio", "video"],
				omit_in_ssr: !0,
				bidirectional: !0
			},
			muted: {
				valid_elements: ["audio", "video"],
				omit_in_ssr: !0,
				bidirectional: !0
			},
			playbackRate: {
				valid_elements: ["audio", "video"],
				omit_in_ssr: !0,
				bidirectional: !0
			},
			seeking: {
				valid_elements: ["audio", "video"],
				omit_in_ssr: !0
			},
			ended: {
				valid_elements: ["audio", "video"],
				omit_in_ssr: !0
			},
			readyState: {
				valid_elements: ["audio", "video"],
				omit_in_ssr: !0
			},
			videoHeight: {
				valid_elements: ["video"],
				event: "resize",
				omit_in_ssr: !0
			},
			videoWidth: {
				valid_elements: ["video"],
				event: "resize",
				omit_in_ssr: !0
			},
			naturalWidth: {
				valid_elements: ["img"],
				event: "load",
				omit_in_ssr: !0
			},
			naturalHeight: {
				valid_elements: ["img"],
				event: "load",
				omit_in_ssr: !0
			},
			activeElement: {
				valid_elements: ["svelte:document"],
				omit_in_ssr: !0
			},
			fullscreenElement: {
				valid_elements: ["svelte:document"],
				event: "fullscreenchange",
				omit_in_ssr: !0
			},
			pointerLockElement: {
				valid_elements: ["svelte:document"],
				event: "pointerlockchange",
				omit_in_ssr: !0
			},
			visibilityState: {
				valid_elements: ["svelte:document"],
				event: "visibilitychange",
				omit_in_ssr: !0
			},
			innerWidth: {
				valid_elements: ["svelte:window"],
				omit_in_ssr: !0
			},
			innerHeight: {
				valid_elements: ["svelte:window"],
				omit_in_ssr: !0
			},
			outerWidth: {
				valid_elements: ["svelte:window"],
				omit_in_ssr: !0
			},
			outerHeight: {
				valid_elements: ["svelte:window"],
				omit_in_ssr: !0
			},
			scrollX: {
				valid_elements: ["svelte:window"],
				omit_in_ssr: !0,
				bidirectional: !0
			},
			scrollY: {
				valid_elements: ["svelte:window"],
				omit_in_ssr: !0,
				bidirectional: !0
			},
			online: {
				valid_elements: ["svelte:window"],
				omit_in_ssr: !0
			},
			devicePixelRatio: {
				valid_elements: ["svelte:window"],
				event: "resize",
				omit_in_ssr: !0
			},
			clientWidth: {
				omit_in_ssr: !0,
				invalid_elements: ["svelte:window", "svelte:document"]
			},
			clientHeight: {
				omit_in_ssr: !0,
				invalid_elements: ["svelte:window", "svelte:document"]
			},
			offsetWidth: {
				omit_in_ssr: !0,
				invalid_elements: ["svelte:window", "svelte:document"]
			},
			offsetHeight: {
				omit_in_ssr: !0,
				invalid_elements: ["svelte:window", "svelte:document"]
			},
			contentRect: {
				omit_in_ssr: !0,
				invalid_elements: ["svelte:window", "svelte:document"]
			},
			contentBoxSize: {
				omit_in_ssr: !0,
				invalid_elements: ["svelte:window", "svelte:document"]
			},
			borderBoxSize: {
				omit_in_ssr: !0,
				invalid_elements: ["svelte:window", "svelte:document"]
			},
			devicePixelContentBoxSize: {
				omit_in_ssr: !0,
				invalid_elements: ["svelte:window", "svelte:document"]
			},
			indeterminate: {
				event: "change",
				bidirectional: !0,
				valid_elements: ["input"],
				omit_in_ssr: !0
			},
			checked: {
				valid_elements: ["input"],
				bidirectional: !0
			},
			group: {
				valid_elements: ["input"],
				bidirectional: !0
			},
			this: { omit_in_ssr: !0 },
			innerText: {
				invalid_elements: ["svelte:window", "svelte:document"],
				bidirectional: !0
			},
			innerHTML: {
				invalid_elements: ["svelte:window", "svelte:document"],
				bidirectional: !0
			},
			textContent: {
				invalid_elements: ["svelte:window", "svelte:document"],
				bidirectional: !0
			},
			open: {
				event: "toggle",
				bidirectional: !0,
				valid_elements: ["details"]
			},
			value: {
				valid_elements: [
					"input",
					"textarea",
					"select"
				],
				bidirectional: !0
			},
			files: {
				valid_elements: ["input"],
				omit_in_ssr: !0,
				bidirectional: !0
			}
		};
		function hp(e) {
			!e.name.includes(":") || e.name.startsWith("xmlns:") || e.name.startsWith("xlink:") || e.name.startsWith("xml:") || qe(e, "attribute_illegal_colon", "Attributes should not contain ':' characters to prevent ambiguity with Svelte directives\nhttps://svelte.dev/e/attribute_illegal_colon");
		}
		function mp(e, t) {
			if (Array.isArray(e.value) && 1 === e.value.length && "ExpressionTag" === e.value[0].type && ("Component" === t.type || "SvelteComponent" === t.type || "SvelteSelf" === t.type || "RegularElement" === t.type && el(t)) && qe(e, "attribute_quoted", "Quoted attributes on components and custom elements will be stringified in a future version of Svelte. If this isn't what you want, remove the quotes\nhttps://svelte.dev/e/attribute_quoted"), !0 === e.value || !Array.isArray(e.value) || 1 === e.value.length) return;
			e.value.at(-1)?.end !== e.end || function(e) {
				zs(e, "attribute_unquoted_sequence", "Attribute values containing `{...}` must be enclosed in quote marks, unless the value only contains the expression\nhttps://svelte.dev/e/attribute_unquoted_sequence");
			}(e);
		}
		function fp(e, t, n = !1) {
			const s = e.path.at(-2);
			let r;
			if ("SnippetBlock" === s?.type) return void (Xi(t) || oa(t));
			let a = e.path.length;
			for (; a--;) {
				const t = e.path[a];
				!r && ("Component" === t.type || "SvelteComponent" === t.type || "SvelteSelf" === t.type || "SvelteElement" === t.type || "RegularElement" === t.type && el(t)) && (r = t);
			}
			if (r) {
				if ("Component" === r.type || "SvelteComponent" === r.type || "SvelteSelf" === r.type) if (r !== s) n || la(t);
				else {
					Xi(t) || oa(t);
					const n = t.value[0].data;
					if (e.state.component_slots.has(n) && function(e, t, n) {
						zs(e, "slot_attribute_duplicate", `Duplicate slot name '${t}' in <${n}>\nhttps://svelte.dev/e/slot_attribute_duplicate`);
					}(t, n, r.name), e.state.component_slots.add(n), "default" === n) for (const e of r.fragment.nodes) "Text" === e.type && d.test(e.data) || ("RegularElement" !== e.type && "SvelteFragment" !== e.type || !e.attributes.some(((e) => "Attribute" === e.type && "slot" === e.name))) && ca(e);
				}
			} else n || la(t);
		}
		function yp(e) {
			return !e || "import" === e.declaration_kind || "prop" === e.kind || "rest_prop" === e.kind || "bindable_prop" === e.kind || "SnippetBlock" === e?.initial?.type;
		}
		function vp(e, t) {
			e.metadata.path = [...t.path], e.metadata.snippets = /* @__PURE__ */ new Set();
			let n = !0;
			for (const s of e.attributes) {
				if ("SpreadAttribute" === s.type || "BindDirective" === s.type) {
					n = !1;
					continue;
				}
				if ("Attribute" !== s.type || !Qi(s)) continue;
				const r = Yi(s);
				if ("Identifier" === r.type) {
					const s = t.state.scope.get(r.name);
					n &&= yp(s), "SnippetBlock" === s?.initial?.type && e.metadata.snippets.add(s.initial);
				} else "Literal" !== r.type && (n = !1);
			}
			if (n) for (const t of e.fragment.nodes) "SnippetBlock" === t.type && e.metadata.snippets.add(t);
			t.state.analysis.snippet_renderers.set(e, n), up(t.path);
			for (const n of e.attributes) "Attribute" !== n.type && "SpreadAttribute" !== n.type && "LetDirective" !== n.type && "OnDirective" !== n.type && "BindDirective" !== n.type && "AttachTag" !== n.type && Hr(n), "OnDirective" === n.type && (n.modifiers.length > 1 || n.modifiers.some(((e) => "once" !== e))) && Kr(n), "Attribute" === n.type && (t.state.analysis.runes && (mp(n, e), Qi(n) && gp(Yi(n), t.state.analysis.source)), hp(n), "slot" === n.name && fp(t, n, !0)), "BindDirective" === n.type && "this" !== n.name && (t.state.analysis.uses_component_bindings = !0), "AttachTag" === n.type && gp(n.expression, t.state.analysis.source);
			const s = Ql(e) ? t.state : {
				...t.state,
				scope: e.metadata.scopes.default
			};
			for (const n of e.attributes) t.visit(n, "LetDirective" === n.type ? s : t.state);
			let r = [];
			const a = { default: [] };
			for (const t of e.fragment.nodes) {
				if ("Comment" === t.type) {
					r.push(t);
					continue;
				}
				const e = Ql(t) ?? "default";
				(a[e] ??= []).push(...r, t), "default" !== e && (r = []);
			}
			const i = /* @__PURE__ */ new Set();
			for (const n in a) {
				const s = {
					...t.state,
					scope: e.metadata.scopes[n],
					parent_element: null,
					component_slots: i
				};
				t.visit({
					...e.fragment,
					nodes: a[n]
				}, s);
			}
		}
		function gp(e, t) {
			if ("SequenceExpression" === e.type) {
				let n = e.start;
				for (; --n > 0;) {
					const s = t[n];
					if ("(" === s) break;
					"{" === s && qr(e);
				}
			}
		}
		function bp(e, t) {
			if (!t.has(e) && (t.add(e), "legacy_reactive" === e.kind)) for (const n of e.legacy_dependencies) bp(n, t);
		}
		function _p(e, t) {
			return ("state" === e.kind || "raw_state" === e.kind) && (!t.immutable || e.reassigned || t.accessors);
		}
		function xp(e, t) {
			if (Object.hasOwn(t.transform, e.name)) {
				if (e !== t.scope.get(e.name)?.node) return t.transform[e.name].read(e);
			}
			return e;
		}
		function wp(e, t, n, s) {
			const r = [ui("$$props"), mi(n)];
			let a, i = 0;
			return "bindable_prop" === e.kind && (i |= S), t.analysis.immutable && (i |= w), t.analysis.runes && (i |= k), (t.analysis.accessors || (t.analysis.immutable ? e.reassigned || t.analysis.runes && e.mutated : e.updated)) && (i |= C), s && (oo(s) ? a = s : (a = "CallExpression" === s.type && "Identifier" === s.callee.type && 0 === s.arguments.length ? s.callee : Ti(s), i |= P)), (i || a) && (r.push(mi(i)), a && r.push(a)), ei("$.prop", ...r);
		}
		function kp(e, t) {
			return ("prop" === e.kind || "bindable_prop" === e.kind) && (!t.analysis.runes || t.analysis.accessors || e.reassigned || e.initial || e.updated);
		}
		function Cp(e, t) {
			if (!e || "Literal" === e.type || "TemplateLiteral" === e.type || "ArrowFunctionExpression" === e.type || "FunctionExpression" === e.type || "UnaryExpression" === e.type || "BinaryExpression" === e.type || "Identifier" === e.type && "undefined" === e.name) return !1;
			if ("Identifier" === e.type && null !== t) {
				const n = t.get(e.name);
				if (null !== n && !n.reassigned && null !== n.initial && "FunctionDeclaration" !== n.initial.type && "ClassDeclaration" !== n.initial.type && "ImportDeclaration" !== n.initial.type && "EachBlock" !== n.initial.type && "SnippetBlock" !== n.initial.type) return Cp(n.initial, null);
			}
			return !0;
		}
		function Sp(e, t, n = !1) {
			const s = Ti(t, n);
			return n ? mo(ei("$.async_derived", s)) : ei(e.analysis.runes ? "$.derived" : "$.derived_safe_equal", s);
		}
		var Pp, Ep, Tp, Ap = {}, $p = {}, Rp = {}, Ip = {};
		function Mp() {
			if (Ep) return Rp;
			Ep = 1, Object.defineProperty(Rp, "__esModule", { value: !0 }), Rp.default = function(n, s) {
				"function" == typeof Symbol && "symbol" === t(Symbol.iterator) && Object.defineProperty(n, Symbol.iterator, { value: e.default.bind(s) });
				return n;
			};
			var e = function(e) {
				return e && e.__esModule ? e : { default: e };
			}((Pp || (Pp = 1, Object.defineProperty(Ip, "__esModule", { value: !0 }), Ip.default = void 0, Ip.default = function() {
				var e = this, t = 0, n = {
					"@@iterator": function() {
						return n;
					},
					next: function() {
						if (t < e.length) {
							var n = e[t];
							return t += 1, {
								done: !1,
								value: n
							};
						}
						return { done: !0 };
					}
				};
				return n;
			}), Ip));
			function t(e) {
				return t = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
					return typeof e;
				} : function(e) {
					return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
				}, t(e);
			}
			return Rp;
		}
		function qp() {
			if (Tp) return $p;
			Tp = 1, Object.defineProperty($p, "__esModule", { value: !0 }), $p.default = void 0;
			var e = function(e) {
				return e && e.__esModule ? e : { default: e };
			}(Mp());
			function t(e, t) {
				return function(e) {
					if (Array.isArray(e)) return e;
				}(e) || function(e, t) {
					var n = null == e ? null : "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
					if (null != n) {
						var s, r, a, i, o = [], l = !0, c = !1;
						try {
							if (a = (n = n.call(e)).next, 0 === t) {
								if (Object(n) !== n) return;
								l = !1;
							} else for (; !(l = (s = a.call(n)).done) && (o.push(s.value), o.length !== t); l = !0);
						} catch (e) {
							c = !0, r = e;
						} finally {
							try {
								if (!l && null != n.return && (i = n.return(), Object(i) !== i)) return;
							} finally {
								if (c) throw r;
							}
						}
						return o;
					}
				}(e, t) || function(e, t) {
					if (e) {
						if ("string" == typeof e) return n(e, t);
						var s = {}.toString.call(e).slice(8, -1);
						return "Object" === s && e.constructor && (s = e.constructor.name), "Map" === s || "Set" === s ? Array.from(e) : "Arguments" === s || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(s) ? n(e, t) : void 0;
					}
				}(e, t) || function() {
					throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
				}();
			}
			function n(e, t) {
				(null == t || t > e.length) && (t = e.length);
				for (var n = 0, s = Array(t); n < t; n++) s[n] = e[n];
				return s;
			}
			var s = [
				["aria-activedescendant", { type: "id" }],
				["aria-atomic", { type: "boolean" }],
				["aria-autocomplete", {
					type: "token",
					values: [
						"inline",
						"list",
						"both",
						"none"
					]
				}],
				["aria-braillelabel", { type: "string" }],
				["aria-brailleroledescription", { type: "string" }],
				["aria-busy", { type: "boolean" }],
				["aria-checked", { type: "tristate" }],
				["aria-colcount", { type: "integer" }],
				["aria-colindex", { type: "integer" }],
				["aria-colspan", { type: "integer" }],
				["aria-controls", { type: "idlist" }],
				["aria-current", {
					type: "token",
					values: [
						"page",
						"step",
						"location",
						"date",
						"time",
						!0,
						!1
					]
				}],
				["aria-describedby", { type: "idlist" }],
				["aria-description", { type: "string" }],
				["aria-details", { type: "id" }],
				["aria-disabled", { type: "boolean" }],
				["aria-dropeffect", {
					type: "tokenlist",
					values: [
						"copy",
						"execute",
						"link",
						"move",
						"none",
						"popup"
					]
				}],
				["aria-errormessage", { type: "id" }],
				["aria-expanded", {
					type: "boolean",
					allowundefined: !0
				}],
				["aria-flowto", { type: "idlist" }],
				["aria-grabbed", {
					type: "boolean",
					allowundefined: !0
				}],
				["aria-haspopup", {
					type: "token",
					values: [
						!1,
						!0,
						"menu",
						"listbox",
						"tree",
						"grid",
						"dialog"
					]
				}],
				["aria-hidden", {
					type: "boolean",
					allowundefined: !0
				}],
				["aria-invalid", {
					type: "token",
					values: [
						"grammar",
						!1,
						"spelling",
						!0
					]
				}],
				["aria-keyshortcuts", { type: "string" }],
				["aria-label", { type: "string" }],
				["aria-labelledby", { type: "idlist" }],
				["aria-level", { type: "integer" }],
				["aria-live", {
					type: "token",
					values: [
						"assertive",
						"off",
						"polite"
					]
				}],
				["aria-modal", { type: "boolean" }],
				["aria-multiline", { type: "boolean" }],
				["aria-multiselectable", { type: "boolean" }],
				["aria-orientation", {
					type: "token",
					values: [
						"vertical",
						"undefined",
						"horizontal"
					]
				}],
				["aria-owns", { type: "idlist" }],
				["aria-placeholder", { type: "string" }],
				["aria-posinset", { type: "integer" }],
				["aria-pressed", { type: "tristate" }],
				["aria-readonly", { type: "boolean" }],
				["aria-relevant", {
					type: "tokenlist",
					values: [
						"additions",
						"all",
						"removals",
						"text"
					]
				}],
				["aria-required", { type: "boolean" }],
				["aria-roledescription", { type: "string" }],
				["aria-rowcount", { type: "integer" }],
				["aria-rowindex", { type: "integer" }],
				["aria-rowspan", { type: "integer" }],
				["aria-selected", {
					type: "boolean",
					allowundefined: !0
				}],
				["aria-setsize", { type: "integer" }],
				["aria-sort", {
					type: "token",
					values: [
						"ascending",
						"descending",
						"none",
						"other"
					]
				}],
				["aria-valuemax", { type: "number" }],
				["aria-valuemin", { type: "number" }],
				["aria-valuenow", { type: "number" }],
				["aria-valuetext", { type: "string" }]
			], r = {
				entries: function() {
					return s;
				},
				forEach: function(e) {
					for (var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, r = 0, a = s; r < a.length; r++) {
						var i = t(a[r], 2), o = i[0], l = i[1];
						e.call(n, l, o, s);
					}
				},
				get: function(e) {
					var t = s.find((function(t) {
						return t[0] === e;
					}));
					return t && t[1];
				},
				has: function(e) {
					return !!r.get(e);
				},
				keys: function() {
					return s.map((function(e) {
						return t(e, 1)[0];
					}));
				},
				values: function() {
					return s.map((function(e) {
						return t(e, 2)[1];
					}));
				}
			};
			return $p.default = (0, e.default)(r, r.entries()), $p;
		}
		var Lp, Op = {};
		function Np() {
			if (Lp) return Op;
			Lp = 1, Object.defineProperty(Op, "__esModule", { value: !0 }), Op.default = void 0;
			var e = function(e) {
				return e && e.__esModule ? e : { default: e };
			}(Mp());
			function t(e, t) {
				return function(e) {
					if (Array.isArray(e)) return e;
				}(e) || function(e, t) {
					var n = null == e ? null : "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
					if (null != n) {
						var s, r, a, i, o = [], l = !0, c = !1;
						try {
							if (a = (n = n.call(e)).next, 0 === t) {
								if (Object(n) !== n) return;
								l = !1;
							} else for (; !(l = (s = a.call(n)).done) && (o.push(s.value), o.length !== t); l = !0);
						} catch (e) {
							c = !0, r = e;
						} finally {
							try {
								if (!l && null != n.return && (i = n.return(), Object(i) !== i)) return;
							} finally {
								if (c) throw r;
							}
						}
						return o;
					}
				}(e, t) || function(e, t) {
					if (e) {
						if ("string" == typeof e) return n(e, t);
						var s = {}.toString.call(e).slice(8, -1);
						return "Object" === s && e.constructor && (s = e.constructor.name), "Map" === s || "Set" === s ? Array.from(e) : "Arguments" === s || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(s) ? n(e, t) : void 0;
					}
				}(e, t) || function() {
					throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
				}();
			}
			function n(e, t) {
				(null == t || t > e.length) && (t = e.length);
				for (var n = 0, s = Array(t); n < t; n++) s[n] = e[n];
				return s;
			}
			var s = [
				["a", { reserved: !1 }],
				["abbr", { reserved: !1 }],
				["acronym", { reserved: !1 }],
				["address", { reserved: !1 }],
				["applet", { reserved: !1 }],
				["area", { reserved: !1 }],
				["article", { reserved: !1 }],
				["aside", { reserved: !1 }],
				["audio", { reserved: !1 }],
				["b", { reserved: !1 }],
				["base", { reserved: !0 }],
				["bdi", { reserved: !1 }],
				["bdo", { reserved: !1 }],
				["big", { reserved: !1 }],
				["blink", { reserved: !1 }],
				["blockquote", { reserved: !1 }],
				["body", { reserved: !1 }],
				["br", { reserved: !1 }],
				["button", { reserved: !1 }],
				["canvas", { reserved: !1 }],
				["caption", { reserved: !1 }],
				["center", { reserved: !1 }],
				["cite", { reserved: !1 }],
				["code", { reserved: !1 }],
				["col", { reserved: !0 }],
				["colgroup", { reserved: !0 }],
				["content", { reserved: !1 }],
				["data", { reserved: !1 }],
				["datalist", { reserved: !1 }],
				["dd", { reserved: !1 }],
				["del", { reserved: !1 }],
				["details", { reserved: !1 }],
				["dfn", { reserved: !1 }],
				["dialog", { reserved: !1 }],
				["dir", { reserved: !1 }],
				["div", { reserved: !1 }],
				["dl", { reserved: !1 }],
				["dt", { reserved: !1 }],
				["em", { reserved: !1 }],
				["embed", { reserved: !1 }],
				["fieldset", { reserved: !1 }],
				["figcaption", { reserved: !1 }],
				["figure", { reserved: !1 }],
				["font", { reserved: !1 }],
				["footer", { reserved: !1 }],
				["form", { reserved: !1 }],
				["frame", { reserved: !1 }],
				["frameset", { reserved: !1 }],
				["h1", { reserved: !1 }],
				["h2", { reserved: !1 }],
				["h3", { reserved: !1 }],
				["h4", { reserved: !1 }],
				["h5", { reserved: !1 }],
				["h6", { reserved: !1 }],
				["head", { reserved: !0 }],
				["header", { reserved: !1 }],
				["hgroup", { reserved: !1 }],
				["hr", { reserved: !1 }],
				["html", { reserved: !0 }],
				["i", { reserved: !1 }],
				["iframe", { reserved: !1 }],
				["img", { reserved: !1 }],
				["input", { reserved: !1 }],
				["ins", { reserved: !1 }],
				["kbd", { reserved: !1 }],
				["keygen", { reserved: !1 }],
				["label", { reserved: !1 }],
				["legend", { reserved: !1 }],
				["li", { reserved: !1 }],
				["link", { reserved: !0 }],
				["main", { reserved: !1 }],
				["map", { reserved: !1 }],
				["mark", { reserved: !1 }],
				["marquee", { reserved: !1 }],
				["menu", { reserved: !1 }],
				["menuitem", { reserved: !1 }],
				["meta", { reserved: !0 }],
				["meter", { reserved: !1 }],
				["nav", { reserved: !1 }],
				["noembed", { reserved: !0 }],
				["noscript", { reserved: !0 }],
				["object", { reserved: !1 }],
				["ol", { reserved: !1 }],
				["optgroup", { reserved: !1 }],
				["option", { reserved: !1 }],
				["output", { reserved: !1 }],
				["p", { reserved: !1 }],
				["param", { reserved: !0 }],
				["picture", { reserved: !0 }],
				["pre", { reserved: !1 }],
				["progress", { reserved: !1 }],
				["q", { reserved: !1 }],
				["rp", { reserved: !1 }],
				["rt", { reserved: !1 }],
				["rtc", { reserved: !1 }],
				["ruby", { reserved: !1 }],
				["s", { reserved: !1 }],
				["samp", { reserved: !1 }],
				["script", { reserved: !0 }],
				["section", { reserved: !1 }],
				["select", { reserved: !1 }],
				["small", { reserved: !1 }],
				["source", { reserved: !0 }],
				["spacer", { reserved: !1 }],
				["span", { reserved: !1 }],
				["strike", { reserved: !1 }],
				["strong", { reserved: !1 }],
				["style", { reserved: !0 }],
				["sub", { reserved: !1 }],
				["summary", { reserved: !1 }],
				["sup", { reserved: !1 }],
				["table", { reserved: !1 }],
				["tbody", { reserved: !1 }],
				["td", { reserved: !1 }],
				["textarea", { reserved: !1 }],
				["tfoot", { reserved: !1 }],
				["th", { reserved: !1 }],
				["thead", { reserved: !1 }],
				["time", { reserved: !1 }],
				["title", { reserved: !0 }],
				["tr", { reserved: !1 }],
				["track", { reserved: !0 }],
				["tt", { reserved: !1 }],
				["u", { reserved: !1 }],
				["ul", { reserved: !1 }],
				["var", { reserved: !1 }],
				["video", { reserved: !1 }],
				["wbr", { reserved: !1 }],
				["xmp", { reserved: !1 }]
			], r = {
				entries: function() {
					return s;
				},
				forEach: function(e) {
					for (var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, r = 0, a = s; r < a.length; r++) {
						var i = t(a[r], 2), o = i[0], l = i[1];
						e.call(n, l, o, s);
					}
				},
				get: function(e) {
					var t = s.find((function(t) {
						return t[0] === e;
					}));
					return t && t[1];
				},
				has: function(e) {
					return !!r.get(e);
				},
				keys: function() {
					return s.map((function(e) {
						return t(e, 1)[0];
					}));
				},
				values: function() {
					return s.map((function(e) {
						return t(e, 2)[1];
					}));
				}
			};
			return Op.default = (0, e.default)(r, r.entries()), Op;
		}
		var Dp, jp = {}, Bp = {}, Fp = {};
		var Vp, Hp = {};
		var Up, zp = {};
		var Wp, Gp = {};
		var Kp, Xp = {};
		var Qp, Yp = {};
		var Jp, Zp = {};
		var eu, tu = {};
		var nu, su = {};
		var ru, au = {};
		var iu, ou = {};
		var lu, cu, pu = {};
		function uu() {
			if (cu) return Bp;
			cu = 1, Object.defineProperty(Bp, "__esModule", { value: !0 }), Bp.default = void 0;
			var e = d((Dp || (Dp = 1, Object.defineProperty(Fp, "__esModule", { value: !0 }), Fp.default = void 0, Fp.default = {
				abstract: !0,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [["roletype", "widget"]]
			}), Fp)), t = d((Vp || (Vp = 1, Object.defineProperty(Hp, "__esModule", { value: !0 }), Hp.default = void 0, Hp.default = {
				abstract: !0,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {
					"aria-activedescendant": null,
					"aria-disabled": null
				},
				relatedConcepts: [],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [["roletype", "widget"]]
			}), Hp)), n = d((Up || (Up = 1, Object.defineProperty(zp, "__esModule", { value: !0 }), zp.default = void 0, zp.default = {
				abstract: !0,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: { "aria-disabled": null },
				relatedConcepts: [{
					concept: { name: "input" },
					module: "XForms"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [["roletype", "widget"]]
			}), zp)), s = d((Wp || (Wp = 1, Object.defineProperty(Gp, "__esModule", { value: !0 }), Gp.default = void 0, Gp.default = {
				abstract: !0,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section"
				]]
			}), Gp)), r = d((Kp || (Kp = 1, Object.defineProperty(Xp, "__esModule", { value: !0 }), Xp.default = void 0, Xp.default = {
				abstract: !0,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {
					"aria-valuemax": null,
					"aria-valuemin": null,
					"aria-valuenow": null
				},
				relatedConcepts: [],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [["roletype", "structure"]]
			}), Xp)), a = d((Qp || (Qp = 1, Object.defineProperty(Yp, "__esModule", { value: !0 }), Yp.default = void 0, Yp.default = {
				abstract: !0,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: [],
				prohibitedProps: [],
				props: {
					"aria-atomic": null,
					"aria-busy": null,
					"aria-controls": null,
					"aria-current": null,
					"aria-describedby": null,
					"aria-details": null,
					"aria-dropeffect": null,
					"aria-flowto": null,
					"aria-grabbed": null,
					"aria-hidden": null,
					"aria-keyshortcuts": null,
					"aria-label": null,
					"aria-labelledby": null,
					"aria-live": null,
					"aria-owns": null,
					"aria-relevant": null,
					"aria-roledescription": null
				},
				relatedConcepts: [{
					concept: { name: "role" },
					module: "XHTML"
				}, {
					concept: { name: "type" },
					module: "Dublin Core"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: []
			}), Yp)), i = d((Jp || (Jp = 1, Object.defineProperty(Zp, "__esModule", { value: !0 }), Zp.default = void 0, Zp.default = {
				abstract: !0,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: [],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [
					{
						concept: { name: "frontmatter" },
						module: "DTB"
					},
					{
						concept: { name: "level" },
						module: "DTB"
					},
					{
						concept: { name: "level" },
						module: "SMIL"
					}
				],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [["roletype", "structure"]]
			}), Zp)), o = d((eu || (eu = 1, Object.defineProperty(tu, "__esModule", { value: !0 }), tu.default = void 0, tu.default = {
				abstract: !0,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author", "contents"],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [["roletype", "structure"]]
			}), tu)), l = d((nu || (nu = 1, Object.defineProperty(su, "__esModule", { value: !0 }), su.default = void 0, su.default = {
				abstract: !0,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: { "aria-orientation": null },
				relatedConcepts: [],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"widget",
					"composite"
				], [
					"roletype",
					"structure",
					"section",
					"group"
				]]
			}), su)), c = d((ru || (ru = 1, Object.defineProperty(au, "__esModule", { value: !0 }), au.default = void 0, au.default = {
				abstract: !0,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: [],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [["roletype"]]
			}), au)), p = d((iu || (iu = 1, Object.defineProperty(ou, "__esModule", { value: !0 }), ou.default = void 0, ou.default = {
				abstract: !0,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: [],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [["roletype"]]
			}), ou)), u = d((lu || (lu = 1, Object.defineProperty(pu, "__esModule", { value: !0 }), pu.default = void 0, pu.default = {
				abstract: !0,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: { "aria-modal": null },
				relatedConcepts: [],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [["roletype"]]
			}), pu));
			function d(e) {
				return e && e.__esModule ? e : { default: e };
			}
			return Bp.default = [
				["command", e.default],
				["composite", t.default],
				["input", n.default],
				["landmark", s.default],
				["range", r.default],
				["roletype", a.default],
				["section", i.default],
				["sectionhead", o.default],
				["select", l.default],
				["structure", c.default],
				["widget", p.default],
				["window", u.default]
			], Bp;
		}
		var du, hu = {}, mu = {};
		var fu, yu = {};
		var vu, gu = {};
		var bu, _u = {};
		var xu, wu = {};
		var ku, Cu = {};
		var Su, Pu = {};
		var Eu, Tu = {};
		var Au, $u = {};
		var Ru, Iu = {};
		var Mu, qu = {};
		var Lu, Ou = {};
		var Nu, Du = {};
		var ju, Bu = {};
		var Fu, Vu = {};
		var Hu, Uu = {};
		var zu, Wu = {};
		var Gu, Ku = {};
		var Xu, Qu = {};
		var Yu, Ju = {};
		var Zu, ed = {};
		var td, nd = {};
		var sd, rd = {};
		var ad, id = {};
		var od, ld = {};
		var cd, pd = {};
		var ud, dd = {};
		var hd, md = {};
		var fd, yd = {};
		var vd, gd = {};
		var bd, _d = {};
		var xd, wd = {};
		var kd, Cd = {};
		var Sd, Pd = {};
		var Ed, Td = {};
		var Ad, $d = {};
		var Rd, Id = {};
		var Md, qd = {};
		var Ld, Od = {};
		var Nd, Dd = {};
		var jd, Bd = {};
		var Fd, Vd = {};
		var Hd, Ud = {};
		var zd, Wd = {};
		var Gd, Kd = {};
		var Xd, Qd = {};
		var Yd, Jd = {};
		var Zd, eh = {};
		var th, nh = {};
		var sh, rh = {};
		var ah, ih = {};
		var oh, lh = {};
		var ch, ph = {};
		var uh, dh = {};
		var hh, mh = {};
		var fh, yh = {};
		var vh, gh = {};
		var bh, _h = {};
		var xh, wh = {};
		var kh, Ch = {};
		var Sh, Ph = {};
		var Eh, Th = {};
		var Ah, $h = {};
		var Rh, Ih = {};
		var Mh, qh = {};
		var Lh, Oh = {};
		var Nh, Dh = {};
		var jh, Bh = {};
		var Fh, Vh = {};
		var Hh, Uh = {};
		var zh, Wh = {};
		var Gh, Kh = {};
		var Xh, Qh = {};
		var Yh, Jh = {};
		var Zh, em = {};
		var tm, nm = {};
		var sm, rm = {};
		var am, im = {};
		var om, lm = {};
		var cm, pm = {};
		var um, dm = {};
		var hm, mm = {};
		var fm, ym, vm = {};
		function gm() {
			if (ym) return hu;
			ym = 1, Object.defineProperty(hu, "__esModule", { value: !0 }), hu.default = void 0;
			var e = Ae((du || (du = 1, Object.defineProperty(mu, "__esModule", { value: !0 }), mu.default = void 0, mu.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {
					"aria-atomic": "true",
					"aria-live": "assertive"
				},
				relatedConcepts: [{
					concept: { name: "alert" },
					module: "XForms"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section"
				]]
			}), mu)), t = Ae((fu || (fu = 1, Object.defineProperty(yu, "__esModule", { value: !0 }), yu.default = void 0, yu.default = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [{
					concept: { name: "alert" },
					module: "XForms"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section",
					"alert"
				], [
					"roletype",
					"window",
					"dialog"
				]]
			}), yu)), n = Ae((vu || (vu = 1, Object.defineProperty(gu, "__esModule", { value: !0 }), gu.default = void 0, gu.default = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {
					"aria-activedescendant": null,
					"aria-disabled": null,
					"aria-errormessage": null,
					"aria-expanded": null,
					"aria-haspopup": null,
					"aria-invalid": null
				},
				relatedConcepts: [{ concept: { name: "Device Independence Delivery Unit" } }],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [["roletype", "structure"]]
			}), gu)), s = Ae((bu || (bu = 1, Object.defineProperty(_u, "__esModule", { value: !0 }), _u.default = void 0, _u.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {
					"aria-posinset": null,
					"aria-setsize": null
				},
				relatedConcepts: [{
					concept: { name: "article" },
					module: "HTML"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"document"
				]]
			}), _u)), r = Ae((xu || (xu = 1, Object.defineProperty(wu, "__esModule", { value: !0 }), wu.default = void 0, wu.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [{
					concept: {
						constraints: ["scoped to the body element"],
						name: "header"
					},
					module: "HTML"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section",
					"landmark"
				]]
			}), wu)), a = Ae((ku || (ku = 1, Object.defineProperty(Cu, "__esModule", { value: !0 }), Cu.default = void 0, Cu.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [{
					concept: { name: "blockquote" },
					module: "HTML"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section"
				]]
			}), Cu)), i = Ae((Su || (Su = 1, Object.defineProperty(Pu, "__esModule", { value: !0 }), Pu.default = void 0, Pu.default = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !0,
				nameFrom: ["author", "contents"],
				prohibitedProps: [],
				props: {
					"aria-disabled": null,
					"aria-expanded": null,
					"aria-haspopup": null,
					"aria-pressed": null
				},
				relatedConcepts: [
					{
						concept: {
							attributes: [{
								name: "type",
								value: "button"
							}],
							name: "input"
						},
						module: "HTML"
					},
					{
						concept: {
							attributes: [{
								name: "type",
								value: "image"
							}],
							name: "input"
						},
						module: "HTML"
					},
					{
						concept: {
							attributes: [{
								name: "type",
								value: "reset"
							}],
							name: "input"
						},
						module: "HTML"
					},
					{
						concept: {
							attributes: [{
								name: "type",
								value: "submit"
							}],
							name: "input"
						},
						module: "HTML"
					},
					{
						concept: { name: "button" },
						module: "HTML"
					},
					{
						concept: { name: "trigger" },
						module: "XForms"
					}
				],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"widget",
					"command"
				]]
			}), Pu)), o = Ae((Eu || (Eu = 1, Object.defineProperty(Tu, "__esModule", { value: !0 }), Tu.default = void 0, Tu.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["prohibited"],
				prohibitedProps: ["aria-label", "aria-labelledby"],
				props: {},
				relatedConcepts: [{
					concept: { name: "caption" },
					module: "HTML"
				}],
				requireContextRole: [
					"figure",
					"grid",
					"table"
				],
				requiredContextRole: [
					"figure",
					"grid",
					"table"
				],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section"
				]]
			}), Tu)), l = Ae((Au || (Au = 1, Object.defineProperty($u, "__esModule", { value: !0 }), $u.default = void 0, $u.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author", "contents"],
				prohibitedProps: [],
				props: {
					"aria-colindex": null,
					"aria-colspan": null,
					"aria-rowindex": null,
					"aria-rowspan": null
				},
				relatedConcepts: [{
					concept: {
						constraints: ["ancestor table element has table role"],
						name: "td"
					},
					module: "HTML"
				}],
				requireContextRole: ["row"],
				requiredContextRole: ["row"],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section"
				]]
			}), $u)), c = Ae((Ru || (Ru = 1, Object.defineProperty(Iu, "__esModule", { value: !0 }), Iu.default = void 0, Iu.default = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !0,
				nameFrom: ["author", "contents"],
				prohibitedProps: [],
				props: {
					"aria-checked": null,
					"aria-errormessage": null,
					"aria-expanded": null,
					"aria-invalid": null,
					"aria-readonly": null,
					"aria-required": null
				},
				relatedConcepts: [{
					concept: {
						attributes: [{
							name: "type",
							value: "checkbox"
						}],
						name: "input"
					},
					module: "HTML"
				}, {
					concept: { name: "option" },
					module: "ARIA"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: { "aria-checked": null },
				superClass: [[
					"roletype",
					"widget",
					"input"
				]]
			}), Iu)), p = Ae((Mu || (Mu = 1, Object.defineProperty(qu, "__esModule", { value: !0 }), qu.default = void 0, qu.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["prohibited"],
				prohibitedProps: ["aria-label", "aria-labelledby"],
				props: {},
				relatedConcepts: [{
					concept: { name: "code" },
					module: "HTML"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section"
				]]
			}), qu)), u = Ae((Lu || (Lu = 1, Object.defineProperty(Ou, "__esModule", { value: !0 }), Ou.default = void 0, Ou.default = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author", "contents"],
				prohibitedProps: [],
				props: { "aria-sort": null },
				relatedConcepts: [
					{
						concept: { name: "th" },
						module: "HTML"
					},
					{
						concept: {
							attributes: [{
								name: "scope",
								value: "col"
							}],
							name: "th"
						},
						module: "HTML"
					},
					{
						concept: {
							attributes: [{
								name: "scope",
								value: "colgroup"
							}],
							name: "th"
						},
						module: "HTML"
					}
				],
				requireContextRole: ["row"],
				requiredContextRole: ["row"],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [
					[
						"roletype",
						"structure",
						"section",
						"cell"
					],
					[
						"roletype",
						"structure",
						"section",
						"cell",
						"gridcell"
					],
					[
						"roletype",
						"widget",
						"gridcell"
					],
					[
						"roletype",
						"structure",
						"sectionhead"
					]
				]
			}), Ou)), d = Ae((Nu || (Nu = 1, Object.defineProperty(Du, "__esModule", { value: !0 }), Du.default = void 0, Du.default = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {
					"aria-activedescendant": null,
					"aria-autocomplete": null,
					"aria-errormessage": null,
					"aria-invalid": null,
					"aria-readonly": null,
					"aria-required": null,
					"aria-expanded": "false",
					"aria-haspopup": "listbox"
				},
				relatedConcepts: [
					{
						concept: {
							attributes: [{
								constraints: ["set"],
								name: "list"
							}, {
								name: "type",
								value: "email"
							}],
							name: "input"
						},
						module: "HTML"
					},
					{
						concept: {
							attributes: [{
								constraints: ["set"],
								name: "list"
							}, {
								name: "type",
								value: "search"
							}],
							name: "input"
						},
						module: "HTML"
					},
					{
						concept: {
							attributes: [{
								constraints: ["set"],
								name: "list"
							}, {
								name: "type",
								value: "tel"
							}],
							name: "input"
						},
						module: "HTML"
					},
					{
						concept: {
							attributes: [{
								constraints: ["set"],
								name: "list"
							}, {
								name: "type",
								value: "text"
							}],
							name: "input"
						},
						module: "HTML"
					},
					{
						concept: {
							attributes: [{
								constraints: ["set"],
								name: "list"
							}, {
								name: "type",
								value: "url"
							}],
							name: "input"
						},
						module: "HTML"
					},
					{
						concept: {
							attributes: [{
								constraints: ["set"],
								name: "list"
							}, {
								name: "type",
								value: "url"
							}],
							name: "input"
						},
						module: "HTML"
					},
					{
						concept: {
							attributes: [{
								constraints: ["undefined"],
								name: "multiple"
							}, {
								constraints: ["undefined"],
								name: "size"
							}],
							constraints: ["the multiple attribute is not set and the size attribute does not have a value greater than 1"],
							name: "select"
						},
						module: "HTML"
					},
					{
						concept: { name: "select" },
						module: "XForms"
					}
				],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {
					"aria-controls": null,
					"aria-expanded": "false"
				},
				superClass: [[
					"roletype",
					"widget",
					"input"
				]]
			}), Du)), h = Ae((ju || (ju = 1, Object.defineProperty(Bu, "__esModule", { value: !0 }), Bu.default = void 0, Bu.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [
					{
						concept: {
							constraints: ["scoped to the body element", "scoped to the main element"],
							name: "aside"
						},
						module: "HTML"
					},
					{
						concept: {
							attributes: [{
								constraints: ["set"],
								name: "aria-label"
							}],
							constraints: ["scoped to a sectioning content element", "scoped to a sectioning root element other than body"],
							name: "aside"
						},
						module: "HTML"
					},
					{
						concept: {
							attributes: [{
								constraints: ["set"],
								name: "aria-labelledby"
							}],
							constraints: ["scoped to a sectioning content element", "scoped to a sectioning root element other than body"],
							name: "aside"
						},
						module: "HTML"
					}
				],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section",
					"landmark"
				]]
			}), Bu)), m = Ae((Fu || (Fu = 1, Object.defineProperty(Vu, "__esModule", { value: !0 }), Vu.default = void 0, Vu.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [{
					concept: {
						constraints: ["scoped to the body element"],
						name: "footer"
					},
					module: "HTML"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section",
					"landmark"
				]]
			}), Vu)), f = Ae((Hu || (Hu = 1, Object.defineProperty(Uu, "__esModule", { value: !0 }), Uu.default = void 0, Uu.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [{
					concept: { name: "dd" },
					module: "HTML"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section"
				]]
			}), Uu)), y = Ae((zu || (zu = 1, Object.defineProperty(Wu, "__esModule", { value: !0 }), Wu.default = void 0, Wu.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["prohibited"],
				prohibitedProps: ["aria-label", "aria-labelledby"],
				props: {},
				relatedConcepts: [{
					concept: { name: "del" },
					module: "HTML"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section"
				]]
			}), Wu)), v = Ae((Gu || (Gu = 1, Object.defineProperty(Ku, "__esModule", { value: !0 }), Ku.default = void 0, Ku.default = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [{
					concept: { name: "dialog" },
					module: "HTML"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [["roletype", "window"]]
			}), Ku)), g = Ae((Xu || (Xu = 1, Object.defineProperty(Qu, "__esModule", { value: !0 }), Qu.default = void 0, Qu.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [{ module: "DAISY Guide" }],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section",
					"list"
				]]
			}), Qu)), b = Ae((Yu || (Yu = 1, Object.defineProperty(Ju, "__esModule", { value: !0 }), Ju.default = void 0, Ju.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [{ concept: { name: "Device Independence Delivery Unit" } }, {
					concept: { name: "html" },
					module: "HTML"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [["roletype", "structure"]]
			}), Ju)), _ = Ae((Zu || (Zu = 1, Object.defineProperty(ed, "__esModule", { value: !0 }), ed.default = void 0, ed.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["prohibited"],
				prohibitedProps: ["aria-label", "aria-labelledby"],
				props: {},
				relatedConcepts: [{
					concept: { name: "em" },
					module: "HTML"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section"
				]]
			}), ed)), x = Ae((td || (td = 1, Object.defineProperty(nd, "__esModule", { value: !0 }), nd.default = void 0, nd.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [["article"]],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section",
					"list"
				]]
			}), nd)), w = Ae((sd || (sd = 1, Object.defineProperty(rd, "__esModule", { value: !0 }), rd.default = void 0, rd.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [{
					concept: { name: "figure" },
					module: "HTML"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section"
				]]
			}), rd)), k = Ae((ad || (ad = 1, Object.defineProperty(id, "__esModule", { value: !0 }), id.default = void 0, id.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [
					{
						concept: {
							attributes: [{
								constraints: ["set"],
								name: "aria-label"
							}],
							name: "form"
						},
						module: "HTML"
					},
					{
						concept: {
							attributes: [{
								constraints: ["set"],
								name: "aria-labelledby"
							}],
							name: "form"
						},
						module: "HTML"
					},
					{
						concept: {
							attributes: [{
								constraints: ["set"],
								name: "name"
							}],
							name: "form"
						},
						module: "HTML"
					}
				],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section",
					"landmark"
				]]
			}), id)), C = Ae((od || (od = 1, Object.defineProperty(ld, "__esModule", { value: !0 }), ld.default = void 0, ld.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["prohibited"],
				prohibitedProps: ["aria-label", "aria-labelledby"],
				props: {},
				relatedConcepts: [
					{
						concept: { name: "a" },
						module: "HTML"
					},
					{
						concept: { name: "area" },
						module: "HTML"
					},
					{
						concept: { name: "aside" },
						module: "HTML"
					},
					{
						concept: { name: "b" },
						module: "HTML"
					},
					{
						concept: { name: "bdo" },
						module: "HTML"
					},
					{
						concept: { name: "body" },
						module: "HTML"
					},
					{
						concept: { name: "data" },
						module: "HTML"
					},
					{
						concept: { name: "div" },
						module: "HTML"
					},
					{
						concept: {
							constraints: [
								"scoped to the main element",
								"scoped to a sectioning content element",
								"scoped to a sectioning root element other than body"
							],
							name: "footer"
						},
						module: "HTML"
					},
					{
						concept: {
							constraints: [
								"scoped to the main element",
								"scoped to a sectioning content element",
								"scoped to a sectioning root element other than body"
							],
							name: "header"
						},
						module: "HTML"
					},
					{
						concept: { name: "hgroup" },
						module: "HTML"
					},
					{
						concept: { name: "i" },
						module: "HTML"
					},
					{
						concept: { name: "pre" },
						module: "HTML"
					},
					{
						concept: { name: "q" },
						module: "HTML"
					},
					{
						concept: { name: "samp" },
						module: "HTML"
					},
					{
						concept: { name: "section" },
						module: "HTML"
					},
					{
						concept: { name: "small" },
						module: "HTML"
					},
					{
						concept: { name: "span" },
						module: "HTML"
					},
					{
						concept: { name: "u" },
						module: "HTML"
					}
				],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [["roletype", "structure"]]
			}), ld)), S = Ae((cd || (cd = 1, Object.defineProperty(pd, "__esModule", { value: !0 }), pd.default = void 0, pd.default = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {
					"aria-multiselectable": null,
					"aria-readonly": null
				},
				relatedConcepts: [],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [["row"], ["row", "rowgroup"]],
				requiredProps: {},
				superClass: [[
					"roletype",
					"widget",
					"composite"
				], [
					"roletype",
					"structure",
					"section",
					"table"
				]]
			}), pd)), P = Ae((ud || (ud = 1, Object.defineProperty(dd, "__esModule", { value: !0 }), dd.default = void 0, dd.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author", "contents"],
				prohibitedProps: [],
				props: {
					"aria-disabled": null,
					"aria-errormessage": null,
					"aria-expanded": null,
					"aria-haspopup": null,
					"aria-invalid": null,
					"aria-readonly": null,
					"aria-required": null,
					"aria-selected": null
				},
				relatedConcepts: [{
					concept: {
						constraints: ["ancestor table element has grid role", "ancestor table element has treegrid role"],
						name: "td"
					},
					module: "HTML"
				}],
				requireContextRole: ["row"],
				requiredContextRole: ["row"],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section",
					"cell"
				], ["roletype", "widget"]]
			}), dd)), E = Ae((hd || (hd = 1, Object.defineProperty(md, "__esModule", { value: !0 }), md.default = void 0, md.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {
					"aria-activedescendant": null,
					"aria-disabled": null
				},
				relatedConcepts: [
					{
						concept: { name: "details" },
						module: "HTML"
					},
					{
						concept: { name: "fieldset" },
						module: "HTML"
					},
					{
						concept: { name: "optgroup" },
						module: "HTML"
					},
					{
						concept: { name: "address" },
						module: "HTML"
					}
				],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section"
				]]
			}), md)), T = Ae((fd || (fd = 1, Object.defineProperty(yd, "__esModule", { value: !0 }), yd.default = void 0, yd.default = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author", "contents"],
				prohibitedProps: [],
				props: { "aria-level": "2" },
				relatedConcepts: [
					{
						concept: { name: "h1" },
						module: "HTML"
					},
					{
						concept: { name: "h2" },
						module: "HTML"
					},
					{
						concept: { name: "h3" },
						module: "HTML"
					},
					{
						concept: { name: "h4" },
						module: "HTML"
					},
					{
						concept: { name: "h5" },
						module: "HTML"
					},
					{
						concept: { name: "h6" },
						module: "HTML"
					}
				],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: { "aria-level": "2" },
				superClass: [[
					"roletype",
					"structure",
					"sectionhead"
				]]
			}), yd)), A = Ae((vd || (vd = 1, Object.defineProperty(gd, "__esModule", { value: !0 }), gd.default = void 0, gd.default = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !0,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [
					{
						concept: {
							attributes: [{
								constraints: ["set"],
								name: "alt"
							}],
							name: "img"
						},
						module: "HTML"
					},
					{
						concept: {
							attributes: [{
								constraints: ["undefined"],
								name: "alt"
							}],
							name: "img"
						},
						module: "HTML"
					},
					{
						concept: { name: "imggroup" },
						module: "DTB"
					}
				],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section"
				]]
			}), gd)), $ = Ae((bd || (bd = 1, Object.defineProperty(_d, "__esModule", { value: !0 }), _d.default = void 0, _d.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["prohibited"],
				prohibitedProps: ["aria-label", "aria-labelledby"],
				props: {},
				relatedConcepts: [{
					concept: { name: "ins" },
					module: "HTML"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section"
				]]
			}), _d)), R = Ae((xd || (xd = 1, Object.defineProperty(wd, "__esModule", { value: !0 }), wd.default = void 0, wd.default = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author", "contents"],
				prohibitedProps: [],
				props: {
					"aria-disabled": null,
					"aria-expanded": null,
					"aria-haspopup": null
				},
				relatedConcepts: [{
					concept: {
						attributes: [{
							constraints: ["set"],
							name: "href"
						}],
						name: "a"
					},
					module: "HTML"
				}, {
					concept: {
						attributes: [{
							constraints: ["set"],
							name: "href"
						}],
						name: "area"
					},
					module: "HTML"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"widget",
					"command"
				]]
			}), wd)), I = Ae((kd || (kd = 1, Object.defineProperty(Cd, "__esModule", { value: !0 }), Cd.default = void 0, Cd.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [
					{
						concept: { name: "menu" },
						module: "HTML"
					},
					{
						concept: { name: "ol" },
						module: "HTML"
					},
					{
						concept: { name: "ul" },
						module: "HTML"
					}
				],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [["listitem"]],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section"
				]]
			}), Cd)), M = Ae((Sd || (Sd = 1, Object.defineProperty(Pd, "__esModule", { value: !0 }), Pd.default = void 0, Pd.default = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {
					"aria-errormessage": null,
					"aria-expanded": null,
					"aria-invalid": null,
					"aria-multiselectable": null,
					"aria-readonly": null,
					"aria-required": null,
					"aria-orientation": "vertical"
				},
				relatedConcepts: [
					{
						concept: {
							attributes: [{
								constraints: [">1"],
								name: "size"
							}],
							constraints: ["the size attribute value is greater than 1"],
							name: "select"
						},
						module: "HTML"
					},
					{
						concept: {
							attributes: [{ name: "multiple" }],
							name: "select"
						},
						module: "HTML"
					},
					{
						concept: { name: "datalist" },
						module: "HTML"
					},
					{
						concept: { name: "list" },
						module: "ARIA"
					},
					{
						concept: { name: "select" },
						module: "XForms"
					}
				],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [["option", "group"], ["option"]],
				requiredProps: {},
				superClass: [[
					"roletype",
					"widget",
					"composite",
					"select"
				], [
					"roletype",
					"structure",
					"section",
					"group",
					"select"
				]]
			}), Pd)), q = Ae((Ed || (Ed = 1, Object.defineProperty(Td, "__esModule", { value: !0 }), Td.default = void 0, Td.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {
					"aria-level": null,
					"aria-posinset": null,
					"aria-setsize": null
				},
				relatedConcepts: [{
					concept: {
						constraints: [
							"direct descendant of ol",
							"direct descendant of ul",
							"direct descendant of menu"
						],
						name: "li"
					},
					module: "HTML"
				}, {
					concept: { name: "item" },
					module: "XForms"
				}],
				requireContextRole: ["directory", "list"],
				requiredContextRole: ["directory", "list"],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section"
				]]
			}), Td)), L = Ae((Ad || (Ad = 1, Object.defineProperty($d, "__esModule", { value: !0 }), $d.default = void 0, $d.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: { "aria-live": "polite" },
				relatedConcepts: [],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section"
				]]
			}), $d)), O = Ae((Rd || (Rd = 1, Object.defineProperty(Id, "__esModule", { value: !0 }), Id.default = void 0, Id.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [{
					concept: { name: "main" },
					module: "HTML"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section",
					"landmark"
				]]
			}), Id)), N = Ae((Md || (Md = 1, Object.defineProperty(qd, "__esModule", { value: !0 }), qd.default = void 0, qd.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["prohibited"],
				prohibitedProps: [],
				props: {
					"aria-braillelabel": null,
					"aria-brailleroledescription": null,
					"aria-description": null
				},
				relatedConcepts: [{
					concept: { name: "mark" },
					module: "HTML"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section"
				]]
			}), qd)), D = Ae((Ld || (Ld = 1, Object.defineProperty(Od, "__esModule", { value: !0 }), Od.default = void 0, Od.default = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section"
				]]
			}), Od)), j = Ae((Nd || (Nd = 1, Object.defineProperty(Dd, "__esModule", { value: !0 }), Dd.default = void 0, Dd.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [{
					concept: { name: "math" },
					module: "HTML"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section"
				]]
			}), Dd)), B = Ae((jd || (jd = 1, Object.defineProperty(Bd, "__esModule", { value: !0 }), Bd.default = void 0, Bd.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: { "aria-orientation": "vertical" },
				relatedConcepts: [
					{
						concept: { name: "MENU" },
						module: "JAPI"
					},
					{
						concept: { name: "list" },
						module: "ARIA"
					},
					{
						concept: { name: "select" },
						module: "XForms"
					},
					{
						concept: { name: "sidebar" },
						module: "DTB"
					}
				],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [
					["menuitem", "group"],
					["menuitemradio", "group"],
					["menuitemcheckbox", "group"],
					["menuitem"],
					["menuitemcheckbox"],
					["menuitemradio"]
				],
				requiredProps: {},
				superClass: [[
					"roletype",
					"widget",
					"composite",
					"select"
				], [
					"roletype",
					"structure",
					"section",
					"group",
					"select"
				]]
			}), Bd)), F = Ae((Fd || (Fd = 1, Object.defineProperty(Vd, "__esModule", { value: !0 }), Vd.default = void 0, Vd.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: { "aria-orientation": "horizontal" },
				relatedConcepts: [{
					concept: { name: "toolbar" },
					module: "ARIA"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [
					["menuitem", "group"],
					["menuitemradio", "group"],
					["menuitemcheckbox", "group"],
					["menuitem"],
					["menuitemcheckbox"],
					["menuitemradio"]
				],
				requiredProps: {},
				superClass: [[
					"roletype",
					"widget",
					"composite",
					"select",
					"menu"
				], [
					"roletype",
					"structure",
					"section",
					"group",
					"select",
					"menu"
				]]
			}), Vd)), V = Ae((Hd || (Hd = 1, Object.defineProperty(Ud, "__esModule", { value: !0 }), Ud.default = void 0, Ud.default = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author", "contents"],
				prohibitedProps: [],
				props: {
					"aria-disabled": null,
					"aria-expanded": null,
					"aria-haspopup": null,
					"aria-posinset": null,
					"aria-setsize": null
				},
				relatedConcepts: [
					{
						concept: { name: "MENU_ITEM" },
						module: "JAPI"
					},
					{
						concept: { name: "listitem" },
						module: "ARIA"
					},
					{
						concept: { name: "option" },
						module: "ARIA"
					}
				],
				requireContextRole: [
					"group",
					"menu",
					"menubar"
				],
				requiredContextRole: [
					"group",
					"menu",
					"menubar"
				],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"widget",
					"command"
				]]
			}), Ud)), H = Ae((zd || (zd = 1, Object.defineProperty(Wd, "__esModule", { value: !0 }), Wd.default = void 0, Wd.default = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !0,
				nameFrom: ["author", "contents"],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [{
					concept: { name: "menuitem" },
					module: "ARIA"
				}],
				requireContextRole: [
					"group",
					"menu",
					"menubar"
				],
				requiredContextRole: [
					"group",
					"menu",
					"menubar"
				],
				requiredOwnedElements: [],
				requiredProps: { "aria-checked": null },
				superClass: [[
					"roletype",
					"widget",
					"input",
					"checkbox"
				], [
					"roletype",
					"widget",
					"command",
					"menuitem"
				]]
			}), Wd)), U = Ae((Gd || (Gd = 1, Object.defineProperty(Kd, "__esModule", { value: !0 }), Kd.default = void 0, Kd.default = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !0,
				nameFrom: ["author", "contents"],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [{
					concept: { name: "menuitem" },
					module: "ARIA"
				}],
				requireContextRole: [
					"group",
					"menu",
					"menubar"
				],
				requiredContextRole: [
					"group",
					"menu",
					"menubar"
				],
				requiredOwnedElements: [],
				requiredProps: { "aria-checked": null },
				superClass: [
					[
						"roletype",
						"widget",
						"input",
						"checkbox",
						"menuitemcheckbox"
					],
					[
						"roletype",
						"widget",
						"command",
						"menuitem",
						"menuitemcheckbox"
					],
					[
						"roletype",
						"widget",
						"input",
						"radio"
					]
				]
			}), Kd)), z = Ae((Xd || (Xd = 1, Object.defineProperty(Qd, "__esModule", { value: !0 }), Qd.default = void 0, Qd.default = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !0,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {
					"aria-valuetext": null,
					"aria-valuemax": "100",
					"aria-valuemin": "0"
				},
				relatedConcepts: [{
					concept: { name: "meter" },
					module: "HTML"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: { "aria-valuenow": null },
				superClass: [[
					"roletype",
					"structure",
					"range"
				]]
			}), Qd)), W = Ae((Yd || (Yd = 1, Object.defineProperty(Jd, "__esModule", { value: !0 }), Jd.default = void 0, Jd.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [{
					concept: { name: "nav" },
					module: "HTML"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section",
					"landmark"
				]]
			}), Jd)), G = Ae((Zd || (Zd = 1, Object.defineProperty(eh, "__esModule", { value: !0 }), eh.default = void 0, eh.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: [],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: []
			}), eh)), K = Ae((th || (th = 1, Object.defineProperty(nh, "__esModule", { value: !0 }), nh.default = void 0, nh.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section"
				]]
			}), nh)), X = Ae((sh || (sh = 1, Object.defineProperty(rh, "__esModule", { value: !0 }), rh.default = void 0, rh.default = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !0,
				nameFrom: ["author", "contents"],
				prohibitedProps: [],
				props: {
					"aria-checked": null,
					"aria-posinset": null,
					"aria-setsize": null,
					"aria-selected": "false"
				},
				relatedConcepts: [
					{
						concept: { name: "item" },
						module: "XForms"
					},
					{
						concept: { name: "listitem" },
						module: "ARIA"
					},
					{
						concept: { name: "option" },
						module: "HTML"
					}
				],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: { "aria-selected": "false" },
				superClass: [[
					"roletype",
					"widget",
					"input"
				]]
			}), rh)), Q = Ae((ah || (ah = 1, Object.defineProperty(ih, "__esModule", { value: !0 }), ih.default = void 0, ih.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["prohibited"],
				prohibitedProps: ["aria-label", "aria-labelledby"],
				props: {},
				relatedConcepts: [{
					concept: { name: "p" },
					module: "HTML"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section"
				]]
			}), ih)), Y = Ae((oh || (oh = 1, Object.defineProperty(lh, "__esModule", { value: !0 }), lh.default = void 0, lh.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["prohibited"],
				prohibitedProps: ["aria-label", "aria-labelledby"],
				props: {},
				relatedConcepts: [{
					concept: {
						attributes: [{
							name: "alt",
							value: ""
						}],
						name: "img"
					},
					module: "HTML"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [["roletype", "structure"]]
			}), lh)), J = Ae((ch || (ch = 1, Object.defineProperty(ph, "__esModule", { value: !0 }), ph.default = void 0, ph.default = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !0,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: { "aria-valuetext": null },
				relatedConcepts: [{
					concept: { name: "progress" },
					module: "HTML"
				}, {
					concept: { name: "status" },
					module: "ARIA"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"range"
				], ["roletype", "widget"]]
			}), ph)), Z = Ae((uh || (uh = 1, Object.defineProperty(dh, "__esModule", { value: !0 }), dh.default = void 0, dh.default = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !0,
				nameFrom: ["author", "contents"],
				prohibitedProps: [],
				props: {
					"aria-checked": null,
					"aria-posinset": null,
					"aria-setsize": null
				},
				relatedConcepts: [{
					concept: {
						attributes: [{
							name: "type",
							value: "radio"
						}],
						name: "input"
					},
					module: "HTML"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: { "aria-checked": null },
				superClass: [[
					"roletype",
					"widget",
					"input"
				]]
			}), dh)), ee = Ae((hh || (hh = 1, Object.defineProperty(mh, "__esModule", { value: !0 }), mh.default = void 0, mh.default = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {
					"aria-errormessage": null,
					"aria-invalid": null,
					"aria-readonly": null,
					"aria-required": null
				},
				relatedConcepts: [{
					concept: { name: "list" },
					module: "ARIA"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [["radio"]],
				requiredProps: {},
				superClass: [[
					"roletype",
					"widget",
					"composite",
					"select"
				], [
					"roletype",
					"structure",
					"section",
					"group",
					"select"
				]]
			}), mh)), te = Ae((fh || (fh = 1, Object.defineProperty(yh, "__esModule", { value: !0 }), yh.default = void 0, yh.default = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [
					{
						concept: {
							attributes: [{
								constraints: ["set"],
								name: "aria-label"
							}],
							name: "section"
						},
						module: "HTML"
					},
					{
						concept: {
							attributes: [{
								constraints: ["set"],
								name: "aria-labelledby"
							}],
							name: "section"
						},
						module: "HTML"
					},
					{ concept: { name: "Device Independence Glossart perceivable unit" } }
				],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section",
					"landmark"
				]]
			}), yh)), ne = Ae((vh || (vh = 1, Object.defineProperty(gh, "__esModule", { value: !0 }), gh.default = void 0, gh.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author", "contents"],
				prohibitedProps: [],
				props: {
					"aria-colindex": null,
					"aria-expanded": null,
					"aria-level": null,
					"aria-posinset": null,
					"aria-rowindex": null,
					"aria-selected": null,
					"aria-setsize": null
				},
				relatedConcepts: [{
					concept: { name: "tr" },
					module: "HTML"
				}],
				requireContextRole: [
					"grid",
					"rowgroup",
					"table",
					"treegrid"
				],
				requiredContextRole: [
					"grid",
					"rowgroup",
					"table",
					"treegrid"
				],
				requiredOwnedElements: [
					["cell"],
					["columnheader"],
					["gridcell"],
					["rowheader"]
				],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section",
					"group"
				], ["roletype", "widget"]]
			}), gh)), se = Ae((bh || (bh = 1, Object.defineProperty(_h, "__esModule", { value: !0 }), _h.default = void 0, _h.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author", "contents"],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [
					{
						concept: { name: "tbody" },
						module: "HTML"
					},
					{
						concept: { name: "tfoot" },
						module: "HTML"
					},
					{
						concept: { name: "thead" },
						module: "HTML"
					}
				],
				requireContextRole: [
					"grid",
					"table",
					"treegrid"
				],
				requiredContextRole: [
					"grid",
					"table",
					"treegrid"
				],
				requiredOwnedElements: [["row"]],
				requiredProps: {},
				superClass: [["roletype", "structure"]]
			}), _h)), re = Ae((xh || (xh = 1, Object.defineProperty(wh, "__esModule", { value: !0 }), wh.default = void 0, wh.default = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author", "contents"],
				prohibitedProps: [],
				props: { "aria-sort": null },
				relatedConcepts: [{
					concept: {
						attributes: [{
							name: "scope",
							value: "row"
						}],
						name: "th"
					},
					module: "HTML"
				}, {
					concept: {
						attributes: [{
							name: "scope",
							value: "rowgroup"
						}],
						name: "th"
					},
					module: "HTML"
				}],
				requireContextRole: ["row", "rowgroup"],
				requiredContextRole: ["row", "rowgroup"],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [
					[
						"roletype",
						"structure",
						"section",
						"cell"
					],
					[
						"roletype",
						"structure",
						"section",
						"cell",
						"gridcell"
					],
					[
						"roletype",
						"widget",
						"gridcell"
					],
					[
						"roletype",
						"structure",
						"sectionhead"
					]
				]
			}), wh)), ae = Ae((kh || (kh = 1, Object.defineProperty(Ch, "__esModule", { value: !0 }), Ch.default = void 0, Ch.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !0,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {
					"aria-disabled": null,
					"aria-valuetext": null,
					"aria-orientation": "vertical",
					"aria-valuemax": "100",
					"aria-valuemin": "0"
				},
				relatedConcepts: [],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {
					"aria-controls": null,
					"aria-valuenow": null
				},
				superClass: [[
					"roletype",
					"structure",
					"range"
				], ["roletype", "widget"]]
			}), Ch)), ie = Ae((Sh || (Sh = 1, Object.defineProperty(Ph, "__esModule", { value: !0 }), Ph.default = void 0, Ph.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section",
					"landmark"
				]]
			}), Ph)), oe = Ae((Eh || (Eh = 1, Object.defineProperty(Th, "__esModule", { value: !0 }), Th.default = void 0, Th.default = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [{
					concept: {
						attributes: [{
							constraints: ["undefined"],
							name: "list"
						}, {
							name: "type",
							value: "search"
						}],
						constraints: ["the list attribute is not set"],
						name: "input"
					},
					module: "HTML"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"widget",
					"input",
					"textbox"
				]]
			}), Th)), le = Ae((Ah || (Ah = 1, Object.defineProperty($h, "__esModule", { value: !0 }), $h.default = void 0, $h.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !0,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {
					"aria-disabled": null,
					"aria-orientation": "horizontal",
					"aria-valuemax": "100",
					"aria-valuemin": "0",
					"aria-valuenow": null,
					"aria-valuetext": null
				},
				relatedConcepts: [{
					concept: { name: "hr" },
					module: "HTML"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [["roletype", "structure"]]
			}), $h)), ce = Ae((Rh || (Rh = 1, Object.defineProperty(Ih, "__esModule", { value: !0 }), Ih.default = void 0, Ih.default = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !0,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {
					"aria-errormessage": null,
					"aria-haspopup": null,
					"aria-invalid": null,
					"aria-readonly": null,
					"aria-valuetext": null,
					"aria-orientation": "horizontal",
					"aria-valuemax": "100",
					"aria-valuemin": "0"
				},
				relatedConcepts: [{
					concept: {
						attributes: [{
							name: "type",
							value: "range"
						}],
						name: "input"
					},
					module: "HTML"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: { "aria-valuenow": null },
				superClass: [[
					"roletype",
					"widget",
					"input"
				], [
					"roletype",
					"structure",
					"range"
				]]
			}), Ih)), pe = Ae((Mh || (Mh = 1, Object.defineProperty(qh, "__esModule", { value: !0 }), qh.default = void 0, qh.default = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {
					"aria-errormessage": null,
					"aria-invalid": null,
					"aria-readonly": null,
					"aria-required": null,
					"aria-valuetext": null,
					"aria-valuenow": "0"
				},
				relatedConcepts: [{
					concept: {
						attributes: [{
							name: "type",
							value: "number"
						}],
						name: "input"
					},
					module: "HTML"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [
					[
						"roletype",
						"widget",
						"composite"
					],
					[
						"roletype",
						"widget",
						"input"
					],
					[
						"roletype",
						"structure",
						"range"
					]
				]
			}), qh)), ue = Ae((Lh || (Lh = 1, Object.defineProperty(Oh, "__esModule", { value: !0 }), Oh.default = void 0, Oh.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {
					"aria-atomic": "true",
					"aria-live": "polite"
				},
				relatedConcepts: [{
					concept: { name: "output" },
					module: "HTML"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section"
				]]
			}), Oh)), de = Ae((Nh || (Nh = 1, Object.defineProperty(Dh, "__esModule", { value: !0 }), Dh.default = void 0, Dh.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["prohibited"],
				prohibitedProps: ["aria-label", "aria-labelledby"],
				props: {},
				relatedConcepts: [{
					concept: { name: "strong" },
					module: "HTML"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section"
				]]
			}), Dh)), he = Ae((jh || (jh = 1, Object.defineProperty(Bh, "__esModule", { value: !0 }), Bh.default = void 0, Bh.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["prohibited"],
				prohibitedProps: ["aria-label", "aria-labelledby"],
				props: {},
				relatedConcepts: [{
					concept: { name: "sub" },
					module: "HTML"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section"
				]]
			}), Bh)), me = Ae((Fh || (Fh = 1, Object.defineProperty(Vh, "__esModule", { value: !0 }), Vh.default = void 0, Vh.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["prohibited"],
				prohibitedProps: ["aria-label", "aria-labelledby"],
				props: {},
				relatedConcepts: [{
					concept: { name: "sup" },
					module: "HTML"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section"
				]]
			}), Vh)), fe = Ae((Hh || (Hh = 1, Object.defineProperty(Uh, "__esModule", { value: !0 }), Uh.default = void 0, Uh.default = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !0,
				nameFrom: ["author", "contents"],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [{
					concept: { name: "button" },
					module: "ARIA"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: { "aria-checked": null },
				superClass: [[
					"roletype",
					"widget",
					"input",
					"checkbox"
				]]
			}), Uh)), ye = Ae((zh || (zh = 1, Object.defineProperty(Wh, "__esModule", { value: !0 }), Wh.default = void 0, Wh.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !0,
				nameFrom: ["author", "contents"],
				prohibitedProps: [],
				props: {
					"aria-disabled": null,
					"aria-expanded": null,
					"aria-haspopup": null,
					"aria-posinset": null,
					"aria-setsize": null,
					"aria-selected": "false"
				},
				relatedConcepts: [],
				requireContextRole: ["tablist"],
				requiredContextRole: ["tablist"],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"sectionhead"
				], ["roletype", "widget"]]
			}), Wh)), ve = Ae((Gh || (Gh = 1, Object.defineProperty(Kh, "__esModule", { value: !0 }), Kh.default = void 0, Kh.default = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {
					"aria-colcount": null,
					"aria-rowcount": null
				},
				relatedConcepts: [{
					concept: { name: "table" },
					module: "HTML"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [["row"], ["row", "rowgroup"]],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section"
				]]
			}), Kh)), ge = Ae((Xh || (Xh = 1, Object.defineProperty(Qh, "__esModule", { value: !0 }), Qh.default = void 0, Qh.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {
					"aria-level": null,
					"aria-multiselectable": null,
					"aria-orientation": "horizontal"
				},
				relatedConcepts: [{
					module: "DAISY",
					concept: { name: "guide" }
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [["tab"]],
				requiredProps: {},
				superClass: [[
					"roletype",
					"widget",
					"composite"
				]]
			}), Qh)), be = Ae((Yh || (Yh = 1, Object.defineProperty(Jh, "__esModule", { value: !0 }), Jh.default = void 0, Jh.default = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section"
				]]
			}), Jh)), _e = Ae((Zh || (Zh = 1, Object.defineProperty(em, "__esModule", { value: !0 }), em.default = void 0, em.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [{
					concept: { name: "dfn" },
					module: "HTML"
				}, {
					concept: { name: "dt" },
					module: "HTML"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section"
				]]
			}), em)), xe = Ae((tm || (tm = 1, Object.defineProperty(nm, "__esModule", { value: !0 }), nm.default = void 0, nm.default = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {
					"aria-activedescendant": null,
					"aria-autocomplete": null,
					"aria-errormessage": null,
					"aria-haspopup": null,
					"aria-invalid": null,
					"aria-multiline": null,
					"aria-placeholder": null,
					"aria-readonly": null,
					"aria-required": null
				},
				relatedConcepts: [
					{
						concept: {
							attributes: [{
								constraints: ["undefined"],
								name: "type"
							}, {
								constraints: ["undefined"],
								name: "list"
							}],
							constraints: ["the list attribute is not set"],
							name: "input"
						},
						module: "HTML"
					},
					{
						concept: {
							attributes: [{
								constraints: ["undefined"],
								name: "list"
							}, {
								name: "type",
								value: "email"
							}],
							constraints: ["the list attribute is not set"],
							name: "input"
						},
						module: "HTML"
					},
					{
						concept: {
							attributes: [{
								constraints: ["undefined"],
								name: "list"
							}, {
								name: "type",
								value: "tel"
							}],
							constraints: ["the list attribute is not set"],
							name: "input"
						},
						module: "HTML"
					},
					{
						concept: {
							attributes: [{
								constraints: ["undefined"],
								name: "list"
							}, {
								name: "type",
								value: "text"
							}],
							constraints: ["the list attribute is not set"],
							name: "input"
						},
						module: "HTML"
					},
					{
						concept: {
							attributes: [{
								constraints: ["undefined"],
								name: "list"
							}, {
								name: "type",
								value: "url"
							}],
							constraints: ["the list attribute is not set"],
							name: "input"
						},
						module: "HTML"
					},
					{
						concept: { name: "input" },
						module: "XForms"
					},
					{
						concept: { name: "textarea" },
						module: "HTML"
					}
				],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"widget",
					"input"
				]]
			}), nm)), we = Ae((sm || (sm = 1, Object.defineProperty(rm, "__esModule", { value: !0 }), rm.default = void 0, rm.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [{
					concept: { name: "time" },
					module: "HTML"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section"
				]]
			}), rm)), ke = Ae((am || (am = 1, Object.defineProperty(im, "__esModule", { value: !0 }), im.default = void 0, im.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section",
					"status"
				]]
			}), im)), Ce = Ae((om || (om = 1, Object.defineProperty(lm, "__esModule", { value: !0 }), lm.default = void 0, lm.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: { "aria-orientation": "horizontal" },
				relatedConcepts: [{
					concept: { name: "menubar" },
					module: "ARIA"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section",
					"group"
				]]
			}), lm)), Se = Ae((cm || (cm = 1, Object.defineProperty(pm, "__esModule", { value: !0 }), pm.default = void 0, pm.default = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author", "contents"],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section"
				]]
			}), pm)), Pe = Ae((um || (um = 1, Object.defineProperty(dm, "__esModule", { value: !0 }), dm.default = void 0, dm.default = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {
					"aria-errormessage": null,
					"aria-invalid": null,
					"aria-multiselectable": null,
					"aria-required": null,
					"aria-orientation": "vertical"
				},
				relatedConcepts: [],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [["treeitem", "group"], ["treeitem"]],
				requiredProps: {},
				superClass: [[
					"roletype",
					"widget",
					"composite",
					"select"
				], [
					"roletype",
					"structure",
					"section",
					"group",
					"select"
				]]
			}), dm)), Ee = Ae((hm || (hm = 1, Object.defineProperty(mm, "__esModule", { value: !0 }), mm.default = void 0, mm.default = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [["row"], ["row", "rowgroup"]],
				requiredProps: {},
				superClass: [
					[
						"roletype",
						"widget",
						"composite",
						"grid"
					],
					[
						"roletype",
						"structure",
						"section",
						"table",
						"grid"
					],
					[
						"roletype",
						"widget",
						"composite",
						"select",
						"tree"
					],
					[
						"roletype",
						"structure",
						"section",
						"group",
						"select",
						"tree"
					]
				]
			}), mm)), Te = Ae((fm || (fm = 1, Object.defineProperty(vm, "__esModule", { value: !0 }), vm.default = void 0, vm.default = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author", "contents"],
				prohibitedProps: [],
				props: {
					"aria-expanded": null,
					"aria-haspopup": null
				},
				relatedConcepts: [],
				requireContextRole: ["group", "tree"],
				requiredContextRole: ["group", "tree"],
				requiredOwnedElements: [],
				requiredProps: { "aria-selected": null },
				superClass: [[
					"roletype",
					"structure",
					"section",
					"listitem"
				], [
					"roletype",
					"widget",
					"input",
					"option"
				]]
			}), vm));
			function Ae(e) {
				return e && e.__esModule ? e : { default: e };
			}
			return hu.default = [
				["alert", e.default],
				["alertdialog", t.default],
				["application", n.default],
				["article", s.default],
				["banner", r.default],
				["blockquote", a.default],
				["button", i.default],
				["caption", o.default],
				["cell", l.default],
				["checkbox", c.default],
				["code", p.default],
				["columnheader", u.default],
				["combobox", d.default],
				["complementary", h.default],
				["contentinfo", m.default],
				["definition", f.default],
				["deletion", y.default],
				["dialog", v.default],
				["directory", g.default],
				["document", b.default],
				["emphasis", _.default],
				["feed", x.default],
				["figure", w.default],
				["form", k.default],
				["generic", C.default],
				["grid", S.default],
				["gridcell", P.default],
				["group", E.default],
				["heading", T.default],
				["img", A.default],
				["insertion", $.default],
				["link", R.default],
				["list", I.default],
				["listbox", M.default],
				["listitem", q.default],
				["log", L.default],
				["main", O.default],
				["mark", N.default],
				["marquee", D.default],
				["math", j.default],
				["menu", B.default],
				["menubar", F.default],
				["menuitem", V.default],
				["menuitemcheckbox", H.default],
				["menuitemradio", U.default],
				["meter", z.default],
				["navigation", W.default],
				["none", G.default],
				["note", K.default],
				["option", X.default],
				["paragraph", Q.default],
				["presentation", Y.default],
				["progressbar", J.default],
				["radio", Z.default],
				["radiogroup", ee.default],
				["region", te.default],
				["row", ne.default],
				["rowgroup", se.default],
				["rowheader", re.default],
				["scrollbar", ae.default],
				["search", ie.default],
				["searchbox", oe.default],
				["separator", le.default],
				["slider", ce.default],
				["spinbutton", pe.default],
				["status", ue.default],
				["strong", de.default],
				["subscript", he.default],
				["superscript", me.default],
				["switch", fe.default],
				["tab", ye.default],
				["table", ve.default],
				["tablist", ge.default],
				["tabpanel", be.default],
				["term", _e.default],
				["textbox", xe.default],
				["time", we.default],
				["timer", ke.default],
				["toolbar", Ce.default],
				["tooltip", Se.default],
				["tree", Pe.default],
				["treegrid", Ee.default],
				["treeitem", Te.default]
			], hu;
		}
		var bm, _m = {}, xm = {};
		var wm, km = {};
		var Cm, Sm = {};
		var Pm, Em = {};
		var Tm, Am = {};
		var $m, Rm = {};
		var Im, Mm = {};
		var qm, Lm = {};
		var Om, Nm = {};
		var Dm, jm = {};
		var Bm, Fm = {};
		var Vm, Hm = {};
		var Um, zm = {};
		var Wm, Gm = {};
		var Km, Xm = {};
		var Qm, Ym = {};
		var Jm, Zm = {};
		var ef, tf = {};
		var nf, sf = {};
		var rf, af = {};
		var of, lf = {};
		var cf, pf = {};
		var uf, df = {};
		var hf, mf = {};
		var ff, yf = {};
		var vf, gf = {};
		var bf, _f = {};
		var xf, wf = {};
		var kf, Cf = {};
		var Sf, Pf = {};
		var Ef, Tf = {};
		var Af, $f = {};
		var Rf, If = {};
		var Mf, qf = {};
		var Lf, Of = {};
		var Nf, Df = {};
		var jf, Bf = {};
		var Ff, Vf = {};
		var Hf, Uf = {};
		var zf, Wf = {};
		var Gf, Kf, Xf = {};
		function Qf() {
			if (Kf) return _m;
			Kf = 1, Object.defineProperty(_m, "__esModule", { value: !0 }), _m.default = void 0;
			var e = F((bm || (bm = 1, Object.defineProperty(xm, "__esModule", { value: !0 }), xm.default = void 0, xm.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {
					"aria-disabled": null,
					"aria-errormessage": null,
					"aria-expanded": null,
					"aria-haspopup": null,
					"aria-invalid": null
				},
				relatedConcepts: [{
					concept: { name: "abstract [EPUB-SSV]" },
					module: "EPUB"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section"
				]]
			}), xm)), t = F((wm || (wm = 1, Object.defineProperty(km, "__esModule", { value: !0 }), km.default = void 0, km.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {
					"aria-disabled": null,
					"aria-errormessage": null,
					"aria-expanded": null,
					"aria-haspopup": null,
					"aria-invalid": null
				},
				relatedConcepts: [{
					concept: { name: "acknowledgments [EPUB-SSV]" },
					module: "EPUB"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section",
					"landmark"
				]]
			}), km)), n = F((Cm || (Cm = 1, Object.defineProperty(Sm, "__esModule", { value: !0 }), Sm.default = void 0, Sm.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {
					"aria-disabled": null,
					"aria-errormessage": null,
					"aria-expanded": null,
					"aria-haspopup": null,
					"aria-invalid": null
				},
				relatedConcepts: [{
					concept: { name: "afterword [EPUB-SSV]" },
					module: "EPUB"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section",
					"landmark"
				]]
			}), Sm)), s = F((Pm || (Pm = 1, Object.defineProperty(Em, "__esModule", { value: !0 }), Em.default = void 0, Em.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {
					"aria-disabled": null,
					"aria-errormessage": null,
					"aria-expanded": null,
					"aria-haspopup": null,
					"aria-invalid": null
				},
				relatedConcepts: [{
					concept: { name: "appendix [EPUB-SSV]" },
					module: "EPUB"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section",
					"landmark"
				]]
			}), Em)), r = F((Tm || (Tm = 1, Object.defineProperty(Am, "__esModule", { value: !0 }), Am.default = void 0, Am.default = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author", "contents"],
				prohibitedProps: [],
				props: {
					"aria-errormessage": null,
					"aria-invalid": null
				},
				relatedConcepts: [{
					concept: { name: "referrer [EPUB-SSV]" },
					module: "EPUB"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"widget",
					"command",
					"link"
				]]
			}), Am)), a = F(($m || ($m = 1, Object.defineProperty(Rm, "__esModule", { value: !0 }), Rm.default = void 0, Rm.default = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {
					"aria-disabled": null,
					"aria-errormessage": null,
					"aria-expanded": null,
					"aria-haspopup": null,
					"aria-invalid": null
				},
				relatedConcepts: [{
					concept: { name: "EPUB biblioentry [EPUB-SSV]" },
					module: "EPUB"
				}],
				requireContextRole: ["doc-bibliography"],
				requiredContextRole: ["doc-bibliography"],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section",
					"listitem"
				]]
			}), Rm)), i = F((Im || (Im = 1, Object.defineProperty(Mm, "__esModule", { value: !0 }), Mm.default = void 0, Mm.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {
					"aria-disabled": null,
					"aria-errormessage": null,
					"aria-expanded": null,
					"aria-haspopup": null,
					"aria-invalid": null
				},
				relatedConcepts: [{
					concept: { name: "bibliography [EPUB-SSV]" },
					module: "EPUB"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [["doc-biblioentry"]],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section",
					"landmark"
				]]
			}), Mm)), o = F((qm || (qm = 1, Object.defineProperty(Lm, "__esModule", { value: !0 }), Lm.default = void 0, Lm.default = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author", "contents"],
				prohibitedProps: [],
				props: {
					"aria-errormessage": null,
					"aria-invalid": null
				},
				relatedConcepts: [{
					concept: { name: "biblioref [EPUB-SSV]" },
					module: "EPUB"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"widget",
					"command",
					"link"
				]]
			}), Lm)), l = F((Om || (Om = 1, Object.defineProperty(Nm, "__esModule", { value: !0 }), Nm.default = void 0, Nm.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {
					"aria-disabled": null,
					"aria-errormessage": null,
					"aria-expanded": null,
					"aria-haspopup": null,
					"aria-invalid": null
				},
				relatedConcepts: [{
					concept: { name: "chapter [EPUB-SSV]" },
					module: "EPUB"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section",
					"landmark"
				]]
			}), Nm)), c = F((Dm || (Dm = 1, Object.defineProperty(jm, "__esModule", { value: !0 }), jm.default = void 0, jm.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {
					"aria-disabled": null,
					"aria-errormessage": null,
					"aria-expanded": null,
					"aria-haspopup": null,
					"aria-invalid": null
				},
				relatedConcepts: [{
					concept: { name: "colophon [EPUB-SSV]" },
					module: "EPUB"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section"
				]]
			}), jm)), p = F((Bm || (Bm = 1, Object.defineProperty(Fm, "__esModule", { value: !0 }), Fm.default = void 0, Fm.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {
					"aria-disabled": null,
					"aria-errormessage": null,
					"aria-expanded": null,
					"aria-haspopup": null,
					"aria-invalid": null
				},
				relatedConcepts: [{
					concept: { name: "conclusion [EPUB-SSV]" },
					module: "EPUB"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section",
					"landmark"
				]]
			}), Fm)), u = F((Vm || (Vm = 1, Object.defineProperty(Hm, "__esModule", { value: !0 }), Hm.default = void 0, Hm.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {
					"aria-disabled": null,
					"aria-errormessage": null,
					"aria-expanded": null,
					"aria-haspopup": null,
					"aria-invalid": null
				},
				relatedConcepts: [{
					concept: { name: "cover [EPUB-SSV]" },
					module: "EPUB"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section",
					"img"
				]]
			}), Hm)), d = F((Um || (Um = 1, Object.defineProperty(zm, "__esModule", { value: !0 }), zm.default = void 0, zm.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {
					"aria-disabled": null,
					"aria-errormessage": null,
					"aria-expanded": null,
					"aria-haspopup": null,
					"aria-invalid": null
				},
				relatedConcepts: [{
					concept: { name: "credit [EPUB-SSV]" },
					module: "EPUB"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section"
				]]
			}), zm)), h = F((Wm || (Wm = 1, Object.defineProperty(Gm, "__esModule", { value: !0 }), Gm.default = void 0, Gm.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {
					"aria-disabled": null,
					"aria-errormessage": null,
					"aria-expanded": null,
					"aria-haspopup": null,
					"aria-invalid": null
				},
				relatedConcepts: [{
					concept: { name: "credits [EPUB-SSV]" },
					module: "EPUB"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section",
					"landmark"
				]]
			}), Gm)), m = F((Km || (Km = 1, Object.defineProperty(Xm, "__esModule", { value: !0 }), Xm.default = void 0, Xm.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {
					"aria-disabled": null,
					"aria-errormessage": null,
					"aria-expanded": null,
					"aria-haspopup": null,
					"aria-invalid": null
				},
				relatedConcepts: [{
					concept: { name: "dedication [EPUB-SSV]" },
					module: "EPUB"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section"
				]]
			}), Xm)), f = F((Qm || (Qm = 1, Object.defineProperty(Ym, "__esModule", { value: !0 }), Ym.default = void 0, Ym.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {
					"aria-disabled": null,
					"aria-errormessage": null,
					"aria-expanded": null,
					"aria-haspopup": null,
					"aria-invalid": null
				},
				relatedConcepts: [{
					concept: { name: "rearnote [EPUB-SSV]" },
					module: "EPUB"
				}],
				requireContextRole: ["doc-endnotes"],
				requiredContextRole: ["doc-endnotes"],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section",
					"listitem"
				]]
			}), Ym)), y = F((Jm || (Jm = 1, Object.defineProperty(Zm, "__esModule", { value: !0 }), Zm.default = void 0, Zm.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {
					"aria-disabled": null,
					"aria-errormessage": null,
					"aria-expanded": null,
					"aria-haspopup": null,
					"aria-invalid": null
				},
				relatedConcepts: [{
					concept: { name: "rearnotes [EPUB-SSV]" },
					module: "EPUB"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [["doc-endnote"]],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section",
					"landmark"
				]]
			}), Zm)), v = F((ef || (ef = 1, Object.defineProperty(tf, "__esModule", { value: !0 }), tf.default = void 0, tf.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {
					"aria-disabled": null,
					"aria-errormessage": null,
					"aria-expanded": null,
					"aria-haspopup": null,
					"aria-invalid": null
				},
				relatedConcepts: [{
					concept: { name: "epigraph [EPUB-SSV]" },
					module: "EPUB"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section"
				]]
			}), tf)), g = F((nf || (nf = 1, Object.defineProperty(sf, "__esModule", { value: !0 }), sf.default = void 0, sf.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {
					"aria-disabled": null,
					"aria-errormessage": null,
					"aria-expanded": null,
					"aria-haspopup": null,
					"aria-invalid": null
				},
				relatedConcepts: [{
					concept: { name: "epilogue [EPUB-SSV]" },
					module: "EPUB"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section",
					"landmark"
				]]
			}), sf)), b = F((rf || (rf = 1, Object.defineProperty(af, "__esModule", { value: !0 }), af.default = void 0, af.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {
					"aria-disabled": null,
					"aria-errormessage": null,
					"aria-expanded": null,
					"aria-haspopup": null,
					"aria-invalid": null
				},
				relatedConcepts: [{
					concept: { name: "errata [EPUB-SSV]" },
					module: "EPUB"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section",
					"landmark"
				]]
			}), af)), _ = F((of || (of = 1, Object.defineProperty(lf, "__esModule", { value: !0 }), lf.default = void 0, lf.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {
					"aria-disabled": null,
					"aria-errormessage": null,
					"aria-expanded": null,
					"aria-haspopup": null,
					"aria-invalid": null
				},
				relatedConcepts: [],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section"
				]]
			}), lf)), x = F((cf || (cf = 1, Object.defineProperty(pf, "__esModule", { value: !0 }), pf.default = void 0, pf.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {
					"aria-disabled": null,
					"aria-errormessage": null,
					"aria-expanded": null,
					"aria-haspopup": null,
					"aria-invalid": null
				},
				relatedConcepts: [{
					concept: { name: "footnote [EPUB-SSV]" },
					module: "EPUB"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section"
				]]
			}), pf)), w = F((uf || (uf = 1, Object.defineProperty(df, "__esModule", { value: !0 }), df.default = void 0, df.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {
					"aria-disabled": null,
					"aria-errormessage": null,
					"aria-expanded": null,
					"aria-haspopup": null,
					"aria-invalid": null
				},
				relatedConcepts: [{
					concept: { name: "foreword [EPUB-SSV]" },
					module: "EPUB"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section",
					"landmark"
				]]
			}), df)), k = F((hf || (hf = 1, Object.defineProperty(mf, "__esModule", { value: !0 }), mf.default = void 0, mf.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {
					"aria-disabled": null,
					"aria-errormessage": null,
					"aria-expanded": null,
					"aria-haspopup": null,
					"aria-invalid": null
				},
				relatedConcepts: [{
					concept: { name: "glossary [EPUB-SSV]" },
					module: "EPUB"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [["definition"], ["term"]],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section",
					"landmark"
				]]
			}), mf)), C = F((ff || (ff = 1, Object.defineProperty(yf, "__esModule", { value: !0 }), yf.default = void 0, yf.default = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author", "contents"],
				prohibitedProps: [],
				props: {
					"aria-errormessage": null,
					"aria-invalid": null
				},
				relatedConcepts: [{
					concept: { name: "glossref [EPUB-SSV]" },
					module: "EPUB"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"widget",
					"command",
					"link"
				]]
			}), yf)), S = F((vf || (vf = 1, Object.defineProperty(gf, "__esModule", { value: !0 }), gf.default = void 0, gf.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {
					"aria-disabled": null,
					"aria-errormessage": null,
					"aria-expanded": null,
					"aria-haspopup": null,
					"aria-invalid": null
				},
				relatedConcepts: [{
					concept: { name: "index [EPUB-SSV]" },
					module: "EPUB"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section",
					"landmark",
					"navigation"
				]]
			}), gf)), P = F((bf || (bf = 1, Object.defineProperty(_f, "__esModule", { value: !0 }), _f.default = void 0, _f.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {
					"aria-disabled": null,
					"aria-errormessage": null,
					"aria-expanded": null,
					"aria-haspopup": null,
					"aria-invalid": null
				},
				relatedConcepts: [{
					concept: { name: "introduction [EPUB-SSV]" },
					module: "EPUB"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section",
					"landmark"
				]]
			}), _f)), E = F((xf || (xf = 1, Object.defineProperty(wf, "__esModule", { value: !0 }), wf.default = void 0, wf.default = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author", "contents"],
				prohibitedProps: [],
				props: {
					"aria-errormessage": null,
					"aria-invalid": null
				},
				relatedConcepts: [{
					concept: { name: "noteref [EPUB-SSV]" },
					module: "EPUB"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"widget",
					"command",
					"link"
				]]
			}), wf)), T = F((kf || (kf = 1, Object.defineProperty(Cf, "__esModule", { value: !0 }), Cf.default = void 0, Cf.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {
					"aria-disabled": null,
					"aria-errormessage": null,
					"aria-expanded": null,
					"aria-haspopup": null,
					"aria-invalid": null
				},
				relatedConcepts: [{
					concept: { name: "notice [EPUB-SSV]" },
					module: "EPUB"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section",
					"note"
				]]
			}), Cf)), A = F((Sf || (Sf = 1, Object.defineProperty(Pf, "__esModule", { value: !0 }), Pf.default = void 0, Pf.default = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !0,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {
					"aria-errormessage": null,
					"aria-expanded": null,
					"aria-haspopup": null,
					"aria-invalid": null
				},
				relatedConcepts: [{
					concept: { name: "pagebreak [EPUB-SSV]" },
					module: "EPUB"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"separator"
				]]
			}), Pf)), $ = F((Ef || (Ef = 1, Object.defineProperty(Tf, "__esModule", { value: !0 }), Tf.default = void 0, Tf.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["prohibited"],
				prohibitedProps: [],
				props: {
					"aria-braillelabel": null,
					"aria-brailleroledescription": null,
					"aria-description": null,
					"aria-disabled": null,
					"aria-errormessage": null,
					"aria-haspopup": null,
					"aria-invalid": null
				},
				relatedConcepts: [],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section"
				]]
			}), Tf)), R = F((Af || (Af = 1, Object.defineProperty($f, "__esModule", { value: !0 }), $f.default = void 0, $f.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["prohibited"],
				prohibitedProps: [],
				props: {
					"aria-braillelabel": null,
					"aria-brailleroledescription": null,
					"aria-description": null,
					"aria-disabled": null,
					"aria-errormessage": null,
					"aria-haspopup": null,
					"aria-invalid": null
				},
				relatedConcepts: [],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section"
				]]
			}), $f)), I = F((Rf || (Rf = 1, Object.defineProperty(If, "__esModule", { value: !0 }), If.default = void 0, If.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {
					"aria-disabled": null,
					"aria-errormessage": null,
					"aria-expanded": null,
					"aria-haspopup": null,
					"aria-invalid": null
				},
				relatedConcepts: [{
					concept: { name: "page-list [EPUB-SSV]" },
					module: "EPUB"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section",
					"landmark",
					"navigation"
				]]
			}), If)), M = F((Mf || (Mf = 1, Object.defineProperty(qf, "__esModule", { value: !0 }), qf.default = void 0, qf.default = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {
					"aria-disabled": null,
					"aria-errormessage": null,
					"aria-expanded": null,
					"aria-haspopup": null,
					"aria-invalid": null
				},
				relatedConcepts: [{
					concept: { name: "part [EPUB-SSV]" },
					module: "EPUB"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section",
					"landmark"
				]]
			}), qf)), q = F((Lf || (Lf = 1, Object.defineProperty(Of, "__esModule", { value: !0 }), Of.default = void 0, Of.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {
					"aria-disabled": null,
					"aria-errormessage": null,
					"aria-expanded": null,
					"aria-haspopup": null,
					"aria-invalid": null
				},
				relatedConcepts: [{
					concept: { name: "preface [EPUB-SSV]" },
					module: "EPUB"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section",
					"landmark"
				]]
			}), Of)), L = F((Nf || (Nf = 1, Object.defineProperty(Df, "__esModule", { value: !0 }), Df.default = void 0, Df.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {
					"aria-disabled": null,
					"aria-errormessage": null,
					"aria-expanded": null,
					"aria-haspopup": null,
					"aria-invalid": null
				},
				relatedConcepts: [{
					concept: { name: "prologue [EPUB-SSV]" },
					module: "EPUB"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section",
					"landmark"
				]]
			}), Df)), O = F((jf || (jf = 1, Object.defineProperty(Bf, "__esModule", { value: !0 }), Bf.default = void 0, Bf.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [{
					concept: { name: "pullquote [EPUB-SSV]" },
					module: "EPUB"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [["none"]]
			}), Bf)), N = F((Ff || (Ff = 1, Object.defineProperty(Vf, "__esModule", { value: !0 }), Vf.default = void 0, Vf.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {
					"aria-disabled": null,
					"aria-errormessage": null,
					"aria-expanded": null,
					"aria-haspopup": null,
					"aria-invalid": null
				},
				relatedConcepts: [{
					concept: { name: "qna [EPUB-SSV]" },
					module: "EPUB"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section"
				]]
			}), Vf)), D = F((Hf || (Hf = 1, Object.defineProperty(Uf, "__esModule", { value: !0 }), Uf.default = void 0, Uf.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {
					"aria-disabled": null,
					"aria-errormessage": null,
					"aria-expanded": null,
					"aria-haspopup": null,
					"aria-invalid": null
				},
				relatedConcepts: [{
					concept: { name: "subtitle [EPUB-SSV]" },
					module: "EPUB"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"sectionhead"
				]]
			}), Uf)), j = F((zf || (zf = 1, Object.defineProperty(Wf, "__esModule", { value: !0 }), Wf.default = void 0, Wf.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {
					"aria-disabled": null,
					"aria-errormessage": null,
					"aria-expanded": null,
					"aria-haspopup": null,
					"aria-invalid": null
				},
				relatedConcepts: [{
					concept: { name: "help [EPUB-SSV]" },
					module: "EPUB"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section",
					"note"
				]]
			}), Wf)), B = F((Gf || (Gf = 1, Object.defineProperty(Xf, "__esModule", { value: !0 }), Xf.default = void 0, Xf.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {
					"aria-disabled": null,
					"aria-errormessage": null,
					"aria-expanded": null,
					"aria-haspopup": null,
					"aria-invalid": null
				},
				relatedConcepts: [{
					concept: { name: "toc [EPUB-SSV]" },
					module: "EPUB"
				}],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section",
					"landmark",
					"navigation"
				]]
			}), Xf));
			function F(e) {
				return e && e.__esModule ? e : { default: e };
			}
			return _m.default = [
				["doc-abstract", e.default],
				["doc-acknowledgments", t.default],
				["doc-afterword", n.default],
				["doc-appendix", s.default],
				["doc-backlink", r.default],
				["doc-biblioentry", a.default],
				["doc-bibliography", i.default],
				["doc-biblioref", o.default],
				["doc-chapter", l.default],
				["doc-colophon", c.default],
				["doc-conclusion", p.default],
				["doc-cover", u.default],
				["doc-credit", d.default],
				["doc-credits", h.default],
				["doc-dedication", m.default],
				["doc-endnote", f.default],
				["doc-endnotes", y.default],
				["doc-epigraph", v.default],
				["doc-epilogue", g.default],
				["doc-errata", b.default],
				["doc-example", _.default],
				["doc-footnote", x.default],
				["doc-foreword", w.default],
				["doc-glossary", k.default],
				["doc-glossref", C.default],
				["doc-index", S.default],
				["doc-introduction", P.default],
				["doc-noteref", E.default],
				["doc-notice", T.default],
				["doc-pagebreak", A.default],
				["doc-pagefooter", $.default],
				["doc-pageheader", R.default],
				["doc-pagelist", I.default],
				["doc-part", M.default],
				["doc-preface", q.default],
				["doc-prologue", L.default],
				["doc-pullquote", O.default],
				["doc-qna", N.default],
				["doc-subtitle", D.default],
				["doc-tip", j.default],
				["doc-toc", B.default]
			], _m;
		}
		var Yf, Jf = {}, Zf = {};
		var ey, ty = {};
		var ny, sy, ry, ay = {};
		function iy() {
			if (sy) return Jf;
			sy = 1, Object.defineProperty(Jf, "__esModule", { value: !0 }), Jf.default = void 0;
			var e = s((Yf || (Yf = 1, Object.defineProperty(Zf, "__esModule", { value: !0 }), Zf.default = void 0, Zf.default = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {
					"aria-disabled": null,
					"aria-errormessage": null,
					"aria-expanded": null,
					"aria-haspopup": null,
					"aria-invalid": null
				},
				relatedConcepts: [
					{
						module: "GRAPHICS",
						concept: { name: "graphics-object" }
					},
					{
						module: "ARIA",
						concept: { name: "img" }
					},
					{
						module: "ARIA",
						concept: { name: "article" }
					}
				],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"document"
				]]
			}), Zf)), t = s((ey || (ey = 1, Object.defineProperty(ty, "__esModule", { value: !0 }), ty.default = void 0, ty.default = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ["author", "contents"],
				prohibitedProps: [],
				props: {
					"aria-errormessage": null,
					"aria-expanded": null,
					"aria-haspopup": null,
					"aria-invalid": null
				},
				relatedConcepts: [
					{
						module: "GRAPHICS",
						concept: { name: "graphics-document" }
					},
					{
						module: "ARIA",
						concept: { name: "group" }
					},
					{
						module: "ARIA",
						concept: { name: "img" }
					},
					{
						module: "GRAPHICS",
						concept: { name: "graphics-symbol" }
					}
				],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section",
					"group"
				]]
			}), ty)), n = s((ny || (ny = 1, Object.defineProperty(ay, "__esModule", { value: !0 }), ay.default = void 0, ay.default = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !0,
				nameFrom: ["author"],
				prohibitedProps: [],
				props: {
					"aria-disabled": null,
					"aria-errormessage": null,
					"aria-expanded": null,
					"aria-haspopup": null,
					"aria-invalid": null
				},
				relatedConcepts: [],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [[
					"roletype",
					"structure",
					"section",
					"img"
				]]
			}), ay));
			function s(e) {
				return e && e.__esModule ? e : { default: e };
			}
			return Jf.default = [
				["graphics-document", e.default],
				["graphics-object", t.default],
				["graphics-symbol", n.default]
			], Jf;
		}
		function oy() {
			if (ry) return jp;
			function e(t) {
				return e = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
					return typeof e;
				} : function(e) {
					return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
				}, e(t);
			}
			ry = 1, Object.defineProperty(jp, "__esModule", { value: !0 }), jp.default = void 0;
			var t = i(uu()), n = i(gm()), s = i(Qf()), r = i(iy()), a = i(Mp());
			function i(e) {
				return e && e.__esModule ? e : { default: e };
			}
			function o(t, n, s) {
				return (n = function(t) {
					var n = function(t, n) {
						if ("object" != e(t) || !t) return t;
						var s = t[Symbol.toPrimitive];
						if (void 0 !== s) {
							var r = s.call(t, n);
							if ("object" != e(r)) return r;
							throw new TypeError("@@toPrimitive must return a primitive value.");
						}
						return ("string" === n ? String : Number)(t);
					}(t, "string");
					return "symbol" == e(n) ? n : n + "";
				}(n)) in t ? Object.defineProperty(t, n, {
					value: s,
					enumerable: !0,
					configurable: !0,
					writable: !0
				}) : t[n] = s, t;
			}
			function l(e, t) {
				var n = "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
				if (!n) {
					if (Array.isArray(e) || (n = p(e)) || t) {
						n && (e = n);
						var s = 0, r = function() {};
						return {
							s: r,
							n: function() {
								return s >= e.length ? { done: !0 } : {
									done: !1,
									value: e[s++]
								};
							},
							e: function(e) {
								throw e;
							},
							f: r
						};
					}
					throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
				}
				var a, i = !0, o = !1;
				return {
					s: function() {
						n = n.call(e);
					},
					n: function() {
						var e = n.next();
						return i = e.done, e;
					},
					e: function(e) {
						o = !0, a = e;
					},
					f: function() {
						try {
							i || null == n.return || n.return();
						} finally {
							if (o) throw a;
						}
					}
				};
			}
			function c(e, t) {
				return function(e) {
					if (Array.isArray(e)) return e;
				}(e) || function(e, t) {
					var n = null == e ? null : "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
					if (null != n) {
						var s, r, a, i, o = [], l = !0, c = !1;
						try {
							if (a = (n = n.call(e)).next, 0 === t) {
								if (Object(n) !== n) return;
								l = !1;
							} else for (; !(l = (s = a.call(n)).done) && (o.push(s.value), o.length !== t); l = !0);
						} catch (e) {
							c = !0, r = e;
						} finally {
							try {
								if (!l && null != n.return && (i = n.return(), Object(i) !== i)) return;
							} finally {
								if (c) throw r;
							}
						}
						return o;
					}
				}(e, t) || p(e, t) || function() {
					throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
				}();
			}
			function p(e, t) {
				if (e) {
					if ("string" == typeof e) return u(e, t);
					var n = {}.toString.call(e).slice(8, -1);
					return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? u(e, t) : void 0;
				}
			}
			function u(e, t) {
				(null == t || t > e.length) && (t = e.length);
				for (var n = 0, s = Array(t); n < t; n++) s[n] = e[n];
				return s;
			}
			var d = [].concat(t.default, n.default, s.default, r.default);
			d.forEach((function(e) {
				var t, n = c(e, 2)[1], s = l(n.superClass);
				try {
					for (s.s(); !(t = s.n()).done;) {
						var r, a = l(t.value);
						try {
							var i = function() {
								var e = r.value, t = d.find((function(t) {
									return c(t, 1)[0] === e;
								}));
								if (t) for (var s = t[1], a = 0, i = Object.keys(s.props); a < i.length; a++) {
									var l = i[a];
									Object.prototype.hasOwnProperty.call(n.props, l) || Object.assign(n.props, o({}, l, s.props[l]));
								}
							};
							for (a.s(); !(r = a.n()).done;) i();
						} catch (e) {
							a.e(e);
						} finally {
							a.f();
						}
					}
				} catch (e) {
					s.e(e);
				} finally {
					s.f();
				}
			}));
			var h = {
				entries: function() {
					return d;
				},
				forEach: function(e) {
					var t, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, s = l(d);
					try {
						for (s.s(); !(t = s.n()).done;) {
							var r = c(t.value, 2), a = r[0], i = r[1];
							e.call(n, i, a, d);
						}
					} catch (e) {
						s.e(e);
					} finally {
						s.f();
					}
				},
				get: function(e) {
					var t = d.find((function(t) {
						return t[0] === e;
					}));
					return t && t[1];
				},
				has: function(e) {
					return !!h.get(e);
				},
				keys: function() {
					return d.map((function(e) {
						return c(e, 1)[0];
					}));
				},
				values: function() {
					return d.map((function(e) {
						return c(e, 2)[1];
					}));
				}
			};
			return jp.default = (0, a.default)(h, h.entries()), jp;
		}
		var ly, cy = {};
		function py() {
			if (ly) return cy;
			ly = 1, Object.defineProperty(cy, "__esModule", { value: !0 }), cy.default = void 0;
			var e = n(Mp()), t = n(oy());
			function n(e) {
				return e && e.__esModule ? e : { default: e };
			}
			function s(e, t) {
				return function(e) {
					if (Array.isArray(e)) return e;
				}(e) || function(e, t) {
					var n = null == e ? null : "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
					if (null != n) {
						var s, r, a, i, o = [], l = !0, c = !1;
						try {
							if (a = (n = n.call(e)).next, 0 === t) {
								if (Object(n) !== n) return;
								l = !1;
							} else for (; !(l = (s = a.call(n)).done) && (o.push(s.value), o.length !== t); l = !0);
						} catch (e) {
							c = !0, r = e;
						} finally {
							try {
								if (!l && null != n.return && (i = n.return(), Object(i) !== i)) return;
							} finally {
								if (c) throw r;
							}
						}
						return o;
					}
				}(e, t) || function(e, t) {
					if (e) {
						if ("string" == typeof e) return r(e, t);
						var n = {}.toString.call(e).slice(8, -1);
						return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? r(e, t) : void 0;
					}
				}(e, t) || function() {
					throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
				}();
			}
			function r(e, t) {
				(null == t || t > e.length) && (t = e.length);
				for (var n = 0, s = Array(t); n < t; n++) s[n] = e[n];
				return s;
			}
			for (var a = [], i = t.default.keys(), o = 0; o < i.length; o++) {
				var l = i[o], c = t.default.get(l);
				if (c) for (var p = [].concat(c.baseConcepts, c.relatedConcepts), u = 0; u < p.length; u++) {
					var d = p[u];
					"HTML" === d.module && function() {
						var e = d.concept;
						if (e) {
							var t, n = a.find((function(t) {
								return n = t[0], s = e, n.name === s.name && function(e, t) {
									if (void 0 === e && void 0 !== t) return !1;
									if (void 0 !== e && void 0 === t) return !1;
									if (void 0 !== e && void 0 !== t) {
										if (e.length !== t.length) return !1;
										for (var n = 0; n < e.length; n++) if (e[n] !== t[n]) return !1;
									}
									return !0;
								}(n.constraints, s.constraints) && m(n.attributes, s.attributes);
								var n, s;
							}));
							t = n ? n[1] : [];
							for (var s = !0, r = 0; r < t.length; r++) if (t[r] === l) {
								s = !1;
								break;
							}
							s && t.push(l), n || a.push([e, t]);
						}
					}();
				}
			}
			var h = {
				entries: function() {
					return a;
				},
				forEach: function(e) {
					for (var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, n = 0, r = a; n < r.length; n++) {
						var i = s(r[n], 2), o = i[0], l = i[1];
						e.call(t, l, o, a);
					}
				},
				get: function(e) {
					var t = a.find((function(t) {
						return e.name === t[0].name && m(e.attributes, t[0].attributes);
					}));
					return t && t[1];
				},
				has: function(e) {
					return !!h.get(e);
				},
				keys: function() {
					return a.map((function(e) {
						return s(e, 1)[0];
					}));
				},
				values: function() {
					return a.map((function(e) {
						return s(e, 2)[1];
					}));
				}
			};
			function m(e, t) {
				if (void 0 === e && void 0 !== t) return !1;
				if (void 0 !== e && void 0 === t) return !1;
				if (void 0 !== e && void 0 !== t) {
					if (e.length !== t.length) return !1;
					for (var n = 0; n < e.length; n++) {
						if (e[n].name !== t[n].name || e[n].value !== t[n].value) return !1;
						if (void 0 === e[n].constraints && void 0 !== t[n].constraints) return !1;
						if (void 0 !== e[n].constraints && void 0 === t[n].constraints) return !1;
						if (void 0 !== e[n].constraints && void 0 !== t[n].constraints) {
							if (e[n].constraints.length !== t[n].constraints.length) return !1;
							for (var s = 0; s < e[n].constraints.length; s++) if (e[n].constraints[s] !== t[n].constraints[s]) return !1;
						}
					}
				}
				return !0;
			}
			return cy.default = (0, e.default)(h, h.entries()), cy;
		}
		var uy, dy, hy = {};
		function my() {
			if (uy) return hy;
			uy = 1, Object.defineProperty(hy, "__esModule", { value: !0 }), hy.default = void 0;
			var e = n(Mp()), t = n(oy());
			function n(e) {
				return e && e.__esModule ? e : { default: e };
			}
			function s(e, t) {
				return function(e) {
					if (Array.isArray(e)) return e;
				}(e) || function(e, t) {
					var n = null == e ? null : "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
					if (null != n) {
						var s, r, a, i, o = [], l = !0, c = !1;
						try {
							if (a = (n = n.call(e)).next, 0 === t) {
								if (Object(n) !== n) return;
								l = !1;
							} else for (; !(l = (s = a.call(n)).done) && (o.push(s.value), o.length !== t); l = !0);
						} catch (e) {
							c = !0, r = e;
						} finally {
							try {
								if (!l && null != n.return && (i = n.return(), Object(i) !== i)) return;
							} finally {
								if (c) throw r;
							}
						}
						return o;
					}
				}(e, t) || function(e, t) {
					if (e) {
						if ("string" == typeof e) return r(e, t);
						var n = {}.toString.call(e).slice(8, -1);
						return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? r(e, t) : void 0;
					}
				}(e, t) || function() {
					throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
				}();
			}
			function r(e, t) {
				(null == t || t > e.length) && (t = e.length);
				for (var n = 0, s = Array(t); n < t; n++) s[n] = e[n];
				return s;
			}
			for (var a = [], i = t.default.keys(), o = 0; o < i.length; o++) {
				var l = i[o], c = t.default.get(l), p = [];
				if (c) {
					for (var u = [].concat(c.baseConcepts, c.relatedConcepts), d = 0; d < u.length; d++) {
						var h = u[d];
						if ("HTML" === h.module) {
							var m = h.concept;
							null != m && p.push(m);
						}
					}
					p.length > 0 && a.push([l, p]);
				}
			}
			var f = {
				entries: function() {
					return a;
				},
				forEach: function(e) {
					for (var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, n = 0, r = a; n < r.length; n++) {
						var i = s(r[n], 2), o = i[0], l = i[1];
						e.call(t, l, o, a);
					}
				},
				get: function(e) {
					var t = a.find((function(t) {
						return t[0] === e;
					}));
					return t && t[1];
				},
				has: function(e) {
					return !!f.get(e);
				},
				keys: function() {
					return a.map((function(e) {
						return s(e, 1)[0];
					}));
				},
				values: function() {
					return a.map((function(e) {
						return s(e, 2)[1];
					}));
				}
			};
			return hy.default = (0, e.default)(f, f.entries()), hy;
		}
		var fy, yy, vy = function() {
			if (dy) return Ap;
			dy = 1, Object.defineProperty(Ap, "__esModule", { value: !0 }), Ap.roles = Ap.roleElements = Ap.elementRoles = Ap.dom = Ap.aria = void 0;
			var e = a(qp()), t = a(Np()), n = a(oy()), s = a(py()), r = a(my());
			function a(e) {
				return e && e.__esModule ? e : { default: e };
			}
			return Ap.aria = e.default, Ap.dom = t.default, Ap.roles = n.default, Ap.elementRoles = s.default, Ap.roleElements = r.default, Ap;
		}(), gy = {}, by = {}, _y = {}, xy = {};
		function wy() {
			if (yy) return _y;
			yy = 1, Object.defineProperty(_y, "__esModule", { value: !0 }), _y.default = function(e, s) {
				"function" == typeof Symbol && "symbol" === n(Symbol.iterator) && Object.defineProperty(e, Symbol.iterator, { value: t.default.bind(s) });
				return e;
			};
			var e, t = (e = function() {
				if (fy) return xy;
				fy = 1, Object.defineProperty(xy, "__esModule", { value: !0 }), xy.default = void 0;
				var e = function() {
					var e = this, t = 0, n = {
						"@@iterator": function() {
							return n;
						},
						next: function() {
							if (t < e.length) {
								var n = e[t];
								return t += 1, {
									done: !1,
									value: n
								};
							}
							return { done: !0 };
						}
					};
					return n;
				};
				return xy.default = e, xy;
			}()) && e.__esModule ? e : { default: e };
			function n(e) {
				return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
					return typeof e;
				} : function(e) {
					return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
				}, n(e);
			}
			return _y;
		}
		var ky, Cy = {}, Sy = {};
		var Py, Ey = {};
		var Ty, Ay = {};
		var $y, Ry = {};
		var Iy, My = {};
		var qy, Ly = {};
		var Oy, Ny = {};
		var Dy, jy = {};
		var By, Fy = {};
		var Vy, Hy = {};
		var Uy, zy = {};
		var Wy, Gy = {};
		var Ky, Xy = {};
		var Qy, Yy = {};
		var Jy, Zy = {};
		var ev, tv = {};
		var nv, sv = {};
		var rv, av = {};
		var iv, ov = {};
		var lv, cv = {};
		var pv, uv = {};
		var dv, hv = {};
		var mv, fv = {};
		var yv, vv = {};
		var gv, bv = {};
		var _v, xv = {};
		var wv, kv = {};
		var Cv, Sv = {};
		var Pv, Ev = {};
		var Tv, Av = {};
		var $v, Rv = {};
		var Iv, Mv = {};
		var qv, Lv = {};
		var Ov, Nv = {};
		var Dv, jv = {};
		var Bv, Fv = {};
		var Vv, Hv = {};
		var Uv, zv = {};
		var Wv, Gv = {};
		var Kv, Xv = {};
		var Qv, Yv = {};
		var Jv, Zv = {};
		var eg, tg = {};
		var ng, sg = {};
		var rg, ag = {};
		var ig, og = {};
		var lg, cg = {};
		var pg, ug = {};
		var dg, hg = {};
		var mg, fg = {};
		var yg, vg = {};
		var gg, bg = {};
		var _g, xg = {};
		var wg, kg = {};
		var Cg, Sg = {};
		var Pg, Eg = {};
		var Tg, Ag = {};
		var $g, Rg = {};
		var Ig, Mg = {};
		var qg, Lg = {};
		var Og, Ng = {};
		var Dg, jg = {};
		var Bg, Fg = {};
		var Vg, Hg = {};
		var Ug, zg = {};
		var Wg, Gg = {};
		var Kg, Xg = {};
		var Qg, Yg = {};
		var Jg, Zg = {};
		var eb, tb = {};
		var nb, sb = {};
		var rb, ab = {};
		var ib, ob = {};
		var lb, cb = {};
		var pb, ub = {};
		var db, hb = {};
		var mb, fb = {};
		var yb, vb = {};
		var gb, bb = {};
		var _b, xb = {};
		var wb, kb = {};
		var Cb, Sb = {};
		var Pb, Eb = {};
		var Tb, Ab = {};
		var $b, Rb = {};
		var Ib, Mb = {};
		var qb, Lb = {};
		var Ob, Nb = {};
		var Db, jb = {};
		var Bb, Fb = {};
		var Vb, Hb = {};
		var Ub, zb = {};
		var Wb, Gb = {};
		var Kb, Xb = {};
		var Qb, Yb = {};
		var Jb, Zb = {};
		var e_, t_ = {};
		var n_, s_ = {};
		var r_, a_ = {};
		var i_, o_ = {};
		var l_, c_ = {};
		var p_, u_ = {};
		var d_, h_ = {};
		var m_, f_ = {};
		var y_, v_ = {};
		var g_, b_ = {};
		var __, x_ = {};
		var w_, k_ = {};
		var C_, S_ = {};
		var P_, E_ = {};
		var T_, A_ = {};
		var $_, R_ = {};
		var I_, M_ = {};
		var q_, L_ = {};
		var O_, N_ = {};
		var D_, j_ = {};
		var B_, F_ = {};
		var V_, H_ = {};
		var U_, z_ = {};
		var W_, G_ = {};
		var K_, X_ = {};
		var Q_, Y_ = {};
		var J_, Z_ = {};
		var ex, tx, nx, sx = {};
		function rx() {
			if (tx) return Cy;
			tx = 1, Object.defineProperty(Cy, "__esModule", { value: !0 }), Cy.default = void 0;
			var e = vt(wy()), t = vt(function() {
				if (ky) return Sy;
				ky = 1, Object.defineProperty(Sy, "__esModule", { value: !0 }), Sy.default = void 0;
				return Sy.default = {
					relatedConcepts: [{
						module: "HTML",
						concept: { name: "abbr" }
					}],
					type: "structure"
				}, Sy;
			}()), n = vt(function() {
				if (Py) return Ey;
				Py = 1, Object.defineProperty(Ey, "__esModule", { value: !0 }), Ey.default = void 0;
				return Ey.default = {
					relatedConcepts: [{
						module: "ARIA",
						concept: { name: "alertdialog" }
					}],
					type: "window"
				}, Ey;
			}()), s = vt(function() {
				if (Ty) return Ay;
				Ty = 1, Object.defineProperty(Ay, "__esModule", { value: !0 }), Ay.default = void 0;
				return Ay.default = {
					relatedConcepts: [{
						module: "ARIA",
						concept: { name: "alert" }
					}],
					type: "structure"
				}, Ay;
			}()), r = vt(function() {
				if ($y) return Ry;
				$y = 1, Object.defineProperty(Ry, "__esModule", { value: !0 }), Ry.default = void 0;
				return Ry.default = {
					relatedConcepts: [],
					type: "structure"
				}, Ry;
			}()), a = vt(function() {
				if (Iy) return My;
				Iy = 1, Object.defineProperty(My, "__esModule", { value: !0 }), My.default = void 0;
				return My.default = {
					relatedConcepts: [{
						module: "ARIA",
						concept: { name: "application" }
					}],
					type: "window"
				}, My;
			}()), i = vt(function() {
				if (qy) return Ly;
				qy = 1, Object.defineProperty(Ly, "__esModule", { value: !0 }), Ly.default = void 0;
				return Ly.default = {
					relatedConcepts: [{
						module: "ARIA",
						concept: { name: "article" }
					}, {
						module: "HTML",
						concept: { name: "article" }
					}],
					type: "structure"
				}, Ly;
			}()), o = vt(function() {
				if (Oy) return Ny;
				Oy = 1, Object.defineProperty(Ny, "__esModule", { value: !0 }), Ny.default = void 0;
				return Ny.default = {
					relatedConcepts: [{
						module: "HTML",
						concept: { name: "audio" }
					}],
					type: "widget"
				}, Ny;
			}()), l = vt(function() {
				if (Dy) return jy;
				Dy = 1, Object.defineProperty(jy, "__esModule", { value: !0 }), jy.default = void 0;
				return jy.default = {
					relatedConcepts: [{
						module: "ARIA",
						concept: { name: "banner" }
					}],
					type: "structure"
				}, jy;
			}()), c = vt(function() {
				if (By) return Fy;
				By = 1, Object.defineProperty(Fy, "__esModule", { value: !0 }), Fy.default = void 0;
				return Fy.default = {
					relatedConcepts: [{
						module: "HTML",
						concept: { name: "blockquote" }
					}],
					type: "structure"
				}, Fy;
			}()), p = vt(function() {
				if (Vy) return Hy;
				Vy = 1, Object.defineProperty(Hy, "__esModule", { value: !0 }), Hy.default = void 0;
				return Hy.default = {
					relatedConcepts: [{
						module: "ARIA",
						concept: { attributes: [{
							name: "aria-busy",
							value: "true"
						}] }
					}],
					type: "widget"
				}, Hy;
			}()), u = vt(function() {
				if (Uy) return zy;
				Uy = 1, Object.defineProperty(zy, "__esModule", { value: !0 }), zy.default = void 0;
				return zy.default = {
					relatedConcepts: [{
						module: "ARIA",
						concept: { name: "button" }
					}, {
						module: "HTML",
						concept: { name: "button" }
					}],
					type: "widget"
				}, zy;
			}()), d = vt(function() {
				if (Wy) return Gy;
				Wy = 1, Object.defineProperty(Gy, "__esModule", { value: !0 }), Gy.default = void 0;
				return Gy.default = {
					relatedConcepts: [{
						module: "HTML",
						concept: { name: "canvas" }
					}],
					type: "widget"
				}, Gy;
			}()), h = vt(function() {
				if (Ky) return Xy;
				Ky = 1, Object.defineProperty(Xy, "__esModule", { value: !0 }), Xy.default = void 0;
				return Xy.default = {
					relatedConcepts: [{
						module: "HTML",
						concept: { name: "caption" }
					}],
					type: "structure"
				}, Xy;
			}()), m = vt(function() {
				if (Qy) return Yy;
				Qy = 1, Object.defineProperty(Yy, "__esModule", { value: !0 }), Yy.default = void 0;
				return Yy.default = {
					relatedConcepts: [
						{
							module: "ARIA",
							concept: { name: "cell" }
						},
						{
							module: "ARIA",
							concept: { name: "gridcell" }
						},
						{
							module: "HTML",
							concept: { name: "td" }
						}
					],
					type: "widget"
				}, Yy;
			}()), f = vt(function() {
				if (Jy) return Zy;
				Jy = 1, Object.defineProperty(Zy, "__esModule", { value: !0 }), Zy.default = void 0;
				return Zy.default = {
					relatedConcepts: [{
						module: "ARIA",
						concept: { name: "checkbox" }
					}, {
						module: "HTML",
						concept: {
							name: "input",
							attributes: [{
								name: "type",
								value: "checkbox"
							}]
						}
					}],
					type: "widget"
				}, Zy;
			}()), y = vt(function() {
				if (ev) return tv;
				ev = 1, Object.defineProperty(tv, "__esModule", { value: !0 }), tv.default = void 0;
				return tv.default = {
					relatedConcepts: [{
						module: "HTML",
						concept: {
							name: "input",
							attributes: [{
								name: "type",
								value: "color"
							}]
						}
					}],
					type: "widget"
				}, tv;
			}()), v = vt(function() {
				if (nv) return sv;
				nv = 1, Object.defineProperty(sv, "__esModule", { value: !0 }), sv.default = void 0;
				return sv.default = {
					relatedConcepts: [{
						module: "ARIA",
						concept: { name: "columnheader" }
					}, {
						module: "HTML",
						concept: { name: "th" }
					}],
					type: "widget"
				}, sv;
			}()), g = vt(function() {
				if (rv) return av;
				rv = 1, Object.defineProperty(av, "__esModule", { value: !0 }), av.default = void 0;
				return av.default = {
					relatedConcepts: [],
					type: "structure"
				}, av;
			}()), b = vt(function() {
				if (iv) return ov;
				iv = 1, Object.defineProperty(ov, "__esModule", { value: !0 }), ov.default = void 0;
				return ov.default = {
					relatedConcepts: [{
						module: "ARIA",
						concept: { name: "combobox" }
					}, {
						module: "HTML",
						concept: { name: "select" }
					}],
					type: "widget"
				}, ov;
			}()), _ = vt(function() {
				if (lv) return cv;
				lv = 1, Object.defineProperty(cv, "__esModule", { value: !0 }), cv.default = void 0;
				return cv.default = {
					relatedConcepts: [{
						module: "ARIA",
						concept: { name: "complementary" }
					}],
					type: "structure"
				}, cv;
			}()), x = vt(function() {
				if (pv) return uv;
				pv = 1, Object.defineProperty(uv, "__esModule", { value: !0 }), uv.default = void 0;
				return uv.default = {
					relatedConcepts: [{
						module: "ARIA",
						concept: { name: "structureinfo" }
					}],
					type: "structure"
				}, uv;
			}()), w = vt(function() {
				if (dv) return hv;
				dv = 1, Object.defineProperty(hv, "__esModule", { value: !0 }), hv.default = void 0;
				return hv.default = {
					relatedConcepts: [{
						module: "HTML",
						concept: {
							name: "input",
							attributes: [{
								name: "type",
								value: "date"
							}]
						}
					}],
					type: "widget"
				}, hv;
			}()), k = vt(function() {
				if (mv) return fv;
				mv = 1, Object.defineProperty(fv, "__esModule", { value: !0 }), fv.default = void 0;
				return fv.default = {
					relatedConcepts: [{
						module: "HTML",
						concept: {
							name: "input",
							attributes: [{
								name: "type",
								value: "datetime"
							}]
						}
					}],
					type: "widget"
				}, fv;
			}()), C = vt(function() {
				if (yv) return vv;
				yv = 1, Object.defineProperty(vv, "__esModule", { value: !0 }), vv.default = void 0;
				return vv.default = {
					relatedConcepts: [{
						module: "HTML",
						concept: { name: "dfn" }
					}],
					type: "structure"
				}, vv;
			}()), S = vt(function() {
				if (gv) return bv;
				gv = 1, Object.defineProperty(bv, "__esModule", { value: !0 }), bv.default = void 0;
				return bv.default = {
					relatedConcepts: [{
						module: "HTML",
						concept: { name: "dd" }
					}],
					type: "structure"
				}, bv;
			}()), P = vt(function() {
				if (_v) return xv;
				_v = 1, Object.defineProperty(xv, "__esModule", { value: !0 }), xv.default = void 0;
				return xv.default = {
					relatedConcepts: [{
						module: "HTML",
						concept: { name: "dl" }
					}],
					type: "structure"
				}, xv;
			}()), E = vt(function() {
				if (wv) return kv;
				wv = 1, Object.defineProperty(kv, "__esModule", { value: !0 }), kv.default = void 0;
				return kv.default = {
					relatedConcepts: [{
						module: "HTML",
						concept: { name: "dt" }
					}],
					type: "structure"
				}, kv;
			}()), T = vt(function() {
				if (Cv) return Sv;
				Cv = 1, Object.defineProperty(Sv, "__esModule", { value: !0 }), Sv.default = void 0;
				return Sv.default = {
					relatedConcepts: [{
						module: "HTML",
						concept: { name: "details" }
					}],
					type: "structure"
				}, Sv;
			}()), A = vt(function() {
				if (Pv) return Ev;
				Pv = 1, Object.defineProperty(Ev, "__esModule", { value: !0 }), Ev.default = void 0;
				return Ev.default = {
					relatedConcepts: [{
						module: "ARIA",
						concept: { name: "dialog" }
					}, {
						module: "HTML",
						concept: { name: "dialog" }
					}],
					type: "window"
				}, Ev;
			}()), $ = vt(function() {
				if (Tv) return Av;
				Tv = 1, Object.defineProperty(Av, "__esModule", { value: !0 }), Av.default = void 0;
				return Av.default = {
					relatedConcepts: [{
						module: "ARIA",
						concept: { name: "directory" }
					}, {
						module: "HTML",
						concept: { name: "dir" }
					}],
					type: "structure"
				}, Av;
			}()), R = vt(function() {
				if ($v) return Rv;
				$v = 1, Object.defineProperty(Rv, "__esModule", { value: !0 }), Rv.default = void 0;
				return Rv.default = {
					relatedConcepts: [{
						module: "HTML",
						concept: {
							constraints: ["scoped to a details element"],
							name: "summary"
						}
					}],
					type: "widget"
				}, Rv;
			}()), I = vt(function() {
				if (Iv) return Mv;
				Iv = 1, Object.defineProperty(Mv, "__esModule", { value: !0 }), Mv.default = void 0;
				return Mv.default = {
					relatedConcepts: [{
						module: "HTML",
						concept: { name: "div" }
					}],
					type: "generic"
				}, Mv;
			}()), M = vt(function() {
				if (qv) return Lv;
				qv = 1, Object.defineProperty(Lv, "__esModule", { value: !0 }), Lv.default = void 0;
				return Lv.default = {
					relatedConcepts: [{
						module: "ARIA",
						concept: { name: "document" }
					}],
					type: "structure"
				}, Lv;
			}()), q = vt(function() {
				if (Ov) return Nv;
				Ov = 1, Object.defineProperty(Nv, "__esModule", { value: !0 }), Nv.default = void 0;
				return Nv.default = {
					relatedConcepts: [{
						module: "HTML",
						concept: { name: "embed" }
					}],
					type: "widget"
				}, Nv;
			}()), L = vt(function() {
				if (Dv) return jv;
				Dv = 1, Object.defineProperty(jv, "__esModule", { value: !0 }), jv.default = void 0;
				return jv.default = {
					relatedConcepts: [{
						module: "ARIA",
						concept: { name: "feed" }
					}],
					type: "structure"
				}, jv;
			}()), O = vt(function() {
				if (Bv) return Fv;
				Bv = 1, Object.defineProperty(Fv, "__esModule", { value: !0 }), Fv.default = void 0;
				return Fv.default = {
					relatedConcepts: [{
						module: "HTML",
						concept: { name: "figcaption" }
					}],
					type: "structure"
				}, Fv;
			}()), N = vt(function() {
				if (Vv) return Hv;
				Vv = 1, Object.defineProperty(Hv, "__esModule", { value: !0 }), Hv.default = void 0;
				return Hv.default = {
					relatedConcepts: [{
						module: "ARIA",
						concept: { name: "figure" }
					}, {
						module: "HTML",
						concept: { name: "figure" }
					}],
					type: "structure"
				}, Hv;
			}()), D = vt(function() {
				if (Uv) return zv;
				Uv = 1, Object.defineProperty(zv, "__esModule", { value: !0 }), zv.default = void 0;
				return zv.default = {
					relatedConcepts: [{
						module: "HTML",
						concept: { name: "footer" }
					}],
					type: "structure"
				}, zv;
			}()), j = vt(function() {
				if (Wv) return Gv;
				Wv = 1, Object.defineProperty(Gv, "__esModule", { value: !0 }), Gv.default = void 0;
				return Gv.default = {
					relatedConcepts: [{
						module: "ARIA",
						concept: { name: "form" }
					}, {
						module: "HTML",
						concept: { name: "form" }
					}],
					type: "structure"
				}, Gv;
			}()), B = vt(function() {
				if (Kv) return Xv;
				Kv = 1, Object.defineProperty(Xv, "__esModule", { value: !0 }), Xv.default = void 0;
				return Xv.default = {
					relatedConcepts: [{
						module: "ARIA",
						concept: { name: "grid" }
					}],
					type: "widget"
				}, Xv;
			}()), F = vt(function() {
				if (Qv) return Yv;
				Qv = 1, Object.defineProperty(Yv, "__esModule", { value: !0 }), Yv.default = void 0;
				return Yv.default = {
					relatedConcepts: [{
						module: "ARIA",
						concept: { name: "group" }
					}],
					type: "structure"
				}, Yv;
			}()), V = vt(function() {
				if (Jv) return Zv;
				Jv = 1, Object.defineProperty(Zv, "__esModule", { value: !0 }), Zv.default = void 0;
				return Zv.default = {
					relatedConcepts: [
						{
							module: "ARIA",
							concept: { name: "heading" }
						},
						{
							module: "HTML",
							concept: { name: "h1" }
						},
						{
							module: "HTML",
							concept: { name: "h2" }
						},
						{
							module: "HTML",
							concept: { name: "h3" }
						},
						{
							module: "HTML",
							concept: { name: "h4" }
						},
						{
							module: "HTML",
							concept: { name: "h5" }
						},
						{
							module: "HTML",
							concept: { name: "h6" }
						}
					],
					type: "structure"
				}, Zv;
			}()), H = vt(function() {
				if (eg) return tg;
				eg = 1, Object.defineProperty(tg, "__esModule", { value: !0 }), tg.default = void 0;
				return tg.default = {
					relatedConcepts: [],
					type: "window"
				}, tg;
			}()), U = vt(function() {
				if (ng) return sg;
				ng = 1, Object.defineProperty(sg, "__esModule", { value: !0 }), sg.default = void 0;
				return sg.default = {
					relatedConcepts: [{
						module: "HTML",
						concept: { name: "iframe" }
					}],
					type: "window"
				}, sg;
			}()), z = vt(function() {
				if (rg) return ag;
				rg = 1, Object.defineProperty(ag, "__esModule", { value: !0 }), ag.default = void 0;
				return ag.default = {
					relatedConcepts: [],
					type: "structure"
				}, ag;
			}()), W = vt(function() {
				if (ig) return og;
				ig = 1, Object.defineProperty(og, "__esModule", { value: !0 }), og.default = void 0;
				return og.default = {
					relatedConcepts: [],
					type: "widget"
				}, og;
			}()), G = vt(function() {
				if (lg) return cg;
				lg = 1, Object.defineProperty(cg, "__esModule", { value: !0 }), cg.default = void 0;
				return cg.default = {
					relatedConcepts: [{
						module: "HTML",
						concept: {
							name: "img",
							attributes: [{ name: "usemap" }]
						}
					}],
					type: "structure"
				}, cg;
			}()), K = vt(function() {
				if (pg) return ug;
				pg = 1, Object.defineProperty(ug, "__esModule", { value: !0 }), ug.default = void 0;
				return ug.default = {
					relatedConcepts: [{
						module: "ARIA",
						concept: { name: "img" }
					}, {
						module: "HTML",
						concept: { name: "img" }
					}],
					type: "structure"
				}, ug;
			}()), X = vt(function() {
				if (dg) return hg;
				dg = 1, Object.defineProperty(hg, "__esModule", { value: !0 }), hg.default = void 0;
				return hg.default = {
					relatedConcepts: [{
						module: "HTML",
						concept: { name: "input" }
					}],
					type: "widget"
				}, hg;
			}()), Q = vt(function() {
				if (mg) return fg;
				mg = 1, Object.defineProperty(fg, "__esModule", { value: !0 }), fg.default = void 0;
				return fg.default = {
					relatedConcepts: [{
						module: "HTML",
						concept: {
							name: "input",
							attributes: [{
								name: "type",
								value: "time"
							}]
						}
					}],
					type: "widget"
				}, fg;
			}()), Y = vt(function() {
				if (yg) return vg;
				yg = 1, Object.defineProperty(vg, "__esModule", { value: !0 }), vg.default = void 0;
				return vg.default = {
					relatedConcepts: [{
						module: "HTML",
						concept: { name: "label" }
					}],
					type: "structure"
				}, vg;
			}()), J = vt(function() {
				if (gg) return bg;
				gg = 1, Object.defineProperty(bg, "__esModule", { value: !0 }), bg.default = void 0;
				return bg.default = {
					relatedConcepts: [{
						module: "HTML",
						concept: { name: "legend" }
					}],
					type: "structure"
				}, bg;
			}()), Z = vt(function() {
				if (_g) return xg;
				_g = 1, Object.defineProperty(xg, "__esModule", { value: !0 }), xg.default = void 0;
				return xg.default = {
					relatedConcepts: [{
						module: "HTML",
						concept: { name: "br" }
					}],
					type: "structure"
				}, xg;
			}()), ee = vt(function() {
				if (wg) return kg;
				wg = 1, Object.defineProperty(kg, "__esModule", { value: !0 }), kg.default = void 0;
				return kg.default = {
					relatedConcepts: [{
						module: "ARIA",
						concept: { name: "link" }
					}, {
						module: "HTML",
						concept: {
							name: "a",
							attributes: [{ name: "href" }]
						}
					}],
					type: "widget"
				}, kg;
			}()), te = vt(function() {
				if (Cg) return Sg;
				Cg = 1, Object.defineProperty(Sg, "__esModule", { value: !0 }), Sg.default = void 0;
				return Sg.default = {
					relatedConcepts: [{
						module: "ARIA",
						concept: { name: "option" }
					}, {
						module: "HTML",
						concept: { name: "option" }
					}],
					type: "widget"
				}, Sg;
			}()), ne = vt(function() {
				if (Pg) return Eg;
				Pg = 1, Object.defineProperty(Eg, "__esModule", { value: !0 }), Eg.default = void 0;
				return Eg.default = {
					relatedConcepts: [
						{
							module: "ARIA",
							concept: { name: "listbox" }
						},
						{
							module: "HTML",
							concept: { name: "datalist" }
						},
						{
							module: "HTML",
							concept: { name: "select" }
						}
					],
					type: "widget"
				}, Eg;
			}()), se = vt(function() {
				if (Tg) return Ag;
				Tg = 1, Object.defineProperty(Ag, "__esModule", { value: !0 }), Ag.default = void 0;
				return Ag.default = {
					relatedConcepts: [{
						module: "ARIA",
						concept: { name: "listitem" }
					}, {
						module: "HTML",
						concept: { name: "li" }
					}],
					type: "structure"
				}, Ag;
			}()), re = vt(function() {
				if ($g) return Rg;
				$g = 1, Object.defineProperty(Rg, "__esModule", { value: !0 }), Rg.default = void 0;
				return Rg.default = {
					relatedConcepts: [],
					type: "structure"
				}, Rg;
			}()), ae = vt(function() {
				if (Ig) return Mg;
				Ig = 1, Object.defineProperty(Mg, "__esModule", { value: !0 }), Mg.default = void 0;
				return Mg.default = {
					relatedConcepts: [
						{
							module: "ARIA",
							concept: { name: "list" }
						},
						{
							module: "HTML",
							concept: { name: "ul" }
						},
						{
							module: "HTML",
							concept: { name: "ol" }
						}
					],
					type: "structure"
				}, Mg;
			}()), ie = vt(function() {
				if (qg) return Lg;
				qg = 1, Object.defineProperty(Lg, "__esModule", { value: !0 }), Lg.default = void 0;
				return Lg.default = {
					relatedConcepts: [{
						module: "ARIA",
						concept: { name: "log" }
					}],
					type: "structure"
				}, Lg;
			}()), oe = vt(function() {
				if (Og) return Ng;
				Og = 1, Object.defineProperty(Ng, "__esModule", { value: !0 }), Ng.default = void 0;
				return Ng.default = {
					relatedConcepts: [{
						module: "ARIA",
						concept: { name: "main" }
					}, {
						module: "HTML",
						concept: { name: "main" }
					}],
					type: "structure"
				}, Ng;
			}()), le = vt(function() {
				if (Dg) return jg;
				Dg = 1, Object.defineProperty(jg, "__esModule", { value: !0 }), jg.default = void 0;
				return jg.default = {
					relatedConcepts: [{
						module: "HTML",
						concept: { name: "mark" }
					}],
					type: "structure"
				}, jg;
			}()), ce = vt(function() {
				if (Bg) return Fg;
				Bg = 1, Object.defineProperty(Fg, "__esModule", { value: !0 }), Fg.default = void 0;
				return Fg.default = {
					relatedConcepts: [{
						module: "ARIA",
						concept: { name: "marquee" }
					}, {
						module: "HTML",
						concept: { name: "marquee" }
					}],
					type: "structure"
				}, Fg;
			}()), pe = vt(function() {
				if (Vg) return Hg;
				Vg = 1, Object.defineProperty(Hg, "__esModule", { value: !0 }), Hg.default = void 0;
				return Hg.default = {
					relatedConcepts: [{
						module: "ARIA",
						concept: { name: "math" }
					}],
					type: "structure"
				}, Hg;
			}()), ue = vt(function() {
				if (Ug) return zg;
				Ug = 1, Object.defineProperty(zg, "__esModule", { value: !0 }), zg.default = void 0;
				return zg.default = {
					relatedConcepts: [{
						module: "ARIA",
						concept: { name: "menubar" }
					}],
					type: "structure"
				}, zg;
			}()), de = vt(function() {
				if (Wg) return Gg;
				Wg = 1, Object.defineProperty(Gg, "__esModule", { value: !0 }), Gg.default = void 0;
				return Gg.default = {
					relatedConcepts: [],
					type: "widget"
				}, Gg;
			}()), he = vt(function() {
				if (Kg) return Xg;
				Kg = 1, Object.defineProperty(Xg, "__esModule", { value: !0 }), Xg.default = void 0;
				return Xg.default = {
					relatedConcepts: [{
						module: "ARIA",
						concept: { name: "menuitem" }
					}, {
						module: "HTML",
						concept: { name: "menuitem" }
					}],
					type: "widget"
				}, Xg;
			}()), me = vt(function() {
				if (Qg) return Yg;
				Qg = 1, Object.defineProperty(Yg, "__esModule", { value: !0 }), Yg.default = void 0;
				return Yg.default = {
					relatedConcepts: [{
						module: "ARIA",
						concept: { name: "menuitemcheckbox" }
					}],
					type: "widget"
				}, Yg;
			}()), fe = vt(function() {
				if (Jg) return Zg;
				Jg = 1, Object.defineProperty(Zg, "__esModule", { value: !0 }), Zg.default = void 0;
				return Zg.default = {
					relatedConcepts: [{
						module: "ARIA",
						concept: { name: "menuitemradio" }
					}],
					type: "widget"
				}, Zg;
			}()), ye = vt(function() {
				if (eb) return tb;
				eb = 1, Object.defineProperty(tb, "__esModule", { value: !0 }), tb.default = void 0;
				return tb.default = {
					relatedConcepts: [],
					type: "widget"
				}, tb;
			}()), ve = vt(function() {
				if (nb) return sb;
				nb = 1, Object.defineProperty(sb, "__esModule", { value: !0 }), sb.default = void 0;
				return sb.default = {
					relatedConcepts: [],
					type: "widget"
				}, sb;
			}()), ge = vt(function() {
				if (rb) return ab;
				rb = 1, Object.defineProperty(ab, "__esModule", { value: !0 }), ab.default = void 0;
				return ab.default = {
					relatedConcepts: [{
						module: "ARIA",
						concept: { name: "menu" }
					}, {
						module: "HTML",
						concept: { name: "menu" }
					}],
					type: "structure"
				}, ab;
			}()), be = vt(function() {
				if (ib) return ob;
				ib = 1, Object.defineProperty(ob, "__esModule", { value: !0 }), ob.default = void 0;
				return ob.default = {
					relatedConcepts: [{
						module: "HTML",
						concept: { name: "meter" }
					}],
					type: "structure"
				}, ob;
			}()), _e = vt(function() {
				if (lb) return cb;
				lb = 1, Object.defineProperty(cb, "__esModule", { value: !0 }), cb.default = void 0;
				return cb.default = {
					relatedConcepts: [{
						module: "ARIA",
						concept: { name: "navigation" }
					}, {
						module: "HTML",
						concept: { name: "nav" }
					}],
					type: "structure"
				}, cb;
			}()), xe = vt(function() {
				if (pb) return ub;
				pb = 1, Object.defineProperty(ub, "__esModule", { value: !0 }), ub.default = void 0;
				return ub.default = {
					relatedConcepts: [{
						module: "ARIA",
						concept: { name: "none" }
					}],
					type: "structure"
				}, ub;
			}()), we = vt(function() {
				if (db) return hb;
				db = 1, Object.defineProperty(hb, "__esModule", { value: !0 }), hb.default = void 0;
				return hb.default = {
					relatedConcepts: [{
						module: "ARIA",
						concept: { name: "note" }
					}],
					type: "structure"
				}, hb;
			}()), ke = vt(function() {
				if (mb) return fb;
				mb = 1, Object.defineProperty(fb, "__esModule", { value: !0 }), fb.default = void 0;
				return fb.default = {
					relatedConcepts: [],
					type: "structure"
				}, fb;
			}()), Ce = vt(function() {
				if (yb) return vb;
				yb = 1, Object.defineProperty(vb, "__esModule", { value: !0 }), vb.default = void 0;
				return vb.default = {
					relatedConcepts: [{
						module: "HTML",
						concept: { name: "p" }
					}],
					type: "structure"
				}, vb;
			}()), Se = vt(function() {
				if (gb) return bb;
				gb = 1, Object.defineProperty(bb, "__esModule", { value: !0 }), bb.default = void 0;
				return bb.default = {
					relatedConcepts: [],
					type: "widget"
				}, bb;
			}()), Pe = vt(function() {
				if (_b) return xb;
				_b = 1, Object.defineProperty(xb, "__esModule", { value: !0 }), xb.default = void 0;
				return xb.default = {
					relatedConcepts: [{
						module: "HTML",
						concept: { name: "pre" }
					}],
					type: "structure"
				}, xb;
			}()), Ee = vt(function() {
				if (wb) return kb;
				wb = 1, Object.defineProperty(kb, "__esModule", { value: !0 }), kb.default = void 0;
				return kb.default = {
					relatedConcepts: [{
						module: "ARIA",
						concept: { name: "presentation" }
					}],
					type: "structure"
				}, kb;
			}()), Te = vt(function() {
				if (Cb) return Sb;
				Cb = 1, Object.defineProperty(Sb, "__esModule", { value: !0 }), Sb.default = void 0;
				return Sb.default = {
					relatedConcepts: [{
						module: "ARIA",
						concept: { name: "progressbar" }
					}, {
						module: "HTML",
						concept: { name: "progress" }
					}],
					type: "structure"
				}, Sb;
			}()), Ae = vt(function() {
				if (Pb) return Eb;
				Pb = 1, Object.defineProperty(Eb, "__esModule", { value: !0 }), Eb.default = void 0;
				return Eb.default = {
					relatedConcepts: [{
						module: "ARIA",
						concept: { name: "radio" }
					}, {
						module: "HTML",
						concept: {
							name: "input",
							attributes: [{
								name: "type",
								value: "radio"
							}]
						}
					}],
					type: "widget"
				}, Eb;
			}()), $e = vt(function() {
				if (Tb) return Ab;
				Tb = 1, Object.defineProperty(Ab, "__esModule", { value: !0 }), Ab.default = void 0;
				return Ab.default = {
					relatedConcepts: [{
						module: "ARIA",
						concept: { name: "radiogroup" }
					}],
					type: "structure"
				}, Ab;
			}()), Re = vt(function() {
				if ($b) return Rb;
				$b = 1, Object.defineProperty(Rb, "__esModule", { value: !0 }), Rb.default = void 0;
				return Rb.default = {
					relatedConcepts: [{
						module: "ARIA",
						concept: { name: "region" }
					}],
					type: "structure"
				}, Rb;
			}()), Ie = vt(function() {
				if (Ib) return Mb;
				Ib = 1, Object.defineProperty(Mb, "__esModule", { value: !0 }), Mb.default = void 0;
				return Mb.default = {
					relatedConcepts: [],
					type: "structure"
				}, Mb;
			}()), Me = vt(function() {
				if (qb) return Lb;
				qb = 1, Object.defineProperty(Lb, "__esModule", { value: !0 }), Lb.default = void 0;
				return Lb.default = {
					relatedConcepts: [{
						module: "ARIA",
						concept: { name: "rowheader" }
					}, {
						module: "HTML",
						concept: {
							name: "th",
							attributes: [{
								name: "scope",
								value: "row"
							}]
						}
					}],
					type: "widget"
				}, Lb;
			}()), qe = vt(function() {
				if (Ob) return Nb;
				Ob = 1, Object.defineProperty(Nb, "__esModule", { value: !0 }), Nb.default = void 0;
				return Nb.default = {
					relatedConcepts: [{
						module: "ARIA",
						concept: { name: "row" }
					}, {
						module: "HTML",
						concept: { name: "tr" }
					}],
					type: "structure"
				}, Nb;
			}()), Le = vt(function() {
				if (Db) return jb;
				Db = 1, Object.defineProperty(jb, "__esModule", { value: !0 }), jb.default = void 0;
				return jb.default = {
					relatedConcepts: [{
						module: "HTML",
						concept: { name: "ruby" }
					}],
					type: "structure"
				}, jb;
			}()), Oe = vt(function() {
				if (Bb) return Fb;
				Bb = 1, Object.defineProperty(Fb, "__esModule", { value: !0 }), Fb.default = void 0;
				return Fb.default = {
					relatedConcepts: [],
					type: "structure"
				}, Fb;
			}()), Ne = vt(function() {
				if (Vb) return Hb;
				Vb = 1, Object.defineProperty(Hb, "__esModule", { value: !0 }), Hb.default = void 0;
				return Hb.default = {
					relatedConcepts: [],
					type: "structure"
				}, Hb;
			}()), De = vt(function() {
				if (Ub) return zb;
				Ub = 1, Object.defineProperty(zb, "__esModule", { value: !0 }), zb.default = void 0;
				return zb.default = {
					relatedConcepts: [{
						module: "ARIA",
						concept: { name: "scrollbar" }
					}],
					type: "widget"
				}, zb;
			}()), je = vt(function() {
				if (Wb) return Gb;
				Wb = 1, Object.defineProperty(Gb, "__esModule", { value: !0 }), Gb.default = void 0;
				return Gb.default = {
					relatedConcepts: [],
					type: "structure"
				}, Gb;
			}()), Be = vt(function() {
				if (Kb) return Xb;
				Kb = 1, Object.defineProperty(Xb, "__esModule", { value: !0 }), Xb.default = void 0;
				return Xb.default = {
					relatedConcepts: [{
						module: "ARIA",
						concept: { name: "search" }
					}],
					type: "structure"
				}, Xb;
			}()), Fe = vt(function() {
				if (Qb) return Yb;
				Qb = 1, Object.defineProperty(Yb, "__esModule", { value: !0 }), Yb.default = void 0;
				return Yb.default = {
					relatedConcepts: [{
						module: "ARIA",
						concept: { name: "searchbox" }
					}, {
						module: "HTML",
						concept: {
							name: "input",
							attributes: [{
								name: "type",
								value: "search"
							}]
						}
					}],
					type: "widget"
				}, Yb;
			}()), Ve = vt(function() {
				if (Jb) return Zb;
				Jb = 1, Object.defineProperty(Zb, "__esModule", { value: !0 }), Zb.default = void 0;
				return Zb.default = {
					relatedConcepts: [{
						module: "ARIA",
						concept: { name: "slider" }
					}, {
						module: "HTML",
						concept: {
							name: "input",
							attributes: [{
								name: "type",
								value: "range"
							}]
						}
					}],
					type: "widget"
				}, Zb;
			}()), He = vt(function() {
				if (e_) return t_;
				e_ = 1, Object.defineProperty(t_, "__esModule", { value: !0 }), t_.default = void 0;
				return t_.default = {
					relatedConcepts: [],
					type: "structure"
				}, t_;
			}()), Ue = vt(function() {
				if (n_) return s_;
				n_ = 1, Object.defineProperty(s_, "__esModule", { value: !0 }), s_.default = void 0;
				return s_.default = {
					relatedConcepts: [{
						module: "ARIA",
						concept: { name: "spinbutton" }
					}, {
						module: "HTML",
						concept: {
							name: "input",
							attributes: [{
								name: "type",
								value: "number"
							}]
						}
					}],
					type: "widget"
				}, s_;
			}()), ze = vt(function() {
				if (r_) return a_;
				r_ = 1, Object.defineProperty(a_, "__esModule", { value: !0 }), a_.default = void 0;
				return a_.default = {
					relatedConcepts: [],
					type: "structure"
				}, a_;
			}()), We = vt(function() {
				if (i_) return o_;
				i_ = 1, Object.defineProperty(o_, "__esModule", { value: !0 }), o_.default = void 0;
				return o_.default = {
					relatedConcepts: [{
						module: "ARIA",
						concept: { name: "separator" }
					}],
					type: "widget"
				}, o_;
			}()), Ge = vt(function() {
				if (l_) return c_;
				l_ = 1, Object.defineProperty(c_, "__esModule", { value: !0 }), c_.default = void 0;
				return c_.default = {
					relatedConcepts: [],
					type: "structure"
				}, c_;
			}()), Ke = vt(function() {
				if (p_) return u_;
				p_ = 1, Object.defineProperty(u_, "__esModule", { value: !0 }), u_.default = void 0;
				return u_.default = {
					relatedConcepts: [{
						module: "ARIA",
						concept: { name: "status" }
					}],
					type: "structure"
				}, u_;
			}()), Xe = vt(function() {
				if (d_) return h_;
				d_ = 1, Object.defineProperty(h_, "__esModule", { value: !0 }), h_.default = void 0;
				return h_.default = {
					relatedConcepts: [],
					type: "structure"
				}, h_;
			}()), Qe = vt(function() {
				if (m_) return f_;
				m_ = 1, Object.defineProperty(f_, "__esModule", { value: !0 }), f_.default = void 0;
				return f_.default = {
					relatedConcepts: [{
						module: "ARIA",
						concept: { name: "switch" }
					}, {
						module: "HTML",
						concept: {
							name: "input",
							attributes: [{
								name: "type",
								value: "checkbox"
							}]
						}
					}],
					type: "widget"
				}, f_;
			}()), Ye = vt(function() {
				if (y_) return v_;
				y_ = 1, Object.defineProperty(v_, "__esModule", { value: !0 }), v_.default = void 0;
				return v_.default = {
					relatedConcepts: [{
						module: "ARIA",
						concept: { name: "tablist" }
					}],
					type: "structure"
				}, v_;
			}()), Je = vt(function() {
				if (g_) return b_;
				g_ = 1, Object.defineProperty(b_, "__esModule", { value: !0 }), b_.default = void 0;
				return b_.default = {
					relatedConcepts: [{
						module: "ARIA",
						concept: { name: "tab" }
					}],
					type: "widget"
				}, b_;
			}()), Ze = vt(function() {
				if (__) return x_;
				__ = 1, Object.defineProperty(x_, "__esModule", { value: !0 }), x_.default = void 0;
				return x_.default = {
					relatedConcepts: [],
					type: "structure"
				}, x_;
			}()), et = vt(function() {
				if (w_) return k_;
				w_ = 1, Object.defineProperty(k_, "__esModule", { value: !0 }), k_.default = void 0;
				return k_.default = {
					relatedConcepts: [{
						module: "ARIA",
						concept: { name: "table" }
					}, {
						module: "HTML",
						concept: { name: "table" }
					}],
					type: "structure"
				}, k_;
			}()), tt = vt(function() {
				if (C_) return S_;
				C_ = 1, Object.defineProperty(S_, "__esModule", { value: !0 }), S_.default = void 0;
				return S_.default = {
					relatedConcepts: [{
						module: "ARIA",
						concept: { name: "tablist" }
					}],
					type: "structure"
				}, S_;
			}()), nt = vt(function() {
				if (P_) return E_;
				P_ = 1, Object.defineProperty(E_, "__esModule", { value: !0 }), E_.default = void 0;
				return E_.default = {
					relatedConcepts: [{
						module: "ARIA",
						concept: { name: "tabpanel" }
					}],
					type: "structure"
				}, E_;
			}()), st = vt(function() {
				if (T_) return A_;
				T_ = 1, Object.defineProperty(A_, "__esModule", { value: !0 }), A_.default = void 0;
				return A_.default = {
					relatedConcepts: [{
						module: "ARIA",
						concept: { name: "term" }
					}],
					type: "structure"
				}, A_;
			}()), rt = vt(function() {
				if ($_) return R_;
				$_ = 1, Object.defineProperty(R_, "__esModule", { value: !0 }), R_.default = void 0;
				return R_.default = {
					relatedConcepts: [{
						module: "ARIA",
						concept: {
							attributes: [{
								name: "aria-multiline",
								value: "true"
							}],
							name: "textbox"
						}
					}, {
						module: "HTML",
						concept: { name: "textarea" }
					}],
					type: "widget"
				}, R_;
			}()), at = vt(function() {
				if (I_) return M_;
				I_ = 1, Object.defineProperty(M_, "__esModule", { value: !0 }), M_.default = void 0;
				return M_.default = {
					relatedConcepts: [
						{
							module: "ARIA",
							concept: { name: "textbox" }
						},
						{
							module: "HTML",
							concept: { name: "input" }
						},
						{
							module: "HTML",
							concept: {
								name: "input",
								attributes: [{
									name: "type",
									value: "text"
								}]
							}
						}
					],
					type: "widget"
				}, M_;
			}()), it = vt(function() {
				if (q_) return L_;
				q_ = 1, Object.defineProperty(L_, "__esModule", { value: !0 }), L_.default = void 0;
				return L_.default = {
					relatedConcepts: [{
						module: "HTML",
						concept: { name: "time" }
					}],
					type: "structure"
				}, L_;
			}()), ot = vt(function() {
				if (O_) return N_;
				O_ = 1, Object.defineProperty(N_, "__esModule", { value: !0 }), N_.default = void 0;
				return N_.default = {
					relatedConcepts: [{
						module: "ARIA",
						concept: { name: "timer" }
					}],
					type: "structure"
				}, N_;
			}()), lt = vt(function() {
				if (D_) return j_;
				D_ = 1, Object.defineProperty(j_, "__esModule", { value: !0 }), j_.default = void 0;
				return j_.default = {
					relatedConcepts: [{
						module: "ARIA",
						concept: { attributes: [{ name: "aria-pressed" }] }
					}],
					type: "widget"
				}, j_;
			}()), ct = vt(function() {
				if (B_) return F_;
				B_ = 1, Object.defineProperty(F_, "__esModule", { value: !0 }), F_.default = void 0;
				return F_.default = {
					relatedConcepts: [{
						module: "ARIA",
						concept: { name: "toolbar" }
					}],
					type: "structure"
				}, F_;
			}()), pt = vt(function() {
				if (V_) return H_;
				V_ = 1, Object.defineProperty(H_, "__esModule", { value: !0 }), H_.default = void 0;
				return H_.default = {
					relatedConcepts: [{
						module: "ARIA",
						concept: { name: "tree" }
					}],
					type: "widget"
				}, H_;
			}()), ut = vt(function() {
				if (U_) return z_;
				U_ = 1, Object.defineProperty(z_, "__esModule", { value: !0 }), z_.default = void 0;
				return z_.default = {
					relatedConcepts: [{
						module: "ARIA",
						concept: { name: "treegrid" }
					}],
					type: "widget"
				}, z_;
			}()), dt = vt(function() {
				if (W_) return G_;
				W_ = 1, Object.defineProperty(G_, "__esModule", { value: !0 }), G_.default = void 0;
				return G_.default = {
					relatedConcepts: [{
						module: "ARIA",
						concept: { name: "treeitem" }
					}],
					type: "widget"
				}, G_;
			}()), ht = vt(function() {
				if (K_) return X_;
				K_ = 1, Object.defineProperty(X_, "__esModule", { value: !0 }), X_.default = void 0;
				return X_.default = {
					relatedConcepts: [{
						module: "ARIA",
						concept: { name: "tooltip" }
					}],
					type: "structure"
				}, X_;
			}()), mt = vt(function() {
				if (Q_) return Y_;
				Q_ = 1, Object.defineProperty(Y_, "__esModule", { value: !0 }), Y_.default = void 0;
				return Y_.default = {
					relatedConcepts: [{
						module: "HTML",
						concept: { name: "video" }
					}],
					type: "widget"
				}, Y_;
			}()), ft = vt(function() {
				if (J_) return Z_;
				J_ = 1, Object.defineProperty(Z_, "__esModule", { value: !0 }), Z_.default = void 0;
				return Z_.default = {
					relatedConcepts: [],
					type: "structure"
				}, Z_;
			}()), yt = vt(function() {
				if (ex) return sx;
				ex = 1, Object.defineProperty(sx, "__esModule", { value: !0 }), sx.default = void 0;
				return sx.default = {
					relatedConcepts: [],
					type: "window"
				}, sx;
			}());
			function vt(e) {
				return e && e.__esModule ? e : { default: e };
			}
			function gt(e, t) {
				return function(e) {
					if (Array.isArray(e)) return e;
				}(e) || function(e, t) {
					var n = null == e ? null : "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
					if (null == n) return;
					var s, r, a = [], i = !0, o = !1;
					try {
						for (n = n.call(e); !(i = (s = n.next()).done) && (a.push(s.value), !t || a.length !== t); i = !0);
					} catch (e) {
						o = !0, r = e;
					} finally {
						try {
							i || null == n.return || n.return();
						} finally {
							if (o) throw r;
						}
					}
					return a;
				}(e, t) || function(e, t) {
					if (!e) return;
					if ("string" == typeof e) return bt(e, t);
					var n = Object.prototype.toString.call(e).slice(8, -1);
					"Object" === n && e.constructor && (n = e.constructor.name);
					if ("Map" === n || "Set" === n) return Array.from(e);
					if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return bt(e, t);
				}(e, t) || function() {
					throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
				}();
			}
			function bt(e, t) {
				(null == t || t > e.length) && (t = e.length);
				for (var n = 0, s = new Array(t); n < t; n++) s[n] = e[n];
				return s;
			}
			var _t = [
				["AbbrRole", t.default],
				["AlertDialogRole", n.default],
				["AlertRole", s.default],
				["AnnotationRole", r.default],
				["ApplicationRole", a.default],
				["ArticleRole", i.default],
				["AudioRole", o.default],
				["BannerRole", l.default],
				["BlockquoteRole", c.default],
				["BusyIndicatorRole", p.default],
				["ButtonRole", u.default],
				["CanvasRole", d.default],
				["CaptionRole", h.default],
				["CellRole", m.default],
				["CheckBoxRole", f.default],
				["ColorWellRole", y.default],
				["ColumnHeaderRole", v.default],
				["ColumnRole", g.default],
				["ComboBoxRole", b.default],
				["ComplementaryRole", _.default],
				["ContentInfoRole", x.default],
				["DateRole", w.default],
				["DateTimeRole", k.default],
				["DefinitionRole", C.default],
				["DescriptionListDetailRole", S.default],
				["DescriptionListRole", P.default],
				["DescriptionListTermRole", E.default],
				["DetailsRole", T.default],
				["DialogRole", A.default],
				["DirectoryRole", $.default],
				["DisclosureTriangleRole", R.default],
				["DivRole", I.default],
				["DocumentRole", M.default],
				["EmbeddedObjectRole", q.default],
				["FeedRole", L.default],
				["FigcaptionRole", O.default],
				["FigureRole", N.default],
				["FooterRole", D.default],
				["FormRole", j.default],
				["GridRole", B.default],
				["GroupRole", F.default],
				["HeadingRole", V.default],
				["IframePresentationalRole", H.default],
				["IframeRole", U.default],
				["IgnoredRole", z.default],
				["ImageMapLinkRole", W.default],
				["ImageMapRole", G.default],
				["ImageRole", K.default],
				["InlineTextBoxRole", X.default],
				["InputTimeRole", Q.default],
				["LabelRole", Y.default],
				["LegendRole", J.default],
				["LineBreakRole", Z.default],
				["LinkRole", ee.default],
				["ListBoxOptionRole", te.default],
				["ListBoxRole", ne.default],
				["ListItemRole", se.default],
				["ListMarkerRole", re.default],
				["ListRole", ae.default],
				["LogRole", ie.default],
				["MainRole", oe.default],
				["MarkRole", le.default],
				["MarqueeRole", ce.default],
				["MathRole", pe.default],
				["MenuBarRole", ue.default],
				["MenuButtonRole", de.default],
				["MenuItemRole", he.default],
				["MenuItemCheckBoxRole", me.default],
				["MenuItemRadioRole", fe.default],
				["MenuListOptionRole", ye.default],
				["MenuListPopupRole", ve.default],
				["MenuRole", ge.default],
				["MeterRole", be.default],
				["NavigationRole", _e.default],
				["NoneRole", xe.default],
				["NoteRole", we.default],
				["OutlineRole", ke.default],
				["ParagraphRole", Ce.default],
				["PopUpButtonRole", Se.default],
				["PreRole", Pe.default],
				["PresentationalRole", Ee.default],
				["ProgressIndicatorRole", Te.default],
				["RadioButtonRole", Ae.default],
				["RadioGroupRole", $e.default],
				["RegionRole", Re.default],
				["RootWebAreaRole", Ie.default],
				["RowHeaderRole", Me.default],
				["RowRole", qe.default],
				["RubyRole", Le.default],
				["RulerRole", Oe.default],
				["ScrollAreaRole", Ne.default],
				["ScrollBarRole", De.default],
				["SeamlessWebAreaRole", je.default],
				["SearchRole", Be.default],
				["SearchBoxRole", Fe.default],
				["SliderRole", Ve.default],
				["SliderThumbRole", He.default],
				["SpinButtonRole", Ue.default],
				["SpinButtonPartRole", ze.default],
				["SplitterRole", We.default],
				["StaticTextRole", Ge.default],
				["StatusRole", Ke.default],
				["SVGRootRole", Xe.default],
				["SwitchRole", Qe.default],
				["TabGroupRole", Ye.default],
				["TabRole", Je.default],
				["TableHeaderContainerRole", Ze.default],
				["TableRole", et.default],
				["TabListRole", tt.default],
				["TabPanelRole", nt.default],
				["TermRole", st.default],
				["TextAreaRole", rt.default],
				["TextFieldRole", at.default],
				["TimeRole", it.default],
				["TimerRole", ot.default],
				["ToggleButtonRole", lt.default],
				["ToolbarRole", ct.default],
				["TreeRole", pt.default],
				["TreeGridRole", ut.default],
				["TreeItemRole", dt.default],
				["UserInterfaceTooltipRole", ht.default],
				["VideoRole", mt.default],
				["WebAreaRole", ft.default],
				["WindowRole", yt.default]
			], xt = {
				entries: function() {
					return _t;
				},
				forEach: function(e) {
					for (var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, n = 0, s = _t; n < s.length; n++) {
						var r = gt(s[n], 2), a = r[0], i = r[1];
						e.call(t, i, a, _t);
					}
				},
				get: function(e) {
					var t = _t.find((function(t) {
						return t[0] === e;
					}));
					return t && t[1];
				},
				has: function(e) {
					return !!xt.get(e);
				},
				keys: function() {
					return _t.map((function(e) {
						return gt(e, 1)[0];
					}));
				},
				values: function() {
					return _t.map((function(e) {
						return gt(e, 2)[1];
					}));
				}
			};
			return Cy.default = (0, e.default)(xt, xt.entries()), Cy;
		}
		function ax() {
			if (nx) return by;
			nx = 1, Object.defineProperty(by, "__esModule", { value: !0 }), by.default = void 0;
			var e = n(wy()), t = n(rx());
			function n(e) {
				return e && e.__esModule ? e : { default: e };
			}
			function s(e, t) {
				return function(e) {
					if (Array.isArray(e)) return e;
				}(e) || function(e, t) {
					var n = null == e ? null : "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
					if (null == n) return;
					var s, r, a = [], i = !0, o = !1;
					try {
						for (n = n.call(e); !(i = (s = n.next()).done) && (a.push(s.value), !t || a.length !== t); i = !0);
					} catch (e) {
						o = !0, r = e;
					} finally {
						try {
							i || null == n.return || n.return();
						} finally {
							if (o) throw r;
						}
					}
					return a;
				}(e, t) || r(e, t) || function() {
					throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
				}();
			}
			function r(e, t) {
				if (e) {
					if ("string" == typeof e) return a(e, t);
					var n = Object.prototype.toString.call(e).slice(8, -1);
					return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? a(e, t) : void 0;
				}
			}
			function a(e, t) {
				(null == t || t > e.length) && (t = e.length);
				for (var n = 0, s = new Array(t); n < t; n++) s[n] = e[n];
				return s;
			}
			var i, o = [], l = function(e, t) {
				var n = "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
				if (!n) {
					if (Array.isArray(e) || (n = r(e)) || t) {
						n && (e = n);
						var s = 0, a = function() {};
						return {
							s: a,
							n: function() {
								return s >= e.length ? { done: !0 } : {
									done: !1,
									value: e[s++]
								};
							},
							e: function(e) {
								throw e;
							},
							f: a
						};
					}
					throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
				}
				var i, o = !0, l = !1;
				return {
					s: function() {
						n = n.call(e);
					},
					n: function() {
						var e = n.next();
						return o = e.done, e;
					},
					e: function(e) {
						l = !0, i = e;
					},
					f: function() {
						try {
							o || null == n.return || n.return();
						} finally {
							if (l) throw i;
						}
					}
				};
			}(t.default.entries());
			try {
				var c = function() {
					var e = s(i.value, 2), t = e[0], n = e[1].relatedConcepts;
					Array.isArray(n) && n.forEach((function(e) {
						if ("HTML" === e.module) {
							var n = e.concept;
							if (n) {
								var r = o.findIndex((function(e) {
									return s(e, 1)[0] === t;
								}));
								-1 === r && (o.push([t, []]), r = o.length - 1), o[r][1].push(n);
							}
						}
					}));
				};
				for (l.s(); !(i = l.n()).done;) c();
			} catch (e) {
				l.e(e);
			} finally {
				l.f();
			}
			var p = {
				entries: function() {
					return o;
				},
				forEach: function(e) {
					for (var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, n = 0, r = o; n < r.length; n++) {
						var a = s(r[n], 2), i = a[0], l = a[1];
						e.call(t, l, i, o);
					}
				},
				get: function(e) {
					var t = o.find((function(t) {
						return t[0] === e;
					}));
					return t && t[1];
				},
				has: function(e) {
					return !!p.get(e);
				},
				keys: function() {
					return o.map((function(e) {
						return s(e, 1)[0];
					}));
				},
				values: function() {
					return o.map((function(e) {
						return s(e, 2)[1];
					}));
				}
			};
			return by.default = (0, e.default)(p, p.entries()), by;
		}
		var ix, ox = {};
		function lx() {
			if (ix) return ox;
			ix = 1, Object.defineProperty(ox, "__esModule", { value: !0 }), ox.default = void 0;
			var e = n(wy()), t = n(rx());
			function n(e) {
				return e && e.__esModule ? e : { default: e };
			}
			function s(e, t) {
				return function(e) {
					if (Array.isArray(e)) return e;
				}(e) || function(e, t) {
					var n = null == e ? null : "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
					if (null == n) return;
					var s, r, a = [], i = !0, o = !1;
					try {
						for (n = n.call(e); !(i = (s = n.next()).done) && (a.push(s.value), !t || a.length !== t); i = !0);
					} catch (e) {
						o = !0, r = e;
					} finally {
						try {
							i || null == n.return || n.return();
						} finally {
							if (o) throw r;
						}
					}
					return a;
				}(e, t) || r(e, t) || function() {
					throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
				}();
			}
			function r(e, t) {
				if (e) {
					if ("string" == typeof e) return a(e, t);
					var n = Object.prototype.toString.call(e).slice(8, -1);
					return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? a(e, t) : void 0;
				}
			}
			function a(e, t) {
				(null == t || t > e.length) && (t = e.length);
				for (var n = 0, s = new Array(t); n < t; n++) s[n] = e[n];
				return s;
			}
			var i, o = [], l = function(e, t) {
				var n = "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
				if (!n) {
					if (Array.isArray(e) || (n = r(e)) || t) {
						n && (e = n);
						var s = 0, a = function() {};
						return {
							s: a,
							n: function() {
								return s >= e.length ? { done: !0 } : {
									done: !1,
									value: e[s++]
								};
							},
							e: function(e) {
								throw e;
							},
							f: a
						};
					}
					throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
				}
				var i, o = !0, l = !1;
				return {
					s: function() {
						n = n.call(e);
					},
					n: function() {
						var e = n.next();
						return o = e.done, e;
					},
					e: function(e) {
						l = !0, i = e;
					},
					f: function() {
						try {
							o || null == n.return || n.return();
						} finally {
							if (l) throw i;
						}
					}
				};
			}(t.default.entries());
			try {
				var c = function() {
					var e = s(i.value, 2), t = e[0], n = e[1].relatedConcepts;
					Array.isArray(n) && n.forEach((function(e) {
						if ("ARIA" === e.module) {
							var n = e.concept;
							if (n) {
								var r = o.findIndex((function(e) {
									return s(e, 1)[0] === t;
								}));
								-1 === r && (o.push([t, []]), r = o.length - 1), o[r][1].push(n);
							}
						}
					}));
				};
				for (l.s(); !(i = l.n()).done;) c();
			} catch (e) {
				l.e(e);
			} finally {
				l.f();
			}
			var p = {
				entries: function() {
					return o;
				},
				forEach: function(e) {
					for (var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, n = 0, r = o; n < r.length; n++) {
						var a = s(r[n], 2), i = a[0], l = a[1];
						e.call(t, l, i, o);
					}
				},
				get: function(e) {
					var t = o.find((function(t) {
						return t[0] === e;
					}));
					return t && t[1];
				},
				has: function(e) {
					return !!p.get(e);
				},
				keys: function() {
					return o.map((function(e) {
						return s(e, 1)[0];
					}));
				},
				values: function() {
					return o.map((function(e) {
						return s(e, 2)[1];
					}));
				}
			};
			return ox.default = (0, e.default)(p, p.entries()), ox;
		}
		var cx, px, ux = {};
		function dx() {
			if (cx) return ux;
			cx = 1, Object.defineProperty(ux, "__esModule", { value: !0 }), ux.default = void 0;
			var e = n(rx()), t = n(wy());
			function n(e) {
				return e && e.__esModule ? e : { default: e };
			}
			function s(e, t) {
				return function(e) {
					if (Array.isArray(e)) return e;
				}(e) || function(e, t) {
					var n = null == e ? null : "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
					if (null == n) return;
					var s, r, a = [], i = !0, o = !1;
					try {
						for (n = n.call(e); !(i = (s = n.next()).done) && (a.push(s.value), !t || a.length !== t); i = !0);
					} catch (e) {
						o = !0, r = e;
					} finally {
						try {
							i || null == n.return || n.return();
						} finally {
							if (o) throw r;
						}
					}
					return a;
				}(e, t) || r(e, t) || function() {
					throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
				}();
			}
			function r(e, t) {
				if (e) {
					if ("string" == typeof e) return a(e, t);
					var n = Object.prototype.toString.call(e).slice(8, -1);
					return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? a(e, t) : void 0;
				}
			}
			function a(e, t) {
				(null == t || t > e.length) && (t = e.length);
				for (var n = 0, s = new Array(t); n < t; n++) s[n] = e[n];
				return s;
			}
			var i, o = [], l = function(e, t) {
				var n = "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
				if (!n) {
					if (Array.isArray(e) || (n = r(e)) || t) {
						n && (e = n);
						var s = 0, a = function() {};
						return {
							s: a,
							n: function() {
								return s >= e.length ? { done: !0 } : {
									done: !1,
									value: e[s++]
								};
							},
							e: function(e) {
								throw e;
							},
							f: a
						};
					}
					throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
				}
				var i, o = !0, l = !1;
				return {
					s: function() {
						n = n.call(e);
					},
					n: function() {
						var e = n.next();
						return o = e.done, e;
					},
					e: function(e) {
						l = !0, i = e;
					},
					f: function() {
						try {
							o || null == n.return || n.return();
						} finally {
							if (l) throw i;
						}
					}
				};
			}(e.default.entries());
			try {
				var c = function() {
					var e = s(i.value, 2), t = e[0], n = e[1].relatedConcepts;
					Array.isArray(n) && n.forEach((function(e) {
						if ("HTML" === e.module) {
							var n = e.concept;
							if (null != n) {
								for (var s, r = JSON.stringify(n), a = 0; a < o.length; a++) {
									var i = o[a][0];
									if (JSON.stringify(i) === r) {
										s = o[a][1];
										break;
									}
								}
								Array.isArray(s) || (s = []), -1 === s.findIndex((function(e) {
									return e === t;
								})) && s.push(t), a < o.length ? o.splice(a, 1, [n, s]) : o.push([n, s]);
							}
						}
					}));
				};
				for (l.s(); !(i = l.n()).done;) c();
			} catch (e) {
				l.e(e);
			} finally {
				l.f();
			}
			var p = {
				entries: function() {
					return o;
				},
				forEach: function(e) {
					for (var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, n = 0, r = o; n < r.length; n++) {
						var a = s(r[n], 2), i = a[0], l = a[1];
						e.call(t, l, i, o);
					}
				},
				get: function(e) {
					var t = o.find((function(t) {
						return e.name === t[0].name && function(e, t) {
							if (void 0 === e && void 0 !== t) return !1;
							if (void 0 !== e && void 0 === t) return !1;
							if (void 0 !== e && void 0 !== t) {
								if (e.length != t.length) return !1;
								for (var n = 0; n < e.length; n++) if (t[n].name !== e[n].name || t[n].value !== e[n].value) return !1;
							}
							return !0;
						}(e.attributes, t[0].attributes);
					}));
					return t && t[1];
				},
				has: function(e) {
					return !!p.get(e);
				},
				keys: function() {
					return o.map((function(e) {
						return s(e, 1)[0];
					}));
				},
				values: function() {
					return o.map((function(e) {
						return s(e, 2)[1];
					}));
				}
			};
			return ux.default = (0, t.default)(p, p.entries()), ux;
		}
		var hx = function() {
			if (px) return gy;
			px = 1, Object.defineProperty(gy, "__esModule", { value: !0 }), gy.elementAXObjects = gy.AXObjects = gy.AXObjectRoles = gy.AXObjectElements = void 0;
			var e = r(ax()), t = r(lx()), n = r(rx()), s = r(dx());
			function r(e) {
				return e && e.__esModule ? e : { default: e };
			}
			gy.AXObjectElements = e.default;
			gy.AXObjectRoles = t.default;
			gy.AXObjects = n.default;
			return gy.elementAXObjects = s.default, gy;
		}();
		const mx = "activedescendant atomic autocomplete busy checked colcount colindex colspan controls current describedby description details disabled dropeffect errormessage expanded flowto grabbed haspopup hidden invalid keyshortcuts label labelledby level live modal multiline multiselectable orientation owns placeholder posinset pressed readonly relevant required roledescription rowcount rowindex rowspan selected setsize sort valuemax valuemin valuenow valuetext".split(" "), fx = {
			a: ["href"],
			area: [
				"alt",
				"aria-label",
				"aria-labelledby"
			],
			html: ["lang"],
			iframe: ["title"],
			img: ["alt"],
			object: [
				"title",
				"aria-label",
				"aria-labelledby"
			]
		}, yx = ["blink", "marquee"], vx = [
			"h1",
			"h2",
			"h3",
			"h4",
			"h5",
			"h6"
		], gx = [
			"button",
			"input",
			"keygen",
			"meter",
			"output",
			"progress",
			"select",
			"textarea"
		], bx = [
			"keypress",
			"keydown",
			"keyup",
			"click",
			"contextmenu",
			"dblclick",
			"drag",
			"dragend",
			"dragenter",
			"dragexit",
			"dragleave",
			"dragover",
			"dragstart",
			"drop",
			"mousedown",
			"mouseenter",
			"mouseleave",
			"mousemove",
			"mouseout",
			"mouseover",
			"mouseup",
			"pointerdown",
			"pointerup",
			"pointermove",
			"pointerenter",
			"pointerleave",
			"pointerover",
			"pointerout",
			"pointercancel",
			"touchstart",
			"touchend",
			"touchmove",
			"touchcancel"
		], _x = [
			"click",
			"mousedown",
			"mouseup",
			"keypress",
			"keydown",
			"keyup"
		], xx = new Map([["header", "banner"], ["footer", "contentinfo"]]), wx = new Map([
			["a", "link"],
			["area", "link"],
			["article", "article"],
			["aside", "complementary"],
			["body", "document"],
			["button", "button"],
			["datalist", "listbox"],
			["dd", "definition"],
			["dfn", "term"],
			["dialog", "dialog"],
			["details", "group"],
			["dt", "term"],
			["fieldset", "group"],
			["figure", "figure"],
			["form", "form"],
			["h1", "heading"],
			["h2", "heading"],
			["h3", "heading"],
			["h4", "heading"],
			["h5", "heading"],
			["h6", "heading"],
			["hr", "separator"],
			["img", "img"],
			["li", "listitem"],
			["link", "link"],
			["main", "main"],
			["menu", "list"],
			["meter", "progressbar"],
			["nav", "navigation"],
			["ol", "list"],
			["option", "option"],
			["optgroup", "group"],
			["output", "status"],
			["progress", "progressbar"],
			["section", "region"],
			["summary", "button"],
			["table", "table"],
			["tbody", "rowgroup"],
			["textarea", "textbox"],
			["tfoot", "rowgroup"],
			["thead", "rowgroup"],
			["tr", "row"],
			["ul", "list"]
		]), kx = new Map([
			["command", "menuitem"],
			["checkbox", "menuitemcheckbox"],
			["radio", "menuitemradio"]
		]), Cx = new Map([
			["button", "button"],
			["image", "button"],
			["reset", "button"],
			["submit", "button"],
			["checkbox", "checkbox"],
			["radio", "radio"],
			["range", "slider"],
			["number", "spinbutton"],
			["email", "textbox"],
			["search", "searchbox"],
			["tel", "textbox"],
			["text", "textbox"],
			["url", "textbox"]
		]), Sx = {
			ul: [
				"listbox",
				"menu",
				"menubar",
				"radiogroup",
				"tablist",
				"tree",
				"treegrid"
			],
			ol: [
				"listbox",
				"menu",
				"menubar",
				"radiogroup",
				"tablist",
				"tree",
				"treegrid"
			],
			menu: [
				"listbox",
				"menu",
				"menubar",
				"radiogroup",
				"tablist",
				"tree",
				"treegrid"
			],
			li: [
				"menuitem",
				"option",
				"row",
				"tab",
				"treeitem"
			],
			table: ["grid"],
			td: ["gridcell"],
			fieldset: ["radiogroup", "presentation"]
		}, Px = [
			"email",
			"search",
			"tel",
			"text",
			"url"
		], Ex = ["shipping", "billing"], Tx = [
			"",
			"on",
			"off",
			"name",
			"honorific-prefix",
			"given-name",
			"additional-name",
			"family-name",
			"honorific-suffix",
			"nickname",
			"username",
			"new-password",
			"current-password",
			"one-time-code",
			"organization-title",
			"organization",
			"street-address",
			"address-line1",
			"address-line2",
			"address-line3",
			"address-level4",
			"address-level3",
			"address-level2",
			"address-level1",
			"country",
			"country-name",
			"postal-code",
			"cc-name",
			"cc-given-name",
			"cc-additional-name",
			"cc-family-name",
			"cc-number",
			"cc-exp",
			"cc-exp-month",
			"cc-exp-year",
			"cc-csc",
			"cc-type",
			"transaction-currency",
			"transaction-amount",
			"language",
			"bday",
			"bday-day",
			"bday-month",
			"bday-year",
			"sex",
			"url",
			"photo"
		], Ax = [
			"home",
			"work",
			"mobile",
			"fax",
			"pager"
		], $x = [
			"tel",
			"tel-country-code",
			"tel-national",
			"tel-area-code",
			"tel-local",
			"tel-local-prefix",
			"tel-local-suffix",
			"tel-extension",
			"email",
			"impp"
		], Rx = {
			Interactive: "interactive",
			NonInteractive: "non-interactive",
			Static: "static"
		}, Ix = [
			"meta",
			"html",
			"script",
			"style"
		], Mx = vy.roles.keys(), qx = Mx.filter(((e) => vy.roles.get(e)?.abstract)), Lx = Mx.filter(((e) => !qx.includes(e))), Ox = Lx.filter(((e) => {
			const t = vy.roles.get(e);
			return ![
				"toolbar",
				"tabpanel",
				"generic",
				"cell"
			].includes(e) && !t?.superClass.some(((e) => e.includes("widget") || e.includes("window")));
		})).concat("progressbar"), Nx = Lx.filter(((e) => !Ox.includes(e) && "generic" !== e)), Dx = ["presentation", "none"], jx = [], Bx = [];
		for (const [e, t] of vy.elementRoles.entries()) [...t].every(((e) => "generic" !== e && Ox.includes(e))) && jx.push(e), [...t].every(((e) => Nx.includes(e))) && Bx.push(e);
		const Fx = [...hx.AXObjects.keys()].filter(((e) => "widget" === hx.AXObjects.get(e).type)), Vx = [], Hx = [], Ux = [...hx.AXObjects.keys()].filter(((e) => ["windows", "structure"].includes(hx.AXObjects.get(e).type)));
		for (const [e, t] of hx.elementAXObjects.entries()) [...t].every(((e) => Fx.includes(e))) && Vx.push(e), [...t].every(((e) => Ux.includes(e))) && Hx.push(e);
		function zx(e, n) {
			const s = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Set(), i = [], o = "SvelteElement" === e.type;
			let l = !1, c = !1, u = !1;
			for (const t of e.attributes) switch (t.type) {
				case "Attribute":
					Zi(t) ? a.add(t.name.slice(2)) : (i.push(t), s.set(t.name, t), "contenteditable" === t.name && (c = !0));
					break;
				case "SpreadAttribute":
					l = !0;
					break;
				case "BindDirective":
					se(t.name) && (u = !0);
					break;
				case "OnDirective": a.add(t.name);
			}
			for (const t of e.attributes) {
				if ("Attribute" !== t.type) continue;
				const c = t.name.toLowerCase();
				if (c.startsWith("aria-")) {
					Ix.includes(e.name) && Ne(t, e.name);
					const n = c.slice(5);
					if (!mx.includes(n)) Ze(t, n, q(n, mx));
					"aria-hidden" === c && v.test(e.name) && je(t, e.name);
					let r = aw(t);
					const a = vy.aria.get(c);
					void 0 !== a && cw(t, c, a, r), "aria-activedescendant" !== c || o || Qx(e.name, s) || s.has("tabindex") || l || Oe(t);
				}
				switch (c) {
					case "role": {
						Ix.includes(e.name) && Ve(t, e.name);
						const c = aw(t);
						if ("string" != typeof c) break;
						for (const p of c.split(r)) {
							const r = p;
							if (r && sw(r)) ze(t, r);
							else if (r && !Mx.includes(r)) et(t, r, q(r, Mx));
							r !== ew(e.name, s) || [
								"ul",
								"ol",
								"li",
								"menu"
							].includes(e.name) || "a" === e.name && !s.has("href") || Ke(t, r);
							if (!lw(n.path, ["section", "article"])) r === xx.get(e.name) && Ke(t, r);
							if (!o && !Zx(r, e.name, s)) {
								const e = vy.roles.get(r);
								if (e) {
									const n = Object.keys(e.requiredProps);
									!l && n.some(((e) => !i.find(((t) => t.name === e)))) && Qe(t, r, pl(n.map(((e) => `"${e}"`)), "and"));
								}
							}
							if (!l && !Kx(s) && !Gx(e.name, s) && !Wx(r) && nw(r) && Jx(e.name, s) && !s.get("tabindex")) [...a].some(((e) => bx.includes(e))) && Fe(e, r);
							!l && Qx(e.name, s) && (tw(r) || Wx(r)) && We(e, e.name, r), !l && Yx(e.name, s) && nw(r) && !Sx[e.name]?.includes(r) && Ge(e, e.name, r);
						}
						break;
					}
					case "accesskey":
						Le(t);
						break;
					case "autofocus":
						"dialog" === e.name || lw(n.path, ["dialog"]) || De(t);
						break;
					case "scope":
						o || "th" === e.name || He(t);
						break;
					case "tabindex": {
						const e = aw(t);
						!isNaN(e) && +e > 0 && Xe(t);
						break;
					}
				}
			}
			const d = s.get("role"), h = rw(d);
			if (a.has("click")) {
				const t = null !== h && !Wx(h);
				if (!o && !Gx(e.name, s) && (!d || t) && !Qx(e.name, s) && !l) a.has("keydown") || a.has("keyup") || a.has("keypress") || function(e) {
					qe(e, "a11y_click_events_have_key_events", "Visible, non-interactive elements with a click event must be accompanied by a keyboard event handler. Consider whether an interactive element such as `<button type=\"button\">` or `<a>` might be more appropriate\nhttps://svelte.dev/e/a11y_click_events_have_key_events");
				}(e);
			}
			const m = d ? h : ew(e.name, s);
			if (!o && !Qx(e.name, s) && !nw(h)) {
				const t = s.get("tabindex"), n = rw(t);
				t && (null === n || Number(n) >= 0) && function(e) {
					qe(e, "a11y_no_noninteractive_tabindex", "noninteractive element cannot have nonnegative tabIndex value\nhttps://svelte.dev/e/a11y_no_noninteractive_tabindex");
				}(e);
			}
			if ("string" == typeof m && vy.roles.has(m)) {
				const { props: t } = vy.roles.get(m), n = vy.aria.keys().filter(((e) => !(e in t))), s = m && void 0 === d;
				for (const t of i) n.includes(t.name) && (s ? Je(t, t.name, m, e.name) : Ye(t, t.name, m));
			}
			if (!l && !c && !Gx(e.name, s) && !Wx(h) && (!Qx(e.name, s) && tw(h) || Yx(e.name, s) && !d)) [...a].some(((e) => _x.includes(e))) && function(e, t) {
				qe(e, "a11y_no_noninteractive_element_interactions", `Non-interactive element \`<${t}>\` should not be assigned mouse or keyboard event listeners\nhttps://svelte.dev/e/a11y_no_noninteractive_element_interactions`);
			}(e, e.name);
			if (!(l || d && null === h || Gx(e.name, s) || Wx(h) || Qx(e.name, s) || nw(h) || Yx(e.name, s) || tw(h) || sw(h))) {
				const t = [...a].filter(((e) => bx.includes(e)));
				t.length > 0 && function(e, t, n) {
					qe(e, "a11y_no_static_element_interactions", `\`<${t}>\` with a ${n} handler must have an ARIA role\nhttps://svelte.dev/e/a11y_no_static_element_interactions`);
				}(e, e.name, pl(t));
			}
			l || !a.has("mouseover") || a.has("focus") || Ue(e, "mouseover", "focus"), l || !a.has("mouseout") || a.has("blur") || Ue(e, "mouseout", "blur");
			const f = s.has("aria-label") || s.has("aria-labelledby") || s.has("title");
			switch (e.name) {
				case "a":
				case "button": {
					const t = "true" === aw(s.get("aria-hidden")) || null !== aw(s.get("inert"));
					if (l || t || f || iw(e) || function(e) {
						qe(e, "a11y_consider_explicit_label", "Buttons and links should either contain text or have an `aria-label`, `aria-labelledby` or `title` attribute\nhttps://svelte.dev/e/a11y_consider_explicit_label");
					}(e), "button" === e.name) break;
					const n = s.get("href") || s.get("xlink:href");
					if (n) {
						const e = rw(n);
						null !== e && ("" === e || "#" === e || _.test(e)) && function(e, t, n) {
							qe(e, "a11y_invalid_attribute", `'${t}' is not a valid ${n} attribute\nhttps://svelte.dev/e/a11y_invalid_attribute`);
						}(n, e, n.name);
					} else if (!l) {
						const t = aw(s.get("id")), n = aw(s.get("name")), r = aw(s.get("aria-disabled"));
						t || n || "true" === r || pw(e, ["href"]);
					}
					break;
				}
				case "input": {
					const t = s.get("type"), n = rw(t);
					if ("image" === n && !l) {
						const t = [
							"alt",
							"aria-label",
							"aria-labelledby"
						];
						t.some(((e) => s.has(e))) || pw(e, t, "input type=\"image\"");
					}
					const a = s.get("autocomplete");
					if (t && a) {
						const e = aw(a);
						(function(e) {
							if (!0 === e) return !1;
							if (!e) return !0;
							const t = e.trim().toLowerCase().split(r);
							"string" == typeof t[0] && t[0].startsWith("section-") && t.shift();
							Ex.includes(t[0]) && t.shift();
							if (Tx.includes(t[0])) t.shift();
							else {
								if (Ax.includes(t[0]) && t.shift(), !$x.includes(t[0])) return !1;
								t.shift();
							}
							"webauthn" === t[0] && t.shift();
							return 0 === t.length;
						})(e) || function(e, t, n) {
							qe(e, "a11y_autocomplete_valid", `'${t}' is an invalid value for 'autocomplete' on \`<input type="${n}">\`\nhttps://svelte.dev/e/a11y_autocomplete_valid`);
						}(a, e, n ?? "...");
					}
					break;
				}
				case "img": {
					const t = rw(s.get("alt")), n = aw(s.get("aria-hidden"));
					!t || n || l || x.test(t) && function(e) {
						qe(e, "a11y_img_redundant_alt", "Screenreaders already announce `<img>` elements as an image\nhttps://svelte.dev/e/a11y_img_redundant_alt");
					}(e);
					break;
				}
				case "label": {
					const n = (e) => {
						let n = !1;
						return t(e, {}, { _(e, { next: t }) {
							"SvelteElement" === e.type || "SlotElement" === e.type || "Component" === e.type || "RenderTag" === e.type || "RegularElement" === e.type && (gx.includes(e.name) || "slot" === e.name) ? n = !0 : t();
						} }), n;
					};
					l || s.has("for") || n(e) || function(e) {
						qe(e, "a11y_label_has_associated_control", "A form label must be associated with a control\nhttps://svelte.dev/e/a11y_label_has_associated_control");
					}(e);
					break;
				}
				case "video": {
					const t = s.get("aria-hidden"), n = t && aw(t);
					if (s.has("muted") || "true" === n || l) return;
					if (!s.has("src")) return;
					let r = !1;
					const a = e.fragment.nodes.find(((e) => "RegularElement" === e.type && "track" === e.name));
					a && (r = a.attributes.some(((e) => "SpreadAttribute" === e.type || "Attribute" === e.type && "kind" === e.name && "captions" === aw(e)))), r || function(e) {
						qe(e, "a11y_media_has_caption", "`<video>` elements must have a `<track kind=\"captions\">`\nhttps://svelte.dev/e/a11y_media_has_caption");
					}(e);
					break;
				}
				case "figcaption":
					lw(n.path, ["figure"]) || function(e) {
						qe(e, "a11y_figcaption_parent", "`<figcaption>` must be an immediate child of `<figure>`\nhttps://svelte.dev/e/a11y_figcaption_parent");
					}(e);
					break;
				case "figure": {
					const t = e.fragment.nodes.filter(((e) => "Comment" !== e.type && ("Text" !== e.type || p.test(e.data)))), n = t.findIndex(((e) => "RegularElement" === e.type && "figcaption" === e.name));
					-1 !== n && 0 !== n && n !== t.length - 1 && function(e) {
						qe(e, "a11y_figcaption_index", "`<figcaption>` must be first or last child of `<figure>`\nhttps://svelte.dev/e/a11y_figcaption_index");
					}(t[n]);
					break;
				}
			}
			if (!l && "a" !== e.name) {
				const t = fx[e.name];
				if (t) t.some(((e) => s.has(e))) || pw(e, t);
			}
			yx.includes(e.name) && function(e, t) {
				qe(e, "a11y_distracting_elements", `Avoid \`<${t}>\` elements\nhttps://svelte.dev/e/a11y_distracting_elements`);
			}(e, e.name), l || f || u || !vx.includes(e.name) || iw(e) || function(e, t) {
				qe(e, "a11y_missing_content", `\`<${t}>\` element should contain text\nhttps://svelte.dev/e/a11y_missing_content`);
			}(e, e.name);
		}
		function Wx(e) {
			return Dx.includes(e);
		}
		function Gx(e, t) {
			if ("input" === e) {
				if ("hidden" === aw(t.get("type"))) return !0;
			}
			const n = t.get("aria-hidden");
			if (!n) return !1;
			const s = aw(n);
			return null === s || !0 === s || "true" === s;
		}
		function Kx(e) {
			if (aw(e.get("disabled"))) return !0;
			const t = e.get("aria-disabled");
			if (t) {
				if ("true" === aw(t)) return !0;
			}
			return !1;
		}
		function Xx(e, t) {
			return Bx.some(((n) => ow(n, e, t))) ? Rx.Interactive : "header" !== e && jx.some(((n) => ow(n, e, t))) ? Rx.NonInteractive : Vx.some(((n) => ow(n, e, t))) ? Rx.Interactive : Hx.some(((n) => ow(n, e, t))) ? Rx.NonInteractive : Rx.Static;
		}
		function Qx(e, t) {
			return Xx(e, t) === Rx.Interactive;
		}
		function Yx(e, t) {
			return Xx(e, t) === Rx.NonInteractive;
		}
		function Jx(e, t) {
			return Xx(e, t) === Rx.Static;
		}
		function Zx(e, t, n) {
			for (const [s, r] of hx.elementAXObjects.entries()) if (s.name === t && (!s.attributes || s.attributes.every(((e) => n.has(e.name) && aw(n.get(e.name)) === e.value)))) for (const t of r) {
				const n = hx.AXObjectRoles.get(t);
				if (n) {
					for (const { name: t } of n) if (t === e) return !0;
				}
			}
			return !1;
		}
		function ew(e, t) {
			return "menuitem" === e ? function(e) {
				const t = e.get("type");
				if (!t) return;
				const n = rw(t);
				return n ? kx.get(n) : void 0;
			}(t) : "input" === e ? function(e) {
				const t = e.get("type");
				if (!t) return;
				const n = rw(t);
				if (!n) return;
				return e.has("list") && Px.includes(n) ? "combobox" : Cx.get(n);
			}(t) : wx.get(e);
		}
		function tw(e) {
			return Ox.includes(e);
		}
		function nw(e) {
			return Nx.includes(e);
		}
		function sw(e) {
			return qx.includes(e);
		}
		function rw(e) {
			const t = aw(e);
			return !0 === t ? null : t;
		}
		function aw(e) {
			return e ? !0 === e.value || (Xi(e) ? e.value[0].data : null) : null;
		}
		function iw(e) {
			for (const t of e.fragment.nodes) if ("Text" !== t.type || "" !== t.data.trim()) {
				if ("RegularElement" === t.type || "SvelteElement" === t.type) {
					if (t.attributes.some(((e) => "Attribute" === e.type && "popover" === e.name))) continue;
					if ("img" === t.name && t.attributes.some(((e) => "Attribute" === e.type && "alt" === e.name))) return !0;
					if ("selectedcontent" === t.name) return !0;
					if (!iw(t)) continue;
				}
				return !0;
			}
		}
		function ow(e, t, n) {
			return e.name === t && (!e.attributes || e.attributes.every(((e) => {
				const t = n.get(e.name);
				return !!t && (!e.value || e.value === rw(t));
			})));
		}
		function lw(e, t) {
			let n = e.length;
			for (; n--;) {
				const s = e[n];
				if ("SvelteElement" === s.type) return !0;
				if ("RegularElement" === s.type) return t.includes(s.name);
			}
			return !1;
		}
		function cw(e, t, n, s) {
			const a = n.type;
			if (null !== s) switch (!0 === s && (s = ""), a) {
				case "id":
				case "string":
					"" === s && Be(e, t, "non-empty string");
					break;
				case "number":
					("" === s || isNaN(+s)) && Be(e, t, "number");
					break;
				case "boolean":
					"true" !== s && "false" !== s && function(e, t) {
						qe(e, "a11y_incorrect_aria_attribute_type_boolean", `The value of '${t}' must be either 'true' or 'false'. It cannot be empty\nhttps://svelte.dev/e/a11y_incorrect_aria_attribute_type_boolean`);
					}(e, t);
					break;
				case "idlist":
					"" === s && function(e, t) {
						qe(e, "a11y_incorrect_aria_attribute_type_idlist", `The value of '${t}' must be a space-separated list of strings that represent DOM element IDs\nhttps://svelte.dev/e/a11y_incorrect_aria_attribute_type_idlist`);
					}(e, t);
					break;
				case "integer":
					"" !== s && Number.isInteger(+s) || function(e, t) {
						qe(e, "a11y_incorrect_aria_attribute_type_integer", `The value of '${t}' must be an integer\nhttps://svelte.dev/e/a11y_incorrect_aria_attribute_type_integer`);
					}(e, t);
					break;
				case "token": {
					const r = (n.values ?? []).map(((e) => e.toString()));
					r.includes(s.toLowerCase()) || function(e, t, n) {
						qe(e, "a11y_incorrect_aria_attribute_type_token", `The value of '${t}' must be exactly one of ${n}\nhttps://svelte.dev/e/a11y_incorrect_aria_attribute_type_token`);
					}(e, t, pl(r.map(((e) => `"${e}"`))));
					break;
				}
				case "tokenlist": {
					const a = (n.values ?? []).map(((e) => e.toString()));
					s.toLowerCase().split(r).some(((e) => !a.includes(e))) && function(e, t, n) {
						qe(e, "a11y_incorrect_aria_attribute_type_tokenlist", `The value of '${t}' must be a space-separated list of one or more of ${n}\nhttps://svelte.dev/e/a11y_incorrect_aria_attribute_type_tokenlist`);
					}(e, t, pl(a.map(((e) => `"${e}"`))));
					break;
				}
				case "tristate": "true" !== s && "false" !== s && "mixed" !== s && function(e, t) {
					qe(e, "a11y_incorrect_aria_attribute_type_tristate", `The value of '${t}' must be exactly one of true, false, or mixed\nhttps://svelte.dev/e/a11y_incorrect_aria_attribute_type_tristate`);
				}(e, t);
			}
		}
		function pw(e, t, n = e.name) {
			(function(e, t, n, s) {
				qe(e, "a11y_missing_attribute", `\`<${t}>\` element should have ${n} ${s} attribute\nhttps://svelte.dev/e/a11y_missing_attribute`);
			})(e, n, y.test(t[0]) || "href" === t[0] ? "an" : "a", t.length > 1 ? t.slice(0, -1).join(", ") + ` or ${t[t.length - 1]}` : t[0]);
		}
		const uw = [
			"preventDefault",
			"stopPropagation",
			"stopImmediatePropagation",
			"capture",
			"once",
			"passive",
			"nonpassive",
			"self",
			"trusted"
		];
		function dw(e, t) {
			let n = !1, s = null, r = null;
			for (const a of e.attributes) if ("Attribute" === a.type) {
				const n = Qi(a);
				if (t.state.analysis.runes && (mp(a, e), n)) {
					const e = Yi(a);
					if ("SequenceExpression" === e.type) {
						let n = e.start;
						for (; --n > 0;) {
							const s = t.state.analysis.source[n];
							if ("(" === s) break;
							"{" === s && qr(e);
						}
					}
				}
				if (g.test(a.name) && Mr(a, a.name), a.name.startsWith("on") && a.name.length > 2) {
					n || Ir(a);
					const e = Yi(a);
					"Identifier" !== e.type || e.name !== a.name || t.state.scope.get(e.name) || dt(a, a.name);
				}
				"slot" === a.name && fp(t, a), "is" === a.name && ut(a);
				const s = hw.get(a.name);
				s && ht(a, a.name, s), hp(a);
			} else if ("AnimateDirective" === a.type) {
				const e = t.path.at(-2);
				"EachBlock" !== e?.type ? Ar(a) : e.key ? e.body.nodes.filter(((e) => "Comment" !== e.type && "ConstTag" !== e.type && ("Text" !== e.type || "" !== e.data.trim()))).length > 1 && Ar(a) : $r(a), n ? Tr(a) : n = !0;
			} else if ("TransitionDirective" === a.type) {
				const e = a.intro && s || a.outro && r;
				if (e) {
					const t = e.intro ? e.outro ? "transition" : "in" : "out", n = a.intro ? a.outro ? "transition" : "in" : "out";
					t === n ? Ma(a, t) : Ia(a, t, n);
				}
				a.intro && (s = a), a.outro && (r = a);
			} else if ("OnDirective" === a.type) {
				let e = !1, t = "";
				for (const n of a.modifiers) {
					if (!uw.includes(n)) Xr(a, `${uw.slice(0, -1).join(", ")} or ${uw.at(-1)}`);
					"passive" === n ? e = !0 : "nonpassive" !== n && "preventDefault" !== n || (t = n), e && t && Qr(a, "passive", t);
				}
			}
		}
		const hw = new Map([["className", "class"], ["htmlFor", "for"]]);
		function mw(e, t, n = /* @__PURE__ */ new Set()) {
			for (const [s] of e.references) {
				const r = e.get(s);
				if (r) {
					if (r.blocker) return !1;
					if (0 !== r.scope.function_depth && !(r.scope.function_depth >= e.function_depth)) {
						if ("SnippetBlock" === r.initial?.type) {
							if (n.has(r)) continue;
							n.add(r);
							if (mw(t.get(r.initial), t, n)) continue;
						}
						return !1;
					}
				}
			}
			return !0;
		}
		const fw = [
			"onerror",
			"failed",
			"pending"
		];
		function yw(e, t) {
			if (e !== t) throw new Error("Assertion failed");
		}
		const vw = {
			_(e, { state: t, next: n, path: s }) {
				const r = s.at(-1), a = [];
				if ("Fragment" === r?.type && "Comment" !== e.type && "Text" !== e.type) for (let n = r.nodes.indexOf(e) - 1; n >= 0; n--) {
					const e = r.nodes[n];
					if ("Comment" === e.type) a.push(..._t(e.start + 4, e.data, t.analysis.runes));
					else if ("Text" !== e.type) break;
				}
				else {
					const n = e.leadingComments;
					if (n) for (const e of n) a.push(..._t(e.start + 2, e.value, t.analysis.runes));
				}
				a.length > 0 && function(e) {
					const t = new Set([...Se.at(-1) || [], ...e]);
					Se.push(t);
				}(a), Pe.set(e, structuredClone(Se));
				const i = t.scopes.get(e);
				n(void 0 !== i && i !== t.scope ? {
					...t,
					scope: i
				} : t), a.length > 0 && Se.pop();
			},
			AnimateDirective: function(e, t) {
				t.next({
					...t.state,
					expression: e.metadata.expression
				}), e.metadata.expression.has_await && ea(e);
			},
			ArrowFunctionExpression: function(e, t) {
				pp(0, t);
			},
			AssignmentExpression: function(e, t) {
				if (Yl(e, e.left, t), t.state.reactive_statement) {
					if (null !== ("MemberExpression" === e.left.type ? Ki(e.left) : e.left)) for (const n of to(e.left)) {
						const e = t.state.scope.get(n.name);
						e && t.state.reactive_statement.assignments.add(e);
					}
				}
				t.state.expression && (t.state.expression.has_assignment = !0), t.next();
			},
			AttachTag: function(e, t) {
				up(t.path), t.next({
					...t.state,
					expression: e.metadata.expression
				}), e.metadata.expression.has_await && ea(e);
			},
			Attribute: function(e, t) {
				t.next();
				const n = t.path.at(-1);
				if ("RegularElement" === n.type && "value" === e.name && "option" === n.name && up(t.path), Zi(e) && up(t.path), ee(e.name) && up(t.path), "class" !== e.name || Array.isArray(e.value) || !0 === e.value || "Literal" === e.value.expression.type || "TemplateLiteral" === e.value.expression.type || "BinaryExpression" === e.value.expression.type || (up(t.path), e.metadata.needs_clsx = !0), !0 !== e.value) {
					for (const t of Ji(e.value)) "ExpressionTag" === t.type && "FunctionExpression" !== t.expression.type && t.expression.type;
					if (Zi(e)) {
						const n = t.path.at(-1);
						"RegularElement" !== n?.type && "SvelteElement" !== n?.type || (t.state.analysis.uses_event_attributes = !0), e.metadata.delegated = "RegularElement" === n?.type && (s = e.name.slice(2), K.includes(s));
					}
				}
				var s;
			},
			AwaitBlock: function(e, t) {
				if (ec(e.pending), ec(e.then), ec(e.catch), t.state.analysis.runes) {
					if (Zl(e, t.state, "#"), e.value) {
						const n = e.value.start, s = t.state.analysis.source.substring(n - 10, n).match(/{(\s*):then\s+$/);
						s && "" !== s[1] && Fr({
							start: n - 10,
							end: n
						}, ":");
					}
					if (e.error) {
						const n = e.error.start, s = t.state.analysis.source.substring(n - 10, n).match(/{(\s*):catch\s+$/);
						s && "" !== s[1] && Fr({
							start: n - 10,
							end: n
						}, ":");
					}
				}
				up(t.path), t.visit(e.expression, {
					...t.state,
					expression: e.metadata.expression
				}), e.pending && t.visit(e.pending), e.then && t.visit(e.then), e.catch && t.visit(e.catch);
			},
			AwaitExpression: function(e, t) {
				const n = "instance" === t.state.ast_type && 1 === t.state.function_depth;
				(function(e, t) {
					if (t) return !0;
					let n = e.length;
					for (; n--;) {
						const t = e[n];
						if ("ArrowFunctionExpression" === t.type || "FunctionExpression" === t.type || "FunctionDeclaration" === t.type) return !1;
						if (t.metadata) return !0;
					}
					return !1;
				})(t.path, t.state.derived_function_depth === t.state.function_depth) && !function(e, t) {
					let n = e.length;
					for (; n--;) {
						const s = e[n];
						if ("ConstTag" === s.type) return !1;
						if (s.metadata) return !0;
						switch (s.type) {
							case "ArrayExpression":
								if (t !== s.elements.at(-1)) return !1;
								break;
							case "AssignmentExpression":
							case "BinaryExpression":
							case "LogicalExpression":
								if (t === s.left) return !1;
								break;
							case "CallExpression":
							case "NewExpression":
								if (t !== s.arguments.at(-1)) return !1;
								break;
							case "ConditionalExpression":
								if (t === s.test) return !1;
								break;
							case "MemberExpression":
								if (s.computed && t === s.object) return !1;
								break;
							case "ObjectExpression":
								if (t !== s.properties.at(-1)) return !1;
								break;
							case "Property":
								if (t === s.key) return !1;
								break;
							case "SequenceExpression":
							case "TemplateLiteral":
								if (t !== s.expressions.at(-1)) return !1;
								break;
							case "TaggedTemplateExpression":
								if (t !== s.quasi.expressions.at(-1)) return !1;
								break;
							case "VariableDeclarator": return !0;
							default: return !1;
						}
						t = s;
					}
				}(t.path, e) && t.state.analysis.pickled_awaits.add(e);
				let s = n;
				t.state.expression && (t.state.expression.has_await = !0, s = !0), s && (t.state.options.experimental.async || function(e) {
					zs(e, "experimental_async", "Cannot use `await` in deriveds and template expressions, or at the top level of a component, unless the `experimental.async` compiler option is `true`\nhttps://svelte.dev/e/experimental_async");
				}(e), t.state.analysis.runes || function(e) {
					zs(e, "legacy_await_invalid", "Cannot use `await` in deriveds and template expressions, or at the top level of a component, unless in runes mode\nhttps://svelte.dev/e/legacy_await_invalid");
				}(e)), t.next();
			},
			BindDirective: function(e, t) {
				const n = t.path.at(-1);
				if ("RegularElement" === n?.type || "SvelteElement" === n?.type || "SvelteWindow" === n?.type || "SvelteDocument" === n?.type || "SvelteBody" === n?.type) if (e.name in dp) {
					const t = dp[e.name];
					if (t.valid_elements && !t.valid_elements.includes(n.name) && Dr(e, e.name, t.valid_elements.map(((e) => `\`<${e}>\``)).join(", ")), t.invalid_elements && t.invalid_elements.includes(n.name)) {
						const t = Object.entries(dp).filter((([e, t]) => t.valid_elements?.includes(n.name) || !t.valid_elements && !t.invalid_elements?.includes(n.name))).map((([e]) => e)).sort();
						Or(e, e.name, `Possible bindings for <${n.name}> are ${t.join(", ")}`);
					}
					if ("input" === n.name && "this" !== e.name) {
						const t = n.attributes.find(((e) => "Attribute" === e.type && "type" === e.name));
						t && !Xi(t) ? "value" === e.name && !0 !== t.value || function(e) {
							zs(e, "attribute_invalid_type", "'type' attribute must be a static text value if input uses two-way binding\nhttps://svelte.dev/e/attribute_invalid_type");
						}(t) : ("checked" === e.name && "checkbox" !== t?.value[0].data && Dr(e, e.name, "`<input type=\"checkbox\">`" + ("radio" === t?.value[0].data ? " — for `<input type=\"radio\">`, use `bind:group`" : "")), "files" === e.name && "file" !== t?.value[0].data && Dr(e, e.name, "`<input type=\"file\">`"));
					}
					if ("select" === n.name && "this" !== e.name) {
						const e = n.attributes.find(((e) => "Attribute" === e.type && "multiple" === e.name && !Xi(e) && !0 !== e.value));
						e && function(e) {
							zs(e, "attribute_invalid_multiple", "'multiple' attribute must be static if select uses two-way binding\nhttps://svelte.dev/e/attribute_invalid_multiple");
						}(e);
					}
					if ("offsetWidth" === e.name && oe(n.name) && Dr(e, e.name, "non-`<svg>` elements. Use `bind:clientWidth` for `<svg>` instead"), se(e.name)) {
						const t = n.attributes.find(((e) => "Attribute" === e.type && "contenteditable" === e.name));
						t ? Xi(t) || !0 === t.value || function(e) {
							zs(e, "attribute_contenteditable_dynamic", "'contenteditable' attribute cannot be dynamic if element uses two-way binding\nhttps://svelte.dev/e/attribute_contenteditable_dynamic");
						}(t) : function(e) {
							zs(e, "attribute_contenteditable_missing", "'contenteditable' attribute is required for textContent, innerHTML and innerText two-way bindings\nhttps://svelte.dev/e/attribute_contenteditable_missing");
						}(e);
					}
				} else {
					const t = q(e.name, Object.keys(dp));
					if (t) {
						const s = dp[t];
						s.valid_elements && !s.valid_elements.includes(n.name) || Or(e, e.name, `Did you mean '${t}'?`);
					}
					Or(e, e.name);
				}
				if ("SequenceExpression" === e.expression.type) {
					"group" === e.name && function(e) {
						zs(e, "bind_group_invalid_expression", "`bind:group` can only bind to an Identifier or MemberExpression\nhttps://svelte.dev/e/bind_group_invalid_expression");
					}(e);
					let n = e.expression.start, s = (e.expression.leadingComments?.at(0))?.start, r = (e.expression.leadingComments?.at(-1))?.end;
					for (; "{" !== t.state.analysis.source[--n];) "(" !== t.state.analysis.source[n] || s && r && n <= r && n >= s || Nr(e, e.name);
					2 !== e.expression.expressions.length && Lr(e), up(t.path);
					const [a, i] = e.expression.expressions;
					t.visit("ArrowFunctionExpression" === a.type ? a.body : a, {
						...t.state,
						expression: e.metadata.expression
					}), t.visit("ArrowFunctionExpression" === i.type ? i.body : i, {
						...t.state,
						expression: e.metadata.expression
					}), e.metadata.expression.has_await && ea(e);
					return;
				}
				Yl(e, e.expression, t);
				const s = e.expression, r = Ki(s);
				null === r && Lr(e);
				const a = t.state.scope.get(r.name);
				if (e.metadata.binding = a, "Identifier" === s.type && ("this" === e.name || a && ("state" === a.kind || "raw_state" === a.kind || "prop" === a.kind || "bindable_prop" === a.kind || "each" === a.kind || "store_sub" === a.kind || a.updated) || function(e) {
					zs(e, "bind_invalid_value", "Can only bind to state or props\nhttps://svelte.dev/e/bind_invalid_value");
				}(e.expression)), "group" === e.name) {
					if (!a) throw new Error("Cannot find declaration for bind:group");
					"snippet" === a.kind && function(e) {
						zs(e, "bind_group_invalid_snippet_parameter", "Cannot `bind:group` to a snippet parameter\nhttps://svelte.dev/e/bind_group_invalid_snippet_parameter");
					}(e);
					const n = [], [s, r] = no(e.expression);
					let i = r, o = t.path.length;
					for (; o--;) {
						const e = t.path[o];
						if ("EachBlock" === e.type) {
							const t = i.filter(((t) => e.metadata.declarations.has(t.name)));
							t.length > 0 && (e.metadata.contains_group_binding = !0, n.push(e), i = i.filter(((e) => !t.includes(e))), i.push(...no(e.expression)[1]));
						}
					}
					const l = r.map(((e) => t.state.scope.get(e.name)));
					let c;
					e: for (const [[e, n], r] of t.state.analysis.binding_groups) if (n.length === l.length && e === s) {
						for (let e = 0; e < l.length; e++) if (l[e] !== n[e]) continue e;
						c = r;
					}
					c || (c = t.state.scope.root.unique("binding_group"), t.state.analysis.binding_groups.set([s, l], c)), e.metadata = {
						binding_group_name: c,
						parent_each_blocks: n,
						expression: e.metadata.expression
					};
				}
				"each" === a?.kind && a.metadata?.inside_rest && function(e, t) {
					qe(e, "bind_invalid_each_rest", `The rest operator (...) will create a new object and binding '${t}' with the original object will not work\nhttps://svelte.dev/e/bind_invalid_each_rest`);
				}(a.node, a.node.name), t.next({
					...t.state,
					expression: e.metadata.expression
				}), e.metadata.expression.has_await && ea(e);
			},
			CallExpression: function(e, t) {
				const n = io(t.path, -1), s = xc(e, t.state.scope);
				if (s && "$inspect" !== s) for (const t of e.arguments) "SpreadElement" === t.type && or(e, s);
				switch (s) {
					case null:
						tc(e.callee, t.state.scope) || (t.state.analysis.needs_context = !0);
						break;
					case "$bindable":
						e.arguments.length > 1 && rr(e, "$bindable", "zero or one arguments"), "AssignmentPattern" === n.type && "ObjectPattern" === t.path.at(-3)?.type && "VariableDeclarator" === t.path.at(-4)?.type && "$props" === xc(t.path.at(-4).init, t.state.scope) || function(e) {
							zs(e, "bindable_invalid_location", "`$bindable()` can only be used inside a `$props()` declaration\nhttps://svelte.dev/e/bindable_invalid_location");
						}(e), t.state.analysis.needs_context = !0;
						break;
					case "$host":
						e.arguments.length > 0 ? sr(e, "$host") : "module" !== t.state.ast_type && t.state.analysis.custom_element || function(e) {
							zs(e, "host_invalid_placement", "`$host()` can only be used inside custom element component instances\nhttps://svelte.dev/e/host_invalid_placement");
						}(e);
						break;
					case "$props":
						t.state.has_props_rune && er(e, s), t.state.has_props_rune = !0, "VariableDeclarator" === n.type && "instance" === t.state.ast_type && t.state.scope === t.state.analysis.instance.scope || function(e) {
							zs(e, "props_invalid_placement", "`$props()` can only be used at the top level of components as a variable declaration initializer\nhttps://svelte.dev/e/props_invalid_placement");
						}(e), e.arguments.length > 0 && sr(e, s);
						break;
					case "$props.id": {
						const r = io(t.path, -2);
						t.state.analysis.props_id && er(e, s), "VariableDeclarator" === n.type && "Identifier" === n.id.type && "instance" === t.state.ast_type && t.state.scope === t.state.analysis.instance.scope && "VariableDeclaration" === r.type || function(e) {
							zs(e, "props_id_invalid_placement", "`$props.id()` can only be used at the top level of components as a variable declaration initializer\nhttps://svelte.dev/e/props_id_invalid_placement");
						}(e), e.arguments.length > 0 && sr(e, s), t.state.analysis.props_id = n.id;
						break;
					}
					case "$state":
					case "$state.raw":
					case "$derived":
					case "$derived.by":
						(function(e, t) {
							return "VariableDeclarator" === e.type && "ConstTag" !== io(t.path, -3).type;
						})(n, t) || function(e) {
							return "PropertyDefinition" === e.type && !e.static && !e.computed;
						}(n) || function(e, t) {
							if ("AssignmentExpression" === e.type && "=" === e.operator && "MemberExpression" === e.left.type && "ThisExpression" === e.left.object.type && ("Identifier" === e.left.property.type && !e.left.computed || "PrivateIdentifier" === e.left.property.type || "Literal" === e.left.property.type)) {
								const e = io(t.path, -5);
								return "MethodDefinition" === e?.type && "constructor" === e.kind;
							}
							return !1;
						}(n, t) || mr(e, s), "$derived" !== s && "$derived.by" !== s || 1 === e.arguments.length ? e.arguments.length > 1 && rr(e, s, "zero or one arguments") : rr(e, s, "exactly one argument");
						break;
					case "$effect":
					case "$effect.pre":
						"ExpressionStatement" !== n.type && function(e) {
							zs(e, "effect_invalid_placement", "`$effect()` can only be used as an expression statement\nhttps://svelte.dev/e/effect_invalid_placement");
						}(e), 1 !== e.arguments.length && rr(e, s, "exactly one argument"), t.state.analysis.needs_context = !0;
						break;
					case "$effect.tracking":
						0 !== e.arguments.length && sr(e, s);
						break;
					case "$effect.root":
					case "$inspect().with":
					case "$state.eager":
					case "$state.snapshot":
						1 !== e.arguments.length && rr(e, s, "exactly one argument");
						break;
					case "$effect.pending":
						t.state.expression && (t.state.expression.has_state = !0);
						break;
					case "$inspect":
						e.arguments.length < 1 && rr(e, s, "one or more arguments");
						break;
					case "$inspect.trace": {
						e.arguments.length > 1 && rr(e, s, "zero or one arguments");
						const r = t.path.at(-2), a = t.path.at(-3);
						if (("ExpressionStatement" !== n.type || "BlockStatement" !== r?.type || "FunctionDeclaration" !== a?.type && "FunctionExpression" !== a?.type && "ArrowFunctionExpression" !== a?.type || r.body[0] !== n) && function(e) {
							zs(e, "inspect_trace_invalid_placement", "`$inspect.trace(...)` must be the first statement of a function body\nhttps://svelte.dev/e/inspect_trace_invalid_placement");
						}(e), a.generator && function(e) {
							zs(e, "inspect_trace_generator", "`$inspect.trace(...)` cannot be used inside a generator function\nhttps://svelte.dev/e/inspect_trace_generator");
						}(e), ge) {
							if (e.arguments[0]) t.state.scope.tracing = Ti(e.arguments[0]);
							else {
								const e = function(e) {
									const t = e.at(-1);
									if (("FunctionDeclaration" === t.type || "FunctionExpression" === t.type) && null != t.id) return t.id.name;
									const n = e.at(-2);
									if (!n) return;
									if ("CallExpression" === n.type) return ve.slice(n.callee.start, n.callee.end) + "(...)";
									if ("Property" === n.type && !n.computed) return n.key.name;
									if ("VariableDeclarator" === n.type && "Identifier" === n.id.type) return n.id.name;
								}(t.path.slice(0, -2)) ?? "trace", n = `(${Ce(a)})`;
								t.state.scope.tracing = Ti(mi(e + " " + n));
							}
							t.state.analysis.tracing = !0;
						}
						break;
					}
				}
				if ("$derived" === s) {
					const n = new nl();
					t.next({
						...t.state,
						function_depth: t.state.function_depth + 1,
						derived_function_depth: t.state.function_depth + 1,
						expression: n
					}), n.has_await && t.state.analysis.async_deriveds.add(e);
				} else "$inspect" === s ? t.next({
					...t.state,
					function_depth: t.state.function_depth + 1
				}) : t.next();
				t.state.expression && (!nc(e.callee, t) || t.state.expression.dependencies.size > 0) && (t.state.expression.has_call = !0, t.state.expression.has_state = !0);
			},
			ClassBody: function(e, t) {
				if (!t.state.analysis.runes) return void t.next();
				const n = [];
				for (const t of e.body) "MethodDefinition" !== t.type && "PropertyDefinition" !== t.type || "PrivateIdentifier" !== t.key.type || n.push(t.key.name);
				const s = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Map();
				t.state.analysis.classes.set(e, s);
				let a = null;
				function i(e, n, a) {
					const i = sl(n);
					if (null === i) return;
					const o = xc(a, t.state.scope);
					if (o && function(e) {
						return pe.includes(e);
					}(o)) {
						s.has(i) && function(e, t) {
							zs(e, "state_field_duplicate", `\`${t}\` has already been declared on this class\nhttps://svelte.dev/e/state_field_duplicate`);
						}(e, i);
						const t = ("AssignmentExpression" !== e.type && e.static ? "@" : "") + i, l = r.get(t);
						!l || 1 === l.length && "prop" === l[0] || Qs(e, t), s.set(i, {
							node: e,
							type: o,
							key: "PrivateIdentifier" === n.type ? n : null,
							value: a
						});
					}
				}
				for (const t of e.body) {
					if ("PropertyDefinition" === t.type && !t.computed && !t.static) {
						i(t, t.key, t.value);
						const e = sl(t.key);
						if (!r.get(e)) {
							r.set(e, [t.value ? "assigned_prop" : "prop"]);
							continue;
						}
						Qs(t, e);
					}
					if ("MethodDefinition" === t.type) {
						if ("constructor" === t.kind) a = t;
						else if (!t.computed) {
							const e = (t.static ? "@" : "") + sl(t.key), n = r.get(e);
							if (!n) {
								r.set(e, [t.kind]);
								continue;
							}
							if ((n.includes(t.kind) || n.includes("prop") || n.includes("assigned_prop")) && Qs(t, e), "get" === t.kind) {
								if (1 === n.length && "set" === n[0]) {
									n.push("get");
									continue;
								}
							} else {
								if ("set" !== t.kind) {
									n.push(t.kind);
									continue;
								}
								if (1 === n.length && "get" === n[0]) {
									n.push("set");
									continue;
								}
							}
							Qs(t, e);
						}
					}
				}
				if (a) for (const e of a.value.body.body) {
					if ("ExpressionStatement" !== e.type) continue;
					if ("AssignmentExpression" !== e.expression.type) continue;
					const { left: t, right: n } = e.expression;
					"MemberExpression" === t.type && "ThisExpression" === t.object.type && (t.computed && "Literal" !== t.property.type || i(e.expression, t.property, n));
				}
				for (const [e, t] of s) {
					if ("#" === e[0]) continue;
					let s = e.replace(f, "_");
					for (; n.includes(s);) s = "_" + s;
					n.push(s), t.key = di(s);
				}
				t.next({
					...t.state,
					state_fields: s
				});
			},
			ClassDeclaration: function(e, t) {
				t.state.analysis.runes && null !== e.id && sc(t.state.scope.get(e.id.name));
				const n = "module" === t.state.ast_type ? 0 : 1;
				t.state.scope.function_depth > n && function(e) {
					qe(e, "perf_avoid_nested_class", "Avoid declaring classes below the top level scope\nhttps://svelte.dev/e/perf_avoid_nested_class");
				}(e), t.next();
			},
			ClassDirective: function(e, t) {
				up(t.path), t.next({
					...t.state,
					expression: e.metadata.expression
				});
			},
			Component: function(e, t) {
				const n = t.state.scope.get(e.name.includes(".") ? e.name.slice(0, e.name.indexOf(".")) : e.name);
				e.metadata.dynamic = t.state.analysis.runes && null !== n && ("normal" !== n.kind || e.name.includes(".")), n && (e.metadata.expression.has_state = e.metadata.dynamic, e.metadata.expression.dependencies.add(n), e.metadata.expression.references.add(n)), vp(e, t);
			},
			ConstTag: function(e, t) {
				t.state.analysis.runes && Zl(e, t.state, "@");
				const n = t.path.at(-1), s = t.path.at(-2);
				("Fragment" !== n?.type || "IfBlock" !== s?.type && "SvelteFragment" !== s?.type && "Component" !== s?.type && "SvelteComponent" !== s?.type && "EachBlock" !== s?.type && "AwaitBlock" !== s?.type && "SnippetBlock" !== s?.type && "SvelteBoundary" !== s?.type && "KeyBlock" !== s?.type && ("RegularElement" !== s?.type && "SvelteElement" !== s?.type || !s.attributes.some(((e) => "Attribute" === e.type && "slot" === e.name)))) && function(e) {
					zs(e, "const_tag_invalid_placement", "`{@const}` must be the immediate child of `{#snippet}`, `{#if}`, `{:else if}`, `{:else}`, `{#each}`, `{:then}`, `{:catch}`, `<svelte:fragment>`, `<svelte:boundary>` or `<Component>`\nhttps://svelte.dev/e/const_tag_invalid_placement");
				}(e);
				const r = e.declaration.declarations[0];
				t.visit(r.id), t.visit(r.init, {
					...t.state,
					expression: e.metadata.expression,
					function_depth: t.state.function_depth + 1,
					derived_function_depth: t.state.function_depth + 1
				});
			},
			DebugTag: function(e, t) {
				t.state.analysis.runes && Zl(e, t.state, "@"), t.next();
			},
			EachBlock: function(e, t) {
				Zl(e, t.state, "#"), ec(e.body), ec(e.fallback);
				const n = e.context;
				if ("Identifier" !== n?.type || "$state" !== n.name && "$derived" !== n.name || mr(e, n.name), e.key && (e.metadata.keyed = "Identifier" !== e.key.type || !e.index || e.key.name !== e.index), e.metadata.keyed && !e.context && function(e) {
					zs(e, "each_key_without_as", "An `{#each ...}` block without an `as` clause cannot have a key\nhttps://svelte.dev/e/each_key_without_as");
				}(e.key), t.visit(e.expression, {
					...t.state,
					expression: e.metadata.expression,
					scope: t.state.scope.parent
				}), t.visit(e.body), e.key && t.visit(e.key), e.fallback && t.visit(e.fallback), !t.state.analysis.runes) {
					let n = !!e.context && to(e.context).some(((e) => {
						return !!t.state.scope.get(e.name)?.mutated;
					}));
					for (const t of e.metadata.expression.dependencies) "function" !== t.declaration_kind && bp(t, e.metadata.transitive_deps);
					if (n) for (const t of e.metadata.transitive_deps) "normal" !== t.kind || "const" !== t.declaration_kind && "let" !== t.declaration_kind && "var" !== t.declaration_kind || (t.kind = "state");
				}
				up(t.path);
			},
			ExportDefaultDeclaration: function(e, t) {
				t.state.ast_type ? Zs(e) : "Identifier" === e.declaration.type && rc(e, t.state.scope, e.declaration.name), t.next();
			},
			ExportNamedDeclaration: function(e, t) {
				if (t.next(), t.state.ast_type && e.specifiers.some(((e) => "Identifier" === e.exported.type ? "default" === e.exported.name : "default" === e.exported.value)) && Zs(e), "VariableDeclaration" === e.declaration?.type) {
					t.state.analysis.runes && "instance" === t.state.ast_type && "let" === e.declaration.kind && function(e) {
						zs(e, "legacy_export_invalid", "Cannot use `export let` in runes mode — use `$props()` instead\nhttps://svelte.dev/e/legacy_export_invalid");
					}(e);
					for (const n of e.declaration.declarations) for (const s of to(n.id)) {
						const n = t.state.scope.get(s.name);
						n && ("derived" === n.kind && Xs(e), "state" !== n.kind && "raw_state" !== n.kind || !n.reassigned || hr(e));
					}
				}
				if (t.state.analysis.runes && e.declaration && "instance" === t.state.ast_type) {
					if ("FunctionDeclaration" === e.declaration.type || "ClassDeclaration" === e.declaration.type) t.state.analysis.exports.push({
						name: e.declaration.id.name,
						alias: null
					});
					else if ("const" === e.declaration.kind) for (const n of e.declaration.declarations) for (const e of to(n.id)) t.state.analysis.exports.push({
						name: e.name,
						alias: null
					});
				}
			},
			ExportSpecifier: function(e, t) {
				const n = "Identifier" === e.local.type ? e.local.name : e.local.value, s = "Identifier" === e.exported.type ? e.exported.name : e.exported.value;
				if ("instance" === t.state.ast_type) {
					if (t.state.analysis.runes) {
						t.state.analysis.exports.push({
							name: n,
							alias: s
						});
						const e = t.state.scope.get(n);
						e && (e.reassigned = !0);
					}
				} else rc(e, t.state.scope, n);
			},
			ExpressionStatement: function(e, t) {
				if ("NewExpression" === e.expression.type && "Identifier" === e.expression.callee.type && 1 === e.expression.arguments.length && "ObjectExpression" === e.expression.arguments[0].type && e.expression.arguments[0].properties.some(((e) => "Property" === e.type && "Identifier" === e.key.type && "target" === e.key.name))) {
					const n = t.state.scope.get(e.expression.callee.name);
					if ("normal" === n?.kind && "import" === n.declaration_kind) {
						const t = n.initial;
						t.source.value.endsWith(".svelte") && t.specifiers.find(((e) => e.local.name === n.node.name && "ImportDefaultSpecifier" === e.type)) && function(e) {
							qe(e, "legacy_component_creation", "Svelte 5 components are no longer classes. Instantiate them using `mount` or `hydrate` (imported from 'svelte') instead.\nhttps://svelte.dev/e/legacy_component_creation");
						}(e.expression);
					}
				}
				t.next();
			},
			ExpressionTag: function(e, t) {
				if ("Fragment" === t.path.at(-1)?.type && t.state.parent_element) {
					const n = cl("#text", t.state.parent_element);
					n && na(e, n);
				}
				up(t.path), t.next({
					...t.state,
					expression: e.metadata.expression
				});
			},
			Fragment: function(e, t) {
				t.next({
					...t.state,
					fragment: e
				});
			},
			FunctionDeclaration: function(e, t) {
				t.state.analysis.runes && null !== e.id && sc(t.state.scope.get(e.id.name)), pp(0, t);
			},
			FunctionExpression: function(e, t) {
				pp(0, t);
			},
			HtmlTag: function(e, t) {
				t.state.analysis.runes && Zl(e, t.state, "@"), up(t.path), t.next({
					...t.state,
					expression: e.metadata.expression
				});
			},
			Identifier: function(e, t) {
				let n = t.path.length, s = t.path[--n];
				if (!Xl(e, s)) return;
				if (up(t.path), "arguments" !== e.name || t.path.some(((e) => "FunctionDeclaration" === e.type || "FunctionExpression" === e.type)) || function(e) {
					zs(e, "invalid_arguments_usage", "The arguments keyword cannot be used within the template or at the top level of a component\nhttps://svelte.dev/e/invalid_arguments_usage");
				}(e), "$$slots" === e.name && (t.state.analysis.uses_slots = !0), t.state.analysis.runes && de(e.name) && null === t.state.scope.get(e.name) && "store_sub" !== t.state.scope.get(e.name.slice(1))?.kind) {
					let r = e, a = e.name;
					for (; "MemberExpression" === s.type;) s.computed && ar(s), a += `.${s.property.name}`, r = s, s = t.path[--n], de(a) || ("$effect.active" === a && cr(s, "$effect.active", "$effect.tracking"), "$state.frozen" === a && cr(s, "$state.frozen", "$state.raw"), "$state.is" === a && lr(s, "$state.is"), ir(s, a));
					"CallExpression" !== s.type && function(e) {
						zs(e, "rune_missing_parentheses", "Cannot use rune without parentheses\nhttps://svelte.dev/e/rune_missing_parentheses");
					}(r);
				}
				let r = t.state.scope.get(e.name);
				if (t.state.analysis.runes || ("$$props" === e.name && (t.state.analysis.uses_props = !0), "$$restProps" === e.name && (t.state.analysis.uses_rest_props = !0)), r) {
					if (t.state.expression && (t.state.expression.dependencies.add(r), t.state.expression.references.add(r), t.state.expression.has_state ||= !("static" === r.kind || "prop" !== r.kind && "bindable_prop" !== r.kind && "rest_prop" !== r.kind && r.is_function() || t.state.scope.evaluate(e).is_known)), t.state.analysis.runes && e !== r.node && t.state.function_depth === r.scope.function_depth && ("state" === r.kind && (r.reassigned || "CallExpression" === r.initial?.type && 1 === r.initial.arguments.length && "SpreadElement" !== r.initial.arguments[0].type && !Cp(r.initial.arguments[0], t.state.scope)) || "raw_state" === r.kind || "derived" === r.kind || "prop" === r.kind || "rest_prop" === r.kind) && ("AssignmentExpression" !== s.type || s.left !== e) && "UpdateExpression" !== s.type) {
						let n = "closure", s = t.path.length;
						for (; s--;) {
							const e = t.path[s];
							if ("ArrowFunctionExpression" === e.type || "FunctionDeclaration" === e.type || "FunctionExpression" === e.type) break;
							if ("CallExpression" === e.type && e.arguments.includes(t.path[s + 1])) {
								const s = xc(e, t.state.scope);
								if ("$state" === s || "$state.raw" === s) {
									n = "derived";
									break;
								}
							}
						}
						(function(e, t, n) {
							qe(e, "state_referenced_locally", `This reference only captures the initial value of \`${t}\`. Did you mean to reference it inside a ${n} instead?\nhttps://svelte.dev/e/state_referenced_locally`);
						})(e, e.name, n);
					}
					if (t.state.reactive_statement && r.scope === t.state.analysis.module.scope && r.reassigned && function(e) {
						qe(e, "reactive_declaration_module_script_dependency", "Reassignments of module-level declarations will not cause reactive statements to update\nhttps://svelte.dev/e/reactive_declaration_module_script_dependency");
					}(e), r.metadata?.is_template_declaration && t.state.options.experimental.async) {
						let n;
						for (let s = t.path.length - 1; s >= 0; s--) {
							const a = t.path[s], i = t.path[s - 1];
							if ("SnippetBlock" === a.type) n = a.expression.name;
							else if (n && i && "Fragment" === a.type && (Zo(i) || "SvelteBoundary" === i.type && ("failed" === n || "pending" === n))) {
								if (Zo(i) ? i.metadata.scopes.default !== r.scope : t.state.scopes.get(a) !== r.scope) break;
								Ur(e, e.name);
							}
						}
					}
				}
			},
			IfBlock: function(e, t) {
				ec(e.consequent), ec(e.alternate), t.state.analysis.runes && Zl(e, t.state, e.elseif ? ":" : "#"), up(t.path), t.visit(e.test, {
					...t.state,
					expression: e.metadata.expression
				}), t.visit(e.consequent), e.alternate && t.visit(e.alternate);
				const n = e.alternate;
				if (n && 1 === n.nodes.length && "IfBlock" === n.nodes[0].type && n.nodes[0].elseif) {
					const t = n.nodes[0];
					t.metadata.expression.has_await || t.metadata.expression.has_more_blockers_than(e.metadata.expression) || (e.metadata.flattened = [t, ...t.metadata.flattened ?? []], t.metadata.flattened = void 0);
				}
			},
			ImportDeclaration: function(e, t) {
				if (t.state.analysis.runes) {
					const t = e.source.value;
					if (t.startsWith("svelte/internal") && function(e) {
						zs(e, "import_svelte_internal_forbidden", "Imports of `svelte/internal/*` are forbidden. It contains private runtime code which is subject to change without notice. If you're importing from `svelte/internal/*` to work around a limitation of Svelte, please open an issue at https://github.com/sveltejs/svelte and explain your use case\nhttps://svelte.dev/e/import_svelte_internal_forbidden");
					}(e), "svelte" === t) for (const t of e.specifiers) "ImportSpecifier" === t.type && ("Identifier" !== t.imported.type || "beforeUpdate" !== t.imported.name && "afterUpdate" !== t.imported.name || pr(t, t.imported.name));
				}
			},
			KeyBlock: function(e, t) {
				ec(e.fragment), t.state.analysis.runes && Zl(e, t.state, "#"), up(t.path), t.visit(e.expression, {
					...t.state,
					expression: e.metadata.expression
				}), t.visit(e.fragment);
			},
			LabeledStatement: function(e, t) {
				if ("$" === e.label.name) {
					const n = t.path.at(-1);
					if ("instance" === t.state.ast_type && "Program" === n.type) {
						t.state.analysis.runes && function(e) {
							zs(e, "legacy_reactive_statement_invalid", "`$:` is not allowed in runes mode, use `$derived` or `$effect` instead\nhttps://svelte.dev/e/legacy_reactive_statement_invalid");
						}(e);
						const n = {
							assignments: /* @__PURE__ */ new Set(),
							dependencies: []
						};
						t.next({
							...t.state,
							reactive_statement: n,
							function_depth: t.state.scope.function_depth + 1
						});
						for (const [e, s] of t.state.scope.references) {
							const r = t.state.scope.get(e);
							if (null !== r) for (const { node: e, path: t } of s) {
								let s = e, a = t.length - 1, i = t.at(a);
								for (; "MemberExpression" === i.type;) s = i, i = t.at(--a);
								if ("AssignmentExpression" !== i.type || "=" !== i.operator || i.left !== s) {
									n.dependencies.push(r);
									break;
								}
							}
						}
						if (t.state.analysis.reactive_statements.set(e, n), "ExpressionStatement" === e.body.type && "AssignmentExpression" === e.body.expression.type) {
							let s = to(e.body.expression.left);
							if ("MemberExpression" === e.body.expression.left.type) {
								const t = Ki(e.body.expression.left);
								null !== t && (s = [t]);
							}
							for (const e of s) {
								const s = t.state.scope.get(e.name);
								"legacy_reactive" === s?.kind && (s.legacy_dependencies = Array.from(n.dependencies));
							}
						}
					} else t.state.analysis.runes || function(e) {
						qe(e, "reactive_declaration_invalid_placement", "Reactive declarations only exist at the top level of the instance script\nhttps://svelte.dev/e/reactive_declaration_invalid_placement");
					}(e);
				}
				t.next();
			},
			LetDirective: function(e, t) {
				const n = t.path.at(-1);
				(void 0 === n || "Component" !== n.type && "RegularElement" !== n.type && "SlotElement" !== n.type && "SvelteElement" !== n.type && "SvelteComponent" !== n.type && "SvelteSelf" !== n.type && "SvelteFragment" !== n.type) && function(e) {
					zs(e, "let_directive_invalid_placement", "`let:` directive at invalid position\nhttps://svelte.dev/e/let_directive_invalid_placement");
				}(e);
			},
			Literal: function(e) {
				"string" == typeof e.value && b.test(e.value) && tt(e);
			},
			MemberExpression: function(e, t) {
				if ("Identifier" === e.object.type && "Identifier" === e.property.type) "rest_prop" === t.state.scope.get(e.object.name)?.kind && e.property.name.startsWith("$$") && tr(e.property);
				t.state.expression && (t.state.expression.has_member_expression = !0, t.state.expression.has_state ||= !nc(e, t)), tc(e, t.state.scope) || (t.state.analysis.needs_context = !0), t.next();
			},
			NewExpression: function(e, t) {
				"ClassExpression" === e.callee.type && t.state.scope.function_depth > 0 && function(e) {
					qe(e, "perf_avoid_inline_class", "Avoid 'new class' — instead, declare the class at the top level scope\nhttps://svelte.dev/e/perf_avoid_inline_class");
				}(e), t.state.analysis.needs_context = !0, t.next();
			},
			OnDirective: function(e, t) {
				if (t.state.analysis.runes) {
					const n = t.path.at(-1)?.type;
					"RegularElement" !== n && "SvelteElement" !== n || function(e, t) {
						qe(e, "event_directive_deprecated", `Using \`on:${t}\` to listen to the ${t} event is deprecated. Use the event attribute \`on${t}\` instead\nhttps://svelte.dev/e/event_directive_deprecated`);
					}(e, e.name);
				}
				const n = t.path.at(-1);
				"SvelteElement" !== n?.type && "RegularElement" !== n?.type || (t.state.analysis.event_directive_node ??= e), up(t.path), t.next({
					...t.state,
					expression: e.metadata.expression
				});
			},
			PropertyDefinition: function(e, t) {
				const n = sl(e.key), s = n && t.state.state_fields.get(n);
				s && e !== s.node && e.value && e.start < s.node.start && dr(e), t.next();
			},
			RegularElement: function(e, t) {
				if (dw(e, t), zx(e, t), e.metadata.path = [...t.path], t.state.analysis.elements.push(e), "textarea" === e.name && e.fragment.nodes.length > 0) {
					for (const t of e.attributes) "Attribute" === t.type && "value" === t.name && Aa(e);
					if (e.fragment.nodes.length > 1 || "Text" !== e.fragment.nodes[0].type) {
						const t = e.fragment.nodes[0];
						"Text" === t.type && (t.data = t.data.replace(a, ""), t.raw = t.raw.replace(a, "")), e.attributes.push(tl("value", null, -1, -1, e.fragment.nodes)), e.fragment.nodes = [];
					}
				}
				if ("select" === e.name && !we) {
					for (const n of e.attributes) if ("BindDirective" === n.type && "value" === n.name && "SequenceExpression" !== n.expression.type) {
						const e = Ki(n.expression), s = e && t.state.scope.get(e.name);
						if (s) for (const e of t.state.scope.references.keys()) {
							if (e === s.node.name) continue;
							const n = t.state.scope.get(e);
							n && s.legacy_indirect_bindings.add(n);
						}
						break;
					}
				}
				if ("option" === e.name && 1 === e.fragment.nodes?.length && "ExpressionTag" === e.fragment.nodes[0].type && !e.attributes.some(((e) => "Attribute" === e.type && "value" === e.name))) {
					const t = e.fragment.nodes[0];
					e.metadata.synthetic_value_node = t;
				}
				(rl(e) || "selectedcontent" === e.name) && (e.fragment.metadata.dynamic = !0, up(t.path));
				const n = t.state.scope.get(e.name);
				if (null !== n && "import" === n.declaration_kind && 0 === n.references.length && function(e, t) {
					qe(e, "component_name_lowercase", `\`<${t}>\` will be treated as an HTML element unless it begins with a capital letter\nhttps://svelte.dev/e/component_name_lowercase`);
				}(e, e.name), e.metadata.has_spread = e.attributes.some(((e) => "SpreadAttribute" === e.type)), e.metadata.svg = (() => {
					if (oe(e.name)) return !0;
					if ("a" === e.name || "title" === e.name) {
						let e = t.path.length;
						for (; e--;) {
							const n = t.path[e];
							if ("RegularElement" === n.type) return n.metadata.svg;
						}
					}
					return !1;
				})(), e.metadata.mathml = ce(e.name), el(e) && e.attributes.length > 0 && up(t.path), t.state.parent_element) {
					let n = !1, s = !1;
					const r = [t.state.parent_element];
					for (let a = t.path.length - 1; a >= 0; a--) {
						const i = t.path[a];
						if ("IfBlock" !== i.type && "EachBlock" !== i.type && "AwaitBlock" !== i.type && "KeyBlock" !== i.type || (s = !0), n) {
							if ("RegularElement" === i.type) {
								r.push(i.name);
								const t = ll(e.name, r);
								t && (s ? ft(e, t) : na(e, t));
							} else if ("Component" === i.type || "SvelteComponent" === i.type || "SvelteElement" === i.type || "SvelteSelf" === i.type || "SnippetBlock" === i.type) break;
						} else if ("RegularElement" === i.type && i.name === t.state.parent_element) {
							const r = cl(e.name, t.state.parent_element);
							r && (s ? ft(e, r) : na(e, r)), n = !0;
						}
					}
				}
				const s = e.name.replace(/[a-zA-Z-]*:/g, "");
				if ("/" !== t.state.analysis.source[e.end - 2] || z(s) || oe(s) || ce(s) || function(e, t) {
					qe(e, "element_invalid_self_closing_tag", `Self-closing HTML tags for non-void elements are ambiguous — use \`<${t} ...></${t}>\` rather than \`<${t} ... />\`\nhttps://svelte.dev/e/element_invalid_self_closing_tag`);
				}(e, e.name), t.next({
					...t.state,
					parent_element: e.name
				}), "a" === e.name && !t.state.parent_element) {
					for (const t of e.fragment.nodes) if ("RegularElement" === t.type && t.metadata.svg && "svg" !== t.name) {
						e.metadata.svg = !0;
						break;
					}
				}
			},
			RenderTag: function(e, t) {
				Zl(e, t.state, "@"), e.metadata.path = [...t.path];
				const n = lo(e.expression), s = n.callee, r = "Identifier" === s.type ? t.state.scope.get(s.name) : null;
				e.metadata.dynamic = "normal" !== r?.kind;
				let a = "Identifier" === s.type && yp(r);
				"SnippetBlock" === r?.initial?.type && e.metadata.snippets.add(r.initial), t.state.analysis.snippet_renderers.set(e, a), t.state.analysis.uses_render_tags = !0;
				const i = lo(e.expression).arguments;
				for (const e of i) "SpreadElement" === e.type && sa(e);
				"MemberExpression" === s.type && "Identifier" === s.property.type && [
					"bind",
					"apply",
					"call"
				].includes(s.property.name) && function(e) {
					zs(e, "render_tag_invalid_call_expression", "Calling a snippet function using apply, bind or call is not allowed\nhttps://svelte.dev/e/render_tag_invalid_call_expression");
				}(e), up(t.path), t.visit(s, {
					...t.state,
					expression: e.metadata.expression
				});
				for (const s of n.arguments) {
					const n = new nl();
					e.metadata.arguments.push(n), t.visit(s, {
						...t.state,
						expression: n
					});
				}
			},
			SlotElement: function(e, t) {
				t.state.analysis.runes && !t.state.analysis.custom_element && function(e) {
					qe(e, "slot_element_deprecated", "Using `<slot>` to render parent content is deprecated. Use `{@render ...}` tags instead\nhttps://svelte.dev/e/slot_element_deprecated");
				}(e), up(t.path);
				let n = "default";
				for (const t of e.attributes) "Attribute" === t.type ? "name" === t.name && (Xi(t) || ua(t), n = t.value[0].data, "default" === n && da(t)) : "SpreadAttribute" !== t.type && "LetDirective" !== t.type && pa(t);
				t.state.analysis.slot_names.set(n, e), t.next();
			},
			SnippetBlock: function(e, t) {
				t.state.analysis.snippets.add(e), ec(e.body), t.state.analysis.runes && Zl(e, t.state, "#");
				for (const t of e.parameters) "RestElement" === t.type && ha(t);
				t.next({
					...t.state,
					parent_element: null
				});
				const n = 1 === t.path.length && "Fragment" === t.path[0].type && mw(t.state.scope, t.state.scopes), s = e.expression.name;
				if (n) {
					const e = t.state.scope.get(s);
					t.state.analysis.module.scope.declarations.set(s, e);
				}
				e.metadata.can_hoist = n;
				const { path: r } = t, a = r.at(-2);
				a && ("Component" === a.type && a.attributes.some(((t) => ("Attribute" === t.type || "BindDirective" === t.type) && t.name === e.expression.name)) && function(e, t) {
					zs(e, "snippet_shadowing_prop", `This snippet is shadowing the prop \`${t}\` with the same name\nhttps://svelte.dev/e/snippet_shadowing_prop`);
				}(e, e.expression.name), "children" === e.expression.name && ("Component" !== a.type && "SvelteComponent" !== a.type && "SvelteSelf" !== a.type || a.fragment.nodes.some(((e) => "SnippetBlock" !== e.type && ("Text" !== e.type || e.data.trim()) && "Comment" !== e.type)) && function(e) {
					zs(e, "snippet_conflict", "Cannot use explicit children snippet at the same time as implicit children content. Remove either the non-whitespace content or the children snippet block\nhttps://svelte.dev/e/snippet_conflict");
				}(e)));
			},
			SpreadAttribute: function(e, t) {
				up(t.path), t.next({
					...t.state,
					expression: e.metadata.expression
				});
			},
			SpreadElement: function(e, t) {
				t.state.expression && (t.state.expression.has_call = !0, t.state.expression.has_state = !0), t.next();
			},
			StyleDirective: function(e, t) {
				if ((e.modifiers.length > 1 || e.modifiers.length && "important" !== e.modifiers[0]) && function(e) {
					zs(e, "style_directive_invalid_modifier", "`style:` directive can only use the `important` modifier\nhttps://svelte.dev/e/style_directive_invalid_modifier");
				}(e), up(t.path), !0 === e.value) {
					let n = t.state.scope.get(e.name);
					n && ("normal" !== n.kind && (e.metadata.expression.has_state = !0), n.blocker && e.metadata.expression.dependencies.add(n));
				} else {
					t.next();
					for (const t of Ji(e.value)) "ExpressionTag" === t.type && e.metadata.expression.merge(t.metadata.expression);
				}
			},
			SvelteBody: function(e, t) {
				Fl(e);
				for (const t of e.attributes) ("SpreadAttribute" === t.type || "Attribute" === t.type && !Zi(t)) && ma(t);
				t.next();
			},
			SvelteComponent: function(e, t) {
				t.state.analysis.runes && function(e) {
					qe(e, "svelte_component_deprecated", "`<svelte:component>` is deprecated in runes mode — components are dynamic by default\nhttps://svelte.dev/e/svelte_component_deprecated");
				}(e), t.visit(e.expression, {
					...t.state,
					expression: e.metadata.expression
				}), vp(e, t);
			},
			SvelteDocument: function(e, t) {
				Fl(e);
				for (const t of e.attributes) ("SpreadAttribute" === t.type || "Attribute" === t.type && !Zi(t)) && ta(t, "svelte:document");
				t.next();
			},
			SvelteElement: function(e, t) {
				dw(e, t), zx(e, t), e.metadata.path = [...t.path], t.state.analysis.elements.push(e);
				const n = e.attributes.find(((e) => "Attribute" === e.type && "xmlns" === e.name && Xi(e)));
				if (n) e.metadata.svg = n.value[0].data === I, e.metadata.mathml = n.value[0].data === M;
				else {
					let n = t.path.length;
					for (; n--;) {
						const s = t.path[n];
						if ("Component" === s.type || "SvelteComponent" === s.type || "SvelteFragment" === s.type || "SnippetBlock" === s.type || 0 === n) {
							e.metadata.svg = "svg" === t.state.options.namespace, e.metadata.mathml = "mathml" === t.state.options.namespace;
							break;
						}
						if ("SvelteElement" === s.type || "RegularElement" === s.type) {
							e.metadata.svg = ("RegularElement" !== s.type || "foreignObject" !== s.name) && s.metadata.svg, e.metadata.mathml = ("RegularElement" !== s.type || "foreignObject" !== s.name) && s.metadata.mathml;
							break;
						}
					}
				}
				up(t.path), t.visit(e.tag, {
					...t.state,
					expression: e.metadata.expression
				});
				for (const n of e.attributes) t.visit(n);
				t.visit(e.fragment, {
					...t.state,
					parent_element: null
				});
			},
			SvelteFragment: function(e, t) {
				const n = t.path.at(-2);
				"Component" !== n?.type && "SvelteComponent" !== n?.type && function(e) {
					zs(e, "svelte_fragment_invalid_placement", "`<svelte:fragment>` must be the direct child of a component\nhttps://svelte.dev/e/svelte_fragment_invalid_placement");
				}(e);
				for (const n of e.attributes) "Attribute" === n.type ? "slot" === n.name && fp(t, n) : "LetDirective" !== n.type && ga(n);
				t.next({
					...t.state,
					parent_element: null
				});
			},
			SvelteHead: function(e, t) {
				for (const t of e.attributes) ba(t);
				up(t.path), t.next();
			},
			SvelteSelf: function(e, t) {
				if (t.path.some(((e) => "IfBlock" === e.type || "EachBlock" === e.type || "Component" === e.type || "SnippetBlock" === e.type)) || function(e) {
					zs(e, "svelte_self_invalid_placement", "`<svelte:self>` components can only exist inside `{#if}` blocks, `{#each}` blocks, `{#snippet}` blocks or slots passed to components\nhttps://svelte.dev/e/svelte_self_invalid_placement");
				}(e), t.state.analysis.runes) (function(e, t, n) {
					qe(e, "svelte_self_deprecated", `\`<svelte:self>\` is deprecated — use self-imports (e.g. \`import ${t} from './${n}'\`) instead\nhttps://svelte.dev/e/svelte_self_deprecated`);
				})(e, me === ye ? "Self" : t.state.analysis.name, me === ye ? "Self.svelte" : me.split(/[/\\]/).pop());
				vp(e, t);
			},
			SvelteWindow: function(e, t) {
				Fl(e);
				for (const t of e.attributes) ("SpreadAttribute" === t.type || "Attribute" === t.type && !Zi(t)) && ta(t, "svelte:window");
				t.next();
			},
			SvelteBoundary: function(e, t) {
				for (const t of e.attributes) "Attribute" === t.type && fw.includes(t.name) || fa(t), (!0 === t.value || Array.isArray(t.value) && (1 !== t.value.length || "ExpressionTag" !== t.value[0].type)) && ya(t);
				up(t.path), t.next();
			},
			TaggedTemplateExpression: function(e, t) {
				t.state.expression && !nc(e.tag, t) && (t.state.expression.has_call = !0, t.state.expression.has_state = !0), t.next();
			},
			TemplateElement: function(e) {
				b.test(e.value.cooked ?? "") && tt(e);
			},
			Text: function(e, t) {
				const n = t.path.at(-1);
				if ("Fragment" === n.type && t.state.parent_element && p.test(e.data)) {
					const n = cl("#text", t.state.parent_element);
					n && na(e, n);
				}
				b.lastIndex = 0;
				for (const s of e.data.matchAll(b)) {
					let r = !1;
					if ("Fragment" === n.type) for (const s of n.nodes) {
						if (s === e) break;
						"Comment" === s.type && (r ||= _t(s.start + 4, s.data, t.state.analysis.runes).includes("bidirectional_control_characters"));
					}
					if (!r) {
						let t = s.index + e.start;
						tt({
							start: t,
							end: t + s[0].length
						});
					}
				}
			},
			TransitionDirective: function(e, t) {
				up(t.path), t.next({
					...t.state,
					expression: e.metadata.expression
				}), e.metadata.expression.has_await && ea(e);
			},
			TitleElement: function(e, t) {
				for (const t of e.attributes) $a(t);
				for (const t of e.fragment.nodes) "Text" !== t.type && "ExpressionTag" !== t.type && Ra(t);
				t.next();
			},
			UpdateExpression: function(e, t) {
				if (Yl(e, e.argument, t), t.state.reactive_statement) {
					const n = "MemberExpression" === e.argument.type ? Ki(e.argument) : e.argument;
					if ("Identifier" === n?.type) {
						const e = t.state.scope.get(n.name);
						e && t.state.reactive_statement.assignments.add(e);
					}
				}
				t.state.expression && (t.state.expression.has_assignment = !0), t.next();
			},
			UseDirective: function(e, t) {
				up(t.path), t.next({
					...t.state,
					expression: e.metadata.expression
				}), e.metadata.expression.has_await && ea(e);
			},
			VariableDeclarator: function(e, t) {
				if (function(e, t) {
					const n = to(e.id);
					for (const s of n) "instance" === t.ast_type && t.scope === t.analysis.instance.scope && "import" === t.analysis.module.scope.get(s.name)?.declaration_kind && Ks(e.id);
				}(e, t.state), t.state.analysis.runes) {
					const n = xc(e.init, t.state.scope), { paths: s } = ro(e.id, ui("dummy"));
					for (const e of s) sc(t.state.scope.get(e.node.name));
					if ("$state" === n || "$state.raw" === n || "$derived" === n || "$derived.by" === n || "$props" === n) for (const r of s) {
						const s = t.state.scope.get(r.node.name);
						if (s.kind = "$state" === n ? "state" : "$state.raw" === n ? "raw_state" : "$derived" === n || "$derived.by" === n ? "derived" : r.is_rest ? "rest_prop" : "prop", "$props" === n && "rest_prop" === s.kind && "ObjectPattern" === e.id.type) {
							const { properties: t } = e.id, n = [];
							for (const e of t) {
								if ("RestElement" === e.type) continue;
								const t = e.key;
								n.push("Identifier" === t.type ? t.name : t.value.toString());
							}
							(s.metadata ??= {}).exclude_props = n;
						}
					}
					if ("$props" === n) {
						if ("ObjectPattern" !== e.id.type && "Identifier" !== e.id.type && function(e) {
							zs(e, "props_invalid_identifier", "`$props()` can only be used with an object destructuring pattern\nhttps://svelte.dev/e/props_invalid_identifier");
						}(e), t.state.analysis.custom_element && null == t.state.options.customElementOptions?.props) {
							let t;
							"Identifier" !== e.id.type && null == (t = e.id.properties.find(((e) => "RestElement" === e.type))) || function(e) {
								qe(e, "custom_element_props_identifier", "Using a rest element or a non-destructured declaration with `$props()` means that Svelte can't infer what properties to expose when creating a custom element. Consider destructuring all the props or explicitly specifying the `customElement.props` option.\nhttps://svelte.dev/e/custom_element_props_identifier");
							}(t ?? e.id);
						}
						if (t.state.analysis.needs_props = !0, "Identifier" === e.id.type) {
							const n = t.state.scope.get(e.id.name);
							n.initial = null, n.kind = "rest_prop";
						} else {
							yw(e.id.type, "ObjectPattern");
							for (const n of e.id.properties) {
								if ("Property" !== n.type) continue;
								n.computed && nr(n), "Identifier" === n.key.type && n.key.name.startsWith("$$") && tr(n);
								const e = "AssignmentPattern" === n.value.type ? n.value.left : n.value;
								"Identifier" !== e.type && nr(n);
								const s = "Identifier" === n.key.type ? n.key.name : String(n.key.value);
								let r = "AssignmentPattern" === n.value.type ? n.value.right : null;
								const a = t.state.scope.get(e.name);
								a.prop_alias = s, "CallExpression" === r?.type && "Identifier" === r.callee.type && "$bindable" === r.callee.name ? (a.initial = r.arguments[0] ?? null, a.kind = "bindable_prop") : a.initial = r;
							}
						}
					}
				} else if ("CallExpression" === e.init?.type) {
					const n = e.init.callee;
					"Identifier" !== n.type || "$state" !== n.name && "$derived" !== n.name && "$props" !== n.name || "store_sub" === t.state.scope.get(n.name)?.kind || function(e, t) {
						zs(e, "rune_invalid_usage", `Cannot use \`${t}\` rune in non-runes mode\nhttps://svelte.dev/e/rune_invalid_usage`);
					}(e.init, n.name);
				}
				e.init && "$props" === xc(e.init, t.state.scope) ? (t.visit(e.id, {
					...t.state,
					function_depth: t.state.function_depth + 1
				}), t.visit(e.init)) : t.next();
			}
		};
		function gw(e, t, n, s) {
			const r = e?.content ?? {
				type: "Program",
				sourceType: "module",
				start: -1,
				end: -1,
				body: []
			}, { scope: a, scopes: i, has_await: o } = bc(r, t, n, s);
			return {
				ast: r,
				scope: a,
				scopes: i,
				has_await: o
			};
		}
		const bw = [
			"$$props",
			"$$restProps",
			"$$slots"
		];
		function _w(e, n, s) {
			const r = new gc(), a = gw(e.module, r, !1, null), i = gw(e.instance, r, !0, a.scope), { scope: o, scopes: l, has_await: c } = bc(e.fragment, r, !1, i.scope), p = {
				ast: e.fragment,
				scope: o,
				scopes: l
			};
			let u = [];
			for (const [e, t] of a.scope.references) {
				if ("$" !== e[0] || bw.includes(e)) continue;
				"$" !== e && "$" !== e[1] || Js(t[0].node, e);
				const n = e.slice(1), r = i.scope.get(n), o = r?.initial;
				if (!1 === s.runes || !de(e) || null !== r && (null === xc(o, i.scope) || "props" !== n && "$props" === xc(o, i.scope)) && ("$derived" !== e || "ImportDeclaration" !== r.initial?.type || "svelte/store" !== r.initial.source.value)) {
					let o;
					e: for (const e of t) for (let t = e.path.length - 1; t >= 0; t--) {
						const s = l.get(e.path[t]) || a.scopes.get(e.path[t]) || i.scopes.get(e.path[t]);
						if (s) {
							const t = s?.owner(n);
							if (t && t !== a.scope && t !== i.scope) {
								o = e.node;
								break e;
							}
							break;
						}
					}
					if (o && zs(o, "store_invalid_scoped_subscription", "Cannot subscribe to stores that are not declared at the top level of the component\nhttps://svelte.dev/e/store_invalid_scoped_subscription"), !1 !== s.runes) {
						if (null === r && /[a-z]/.test(n[0])) Js(t[0].node, e);
						else if (null !== r && de(e)) for (const { node: e, path: s } of t) "CallExpression" === s.at(-1)?.type && pt(e, n);
					}
					if (a.ast) for (const { node: e, path: n } of t) e.start > a.ast.start && e.end < a.ast.end && null === xc(n.at(-1), a.scope) && fr(e);
					u.push((() => {
						null !== r && "normal" === r.kind && "let" === r.declaration_kind && r.reassigned && (r.kind = "state");
					}));
					i.scope.declare(ui(e), "store_sub", "synthetic").references = t, i.scope.references.set(e, t), a.scope.references.delete(e);
				}
			}
			const d = function(e) {
				const t = e.split(/[/\\]/), n = t.pop(), s = t.at(-1);
				let r = n.replace(".svelte", "");
				return "index" === r && s && "src" !== s && (r = s), r[0].toUpperCase() + r.slice(1);
			}(s.filename), h = s.runes ?? (c || i.has_await || Array.from(a.scope.references.keys()).some(de));
			if (!h) for (let e of u) e();
			if (h && e.module) {
				const t = e.module.attributes.find(((e) => "context" === e.name));
				t && function(e) {
					qe(e, "script_context_deprecated", "`context=\"module\"` is deprecated, use the `module` attribute instead\nhttps://svelte.dev/e/script_context_deprecated");
				}(t);
			}
			const m = !!s.customElementOptions || s.customElement, f = a.scope.generate(s.name ?? d);
			Ae({
				component_name: f,
				dev: s.dev,
				rootDir: s.rootDir,
				runes: h
			});
			const y = {
				name: f,
				root: r,
				module: a,
				instance: i,
				template: p,
				comments: e.comments,
				elements: [],
				runes: h,
				maybe_runes: !h && !1 !== s.runes && ![...a.scope.references.keys()].some(((e) => ["$$props", "$$restProps"].includes(e))) && !i.ast.body.some(((e) => "LabeledStatement" === e.type || "ExportNamedDeclaration" === e.type && (e.declaration && "VariableDeclaration" === e.declaration.type && "let" === e.declaration.kind || e.specifiers.some(((e) => "Identifier" === e.local.type && "let" === i.scope.get(e.local.name)?.declaration_kind))))),
				tracing: !1,
				classes: /* @__PURE__ */ new Map(),
				immutable: h || s.immutable,
				exports: [],
				uses_props: !1,
				props_id: null,
				uses_rest_props: !1,
				uses_slots: !1,
				uses_component_bindings: !1,
				uses_render_tags: !1,
				needs_context: !1,
				needs_mutation_validation: !1,
				needs_props: !1,
				event_directive_node: null,
				uses_event_attributes: !1,
				custom_element: m,
				inject_styles: "injected" === s.css || m,
				accessors: m || !h && !!s.accessors || 4 === s.compatibility?.componentApi,
				reactive_statements: /* @__PURE__ */ new Map(),
				binding_groups: /* @__PURE__ */ new Map(),
				slot_names: /* @__PURE__ */ new Map(),
				css: {
					ast: e.css,
					hash: e.css ? s.cssHash({
						css: e.css.content.styles,
						filename: me,
						name: d,
						hash: H
					}) : "",
					keyframes: [],
					has_global: !1
				},
				source: n,
				snippet_renderers: /* @__PURE__ */ new Map(),
				snippets: /* @__PURE__ */ new Set(),
				async_deriveds: /* @__PURE__ */ new Set(),
				pickled_awaits: /* @__PURE__ */ new Set(),
				instance_body: {
					sync: [],
					async: [],
					declarations: [],
					hoisted: []
				}
			};
			if (!h) {
				for (const e of i.ast.body) if ("ExportNamedDeclaration" === e.type) if (y.needs_props = !0, e.declaration) {
					if ("FunctionDeclaration" === e.declaration.type || "ClassDeclaration" === e.declaration.type) y.exports.push({
						name: e.declaration.id.name,
						alias: null
					});
					else if ("VariableDeclaration" === e.declaration.type) if ("const" === e.declaration.kind) for (const t of e.declaration.declarations) for (const e of to(t.id)) y.exports.push({
						name: e.name,
						alias: null
					});
					else for (const t of e.declaration.declarations) for (const e of to(t.id)) i.scope.get(e.name).kind = "bindable_prop";
				} else for (const t of e.specifiers) {
					if ("Identifier" !== t.local.type || "Identifier" !== t.exported.type) continue;
					const e = i.scope.get(t.local.name);
					!e || "var" !== e.declaration_kind && "let" !== e.declaration_kind ? y.exports.push({
						name: t.local.name,
						alias: t.exported.name
					}) : (e.kind = "bindable_prop", t.exported.name !== t.local.name && (e.prop_alias = t.exported.name));
				}
				for (const e of i.scope.declarations.values()) if ("normal" === e.kind) for (const { node: t, path: n } of e.references) t !== e.node && e.updated && ("StyleDirective" === n[n.length - 1].type || n.some(((e) => "Fragment" === e.type)) || "LabeledStatement" === n[1].type && "$" === n[1].label.name) && (e.kind = "state");
				t(p.ast, null, { EachBlock(e) {
					const n = p.scopes.get(e);
					for (const s of n.declarations.values()) if (s.updated) {
						const s = {
							scope: n.parent,
							scopes: p.scopes
						};
						t(e.expression, s, {
							_: _c,
							Identifier(e, t) {
								if (Xl(e, t.path.at(-1))) {
									const n = t.state.scope.get(e.name);
									n && "normal" === n.kind && "import" !== n.declaration_kind && "function" !== n.declaration_kind && (n.kind = "state", n.mutated = !0);
								}
							}
						});
						break;
					}
				} });
			}
			if (e.options) for (const t of e.options.attributes) "accessors" === t.name && y.runes && rt(t), "customElement" !== t.name || s.customElement || it(t), "immutable" === t.name && y.runes && at(t);
			if (function(e, n) {
				const s = (n, r, a, i = /* @__PURE__ */ new Set()) => {
					i.has(n) || (i.add(n), t(n, { scope: r }, {
						_(t, n) {
							const s = e.scopes.get(t);
							s ? n.next({ scope: s }) : n.next();
						},
						ImportDeclaration(e) {},
						Identifier(e, t) {
							if (Xl(e, t.path.at(-1))) {
								const n = t.state.scope.get(e.name);
								if (n) {
									a.add(n);
									for (const e of n.assignments) s(e.value, e.scope, a, i);
								}
							}
						}
					}));
				}, r = (n, r, a, i) => {
					function o(e, t) {
						for (const n of eo(e)) {
							const e = Ki(n);
							if (!e) return;
							const s = t.get(e.name);
							if (!s) return;
							a.add(s);
						}
					}
					t(n, { scope: i }, {
						_(t, n) {
							const s = e.scopes.get(t);
							s ? n.next({ scope: s }) : n.next();
						},
						AssignmentExpression(e, t) {
							o(e.left, t.state.scope);
						},
						UpdateExpression(e, t) {
							o(e.argument, t.state.scope);
						},
						CallExpression(e, t) {
							if ("$effect" === xc(e, t.state.scope)) return;
							const n = /* @__PURE__ */ new Set();
							s(e, t.state.scope, n);
							for (const e of n) a.add(e);
						},
						Identifier(e, t) {
							if (Xl(e, t.path.at(-1))) {
								const n = t.state.scope.get(e.name);
								n && r.add(n);
							}
						},
						ReturnStatement(e, t) {
							e.argument && s(e.argument, t.state.scope, r);
						},
						ArrowFunctionExpression(e, t) {},
						FunctionDeclaration(e, t) {},
						FunctionExpression(e, t) {}
					});
				};
				let a = !1;
				const i = ui("$$promises");
				function o(t, s) {
					n.instance_body.declarations.push(t);
					e.scope.get(t.name).blocker = s;
				}
				const l = [];
				for (let t of e.ast.body) {
					if ("ImportDeclaration" === t.type) {
						n.instance_body.hoisted.push(t);
						continue;
					}
					if ("ExportDefaultDeclaration" === t.type || "ExportAllDeclaration" === t.type) continue;
					if ("ExportNamedDeclaration" === t.type) {
						if (!t.declaration) continue;
						t = t.declaration;
					}
					const s = ho(t);
					if (a ||= s, "FunctionDeclaration" === t.type) n.instance_body.sync.push(t), l.push(t);
					else if ("VariableDeclaration" === t.type) {
						for (const c of t.declarations) if ("$props.id" !== xc(c.init, e.scope)) if ("ArrowFunctionExpression" === c.init?.type || "FunctionExpression" === c.init?.type) n.instance_body.sync.push(1 === t.declarations.length ? t : ai(t.kind, [c])), l.push(c);
						else if (a) {
							const t = /* @__PURE__ */ new Set(), a = /* @__PURE__ */ new Set();
							r(c, t, a, e.scope);
							const l = fi(i, mi(n.instance_body.async.length), !0);
							for (const e of a) e.blocker = l;
							for (const e of to(c.id)) o(e, l);
							n.instance_body.async.push({
								node: c,
								has_await: s
							});
						} else n.instance_body.sync.push(1 === t.declarations.length ? t : ai(t.kind, [c]));
					} else if (a) {
						const a = /* @__PURE__ */ new Set(), l = /* @__PURE__ */ new Set();
						r(t, a, l, e.scope);
						const c = fi(i, mi(n.instance_body.async.length), !0);
						for (const e of l) e.blocker = c;
						"ClassDeclaration" === t.type ? (o(t.id, c), n.instance_body.async.push({
							node: t,
							has_await: s
						})) : n.instance_body.async.push({
							node: t,
							has_await: s
						});
					} else n.instance_body.sync.push(t);
				}
				for (const t of l) {
					const n = /* @__PURE__ */ new Set(), s = "VariableDeclarator" === t.type ? t.init : t;
					r(s.body, n, n, e.scopes.get(s));
					const a = [...n].reduce(((e, t) => {
						if (t.blocker) {
							let n = t.blocker.property;
							return Math.max(n.value, e);
						}
						return e;
					}), -1);
					if (-1 === a) continue;
					const o = fi(i, mi(a), !0);
					(t.type, e.scope.get(t.id.name)).blocker = o;
				}
			}(i, y), y.runes) {
				const e = a.scope.references.get("$$props");
				e && function(e) {
					zs(e, "legacy_props_invalid", "Cannot use `$$props` in runes mode\nhttps://svelte.dev/e/legacy_props_invalid");
				}(e[0].node);
				const n = a.scope.references.get("$$restProps");
				n && function(e) {
					zs(e, "legacy_rest_props_invalid", "Cannot use `$$restProps` in runes mode\nhttps://svelte.dev/e/legacy_rest_props_invalid");
				}(n[0].node);
				for (const { ast: e, scope: n, scopes: r } of [
					a,
					i,
					p
				]) t(e, {
					scope: n,
					scopes: r,
					analysis: y,
					options: s,
					ast_type: e === i.ast ? "instance" : e === p.ast ? "template" : "module",
					fragment: e === p.ast ? e : null,
					parent_element: null,
					has_props_rune: !1,
					component_slots: /* @__PURE__ */ new Set(),
					expression: null,
					state_fields: /* @__PURE__ */ new Map(),
					function_depth: n.function_depth,
					reactive_statement: null,
					derived_function_depth: -1
				}, vw);
				for (const e of [a.scope, i.scope]) e: for (const [t, n] of e.declarations) if ("normal" === n.kind && n.reassigned) {
					t: for (const { path: e } of n.references) if ("Fragment" === e[0].type) {
						for (let s = 1; s < e.length; s += 1) {
							const r = e[s].type;
							if ("FunctionDeclaration" === r || "FunctionExpression" === r || "ArrowFunctionExpression" === r) continue t;
							if ("BindDirective" === r && "this" === e[s].name) {
								for (let r = s - 1; r >= 0; r -= 1) {
									const s = e[r].type;
									if ("IfBlock" === s || "EachBlock" === s || "AwaitBlock" === s || "KeyBlock" === s) {
										ct(n.node, t);
										continue e;
									}
								}
								continue t;
							}
						}
						ct(n.node, t);
						continue e;
					}
				}
			} else {
				i.scope.declare(ui("$$props"), "rest_prop", "synthetic"), i.scope.declare(ui("$$restProps"), "rest_prop", "synthetic");
				for (const { ast: e, scope: n, scopes: r } of [
					a,
					i,
					p
				]) t(e, {
					scope: n,
					scopes: r,
					analysis: y,
					options: s,
					fragment: e === p.ast ? e : null,
					parent_element: null,
					has_props_rune: !1,
					ast_type: e === i.ast ? "instance" : e === p.ast ? "template" : "module",
					reactive_statement: null,
					component_slots: /* @__PURE__ */ new Set(),
					expression: null,
					state_fields: /* @__PURE__ */ new Map(),
					function_depth: n.function_depth,
					derived_function_depth: -1
				}, vw);
				for (const [e, t] of i.scope.declarations) if (("prop" === t.kind || "bindable_prop" === t.kind) && "$$props" !== t.node.name) t.references.filter(((e) => e.node !== t.node && "ExportSpecifier" !== e.path.at(-1)?.type)).length || i.scope.declarations.has(`$${e}`) || lt(t.node, e);
				y.reactive_statements = function(e) {
					const t = /* @__PURE__ */ new Map();
					for (const [n, s] of e) for (const e of s.assignments) {
						const r = t.get(e.node.name) ?? [];
						r.push([n, s]), t.set(e.node.name, r);
					}
					const n = [];
					for (const [, { assignments: t, dependencies: s }] of e) for (const e of t) for (const r of s) t.has(r) || n.push([e.node.name, r.node.name]);
					const s = kc(n);
					if (s?.length) (function(e, t) {
						zs(e, "reactive_declaration_cycle", `Cyclical dependency detected: ${t}\nhttps://svelte.dev/e/reactive_declaration_cycle`);
					})(t.get(s[0])[0][0], s.join(" → "));
					const r = /* @__PURE__ */ new Map(), a = (e, n) => {
						if (![...r.values()].includes(n)) {
							for (const e of n.dependencies) if (!n.assignments.has(e)) for (const [n, s] of t.get(e.node.name) ?? []) a(n, s);
							r.set(e, n);
						}
					};
					for (const [t, n] of e) a(t, n);
					return r;
				}(y.reactive_statements);
			}
			for (const e of y.module.ast.body) if ("ExportNamedDeclaration" === e.type && null !== e.specifiers && null == e.source) for (const t of e.specifiers) {
				if ("Identifier" !== t.local.type) continue;
				const e = t.local.name;
				y.module.scope.get(e) || ([...y.snippets].find(((t) => t.expression.name === e)) ? ur(t) : Ys(t, e));
			}
			y.event_directive_node && y.uses_event_attributes && function(e, t) {
				zs(e, "mixed_event_handler_syntaxes", `Mixing old (on:${t}) and new syntaxes for event handling is not allowed. Use only the on${t} syntax\nhttps://svelte.dev/e/mixed_event_handler_syntaxes`);
			}(y.event_directive_node, y.event_directive_node.name);
			for (const [e, t] of y.snippet_renderers) {
				t || (e.metadata.snippets = y.snippets);
				for (const t of e.metadata.snippets) t.metadata.sites.add(e);
			}
			if (y.uses_render_tags && (y.uses_slots || !y.custom_element && y.slot_names.size > 0)) (function(e) {
				zs(e, "slot_snippet_conflict", "Cannot use `<slot>` syntax and `{@render ...}` tags in the same component. Migrate towards `{@render ...}` tags completely\nhttps://svelte.dev/e/slot_snippet_conflict");
			})(y.slot_names.values().next().value ?? y.source.indexOf("$$slot"));
			if (y.css.ast) {
				(function(e, n) {
					t(e, {
						keyframes: n.css.keyframes,
						rule: null,
						analysis: n
					}, Lc);
				})(y.css.ast, y);
				for (const e of y.elements) Wc(y.css.ast, e);
				const { comment: e } = y.css.ast.content;
				e && _t(e.start, e.data, y.runes).includes("css_unused_selector") || t(v = y.css.ast, { stylesheet: v }, cp);
			}
			var v;
			for (const e of y.elements) {
				e.metadata.scoped && el(e) && up(e.metadata.path);
				let t = !1, n = !1, s = !1, r = !1, a = !1;
				for (const i of e.attributes) {
					if ("SpreadAttribute" === i.type) {
						s = !0;
						break;
					}
					"Attribute" === i.type ? (t ||= "class" === i.name.toLowerCase(), n ||= "style" === i.name.toLowerCase()) : "ClassDirective" === i.type ? r = !0 : "StyleDirective" === i.type && (a = !0);
				}
				s || t || !e.metadata.scoped && !r || e.attributes.push(tl("class", null, -1, -1, [{
					type: "Text",
					data: "",
					raw: "",
					start: -1,
					end: -1
				}])), s || n || !a || e.attributes.push(tl("style", null, -1, -1, [{
					type: "Text",
					data: "",
					raw: "",
					start: -1,
					end: -1
				}]));
			}
			return y;
		}
		const xw = ",".charCodeAt(0), ww = ";".charCodeAt(0), kw = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", Cw = new Uint8Array(64), Sw = new Uint8Array(128);
		for (let e = 0; e < 64; e++) {
			const t = kw.charCodeAt(e);
			Cw[e] = t, Sw[t] = e;
		}
		function Pw(e, t) {
			let n = 0, s = 0, r = 0;
			do
				r = Sw[e.next()], n |= (31 & r) << s, s += 5;
			while (32 & r);
			const a = 1 & n;
			return n >>>= 1, a && (n = -2147483648 | -n), t + n;
		}
		function Ew(e, t, n) {
			let s = t - n;
			s = s < 0 ? -s << 1 | 1 : s << 1;
			do {
				let t = 31 & s;
				s >>>= 5, s > 0 && (t |= 32), e.write(Cw[t]);
			} while (s > 0);
			return t;
		}
		function Tw(e, t) {
			return !(e.pos >= t) && e.peek() !== xw;
		}
		const Aw = "undefined" != typeof TextDecoder ? new TextDecoder() : "undefined" != typeof Buffer ? { decode: (e) => Buffer.from(e.buffer, e.byteOffset, e.byteLength).toString() } : { decode(e) {
			let t = "";
			for (let n = 0; n < e.length; n++) t += String.fromCharCode(e[n]);
			return t;
		} };
		class $w {
			constructor() {
				this.pos = 0, this.out = "", this.buffer = new Uint8Array(16384);
			}
			write(e) {
				const { buffer: t } = this;
				t[this.pos++] = e, 16384 === this.pos && (this.out += Aw.decode(t), this.pos = 0);
			}
			flush() {
				const { buffer: e, out: t, pos: n } = this;
				return n > 0 ? t + Aw.decode(e.subarray(0, n)) : t;
			}
		}
		class Rw {
			constructor(e) {
				this.pos = 0, this.buffer = e;
			}
			next() {
				return this.buffer.charCodeAt(this.pos++);
			}
			peek() {
				return this.buffer.charCodeAt(this.pos);
			}
			indexOf(e) {
				const { buffer: t, pos: n } = this, s = t.indexOf(e, n);
				return -1 === s ? t.length : s;
			}
		}
		function Iw(e) {
			const { length: t } = e, n = new Rw(e), s = [];
			let r = 0, a = 0, i = 0, o = 0, l = 0;
			do {
				const e = n.indexOf(";"), t = [];
				let c = !0, p = 0;
				for (r = 0; n.pos < e;) {
					let s;
					r = Pw(n, r), r < p && (c = !1), p = r, Tw(n, e) ? (a = Pw(n, a), i = Pw(n, i), o = Pw(n, o), Tw(n, e) ? (l = Pw(n, l), s = [
						r,
						a,
						i,
						o,
						l
					]) : s = [
						r,
						a,
						i,
						o
					]) : s = [r], t.push(s), n.pos++;
				}
				c || Mw(t), s.push(t), n.pos = e + 1;
			} while (n.pos <= t);
			return s;
		}
		function Mw(e) {
			e.sort(qw);
		}
		function qw(e, t) {
			return e[0] - t[0];
		}
		function Lw(e) {
			const t = new $w();
			let n = 0, s = 0, r = 0, a = 0;
			for (let i = 0; i < e.length; i++) {
				const o = e[i];
				if (i > 0 && t.write(ww), 0 === o.length) continue;
				let l = 0;
				for (let e = 0; e < o.length; e++) {
					const i = o[e];
					e > 0 && t.write(xw), l = Ew(t, i[0], l), 1 !== i.length && (n = Ew(t, i[1], n), s = Ew(t, i[2], s), r = Ew(t, i[3], r), 4 !== i.length && (a = Ew(t, i[4], a)));
				}
			}
			return t.flush();
		}
		const Ow = 0, Nw = 1, Dw = 2, jw = 3, Bw = 4;
		class Fw {
			#r;
			#a;
			#i = !1;
			multiline = !1;
			constructor(e, t = []) {
				this.#r = e, this.#a = t;
			}
			indent() {
				this.#a.push(Dw);
			}
			dedent() {
				this.#a.push(jw);
			}
			margin() {
				this.#a.push(Ow);
			}
			newline() {
				this.#i = !0, this.#a.push(Nw);
			}
			space() {
				this.#a.push(Bw);
			}
			append(e) {
				this.#a.push(e.#a), (this.#i || e.multiline) && (this.multiline = !0);
			}
			write(e, t) {
				t?.loc ? (this.location(t.loc.start.line, t.loc.start.column), this.#a.push(e), this.location(t.loc.end.line, t.loc.end.column)) : this.#a.push(e), this.#i && (this.multiline = !0);
			}
			location(e, t) {
				this.#a.push({
					type: "Location",
					line: e,
					column: t
				});
			}
			visit(e) {
				const t = this.#r[e.type];
				if (!t) {
					let t = `Not implemented: ${e.type}`;
					throw e.type.includes("TS") && (t += " (consider using 'esrap/languages/ts')"), e.type.includes("JSX") && (t += " (consider using 'esrap/languages/tsx')"), new Error(t);
				}
				this.#r._ ? this.#r._(e, this, ((e) => t(e, this))) : t(e, this);
			}
			empty() {
				return !this.#a.some(Hw);
			}
			measure() {
				return Vw(this.#a);
			}
			new() {
				return new Fw(this.#r);
			}
		}
		function Vw(e, t = 0, n = e.length) {
			let s = 0;
			for (let r = t; r < n; r += 1) {
				const t = e[r];
				"string" == typeof t ? s += t.length : Array.isArray(t) && (s += Vw(t));
			}
			return s;
		}
		function Hw(e) {
			return Array.isArray(e) ? e.some(Hw) : "string" == typeof e && e.length > 0;
		}
		let Uw = () => {
			throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be supported.");
		};
		"undefined" != typeof window && "function" == typeof window.btoa ? Uw = (e) => window.btoa(unescape(encodeURIComponent(e))) : "function" == typeof Buffer && (Uw = (e) => Buffer.from(e, "utf-8").toString("base64"));
		let zw = class {
			version = 3;
			names = [];
			constructor(e, t) {
				this.sources = [t.sourceMapSource || null], this.sourcesContent = [t.sourceMapContent || null], this.mappings = !1 === t.sourceMapEncodeMappings ? e : Lw(e);
			}
			toString() {
				return JSON.stringify(this);
			}
			toUrl() {
				return "data:application/json;charset=utf-8;base64," + Uw(this.toString());
			}
		};
		function Ww(e, t, n = {}) {
			const s = [];
			new Fw(t, s).visit(e);
			let r = "", a = 0, i = [], o = [];
			function l(e) {
				r += e;
				for (let t = 0; t < e.length; t += 1) "\n" === e[t] ? (i.push(o), o = [], a = 0) : a += 1;
			}
			let c = "\n";
			const p = n.indent ?? "	";
			let u, d = !1, h = !1, m = !1;
			function f(e) {
				if (Array.isArray(e)) for (let t = 0; t < e.length; t += 1) f(e[t]);
				else "number" != typeof e ? (d ? l(h ? "\n" + c : c) : m && l(" "), h = d = m = !1, "string" != typeof e ? "Location" === e.type && o.push([
					a,
					0,
					e.line - 1,
					e.column
				]) : l(e)) : e === Nw ? d = !0 : e === Ow ? h = !0 : e === Bw ? m = !0 : e === Dw ? c += p : e === jw && (c = c.slice(0, -p.length));
			}
			for (let e = 0; e < s.length; e += 1) f(s[e]);
			return i.push(o), {
				code: r,
				get map() {
					return u ??= new zw(i, n);
				}
			};
		}
		const Gw = {
			JSXFragment: 20,
			JSXElement: 20,
			ArrayPattern: 20,
			ObjectPattern: 20,
			ArrayExpression: 20,
			TaggedTemplateExpression: 20,
			ThisExpression: 20,
			Identifier: 20,
			TemplateLiteral: 20,
			Super: 20,
			SequenceExpression: 20,
			MemberExpression: 19,
			MetaProperty: 19,
			CallExpression: 19,
			ChainExpression: 19,
			ImportExpression: 19,
			NewExpression: 19,
			Literal: 18,
			TSSatisfiesExpression: 18,
			TSInstantiationExpression: 18,
			TSNonNullExpression: 18,
			TSTypeAssertion: 18,
			AwaitExpression: 17,
			ClassExpression: 17,
			FunctionExpression: 17,
			ObjectExpression: 17,
			TSAsExpression: 16,
			UpdateExpression: 16,
			UnaryExpression: 15,
			BinaryExpression: 14,
			LogicalExpression: 13,
			ConditionalExpression: 4,
			ArrowFunctionExpression: 3,
			AssignmentExpression: 3,
			YieldExpression: 2,
			RestElement: 1
		}, Kw = {
			"||": 2,
			"&&": 3,
			"??": 4,
			"|": 5,
			"^": 6,
			"&": 7,
			"==": 8,
			"!=": 8,
			"===": 8,
			"!==": 8,
			"<": 9,
			">": 9,
			"<=": 9,
			">=": 9,
			in: 9,
			instanceof: 9,
			"<<": 10,
			">>": 10,
			">>>": 10,
			"+": 11,
			"-": 11,
			"*": 12,
			"%": 12,
			"/": 12,
			"**": 13
		};
		function Xw(e, t) {
			if ("Line" === e.type) t.write(`//${e.value}`);
			else {
				t.write("/*");
				const n = e.value.split("\n");
				for (let e = 0; e < n.length; e += 1) e > 0 && t.newline(), t.write(n[e]);
				t.write("*/"), n.length > 1 && t.newline();
			}
		}
		var Qw = (e = {}) => {
			const t = "double" === e.quotes ? "\"" : "'", n = e.comments ?? [];
			let s = 0;
			function r(e, t, n) {
				if (t) for (let s = 0; s < t.length; s += 1) {
					const r = t[s];
					"trailing" === n && 0 === s && e.write(" "), Xw(r, e), "leading" === n && ("Line" === r.type ? e.newline() : "Block" !== r.type || r.value.includes("\n") || e.write(" "));
				}
			}
			function a(e, t, r) {
				for (; s < n.length;) {
					const a = n[s];
					if (a && t && a.loc.start.line === t.line && (null === r || Zw(a.loc.end, r))) {
						if (e.write(" "), Xw(a, e), s += 1, "Line" !== a.type) continue;
						e.newline();
					}
					break;
				}
			}
			function i(e, t, r, a) {
				let i = !0;
				for (; s < n.length;) {
					const o = n[s];
					if (!(o && o.loc && r && Zw(o.loc.start, r))) break;
					i && null !== t && o.loc.start.line > t.line && (e.margin(), e.newline()), i = !1, Xw(o, e), o.loc.end.line < r.line ? e.newline() : a && e.write(" "), s += 1;
				}
			}
			function o(e) {
				if (!e || "Property" !== e.type) return !1;
				const t = "AssignmentPattern" === e.value?.type ? e.value.left : e.value;
				return "ObjectExpression" === t?.type || "ArrayExpression" === t?.type;
			}
			function l(e, t, n, s, r = ",") {
				let l = !1, c = -1;
				const p = [], u = t.map(((s, i) => {
					const o = e.new();
					s && o.visit(s), p[i] = o.multiline, (i < t.length - 1 || !s) && o.write(r);
					const u = i === t.length - 1 ? n : t[i + 1]?.loc?.start || null;
					return a(o, s?.loc?.end || null, u), c += o.measure() + 1, l ||= o.multiline, o;
				}));
				l ||= c > 60, l ? (e.indent(), e.newline()) : s && c > 0 && e.write(" ");
				let d = null;
				for (let n = 0; n < t.length; n += 1) {
					const s = u[n];
					null !== d && (p[n - 1] && p[n] && (o(t[n - 1]) && o(t[n]) || e.margin()), t[n] && (l ? e.newline() : e.write(" "))), e.append(s), d = s;
				}
				i(e, t[t.length - 1]?.loc?.end ?? null, n, !1), l ? (e.dedent(), e.newline()) : s && c > 0 && e.write(" ");
			}
			function c(e, t) {
				(function(e) {
					if (!e.loc) return void (s = n.length);
					let t = n[s - 1], r = n[s];
					r && r.loc && !Zw(r.loc.start, e.loc.start) && (!t || t.loc && Zw(t.loc.start, e.loc.start)) || (s = n.findIndex(((t) => t.loc && e.loc && !Zw(t.loc.start, e.loc.start))), -1 === s && (s = n.length));
				})(t);
				let r = null, o = !1;
				for (let n = 0; n < t.body.length; n += 1) {
					const s = t.body[n];
					if ("EmptyStatement" === s.type) continue;
					const i = e.new();
					i.visit(s), null !== r && ((i.multiline || o || s.type !== r) && e.margin(), e.newline()), e.append(i), a(e, s.loc?.end || null, t.body[n + 1]?.loc?.end ?? t.loc?.end ?? null), r = s.type, o = i.multiline;
				}
				t.loc && (e.newline(), i(e, t.body[t.body.length - 1]?.loc?.end ?? null, t.loc.end, !1));
			}
			const p = {
				"ArrayExpression|ArrayPattern": (e, t) => {
					t.write("["), l(t, e.elements, e.loc?.end ?? null, !1), t.write("]");
				},
				"BinaryExpression|LogicalExpression": (e, t) => {
					Yw(e.left, e, !1) ? (t.write("("), t.visit(e.left), t.write(")")) : t.visit(e.left), t.write(` ${e.operator} `), Yw(e.right, e, !0) ? (t.write("("), t.visit(e.right), t.write(")")) : t.visit(e.right);
				},
				"BlockStatement|ClassBody": (e, t) => {
					if (e.loc) {
						const { line: n, column: s } = e.loc.start;
						t.location(n, s), t.write("{"), t.location(n, s + 1);
					} else t.write("{");
					const n = t.new();
					if (c(n, e), n.empty() || (t.indent(), t.newline(), t.append(n), t.dedent(), t.newline()), e.loc) {
						const { line: n, column: s } = e.loc.end;
						t.location(n, s - 1), t.write("}"), t.location(n, s);
					} else t.write("}");
				},
				"CallExpression|NewExpression": (e, t) => {
					"NewExpression" === e.type && t.write("new ");
					Gw[e.callee.type] < Gw.CallExpression || "NewExpression" === e.type && function(e) {
						for (; e;) {
							if ("CallExpression" === e.type) return !0;
							if ("MemberExpression" !== e.type) return !1;
							e = e.object;
						}
					}(e.callee) ? (t.write("("), t.visit(e.callee), t.write(")")) : t.visit(e.callee), e.optional && t.write("?."), e.typeArguments && t.visit(e.typeArguments);
					const i = t.new(), o = t.new();
					t.write("("), t.append(i);
					const l = t.new(), c = t.new();
					t.append(l), t.append(c);
					for (let t = 0; t < e.arguments.length; t += 1) {
						const r = t === e.arguments.length - 1, i = r ? c : l, p = e.arguments[t];
						r && p.loc && n[s] && n[s].loc && n[s].loc.start.line < p.loc.start.line && (l.multiline = !0), i.visit(p), r || i.write(",");
						const u = r ? e.loc?.end ?? null : e.arguments[t + 1]?.loc?.start ?? null;
						a(i, p.loc?.end ?? null, u), r || i.append(o);
					}
					t.multiline ||= l.multiline || c.multiline, l.multiline ? (i.indent(), i.newline(), o.newline(), t.dedent(), t.newline()) : o.write(" "), t.write(")");
				},
				"ClassDeclaration|ClassExpression": (e, t) => {
					if (e.decorators) for (const n of e.decorators) t.visit(n);
					e.declare && t.write("declare "), e.abstract && t.write("abstract "), t.write("class "), e.id && (t.visit(e.id), t.write(" ")), e.superClass && (t.write("extends "), t.visit(e.superClass), t.write(" ")), e.implements && e.implements.length > 0 && (t.write("implements"), l(t, e.implements, e.body.loc?.start ?? null, !0)), t.visit(e.body);
				},
				"ForInStatement|ForOfStatement": (e, t) => {
					t.write("for "), "ForOfStatement" === e.type && e.await && t.write("await "), t.write("("), "VariableDeclaration" === e.left.type ? Jw(e.left, t) : t.visit(e.left), t.write("ForInStatement" === e.type ? " in " : " of "), t.visit(e.right), t.write(") "), t.visit(e.body);
				},
				"FunctionDeclaration|FunctionExpression": (e, t) => {
					e.async && t.write("async "), t.write(e.generator ? "function* " : "function "), e.id && t.visit(e.id), e.typeParameters && t.visit(e.typeParameters), t.write("("), l(t, e.params, (e.returnType ?? e.body).loc?.start ?? null, !1), t.write(")"), e.returnType && t.visit(e.returnType), t.write(" "), t.visit(e.body);
				},
				"MethodDefinition|TSAbstractMethodDefinition": (e, t) => {
					if (e.decorators) for (const n of e.decorators) t.visit(n);
					(e.abstract || "TSAbstractMethodDefinition" === e.type) && t.write("abstract "), e.static && t.write("static "), "get" !== e.kind && "set" !== e.kind || t.write(e.kind + " "), e.value.async && t.write("async "), e.value.generator && t.write("*"), e.computed && t.write("["), t.visit(e.key), e.computed && t.write("]"), t.write("("), l(t, e.value.params, (e.value.returnType ?? e.value.body)?.loc?.start ?? e.loc?.end ?? null, !1), t.write(")"), e.value.returnType && t.visit(e.value.returnType), t.write(" "), e.value.body && t.visit(e.value.body);
				},
				"PropertyDefinition|TSAbstractPropertyDefinition|AccessorProperty|TSAbstractAccessorProperty": (e, t) => {
					if (e.decorators) for (const n of e.decorators) t.visit(n);
					e.accessibility && t.write(e.accessibility + " "), (e.abstract || "TSAbstractPropertyDefinition" === e.type || "TSAbstractAccessorProperty" === e.type) && t.write("abstract "), e.static && t.write("static "), (e.accessor || "AccessorProperty" === e.type || "TSAbstractAccessorProperty" === e.type) && t.write("accessor "), e.computed ? (t.write("["), t.visit(e.key), t.write("]")) : t.visit(e.key), e.typeAnnotation && ("AccessorProperty" === e.type || "TSAbstractAccessorProperty" === e.type ? t.visit(e.typeAnnotation) : (t.write(": "), t.visit(e.typeAnnotation.typeAnnotation))), e.value && (t.write(" = "), t.visit(e.value)), t.write(";"), a(t, (e.value ?? e.typeAnnotation ?? e.key).loc?.end ?? null, null);
				},
				"RestElement|SpreadElement": (e, t) => {
					t.write("..."), t.visit(e.argument), e.typeAnnotation && t.visit(e.typeAnnotation);
				},
				"TSConstructSignatureDeclaration|TSCallSignatureDeclaration": (e, t) => {
					"TSConstructSignatureDeclaration" === e.type && t.write("new"), e.typeParameters && t.visit(e.typeParameters), t.write("("), l(t, e.parameters ?? e.params, (e.typeAnnotation ?? e.returnType)?.loc?.start ?? null, !1), t.write(")"), (e.typeAnnotation || e.returnType) && t.visit(e.typeAnnotation ?? e.returnType);
				},
				"TSFunctionType|TSConstructorType": (e, t) => {
					"TSConstructorType" === e.type && t.write("new "), e.typeParameters && t.visit(e.typeParameters), t.write("("), l(t, e.parameters ?? e.params, e.typeAnnotation?.typeAnnotation?.loc?.start ?? e.returnType?.typeAnnotation?.loc?.start ?? null, !1), t.write(") => "), t.visit(e.typeAnnotation?.typeAnnotation ?? e.returnType?.typeAnnotation);
				}
			};
			return {
				_(t, n, s) {
					r(n, e.getLeadingComments?.(t), "leading"), t.loc && i(n, null, t.loc.start, !0), s(t), r(n, e.getTrailingComments?.(t), "trailing");
				},
				AccessorProperty: p["PropertyDefinition|TSAbstractPropertyDefinition|AccessorProperty|TSAbstractAccessorProperty"],
				ArrayExpression: p["ArrayExpression|ArrayPattern"],
				ArrayPattern: p["ArrayExpression|ArrayPattern"],
				ArrowFunctionExpression: (e, t) => {
					e.async && t.write("async "), t.write("("), l(t, e.params, e.body.loc?.start ?? null, !1), t.write(") => "), "ObjectExpression" === e.body.type || "AssignmentExpression" === e.body.type && "ObjectPattern" === e.body.left.type || "LogicalExpression" === e.body.type && "ObjectExpression" === e.body.left.type || "ConditionalExpression" === e.body.type && "ObjectExpression" === e.body.test.type ? (t.write("("), t.visit(e.body), t.write(")")) : t.visit(e.body);
				},
				AssignmentExpression(e, t) {
					t.visit(e.left), t.write(` ${e.operator} `), t.visit(e.right);
				},
				AssignmentPattern(e, t) {
					t.visit(e.left), t.write(" = "), t.visit(e.right);
				},
				AwaitExpression(e, t) {
					if (e.argument) {
						const n = Gw[e.argument.type];
						n && n < Gw.AwaitExpression ? (t.write("await ("), t.visit(e.argument), t.write(")")) : (t.write("await "), t.visit(e.argument));
					} else t.write("await");
				},
				BinaryExpression: p["BinaryExpression|LogicalExpression"],
				BlockStatement: p["BlockStatement|ClassBody"],
				BreakStatement(e, t) {
					e.label ? (t.write("break "), t.visit(e.label), t.write(";")) : t.write("break;");
				},
				CallExpression: p["CallExpression|NewExpression"],
				ChainExpression(e, t) {
					t.visit(e.expression);
				},
				ClassBody: p["BlockStatement|ClassBody"],
				ClassDeclaration: p["ClassDeclaration|ClassExpression"],
				ClassExpression: p["ClassDeclaration|ClassExpression"],
				ConditionalExpression(e, t) {
					Gw[e.test.type] > Gw.ConditionalExpression ? t.visit(e.test) : (t.write("("), t.visit(e.test), t.write(")"));
					const n = t.new(), s = t.new();
					n.visit(e.consequent), s.visit(e.alternate), n.multiline || s.multiline || n.measure() + s.measure() > 50 ? (t.indent(), t.newline(), t.write("? "), t.append(n), t.newline(), t.write(": "), t.append(s), t.dedent()) : (t.write(" ? "), t.append(n), t.write(" : "), t.append(s));
				},
				ContinueStatement(e, t) {
					e.label ? (t.write("continue "), t.visit(e.label), t.write(";")) : t.write("continue;");
				},
				DebuggerStatement(e, t) {
					t.write("debugger", e), t.write(";");
				},
				Decorator(e, t) {
					t.write("@"), t.visit(e.expression), t.newline();
				},
				DoWhileStatement(e, t) {
					t.write("do "), t.visit(e.body), t.write(" while ("), t.visit(e.test), t.write(");");
				},
				EmptyStatement(e, t) {
					t.write(";");
				},
				ExportAllDeclaration(e, t) {
					t.write("type" === e.exportKind ? "export type * " : "export * "), e.exported && (t.write("as "), t.visit(e.exported)), t.write(" from "), t.visit(e.source), t.write(";");
				},
				ExportDefaultDeclaration(e, t) {
					t.write("export default "), t.visit(e.declaration), "FunctionDeclaration" !== e.declaration.type && t.write(";");
				},
				ExportNamedDeclaration(e, t) {
					if (e.declaration) {
						const n = e.declaration;
						if (n.decorators && n.decorators.length > 0) {
							for (const e of n.decorators) t.visit(e);
							t.write("export ");
							const s = n.decorators;
							n.decorators = [], t.visit(e.declaration), n.decorators = s;
						} else t.write("export "), t.visit(e.declaration);
					} else t.write("export "), "type" === e.exportKind && t.write("type "), t.write("{"), l(t, e.specifiers, e.source?.loc?.start ?? e.loc?.end ?? null, !0), t.write("}"), e.source && (t.write(" from "), t.visit(e.source)), t.write(";");
				},
				ExportSpecifier(e, t) {
					"type" === e.exportKind && t.write("type "), t.visit(e.local), "Identifier" === e.local.type && "Identifier" === e.exported.type && e.local.name !== e.exported.name && (t.write(" as "), t.visit(e.exported));
				},
				ExpressionStatement(e, t) {
					if ("ObjectExpression" === e.expression.type || "AssignmentExpression" === e.expression.type && "ObjectPattern" === e.expression.left.type || "FunctionExpression" === e.expression.type) return t.write("("), t.visit(e.expression), void t.write(");");
					t.visit(e.expression), t.write(";");
				},
				ForStatement: (e, t) => {
					t.write("for ("), e.init && ("VariableDeclaration" === e.init.type ? Jw(e.init, t) : t.visit(e.init)), t.write("; "), e.test && t.visit(e.test), t.write("; "), e.update && t.visit(e.update), t.write(") "), t.visit(e.body);
				},
				ForInStatement: p["ForInStatement|ForOfStatement"],
				ForOfStatement: p["ForInStatement|ForOfStatement"],
				FunctionDeclaration: p["FunctionDeclaration|FunctionExpression"],
				FunctionExpression: p["FunctionDeclaration|FunctionExpression"],
				Identifier(e, t) {
					let n = e.name;
					t.write(n, e), e.typeAnnotation && t.visit(e.typeAnnotation);
				},
				IfStatement(e, t) {
					t.write("if ("), t.visit(e.test), t.write(") "), t.visit(e.consequent), e.alternate && (t.space(), t.write("else "), t.visit(e.alternate));
				},
				ImportDeclaration(e, t) {
					if (0 === e.specifiers.length) return t.write("import "), t.visit(e.source), void t.write(";");
					let n = null, s = null;
					const r = [];
					for (const t of e.specifiers) "ImportNamespaceSpecifier" === t.type ? n = t : "ImportDefaultSpecifier" === t.type ? s = t : r.push(t);
					if (t.write("import "), "type" == e.importKind && t.write("type "), s && (t.write(s.local.name, s), (n || r.length > 0) && t.write(", ")), n && t.write("* as " + n.local.name, n), r.length > 0 && (t.write("{"), l(t, r, e.source.loc?.start ?? null, !0), t.write("}")), t.write(" from "), t.visit(e.source), e.attributes && e.attributes.length > 0) {
						t.write(" with { ");
						for (let n = 0; n < e.attributes.length; n++) {
							const { key: s, value: r } = e.attributes[n];
							t.visit(s), t.write(": "), t.visit(r), n + 1 !== e.attributes.length && t.write(", ");
						}
						t.write(" }");
					}
					t.write(";");
				},
				ImportExpression(e, t) {
					if (t.write("import("), t.visit(e.source), e.arguments) for (let n = 0; n < e.arguments.length; n++) t.write(", "), t.visit(e.arguments[n]);
					e.options && (t.write(", "), t.visit(e.options)), t.write(")");
				},
				ImportSpecifier(e, t) {
					"Identifier" === e.local.type && "Identifier" === e.imported.type && e.local.name !== e.imported.name && (t.visit(e.imported), t.write(" as ")), "type" == e.importKind && t.write("type "), t.visit(e.local);
				},
				LabeledStatement(e, t) {
					t.visit(e.label), t.write(": "), t.visit(e.body);
				},
				Literal(e, n) {
					const s = e.raw || ("string" == typeof e.value ? function(e, t) {
						let n = t;
						for (const s of e) n += "\\" === s ? "\\\\" : s === t ? "\\" + s : "\n" === s ? "\\n" : "\r" === s ? "\\r" : s;
						return n + t;
					}(e.value, t) : String(e.value));
					n.write(s, e);
				},
				LogicalExpression: p["BinaryExpression|LogicalExpression"],
				MemberExpression(e, t) {
					Gw[e.object.type] < Gw.MemberExpression ? (t.write("("), t.visit(e.object), t.write(")")) : t.visit(e.object), e.computed ? (e.optional && t.write("?."), t.write("["), t.visit(e.property), t.write("]")) : (t.write(e.optional ? "?." : "."), t.visit(e.property));
				},
				MetaProperty(e, t) {
					t.visit(e.meta), t.write("."), t.visit(e.property);
				},
				MethodDefinition: p["MethodDefinition|TSAbstractMethodDefinition"],
				NewExpression: p["CallExpression|NewExpression"],
				ObjectExpression(e, t) {
					t.write("{"), l(t, e.properties, e.loc?.end ?? null, !0), t.write("}");
				},
				ObjectPattern(e, t) {
					t.write("{"), l(t, e.properties, e.loc?.end ?? null, !0), t.write("}"), e.typeAnnotation && t.visit(e.typeAnnotation);
				},
				ParenthesizedExpression(e, t) {
					t.write("("), t.visit(e.expression), t.write(")");
				},
				PrivateIdentifier(e, t) {
					t.write("#"), t.write(e.name, e);
				},
				Program(e, t) {
					c(t, e);
				},
				Property(e, t) {
					const n = "AssignmentPattern" === e.value.type ? e.value.left : e.value;
					e.computed || "init" !== e.kind || "Identifier" !== e.key.type || "Identifier" !== n.type || e.key.name !== n.name ? "FunctionExpression" === e.value.type ? ("init" !== e.kind && t.write(e.kind + " "), e.value.async && t.write("async "), e.value.generator && t.write("*"), e.computed && t.write("["), t.visit(e.key), e.computed && t.write("]"), t.write("("), l(t, e.value.params, (e.value.returnType ?? e.value.body).loc?.start ?? null, !1), t.write(")"), e.value.returnType && t.visit(e.value.returnType), t.write(" "), t.visit(e.value.body)) : (e.computed && t.write("["), "get" !== e.kind && "set" !== e.kind || t.write(e.kind + " "), t.visit(e.key), t.write(e.computed ? "]: " : ": "), t.visit(e.value)) : t.visit(e.value);
				},
				PropertyDefinition: p["PropertyDefinition|TSAbstractPropertyDefinition|AccessorProperty|TSAbstractAccessorProperty"],
				RestElement: p["RestElement|SpreadElement"],
				ReturnStatement(e, t) {
					if (e.argument) {
						const r = n[s] && n[s].loc && e.argument.loc && Zw(n[s].loc.start, e.argument.loc.start);
						t.write(r ? "return (" : "return "), t.visit(e.argument), t.write(r ? ");" : ";");
					} else t.write("return;");
				},
				SequenceExpression(e, t) {
					t.write("("), l(t, e.expressions, e.loc?.end ?? null, !1), t.write(")");
				},
				SpreadElement: p["RestElement|SpreadElement"],
				StaticBlock(e, t) {
					t.write("static {"), t.indent(), t.newline(), c(t, e), t.dedent(), t.newline(), t.write("}");
				},
				Super(e, t) {
					t.write("super", e);
				},
				SwitchStatement(e, t) {
					t.write("switch ("), t.visit(e.discriminant), t.write(") {"), t.indent();
					let n = !0;
					for (const s of e.cases) {
						n || t.margin(), n = !1, s.test ? (t.newline(), t.write("case "), t.visit(s.test), t.write(":")) : (t.newline(), t.write("default:")), t.indent();
						for (const e of s.consequent) t.newline(), t.visit(e);
						t.dedent();
					}
					t.dedent(), t.newline(), t.write("}");
				},
				TaggedTemplateExpression(e, t) {
					t.visit(e.tag), t.visit(e.quasi);
				},
				TemplateLiteral(e, t) {
					t.write("`");
					const { quasis: n, expressions: s } = e;
					for (let e = 0; e < s.length; e++) {
						const r = n[e].value.raw;
						t.write(r + "${"), t.visit(s[e]), t.write("}"), /\n/.test(r) && (t.multiline = !0);
					}
					const r = n[n.length - 1].value.raw;
					t.write(r + "`"), /\n/.test(r) && (t.multiline = !0);
				},
				ThisExpression(e, t) {
					t.write("this", e);
				},
				ThrowStatement(e, t) {
					t.write("throw "), e.argument && t.visit(e.argument), t.write(";");
				},
				TryStatement(e, t) {
					t.write("try "), t.visit(e.block), e.handler && (e.handler.param ? (t.write(" catch("), t.visit(e.handler.param), t.write(") ")) : t.write(" catch "), t.visit(e.handler.body)), e.finalizer && (t.write(" finally "), t.visit(e.finalizer));
				},
				UnaryExpression(e, t) {
					t.write(e.operator), e.operator.length > 1 && t.write(" "), Gw[e.argument.type] < Gw.UnaryExpression ? (t.write("("), t.visit(e.argument), t.write(")")) : t.visit(e.argument);
				},
				UpdateExpression(e, t) {
					e.prefix ? (t.write(e.operator), t.visit(e.argument)) : (t.visit(e.argument), t.write(e.operator));
				},
				VariableDeclaration(e, t) {
					Jw(e, t), t.write(";");
				},
				VariableDeclarator(e, t) {
					t.visit(e.id), e.init && (t.write(" = "), t.visit(e.init));
				},
				WhileStatement(e, t) {
					t.write("while ("), t.visit(e.test), t.write(") "), t.visit(e.body);
				},
				WithStatement(e, t) {
					t.write("with ("), t.visit(e.object), t.write(") "), t.visit(e.body);
				},
				YieldExpression(e, t) {
					e.argument ? (t.write(e.delegate ? "yield* " : "yield "), t.visit(e.argument)) : t.write(e.delegate ? "yield*" : "yield");
				},
				TSAbstractMethodDefinition: p["MethodDefinition|TSAbstractMethodDefinition"],
				TSAbstractAccessorProperty: p["PropertyDefinition|TSAbstractPropertyDefinition|AccessorProperty|TSAbstractAccessorProperty"],
				TSAbstractPropertyDefinition: p["PropertyDefinition|TSAbstractPropertyDefinition|AccessorProperty|TSAbstractAccessorProperty"],
				TSDeclareFunction(e, t) {
					t.write("declare "), e.async && t.write("async "), t.write("function"), e.generator && t.write("*"), e.id && (t.write(" "), t.visit(e.id)), e.typeParameters && t.visit(e.typeParameters), t.write("("), l(t, e.params, e.returnType?.loc?.start ?? e.loc?.end ?? null, !1), t.write(")"), e.returnType && t.visit(e.returnType), t.write(";");
				},
				TSNumberKeyword(e, t) {
					t.write("number", e);
				},
				TSStringKeyword(e, t) {
					t.write("string", e);
				},
				TSBooleanKeyword(e, t) {
					t.write("boolean", e);
				},
				TSAnyKeyword(e, t) {
					t.write("any", e);
				},
				TSVoidKeyword(e, t) {
					t.write("void", e);
				},
				TSUnknownKeyword(e, t) {
					t.write("unknown", e);
				},
				TSNeverKeyword(e, t) {
					t.write("never", e);
				},
				TSSymbolKeyword(e, t) {
					t.write("symbol", e);
				},
				TSNullKeyword(e, t) {
					t.write("null", e);
				},
				TSUndefinedKeyword(e, t) {
					t.write("undefined", e);
				},
				TSObjectKeyword(e, t) {
					t.write("object", e);
				},
				TSBigIntKeyword(e, t) {
					t.write("bigint", e);
				},
				TSIntrinsicKeyword(e, t) {
					t.write("intrinsic", e);
				},
				TSArrayType(e, t) {
					t.visit(e.elementType), t.write("[]");
				},
				TSTypeAnnotation(e, t) {
					t.write(": "), t.visit(e.typeAnnotation);
				},
				TSTypeLiteral(e, t) {
					t.write("{ "), l(t, e.members, e.loc?.end ?? null, !1, ";"), t.write(" }");
				},
				TSPropertySignature(e, t) {
					t.visit(e.key), e.optional && t.write("?"), e.typeAnnotation && t.visit(e.typeAnnotation);
				},
				TSTypeReference(e, t) {
					t.visit(e.typeName), e.typeArguments && t.visit(e.typeArguments);
				},
				TSTypeOperator(e, t) {
					t.write(e.operator + " "), e.typeAnnotation && t.visit(e.typeAnnotation);
				},
				TSTemplateLiteralType(e, t) {
					t.write("`");
					const { quasis: n, types: s } = e;
					for (let e = 0; e < s.length; e++) {
						const r = n[e].value.raw;
						t.write(r + "${"), t.visit(s[e]), t.write("}"), /\n/.test(r) && (t.multiline = !0);
					}
					t.write("`");
				},
				TSParameterProperty(e, t) {
					e.accessibility && t.write(e.accessibility + " "), e.readonly && t.write("readonly "), t.visit(e.parameter);
				},
				TSExportAssignment(e, t) {
					t.write("export = "), t.visit(e.expression), t.write(";");
				},
				TSNamespaceExportDeclaration(e, t) {
					t.write("export as namespace "), t.visit(e.id), t.write(";");
				},
				TSExpressionWithTypeArguments(e, t) {
					t.visit(e.expression);
				},
				TSTypeAssertion(e, t) {
					t.write("<"), t.visit(e.typeAnnotation), t.write(">"), Gw[e.expression.type] < Gw.TSTypeAssertion ? (t.write("("), t.visit(e.expression), t.write(")")) : t.visit(e.expression);
				},
				TSTypeParameterInstantiation(e, t) {
					t.write("<");
					for (let n = 0; n < e.params.length; n++) t.visit(e.params[n]), n != e.params.length - 1 && t.write(", ");
					t.write(">");
				},
				TSTypeParameterDeclaration(e, t) {
					t.write("<");
					for (let n = 0; n < e.params.length; n++) t.visit(e.params[n]), n != e.params.length - 1 && t.write(", ");
					t.write(">");
				},
				TSTypeParameter(e, t) {
					e.name && e.name.type ? t.visit(e.name) : t.write(e.name, e), e.constraint && (t.write(" extends "), t.visit(e.constraint));
				},
				TSTypePredicate(e, t) {
					e.parameterName ? t.visit(e.parameterName) : e.typeAnnotation && t.visit(e.typeAnnotation), e.asserts ? t.write(" asserts ") : t.write(" is "), e.typeAnnotation && t.visit(e.typeAnnotation.typeAnnotation);
				},
				TSTypeQuery(e, t) {
					t.write("typeof "), t.visit(e.exprName);
				},
				TSClassImplements(e, t) {
					e.expression && t.visit(e.expression);
				},
				TSEnumMember(e, t) {
					t.visit(e.id), e.initializer && (t.write(" = "), t.visit(e.initializer));
				},
				TSFunctionType: p["TSFunctionType|TSConstructorType"],
				TSIndexSignature(e, t) {
					t.write("["), l(t, e.parameters, e.typeAnnotation?.loc?.start ?? null, !1), t.write("]"), t.visit(e.typeAnnotation);
				},
				TSMappedType(e, t) {
					t.write("{["), e.typeParameter ? t.visit(e.typeParameter) : (t.visit(e.key), t.write(" in "), t.visit(e.constraint)), t.write("]"), e.typeAnnotation && (t.write(": "), t.visit(e.typeAnnotation)), t.write("}");
				},
				TSMethodSignature(e, t) {
					t.visit(e.key), t.write("("), l(t, e.parameters ?? e.params, (e.typeAnnotation ?? e.returnType)?.loc?.start ?? null, !1), t.write(")"), (e.typeAnnotation || e.returnType) && t.visit(e.typeAnnotation ?? e.returnType);
				},
				TSTupleType(e, t) {
					t.write("["), l(t, e.elementTypes, e.loc?.end ?? null, !1), t.write("]");
				},
				TSNamedTupleMember(e, t) {
					t.visit(e.label), t.write(": "), t.visit(e.elementType);
				},
				TSUnionType(e, t) {
					l(t, e.types, e.loc?.end ?? null, !1, " |");
				},
				TSIntersectionType(e, t) {
					l(t, e.types, e.loc?.end ?? null, !1, " &");
				},
				TSInferType(e, t) {
					t.write("infer "), t.visit(e.typeParameter);
				},
				TSLiteralType(e, t) {
					t.visit(e.literal);
				},
				TSCallSignatureDeclaration: p["TSConstructSignatureDeclaration|TSCallSignatureDeclaration"],
				TSConditionalType(e, t) {
					t.visit(e.checkType), t.write(" extends "), t.visit(e.extendsType), t.write(" ? "), t.visit(e.trueType), t.write(" : "), t.visit(e.falseType);
				},
				TSConstructSignatureDeclaration: p["TSConstructSignatureDeclaration|TSCallSignatureDeclaration"],
				TSConstructorType: p["TSFunctionType|TSConstructorType"],
				TSExternalModuleReference(e, t) {
					t.write("require("), t.visit(e.expression), t.write(");");
				},
				TSIndexedAccessType(e, t) {
					t.visit(e.objectType), t.write("["), t.visit(e.indexType), t.write("]");
				},
				TSImportEqualsDeclaration(e, t) {
					t.write("import "), t.visit(e.id), t.write(" = "), t.visit(e.moduleReference);
				},
				TSImportType(e, t) {
					t.write("import("), t.visit(e.argument), t.write(")"), e.qualifier && (t.write("."), t.visit(e.qualifier));
				},
				TSOptionalType(e, t) {
					t.visit(e.typeAnnotation), t.write("?");
				},
				TSRestType(e, t) {
					t.write("..."), t.visit(e.typeAnnotation);
				},
				TSThisType(e, t) {
					t.write("this", e);
				},
				TSAsExpression(e, t) {
					if (e.expression) Gw[e.expression.type] < Gw.TSAsExpression ? (t.write("("), t.visit(e.expression), t.write(")")) : t.visit(e.expression);
					t.write(" as "), t.visit(e.typeAnnotation);
				},
				TSEnumDeclaration(e, t) {
					t.write("enum "), t.visit(e.id), t.write(" {"), t.indent(), t.newline(), l(t, e.members ?? e.body.members, e.loc?.end ?? null, !1), t.dedent(), t.newline(), t.write("}");
				},
				TSModuleBlock(e, t) {
					t.write(" {"), t.indent(), t.newline(), c(t, e), t.dedent(), t.newline(), t.write("}");
				},
				TSModuleDeclaration(e, t) {
					e.declare ? t.write("declare ") : t.write("namespace "), t.visit(e.id), e.body && t.visit(e.body);
				},
				TSNonNullExpression(e, t) {
					t.visit(e.expression), t.write("!");
				},
				TSInterfaceBody(e, t) {
					l(t, e.body, e.loc?.end ?? null, !0, ";");
				},
				TSInterfaceDeclaration(e, t) {
					t.write("interface "), t.visit(e.id), e.typeParameters && t.visit(e.typeParameters), e.extends && e.extends.length > 0 && (t.write(" extends "), l(t, e.extends, e.body.loc?.start ?? null, !1)), t.write(" {"), t.visit(e.body), t.write("}");
				},
				TSInstantiationExpression(e, t) {
					t.visit(e.expression), t.visit(e.typeArguments);
				},
				TSInterfaceHeritage(e, t) {
					e.expression && t.visit(e.expression);
				},
				TSParenthesizedType(e, t) {
					t.write("("), t.visit(e.typeAnnotation), t.write(")");
				},
				TSSatisfiesExpression(e, t) {
					if (e.expression) Gw[e.expression.type] < Gw.TSSatisfiesExpression ? (t.write("("), t.visit(e.expression), t.write(")")) : t.visit(e.expression);
					t.write(" satisfies "), t.visit(e.typeAnnotation);
				},
				TSTypeAliasDeclaration(e, t) {
					t.write("type "), t.visit(e.id), e.typeParameters && t.visit(e.typeParameters), t.write(" = "), t.visit(e.typeAnnotation), t.write(";");
				},
				TSQualifiedName(e, t) {
					t.visit(e.left), t.write("."), t.visit(e.right);
				}
			};
		};
		function Yw(e, t, n) {
			if ("PrivateIdentifier" === e.type) return !1;
			if ("LogicalExpression" === e.type && "LogicalExpression" === t.type && ("??" === t.operator && "??" !== e.operator || "??" !== t.operator && "??" === e.operator)) return !0;
			const s = Gw[e.type], r = Gw[t.type];
			return s !== r ? !n && 15 === s && 14 === r && "**" === t.operator || s < r : (13 === s || 14 === s) && ("**" === e.operator && "**" === t.operator ? !n : n ? Kw[e.operator] <= Kw[t.operator] : Kw[e.operator] < Kw[t.operator]);
		}
		function Jw(e, t) {
			const n = t.new(), s = t.new(), r = t.new();
			t.append(r), e.declare && r.write("declare "), r.write(`${e.kind} `), r.append(n);
			let a = !0;
			for (const t of e.declarations) a || r.append(s), a = !1, r.visit(t);
			const i = r.measure() + 2 * (e.declarations.length - 1);
			r.multiline || e.declarations.length > 1 && i > 50 ? (t.multiline = !0, e.declarations.length > 1 && n.indent(), s.write(","), s.newline(), e.declarations.length > 1 && t.dedent()) : s.write(", ");
		}
		function Zw(e, t) {
			return e.line < t.line || !(e.line > t.line) && e.column < t.column;
		}
		const ek = "5.53.5";
		class tk {
			constructor(e) {
				this.bits = e instanceof tk ? e.bits.slice() : [];
			}
			add(e) {
				this.bits[e >> 5] |= 1 << (31 & e);
			}
			has(e) {
				return !!(this.bits[e >> 5] & 1 << (31 & e));
			}
		}
		class nk {
			constructor(e, t, n) {
				this.start = e, this.end = t, this.original = n, this.intro = "", this.outro = "", this.content = n, this.storeName = !1, this.edited = !1, this.previous = null, this.next = null;
			}
			appendLeft(e) {
				this.outro += e;
			}
			appendRight(e) {
				this.intro = this.intro + e;
			}
			clone() {
				const e = new nk(this.start, this.end, this.original);
				return e.intro = this.intro, e.outro = this.outro, e.content = this.content, e.storeName = this.storeName, e.edited = this.edited, e;
			}
			contains(e) {
				return this.start < e && e < this.end;
			}
			eachNext(e) {
				let t = this;
				for (; t;) e(t), t = t.next;
			}
			eachPrevious(e) {
				let t = this;
				for (; t;) e(t), t = t.previous;
			}
			edit(e, t, n) {
				return this.content = e, n || (this.intro = "", this.outro = ""), this.storeName = t, this.edited = !0, this;
			}
			prependLeft(e) {
				this.outro = e + this.outro;
			}
			prependRight(e) {
				this.intro = e + this.intro;
			}
			reset() {
				this.intro = "", this.outro = "", this.edited && (this.content = this.original, this.storeName = !1, this.edited = !1);
			}
			split(e) {
				const t = e - this.start, n = this.original.slice(0, t), s = this.original.slice(t);
				this.original = n;
				const r = new nk(e, this.end, s);
				return r.outro = this.outro, this.outro = "", this.end = e, this.edited ? (r.edit("", !1), this.content = "") : this.content = n, r.next = this.next, r.next && (r.next.previous = r), r.previous = this, this.next = r, r;
			}
			toString() {
				return this.intro + this.content + this.outro;
			}
			trimEnd(e) {
				if (this.outro = this.outro.replace(e, ""), this.outro.length) return !0;
				const t = this.content.replace(e, "");
				return t.length ? (t !== this.content && (this.split(this.start + t.length).edit("", void 0, !0), this.edited && this.edit(t, this.storeName, !0)), !0) : (this.edit("", void 0, !0), this.intro = this.intro.replace(e, ""), !!this.intro.length || void 0);
			}
			trimStart(e) {
				if (this.intro = this.intro.replace(e, ""), this.intro.length) return !0;
				const t = this.content.replace(e, "");
				if (t.length) {
					if (t !== this.content) {
						const e = this.split(this.end - t.length);
						this.edited && e.edit(t, this.storeName, !0), this.edit("", void 0, !0);
					}
					return !0;
				}
				return this.edit("", void 0, !0), this.outro = this.outro.replace(e, ""), !!this.outro.length || void 0;
			}
		}
		function sk() {
			return "undefined" != typeof globalThis && "function" == typeof globalThis.btoa ? (e) => globalThis.btoa(unescape(encodeURIComponent(e))) : "function" == typeof Buffer ? (e) => Buffer.from(e, "utf-8").toString("base64") : () => {
				throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be supported.");
			};
		}
		const rk = sk();
		let ak = class {
			constructor(e) {
				this.version = 3, this.file = e.file, this.sources = e.sources, this.sourcesContent = e.sourcesContent, this.names = e.names, this.mappings = Lw(e.mappings), void 0 !== e.x_google_ignoreList && (this.x_google_ignoreList = e.x_google_ignoreList), void 0 !== e.debugId && (this.debugId = e.debugId);
			}
			toString() {
				return JSON.stringify(this);
			}
			toUrl() {
				return "data:application/json;charset=utf-8;base64," + rk(this.toString());
			}
		};
		function ik(e, t) {
			const n = e.split(/[/\\]/), s = t.split(/[/\\]/);
			for (n.pop(); n[0] === s[0];) n.shift(), s.shift();
			if (n.length) {
				let e = n.length;
				for (; e--;) n[e] = "..";
			}
			return n.concat(s).join("/");
		}
		const ok = Object.prototype.toString;
		function lk(e) {
			const t = e.split("\n"), n = [];
			for (let e = 0, s = 0; e < t.length; e++) n.push(s), s += t[e].length + 1;
			return function(e) {
				let t = 0, s = n.length;
				for (; t < s;) {
					const r = t + s >> 1;
					e < n[r] ? s = r : t = r + 1;
				}
				const r = t - 1;
				return {
					line: r,
					column: e - n[r]
				};
			};
		}
		const ck = /\w/;
		class pk {
			constructor(e) {
				this.hires = e, this.generatedCodeLine = 0, this.generatedCodeColumn = 0, this.raw = [], this.rawSegments = this.raw[this.generatedCodeLine] = [], this.pending = null;
			}
			addEdit(e, t, n, s) {
				if (t.length) {
					const r = t.length - 1;
					let a = t.indexOf("\n", 0), i = -1;
					for (; a >= 0 && r > a;) {
						const r = [
							this.generatedCodeColumn,
							e,
							n.line,
							n.column
						];
						s >= 0 && r.push(s), this.rawSegments.push(r), this.generatedCodeLine += 1, this.raw[this.generatedCodeLine] = this.rawSegments = [], this.generatedCodeColumn = 0, i = a, a = t.indexOf("\n", a + 1);
					}
					const o = [
						this.generatedCodeColumn,
						e,
						n.line,
						n.column
					];
					s >= 0 && o.push(s), this.rawSegments.push(o), this.advance(t.slice(i + 1));
				} else this.pending && (this.rawSegments.push(this.pending), this.advance(t));
				this.pending = null;
			}
			addUneditedChunk(e, t, n, s, r) {
				let a = t.start, i = !0, o = !1;
				for (; a < t.end;) {
					if ("\n" === n[a]) s.line += 1, s.column = 0, this.generatedCodeLine += 1, this.raw[this.generatedCodeLine] = this.rawSegments = [], this.generatedCodeColumn = 0, i = !0, o = !1;
					else {
						if (this.hires || i || r.has(a)) {
							const t = [
								this.generatedCodeColumn,
								e,
								s.line,
								s.column
							];
							"boundary" === this.hires ? ck.test(n[a]) ? o || (this.rawSegments.push(t), o = !0) : (this.rawSegments.push(t), o = !1) : this.rawSegments.push(t);
						}
						s.column += 1, this.generatedCodeColumn += 1, i = !1;
					}
					a += 1;
				}
				this.pending = null;
			}
			advance(e) {
				if (!e) return;
				const t = e.split("\n");
				if (t.length > 1) {
					for (let e = 0; e < t.length - 1; e++) this.generatedCodeLine++, this.raw[this.generatedCodeLine] = this.rawSegments = [];
					this.generatedCodeColumn = 0;
				}
				this.generatedCodeColumn += t[t.length - 1].length;
			}
		}
		const uk = "\n", dk = {
			insertLeft: !1,
			insertRight: !1,
			storeName: !1
		};
		class hk {
			constructor(e, t = {}) {
				const n = new nk(0, e.length, e);
				Object.defineProperties(this, {
					original: {
						writable: !0,
						value: e
					},
					outro: {
						writable: !0,
						value: ""
					},
					intro: {
						writable: !0,
						value: ""
					},
					firstChunk: {
						writable: !0,
						value: n
					},
					lastChunk: {
						writable: !0,
						value: n
					},
					lastSearchedChunk: {
						writable: !0,
						value: n
					},
					byStart: {
						writable: !0,
						value: {}
					},
					byEnd: {
						writable: !0,
						value: {}
					},
					filename: {
						writable: !0,
						value: t.filename
					},
					indentExclusionRanges: {
						writable: !0,
						value: t.indentExclusionRanges
					},
					sourcemapLocations: {
						writable: !0,
						value: new tk()
					},
					storedNames: {
						writable: !0,
						value: {}
					},
					indentStr: {
						writable: !0,
						value: void 0
					},
					ignoreList: {
						writable: !0,
						value: t.ignoreList
					},
					offset: {
						writable: !0,
						value: t.offset || 0
					}
				}), this.byStart[0] = n, this.byEnd[e.length] = n;
			}
			addSourcemapLocation(e) {
				this.sourcemapLocations.add(e);
			}
			append(e) {
				if ("string" != typeof e) throw new TypeError("outro content must be a string");
				return this.outro += e, this;
			}
			appendLeft(e, t) {
				if (e += this.offset, "string" != typeof t) throw new TypeError("inserted content must be a string");
				this._split(e);
				const n = this.byEnd[e];
				return n ? n.appendLeft(t) : this.intro += t, this;
			}
			appendRight(e, t) {
				if (e += this.offset, "string" != typeof t) throw new TypeError("inserted content must be a string");
				this._split(e);
				const n = this.byStart[e];
				return n ? n.appendRight(t) : this.outro += t, this;
			}
			clone() {
				const e = new hk(this.original, {
					filename: this.filename,
					offset: this.offset
				});
				let t = this.firstChunk, n = e.firstChunk = e.lastSearchedChunk = t.clone();
				for (; t;) {
					e.byStart[n.start] = n, e.byEnd[n.end] = n;
					const s = t.next, r = s && s.clone();
					r && (n.next = r, r.previous = n, n = r), t = s;
				}
				return e.lastChunk = n, this.indentExclusionRanges && (e.indentExclusionRanges = this.indentExclusionRanges.slice()), e.sourcemapLocations = new tk(this.sourcemapLocations), e.intro = this.intro, e.outro = this.outro, e;
			}
			generateDecodedMap(e) {
				e = e || {};
				const t = Object.keys(this.storedNames), n = new pk(e.hires), s = lk(this.original);
				return this.intro && n.advance(this.intro), this.firstChunk.eachNext(((e) => {
					const r = s(e.start);
					e.intro.length && n.advance(e.intro), e.edited ? n.addEdit(0, e.content, r, e.storeName ? t.indexOf(e.original) : -1) : n.addUneditedChunk(0, e, this.original, r, this.sourcemapLocations), e.outro.length && n.advance(e.outro);
				})), {
					file: e.file ? e.file.split(/[/\\]/).pop() : void 0,
					sources: [e.source ? ik(e.file || "", e.source) : e.file || ""],
					sourcesContent: e.includeContent ? [this.original] : void 0,
					names: t,
					mappings: n.raw,
					x_google_ignoreList: this.ignoreList ? [0] : void 0
				};
			}
			generateMap(e) {
				return new ak(this.generateDecodedMap(e));
			}
			_ensureindentStr() {
				void 0 === this.indentStr && (this.indentStr = function(e) {
					const t = e.split("\n"), n = t.filter(((e) => /^\t+/.test(e))), s = t.filter(((e) => /^ {2,}/.test(e)));
					if (0 === n.length && 0 === s.length) return null;
					if (n.length >= s.length) return "	";
					const r = s.reduce(((e, t) => {
						const n = /^ +/.exec(t)[0].length;
						return Math.min(n, e);
					}), Infinity);
					return new Array(r + 1).join(" ");
				}(this.original));
			}
			_getRawIndentString() {
				return this._ensureindentStr(), this.indentStr;
			}
			getIndentString() {
				return this._ensureindentStr(), null === this.indentStr ? "	" : this.indentStr;
			}
			indent(e, t) {
				const n = /^[^\r\n]/gm;
				var s;
				if (s = e, "[object Object]" === ok.call(s) && (t = e, e = void 0), void 0 === e && (this._ensureindentStr(), e = this.indentStr || "	"), "" === e) return this;
				const r = {};
				if ((t = t || {}).exclude) ("number" == typeof t.exclude[0] ? [t.exclude] : t.exclude).forEach(((e) => {
					for (let t = e[0]; t < e[1]; t += 1) r[t] = !0;
				}));
				let a = !1 !== t.indentStart;
				const i = (t) => a ? `${e}${t}` : (a = !0, t);
				this.intro = this.intro.replace(n, i);
				let o = 0, l = this.firstChunk;
				for (; l;) {
					const t = l.end;
					if (l.edited) r[o] || (l.content = l.content.replace(n, i), l.content.length && (a = "\n" === l.content[l.content.length - 1]));
					else for (o = l.start; o < t;) {
						if (!r[o]) {
							const t = this.original[o];
							"\n" === t ? a = !0 : "\r" !== t && a && (a = !1, o === l.start || (this._splitChunk(l, o), l = l.next), l.prependRight(e));
						}
						o += 1;
					}
					o = l.end, l = l.next;
				}
				return this.outro = this.outro.replace(n, i), this;
			}
			insert() {
				throw new Error("magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)");
			}
			insertLeft(e, t) {
				return dk.insertLeft || (console.warn("magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead"), dk.insertLeft = !0), this.appendLeft(e, t);
			}
			insertRight(e, t) {
				return dk.insertRight || (console.warn("magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead"), dk.insertRight = !0), this.prependRight(e, t);
			}
			move(e, t, n) {
				if (e += this.offset, t += this.offset, (n += this.offset) >= e && n <= t) throw new Error("Cannot move a selection inside itself");
				this._split(e), this._split(t), this._split(n);
				const s = this.byStart[e], r = this.byEnd[t], a = s.previous, i = r.next, o = this.byStart[n];
				if (!o && r === this.lastChunk) return this;
				const l = o ? o.previous : this.lastChunk;
				return a && (a.next = i), i && (i.previous = a), l && (l.next = s), o && (o.previous = r), s.previous || (this.firstChunk = r.next), r.next || (this.lastChunk = s.previous, this.lastChunk.next = null), s.previous = l, r.next = o || null, l || (this.firstChunk = s), o || (this.lastChunk = r), this;
			}
			overwrite(e, t, n, s) {
				return s = s || {}, this.update(e, t, n, {
					...s,
					overwrite: !s.contentOnly
				});
			}
			update(e, t, n, s) {
				if (e += this.offset, t += this.offset, "string" != typeof n) throw new TypeError("replacement content must be a string");
				if (0 !== this.original.length) {
					for (; e < 0;) e += this.original.length;
					for (; t < 0;) t += this.original.length;
				}
				if (t > this.original.length) throw new Error("end is out of bounds");
				if (e === t) throw new Error("Cannot overwrite a zero-length range – use appendLeft or prependRight instead");
				this._split(e), this._split(t), !0 === s && (dk.storeName || (console.warn("The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string"), dk.storeName = !0), s = { storeName: !0 });
				const r = void 0 !== s && s.storeName, a = void 0 !== s && s.overwrite;
				if (r) {
					const n = this.original.slice(e, t);
					Object.defineProperty(this.storedNames, n, {
						writable: !0,
						value: !0,
						enumerable: !0
					});
				}
				const i = this.byStart[e], o = this.byEnd[t];
				if (i) {
					let e = i;
					for (; e !== o;) {
						if (e.next !== this.byStart[e.end]) throw new Error("Cannot overwrite across a split point");
						e = e.next, e.edit("", !1);
					}
					i.edit(n, r, !a);
				} else {
					const s = new nk(e, t, "").edit(n, r);
					o.next = s, s.previous = o;
				}
				return this;
			}
			prepend(e) {
				if ("string" != typeof e) throw new TypeError("outro content must be a string");
				return this.intro = e + this.intro, this;
			}
			prependLeft(e, t) {
				if (e += this.offset, "string" != typeof t) throw new TypeError("inserted content must be a string");
				this._split(e);
				const n = this.byEnd[e];
				return n ? n.prependLeft(t) : this.intro = t + this.intro, this;
			}
			prependRight(e, t) {
				if (e += this.offset, "string" != typeof t) throw new TypeError("inserted content must be a string");
				this._split(e);
				const n = this.byStart[e];
				return n ? n.prependRight(t) : this.outro = t + this.outro, this;
			}
			remove(e, t) {
				if (e += this.offset, t += this.offset, 0 !== this.original.length) {
					for (; e < 0;) e += this.original.length;
					for (; t < 0;) t += this.original.length;
				}
				if (e === t) return this;
				if (e < 0 || t > this.original.length) throw new Error("Character is out of bounds");
				if (e > t) throw new Error("end must be greater than start");
				this._split(e), this._split(t);
				let n = this.byStart[e];
				for (; n;) n.intro = "", n.outro = "", n.edit(""), n = t > n.end ? this.byStart[n.end] : null;
				return this;
			}
			reset(e, t) {
				if (e += this.offset, t += this.offset, 0 !== this.original.length) {
					for (; e < 0;) e += this.original.length;
					for (; t < 0;) t += this.original.length;
				}
				if (e === t) return this;
				if (e < 0 || t > this.original.length) throw new Error("Character is out of bounds");
				if (e > t) throw new Error("end must be greater than start");
				this._split(e), this._split(t);
				let n = this.byStart[e];
				for (; n;) n.reset(), n = t > n.end ? this.byStart[n.end] : null;
				return this;
			}
			lastChar() {
				if (this.outro.length) return this.outro[this.outro.length - 1];
				let e = this.lastChunk;
				do {
					if (e.outro.length) return e.outro[e.outro.length - 1];
					if (e.content.length) return e.content[e.content.length - 1];
					if (e.intro.length) return e.intro[e.intro.length - 1];
				} while (e = e.previous);
				return this.intro.length ? this.intro[this.intro.length - 1] : "";
			}
			lastLine() {
				let e = this.outro.lastIndexOf(uk);
				if (-1 !== e) return this.outro.substr(e + 1);
				let t = this.outro, n = this.lastChunk;
				do {
					if (n.outro.length > 0) {
						if (e = n.outro.lastIndexOf(uk), -1 !== e) return n.outro.substr(e + 1) + t;
						t = n.outro + t;
					}
					if (n.content.length > 0) {
						if (e = n.content.lastIndexOf(uk), -1 !== e) return n.content.substr(e + 1) + t;
						t = n.content + t;
					}
					if (n.intro.length > 0) {
						if (e = n.intro.lastIndexOf(uk), -1 !== e) return n.intro.substr(e + 1) + t;
						t = n.intro + t;
					}
				} while (n = n.previous);
				return e = this.intro.lastIndexOf(uk), -1 !== e ? this.intro.substr(e + 1) + t : this.intro + t;
			}
			slice(e = 0, t = this.original.length - this.offset) {
				if (e += this.offset, t += this.offset, 0 !== this.original.length) {
					for (; e < 0;) e += this.original.length;
					for (; t < 0;) t += this.original.length;
				}
				let n = "", s = this.firstChunk;
				for (; s && (s.start > e || s.end <= e);) {
					if (s.start < t && s.end >= t) return n;
					s = s.next;
				}
				if (s && s.edited && s.start !== e) throw new Error(`Cannot use replaced character ${e} as slice start anchor.`);
				const r = s;
				for (; s;) {
					!s.intro || r === s && s.start !== e || (n += s.intro);
					const a = s.start < t && s.end >= t;
					if (a && s.edited && s.end !== t) throw new Error(`Cannot use replaced character ${t} as slice end anchor.`);
					const i = r === s ? e - s.start : 0, o = a ? s.content.length + t - s.end : s.content.length;
					if (n += s.content.slice(i, o), !s.outro || a && s.end !== t || (n += s.outro), a) break;
					s = s.next;
				}
				return n;
			}
			snip(e, t) {
				const n = this.clone();
				return n.remove(0, e), n.remove(t, n.original.length), n;
			}
			_split(e) {
				if (this.byStart[e] || this.byEnd[e]) return;
				let t = this.lastSearchedChunk;
				const n = e > t.end;
				for (; t;) {
					if (t.contains(e)) return this._splitChunk(t, e);
					t = n ? this.byStart[t.end] : this.byEnd[t.start];
				}
			}
			_splitChunk(e, t) {
				if (e.edited && e.content.length) {
					const n = lk(this.original)(t);
					throw new Error(`Cannot split a chunk that has already been edited (${n.line}:${n.column} – "${e.original}")`);
				}
				const n = e.split(t);
				return this.byEnd[t] = e, this.byStart[t] = n, this.byEnd[n.end] = n, e === this.lastChunk && (this.lastChunk = n), this.lastSearchedChunk = e, !0;
			}
			toString() {
				let e = this.intro, t = this.firstChunk;
				for (; t;) e += t.toString(), t = t.next;
				return e + this.outro;
			}
			isEmpty() {
				let e = this.firstChunk;
				do
					if (e.intro.length && e.intro.trim() || e.content.length && e.content.trim() || e.outro.length && e.outro.trim()) return !1;
				while (e = e.next);
				return !0;
			}
			length() {
				let e = this.firstChunk, t = 0;
				do
					t += e.intro.length + e.content.length + e.outro.length;
				while (e = e.next);
				return t;
			}
			trimLines() {
				return this.trim("[\\r\\n]");
			}
			trim(e) {
				return this.trimStart(e).trimEnd(e);
			}
			trimEndAborted(e) {
				const t = new RegExp((e || "\\s") + "+$");
				if (this.outro = this.outro.replace(t, ""), this.outro.length) return !0;
				let n = this.lastChunk;
				do {
					const e = n.end, s = n.trimEnd(t);
					if (n.end !== e && (this.lastChunk === n && (this.lastChunk = n.next), this.byEnd[n.end] = n, this.byStart[n.next.start] = n.next, this.byEnd[n.next.end] = n.next), s) return !0;
					n = n.previous;
				} while (n);
				return !1;
			}
			trimEnd(e) {
				return this.trimEndAborted(e), this;
			}
			trimStartAborted(e) {
				const t = new RegExp("^" + (e || "\\s") + "+");
				if (this.intro = this.intro.replace(t, ""), this.intro.length) return !0;
				let n = this.firstChunk;
				do {
					const e = n.end, s = n.trimStart(t);
					if (n.end !== e && (n === this.lastChunk && (this.lastChunk = n.next), this.byEnd[n.end] = n, this.byStart[n.next.start] = n.next, this.byEnd[n.next.end] = n.next), s) return !0;
					n = n.next;
				} while (n);
				return !1;
			}
			trimStart(e) {
				return this.trimStartAborted(e), this;
			}
			hasChanged() {
				return this.original !== this.toString();
			}
			_replaceRegexp(e, t) {
				function n(e, n) {
					return "string" == typeof t ? t.replace(/\$(\$|&|\d+)/g, ((t, n) => {
						if ("$" === n) return "$";
						if ("&" === n) return e[0];
						return +n < e.length ? e[+n] : `$${n}`;
					})) : t(...e, e.index, n, e.groups);
				}
				if (e.global) (function(e, t) {
					let n;
					const s = [];
					for (; n = e.exec(t);) s.push(n);
					return s;
				})(e, this.original).forEach(((e) => {
					if (null != e.index) {
						const t = n(e, this.original);
						t !== e[0] && this.overwrite(e.index, e.index + e[0].length, t);
					}
				}));
				else {
					const t = this.original.match(e);
					if (t && null != t.index) {
						const e = n(t, this.original);
						e !== t[0] && this.overwrite(t.index, t.index + t[0].length, e);
					}
				}
				return this;
			}
			_replaceString(e, t) {
				const { original: n } = this, s = n.indexOf(e);
				return -1 !== s && this.overwrite(s, s + e.length, t), this;
			}
			replace(e, t) {
				return "string" == typeof e ? this._replaceString(e, t) : this._replaceRegexp(e, t);
			}
			_replaceAllString(e, t) {
				const { original: n } = this, s = e.length;
				for (let r = n.indexOf(e); -1 !== r; r = n.indexOf(e, r + s)) n.slice(r, r + s) !== t && this.overwrite(r, r + s, t);
				return this;
			}
			replaceAll(e, t) {
				if ("string" == typeof e) return this._replaceAllString(e, t);
				if (!e.global) throw new TypeError("MagicString.prototype.replaceAll called with a non-global RegExp argument");
				return this._replaceRegexp(e, t);
			}
		}
		const mk = /^[\w+.-]+:\/\//, fk = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/, yk = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
		var vk;
		function gk(e) {
			return e.startsWith("/");
		}
		function bk(e) {
			return /^[.?#]/.test(e);
		}
		function _k(e) {
			const t = fk.exec(e);
			return xk(t[1], t[2] || "", t[3], t[4] || "", t[5] || "/", t[6] || "", t[7] || "");
		}
		function xk(e, t, n, s, r, a, i) {
			return {
				scheme: e,
				user: t,
				host: n,
				port: s,
				path: r,
				query: a,
				hash: i,
				type: vk.Absolute
			};
		}
		function wk(e) {
			if (function(e) {
				return e.startsWith("//");
			}(e)) {
				const t = _k("http:" + e);
				return t.scheme = "", t.type = vk.SchemeRelative, t;
			}
			if (gk(e)) {
				const t = _k("http://foo.com" + e);
				return t.scheme = "", t.host = "", t.type = vk.AbsolutePath, t;
			}
			if (function(e) {
				return e.startsWith("file:");
			}(e)) return function(e) {
				const t = yk.exec(e), n = t[2];
				return xk("file:", "", t[1] || "", "", gk(n) ? n : "/" + n, t[3] || "", t[4] || "");
			}(e);
			if (function(e) {
				return mk.test(e);
			}(e)) return _k(e);
			const t = _k("http://foo.com/" + e);
			return t.scheme = "", t.host = "", t.type = e ? e.startsWith("?") ? vk.Query : e.startsWith("#") ? vk.Hash : vk.RelativePath : vk.Empty, t;
		}
		function kk(e, t) {
			const n = t <= vk.RelativePath, s = e.path.split("/");
			let r = 1, a = 0, i = !1;
			for (let e = 1; e < s.length; e++) {
				const t = s[e];
				t ? (i = !1, "." !== t && (".." !== t ? (s[r++] = t, a++) : a ? (i = !0, a--, r--) : n && (s[r++] = t))) : i = !0;
			}
			let o = "";
			for (let e = 1; e < r; e++) o += "/" + s[e];
			(!o || i && !o.endsWith("/..")) && (o += "/"), e.path = o;
		}
		function Ck(e, t) {
			if (!e && !t) return "";
			const n = wk(e);
			let s = n.type;
			if (t && s !== vk.Absolute) {
				const e = wk(t), r = e.type;
				switch (s) {
					case vk.Empty: n.hash = e.hash;
					case vk.Hash: n.query = e.query;
					case vk.Query:
					case vk.RelativePath: (function(e, t) {
						kk(t, t.type), "/" === e.path ? e.path = t.path : e.path = function(e) {
							if (e.endsWith("/..")) return e;
							const t = e.lastIndexOf("/");
							return e.slice(0, t + 1);
						}(t.path) + e.path;
					})(n, e);
					case vk.AbsolutePath: n.user = e.user, n.host = e.host, n.port = e.port;
					case vk.SchemeRelative: n.scheme = e.scheme;
				}
				r > s && (s = r);
			}
			kk(n, s);
			const r = n.query + n.hash;
			switch (s) {
				case vk.Hash:
				case vk.Query: return r;
				case vk.RelativePath: {
					const s = n.path.slice(1);
					return s ? bk(t || e) && !bk(s) ? "./" + s + r : s + r : r || ".";
				}
				case vk.AbsolutePath: return n.path + r;
				default: return n.scheme + "//" + n.user + n.host + n.port + n.path + r;
			}
		}
		function Sk(e, t) {
			const n = function(e) {
				if (!e) return "";
				const t = e.lastIndexOf("/");
				return e.slice(0, t + 1);
			}(e), s = t ? t + "/" : "";
			return (e) => Ck(s + (e || ""), n);
		}
		(function(e) {
			e[e.Empty = 1] = "Empty", e[e.Hash = 2] = "Hash", e[e.Query = 3] = "Query", e[e.RelativePath = 4] = "RelativePath", e[e.AbsolutePath = 5] = "AbsolutePath", e[e.SchemeRelative = 6] = "SchemeRelative", e[e.Absolute = 7] = "Absolute";
		})(vk || (vk = {}));
		var Pk = 0;
		function Ek(e, t) {
			for (let n = t; n < e.length; n++) if (!Tk(e[n])) return n;
			return e.length;
		}
		function Tk(e) {
			for (let t = 1; t < e.length; t++) if (e[t][Pk] < e[t - 1][Pk]) return !1;
			return !0;
		}
		function Ak(e, t) {
			return t || (e = e.slice()), e.sort($k);
		}
		function $k(e, t) {
			return e[Pk] - t[Pk];
		}
		var Rk = !1;
		function Ik(e, t, n, s) {
			const { lastKey: r, lastNeedle: a, lastIndex: i } = n;
			let o = 0, l = e.length - 1;
			if (s === r) {
				if (t === a) return Rk = -1 !== i && e[i][Pk] === t, i;
				t >= a ? o = -1 === i ? 0 : i : l = i;
			}
			return n.lastKey = s, n.lastNeedle = t, n.lastIndex = function(e, t, n, s) {
				for (; n <= s;) {
					const r = n + (s - n >> 1), a = e[r][Pk] - t;
					if (0 === a) return Rk = !0, r;
					a < 0 ? n = r + 1 : s = r - 1;
				}
				return Rk = !1, n - 1;
			}(e, t, o, l);
		}
		var Mk = class {
			constructor(e, t) {
				const n = "string" == typeof e;
				if (!n && e._decodedMemo) return e;
				const s = function(e) {
					return "string" == typeof e ? JSON.parse(e) : e;
				}(e), { version: r, file: a, names: i, sourceRoot: o, sources: l, sourcesContent: c } = s;
				this.version = r, this.file = a, this.names = i || [], this.sourceRoot = o, this.sources = l, this.sourcesContent = c, this.ignoreList = s.ignoreList || s.x_google_ignoreList || void 0;
				const p = Sk(t, o);
				this.resolvedSources = l.map(p);
				const { mappings: u } = s;
				if ("string" == typeof u) this._encoded = u, this._decoded = void 0;
				else {
					if (!Array.isArray(u)) throw s.sections ? /* @__PURE__ */ new Error("TraceMap passed sectioned source map, please use FlattenMap export instead") : /* @__PURE__ */ new Error(`invalid source map: ${JSON.stringify(s)}`);
					this._encoded = void 0, this._decoded = function(e, t) {
						const n = Ek(e, 0);
						if (n === e.length) return e;
						t || (e = e.slice());
						for (let s = n; s < e.length; s = Ek(e, s + 1)) e[s] = Ak(e[s], t);
						return e;
					}(u, n);
				}
				this._decodedMemo = {
					lastKey: -1,
					lastNeedle: -1,
					lastIndex: -1
				}, this._bySources = void 0, this._bySourceMemos = void 0;
			}
		};
		function qk(e) {
			var t;
			return (t = e)._decoded || (t._decoded = Iw(e._encoded));
		}
		function Lk(e, t, n) {
			const s = qk(e);
			if (t >= s.length) return null;
			const r = s[t], a = function(e, t, n, s, r) {
				let a = Ik(e, s, t, n);
				Rk && (a = function(e, t, n) {
					for (let s = n - 1; s >= 0 && e[s][Pk] === t; n = s--);
					return n;
				}(e, s, a));
				return -1 === a || a === e.length ? -1 : a;
			}(r, e._decodedMemo, t, n);
			return -1 === a ? null : r[a];
		}
		class Ok {
			constructor() {
				this._indexes = { __proto__: null }, this.array = [];
			}
		}
		function Nk(e, t) {
			return e._indexes[t];
		}
		function Dk(e, t) {
			const n = Nk(e, t);
			if (void 0 !== n) return n;
			const { array: s, _indexes: r } = e;
			return r[t] = s.push(t) - 1;
		}
		const jk = 0, Bk = 1, Fk = 2, Vk = 3, Hk = 4, Uk = -1;
		class zk {
			constructor({ file: e, sourceRoot: t } = {}) {
				this._names = new Ok(), this._sources = new Ok(), this._sourcesContent = [], this._mappings = [], this.file = e, this.sourceRoot = t, this._ignoreList = new Ok();
			}
		}
		const Wk = (e, t, n, s, r, a, i, o) => function(e, t, n, s, r, a, i, o, l) {
			const { _mappings: c, _sources: p, _sourcesContent: u, _names: d } = t, h = function(e, t) {
				for (let n = e.length; n <= t; n++) e[n] = [];
				return e[t];
			}(c, n), m = function(e, t) {
				let n = e.length;
				for (let s = n - 1; s >= 0; n = s--) if (t >= e[s][jk]) break;
				return n;
			}(h, s);
			if (!r) {
				if (function(e, t) {
					if (0 === t) return !0;
					return 1 === e[t - 1].length;
				}(h, m)) return;
				return Qk(h, m, [s]);
			}
			const f = Dk(p, r), y = o ? Dk(d, o) : Uk;
			f === u.length && (u[f] = null);
			if (function(e, t, n, s, r, a) {
				if (0 === t) return !1;
				const i = e[t - 1];
				return 1 !== i.length && n === i[Bk] && s === i[Fk] && r === i[Vk] && a === (5 === i.length ? i[Hk] : Uk);
			}(h, m, f, a, i, y)) return;
			return Qk(h, m, o ? [
				s,
				f,
				a,
				i,
				y
			] : [
				s,
				f,
				a,
				i
			]);
		}(0, e, t, n, s, r, a, i);
		function Gk(e, t, n) {
			const { _sources: s, _sourcesContent: r } = e;
			r[Dk(s, t)] = n;
		}
		function Kk(e, t, n = !0) {
			const { _sources: s, _sourcesContent: r, _ignoreList: a } = e, i = Dk(s, t);
			i === r.length && (r[i] = null), n ? Dk(a, i) : function(e, t) {
				const n = Nk(e, t);
				if (void 0 === n) return;
				const { array: s, _indexes: r } = e;
				for (let e = n + 1; e < s.length; e++) {
					const t = s[e];
					s[e - 1] = t, r[t]--;
				}
				r[t] = void 0, s.pop();
			}(a, i);
		}
		function Xk(e) {
			const { _mappings: t, _sources: n, _sourcesContent: s, _names: r, _ignoreList: a } = e;
			return function(e) {
				const { length: t } = e;
				let n = t;
				for (let t = n - 1; t >= 0 && !(e[t].length > 0); n = t, t--);
				n < t && (e.length = n);
			}(t), {
				version: 3,
				file: e.file || void 0,
				names: r.array,
				sourceRoot: e.sourceRoot || void 0,
				sources: n.array,
				sourcesContent: s,
				mappings: t,
				ignoreList: a.array
			};
		}
		function Qk(e, t, n) {
			for (let n = e.length; n > t; n--) e[n] = e[n - 1];
			e[t] = n;
		}
		var Yk = Zk("", -1, -1, "", null, !1), Jk = [];
		function Zk(e, t, n, s, r, a) {
			return {
				source: e,
				line: t,
				column: n,
				name: s,
				content: r,
				ignore: a
			};
		}
		function eC(e, t, n, s, r) {
			return {
				map: e,
				sources: t,
				source: n,
				content: s,
				ignore: r
			};
		}
		function tC(e, t) {
			return eC(e, t, "", null, !1);
		}
		function nC(e, t, n, s) {
			if (!e.map) return Zk(e.source, t, n, s, e.content, e.ignore);
			const r = Lk(e.map, t, n);
			return null == r ? null : 1 === r.length ? Yk : nC(e.sources[r[1]], r[2], r[3], 5 === r.length ? e.map.names[r[4]] : s);
		}
		function sC(e, t) {
			const n = (s = e, Array.isArray(s) ? s : [s]).map(((e) => new Mk(e, "")));
			var s;
			const r = n.pop();
			for (let e = 0; e < n.length; e++) if (n[e].sources.length > 1) throw new Error(`Transformation map ${e} must have exactly one source file.\nDid you specify these with the most recent transformation maps first?`);
			let a = rC(r, t, "", 0);
			for (let e = n.length - 1; e >= 0; e--) a = tC(n[e], [a]);
			return a;
		}
		function rC(e, t, n, s) {
			const { resolvedSources: r, sourcesContent: a, ignoreList: i } = e, o = s + 1;
			return tC(e, r.map(((e, s) => {
				const r = {
					importer: n,
					depth: o,
					source: e || "",
					content: void 0,
					ignore: void 0
				}, l = t(r.source, r), { source: c } = r;
				if (l) return rC(new Mk(l, c), t, c, o);
				return function(e, t, n) {
					return eC(null, Jk, e, t, n);
				}(c, a ? a[s] : null, !!i && i.includes(s));
			})));
		}
		var aC = class {
			constructor(e, t) {
				const n = t.decodedMappings ? Xk(e) : function(e) {
					const t = Xk(e);
					return Object.assign(Object.assign({}, t), { mappings: Lw(t.mappings) });
				}(e);
				this.version = n.version, this.file = n.file, this.mappings = n.mappings, this.names = n.names, this.ignoreList = n.ignoreList, this.sourceRoot = n.sourceRoot, this.sources = n.sources, t.excludeContent || (this.sourcesContent = n.sourcesContent);
			}
			toString() {
				return JSON.stringify(this);
			}
		};
		function iC(e, t, n) {
			return new aC(function(e) {
				const t = new zk({ file: e.map.file }), { sources: n, map: s } = e, r = s.names, a = qk(s);
				for (let e = 0; e < a.length; e++) {
					const s = a[e];
					for (let a = 0; a < s.length; a++) {
						const i = s[a], o = i[0];
						let l = Yk;
						if (1 !== i.length && (l = nC(n[i[1]], i[2], i[3], 5 === i.length ? r[i[4]] : ""), null == l)) continue;
						const { column: c, line: p, name: u, content: d, source: h, ignore: m } = l;
						Wk(t, e, o, h, p, c, u), h && null != d && Gk(t, h, d), m && Kk(t, h, !0);
					}
				}
				return t;
			}(sC(e, t)), {
				excludeContent: !0,
				decodedMappings: !1
			});
		}
		function oC(e, t) {
			for (let n = 0; n < t.length; n++) e.push(t[n]);
		}
		function lC(e, t, n) {
			if (0 != e.mappings.length) for (let s = 0; s < e.mappings.length; s++) {
				const r = e.mappings[s];
				for (let e = 0; e < r.length; e++) {
					const s = r[e];
					s[1] === n && (0 === s[2] && (s[3] += t.column), s[2] += t.line);
				}
			}
		}
		function cC(e, t) {
			const n = e.slice(), s = [];
			t = t || [];
			let r = !1;
			for (const [a, i] of t.entries()) {
				const t = e.indexOf(i);
				if (t >= 0) s[a] = t;
				else {
					const e = n.length;
					n[e] = i, s[a] = e, r = !0;
				}
			}
			let a = r;
			return r && void 0 === s.find(((e, t) => e != t)) && (a = !1), [
				n,
				s,
				r,
				a
			];
		}
		const pC = /([^\w\s]|\s+)/g;
		class uC {
			string = void 0;
			map = void 0;
			constructor(e = "", t = null) {
				this.string = e, this.map = t || {
					version: 3,
					mappings: [],
					sources: [],
					names: []
				};
			}
			concat(e) {
				if ("" == e.string) return this;
				if ("" == this.string) return this.string = e.string, this.map = e.map, this;
				const t = (n = this.string).length - n.lastIndexOf("\n") - 1;
				var n;
				this.string += e.string;
				const s = this.map, r = e.map;
				if (0 == r.mappings.length) return this;
				const [a, i, o, l] = cC(s.sources, r.sources), [c, p, u, d] = cC(s.names, r.names);
				if (o && (s.sources = a), u && (s.names = c), l && d) for (let e = 0; e < r.mappings.length; e++) {
					const t = r.mappings[e];
					for (let e = 0; e < t.length; e++) {
						const n = t[e];
						n[1] >= 0 && (n[1] = i[n[1]]), n[4] >= 0 && (n[4] = p[n[4]]);
					}
				}
				else if (l) for (let e = 0; e < r.mappings.length; e++) {
					const t = r.mappings[e];
					for (let e = 0; e < t.length; e++) {
						const n = t[e];
						n[1] >= 0 && (n[1] = i[n[1]]);
					}
				}
				else if (d) for (let e = 0; e < r.mappings.length; e++) {
					const t = r.mappings[e];
					for (let e = 0; e < t.length; e++) {
						const n = t[e];
						n[4] >= 0 && (n[4] = p[n[4]]);
					}
				}
				if (r.mappings.length > 0 && t > 0) {
					const e = r.mappings[0];
					for (let n = 0; n < e.length; n++) e[n][0] += t;
				}
				return oC(s.mappings[s.mappings.length - 1], r.mappings.shift()), oC(s.mappings, r.mappings), this;
			}
			static from_processed(e, t) {
				const n = e.split("\n").length;
				if (t) {
					const s = n - t.mappings.length;
					for (let e = 0; e < s; e++) t.mappings.push([]);
					return new uC(e, t);
				}
				if ("" == e) return new uC();
				t = {
					version: 3,
					names: [],
					sources: [],
					mappings: []
				};
				for (let e = 0; e < n; e++) t.mappings.push([]);
				return new uC(e, t);
			}
			static from_source({ source: e, file_basename: t, get_location: n }) {
				let s = n(0);
				s || (s = {
					line: 0,
					column: 0
				});
				const r = {
					version: 3,
					names: [],
					sources: [t],
					mappings: []
				};
				if ("" == e) return new uC(e, r);
				const a = e.split("\n");
				for (let e = 0; e < a.length; e++) {
					r.mappings.push([]);
					const t = a[e].split(pC);
					for (let n = 0, a = 0; n < t.length; n++) "" != t[n] && (r.mappings[e].push([
						a,
						0,
						s.line + e,
						a
					]), a += t[n].length);
				}
				const i = r.mappings[0];
				for (let e = 0; e < i.length; e++) i[e][3] += s.column;
				return new uC(e, r);
			}
		}
		const dC = "undefined" != typeof window && "function" == typeof btoa ? (e) => btoa(unescape(encodeURIComponent(e))) : (e) => Buffer.from(e).toString("base64"), hC = "undefined" != typeof window && "function" == typeof atob ? atob : (e) => Buffer.from(e, "base64").toString();
		function mC(e, t) {
			if (0 == t.length) return null;
			let n = 1;
			const s = void 0 === t.slice(0, -1).find(((e) => 1 !== e.sources.length)) ? iC(t, (() => null)) : iC(t[0], ((s) => s === e && t[n] ? t[n++] : null));
			return s.file || delete s.file, s.sources.length || (s.sources = [e]), s;
		}
		const fC = /data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,(\S*)/;
		function yC(e, t, n) {
			if (t.sourcemap) {
				const s = gC(t.filename);
				e.map.sources = [s], Object.assign(e.map, function(e, t, n) {
					if (!t || !n) return t;
					const s = mC(e, [t, "string" == typeof n ? JSON.parse(n) : n]);
					return Object.defineProperties(s, {
						toString: {
							enumerable: !1,
							value: function() {
								return JSON.stringify(this);
							}
						},
						toUrl: {
							enumerable: !1,
							value: function() {
								return "data:application/json;charset=utf-8;base64," + dC(this.toString());
							}
						}
					}), s;
				}(s, e.map, t.sourcemap)), s !== n && (e.map.sources = e.map.sources.map(((e) => vC(n, e))));
			}
		}
		function vC(e, t) {
			const n = e.split(/[/\\]/), s = t.split(/[/\\]/);
			for (n.pop(); n[0] === s[0];) n.shift(), s.shift();
			if (n.length) {
				let e = n.length;
				for (; e--;) n[e] = "..";
			}
			return n.concat(s).join("/");
		}
		function gC(e) {
			return e.split(/[/\\]/).pop();
		}
		function bC(e, t, n) {
			return t ? vC(t, e) : gC(e);
		}
		function _C(e, n, s) {
			const r = new hk(e), a = {
				code: r,
				hash: n.css.hash,
				minify: n.inject_styles && !s.dev,
				selector: `.${n.css.hash}`,
				keyframes: n.css.keyframes,
				specificity: { bumped: !1 }
			}, i = n.css.ast;
			t(i, a, xC), r.remove(0, i.content.start), r.remove(i.content.end, e.length), a.minify && CC(i.content.end, a);
			const o = {
				code: r.toString(),
				map: r.generateMap({
					includeContent: !0,
					source: s.filename,
					file: s.cssOutputFilename || s.filename
				}),
				hasGlobal: n.css.has_global
			};
			return yC(o, s, o.map.sources[0]), ge && "injected" === s.css && o.code && (o.code += `\n/*# sourceMappingURL=${o.map.toUrl()} */`), o;
		}
		const xC = {
			_: (e, t) => {
				t.state.code.addSourcemapLocation(e.start), t.state.code.addSourcemapLocation(e.end), t.next();
			},
			Atrule(e, { state: t, next: n, path: s }) {
				if (Ec(e)) {
					let n = e.start + e.name.length + 1;
					for (; " " === t.code.original[n];) n += 1;
					let r = n;
					for (; "{" !== t.code.original[r] && " " !== t.code.original[r];) r += 1;
					e.prelude.startsWith("-global-") ? t.code.remove(n, n + 8) : wC(s) || t.code.prependRight(n, `${t.hash}-`);
				} else n();
			},
			Declaration(e, { state: t }) {
				const n = e.property && Pc(e.property.toLowerCase());
				if ("animation" === n || "animation-name" === n) {
					let n = e.start + e.property.length + 1, s = "";
					for (; n < t.code.original.length;) {
						const e = t.code.original[n];
						if (Sc.test(e)) {
							if (t.keyframes.includes(s) && t.code.prependRight(n - s.length, `${t.hash}-`), ";" === e || "}" === e) break;
							s = "";
						} else s += e;
						n++;
					}
				} else if (t.minify && (CC(e.start, t), !e.property.startsWith("--"))) {
					let n = e.start + e.property.length + 1, s = n;
					for (; /\s/.test(t.code.original[s]);) s++;
					s > n && t.code.remove(n, s);
				}
			},
			Rule(e, { state: t, next: n, visit: s, path: r }) {
				if (t.minify && (CC(e.start, t), CC(e.block.end - 1, t)), ge || !SC(e, wC(r))) if (PC(e) || wC(r)) {
					if (e.metadata.is_global_block) {
						const n = e.prelude.children[0];
						if (1 === e.prelude.children.length && 1 === n.children.length && 1 === n.children[0].selectors.length) return t.minify ? (t.code.remove(e.start, e.block.start + 1), t.code.remove(e.block.end - 1, e.end)) : (t.code.prependRight(e.start, "/* "), t.code.appendLeft(e.block.start + 1, "*/"), t.code.prependRight(e.block.end - 1, "/*"), t.code.appendLeft(e.block.end, "*/")), void s(e.block);
					}
					n();
				} else t.minify ? t.code.remove(e.start, e.end) : (t.code.prependRight(e.start, "/* (unused) "), t.code.appendLeft(e.end, "*/"), EC(e, t.code));
				else t.minify ? t.code.remove(e.start, e.end) : (t.code.prependRight(e.start, "/* (empty) "), t.code.appendLeft(e.end, "*/"), EC(e, t.code));
			},
			SelectorList(e, { state: t, next: n, path: s }) {
				const r = s.at(-1);
				if ((!wC(s) || e.children.length > 1 && "Rule" === r?.type && r.metadata.is_global_block) && !s.find(((e) => "ComplexSelector" === e.type && !e.metadata.used))) {
					const n = e.children;
					let s = !1, r = n[0].start, a = r, i = !1;
					for (let e = 0; e < n.length; e += 1) {
						const o = n[e];
						if (o.metadata.used === s) {
							if (s) {
								let e = o.start;
								for (; "," !== t.code.original[e];) e--;
								t.minify ? t.code.remove(r, i ? e : e + 1) : t.code.appendRight(i ? e : e + 1, "*/");
							} else 0 === e ? t.minify ? r = o.start : t.code.prependRight(o.start, "/* (unused) ") : t.minify ? r = a : t.code.overwrite(a, o.start, " /* (unused) ");
							s = !s;
						}
						!s && o.metadata.used && (i = !0), a = o.end;
					}
					s && (t.minify ? t.code.remove(r, a) : t.code.appendLeft(a, "*/"));
				}
				let a = t.specificity;
				if ("Rule" === r?.type) {
					a = { bumped: !1 };
					let e = r.metadata.parent_rule;
					for (; e;) {
						if (e.metadata.has_local_selectors) {
							a = { bumped: !0 };
							break;
						}
						e = e.metadata.parent_rule;
					}
				}
				n({
					...t,
					specificity: a
				});
			},
			ComplexSelector(e, t) {
				const n = t.state.specificity.bumped;
				for (const n of e.children) if (n.metadata.is_global) {
					const s = n.selectors[0];
					kC(s, n.combinator, t.state);
					const r = e.metadata.rule?.metadata.parent_rule;
					if (r && null === s.args && (null === n.combinator && t.state.code.prependRight(s.start, "&"), r.prelude.children.length > 1 && e.children.length === e.children.findIndex(((e) => e === n)) - 1)) {
						const e = r.prelude.children.find(((e) => e.start > s.end));
						e && e.metadata.used && t.state.code.update(s.end, e.start, "");
					}
				} else {
					for (const e of n.selectors) "PseudoClassSelector" === e.type && "global" === e.name && kC(e, null, t.state);
					if (n.metadata.scoped) {
						if (1 === n.selectors.length) {
							const e = n.selectors[0];
							if ("PseudoClassSelector" === e.type && ("is" === e.name || "where" === e.name)) continue;
						}
						if (n.selectors.some(((e) => "NestingSelector" === e.type))) continue;
						let e = t.state.selector;
						t.state.specificity.bumped && (e = `:where(${e})`), t.state.specificity.bumped = !0;
						let s = n.selectors.length;
						for (; s--;) {
							const r = n.selectors[s];
							if ("PseudoElementSelector" !== r.type && "PseudoClassSelector" !== r.type) {
								"TypeSelector" === r.type && "*" === r.name ? t.state.code.update(r.start, r.end, e) : t.state.code.appendLeft(r.end, e);
								break;
							}
							"root" !== r.name && "host" !== r.name && 0 === s && t.state.code.prependRight(r.start, e);
						}
					}
				}
				t.next(), t.state.specificity.bumped = n;
			},
			PseudoClassSelector(e, t) {
				"is" !== e.name && "where" !== e.name && "has" !== e.name && "not" !== e.name || t.next();
			}
		};
		function wC(e) {
			return e.some(((e) => "Rule" === e.type && e.metadata.is_global_block));
		}
		function kC(e, t, n) {
			if (null === e.args) {
				let s = e.start;
				if (" " === t?.name) for (; /\s/.test(n.code.original[s - 1]);) s--;
				n.code.update(s, e.start + 7, "");
			} else n.code.remove(e.start, e.start + 8).remove(e.end - 1, e.end);
		}
		function CC(e, t) {
			let n = e;
			for (; /\s/.test(t.code.original[n - 1]);) n--;
			n < e && t.code.remove(n, e);
		}
		function SC(e, t) {
			if (e.metadata.is_global_block) return 0 === e.block.children.length;
			for (const n of e.block.children) {
				if ("Declaration" === n.type) return !1;
				if ("Rule" === n.type && (PC(n) || t) && !SC(n, t)) return !1;
				if ("Atrule" === n.type && (null === n.block || n.block.children.length > 0)) return !1;
			}
			return !0;
		}
		function PC(e) {
			return e.prelude.children.some(((e) => e.metadata.used));
		}
		function EC(e, t) {
			let n = !1, s = !1;
			for (let r = e.start; r < e.end; r++) if (n) n = !1;
			else {
				const e = t.original[r];
				s ? "*" === e && "/" === t.original[r + 1] && (t.prependRight(++r, "\\"), s = !1) : "\\" === e ? n = !0 : "/" === e && "*" === t.original[++r] && (s = !0);
			}
		}
		function TC(e, t, n) {
			if ("ArrayPattern" === e.left.type || "ObjectPattern" === e.left.type || "RestElement" === e.left.type) {
				const s = t.visit(e.right), r = "Identifier" !== s.type, a = r ? ui("$$value") : s;
				let i = !1;
				const { inserts: o, paths: l } = ro(e.left, a);
				for (const { id: e } of o) e.name = t.state.scope.generate("$$array");
				const c = l.map(((e) => {
					const s = e.expression;
					let r = n("=", e.node, s, t);
					return null !== r && (i = !0), r ?? Qa("=", t.visit(e.node), t.visit(s));
				}));
				if (!i) return null;
				const p = t.path.at(-1).type.endsWith("Statement");
				if (o.length > 0 || r) {
					const e = [...o.map((({ id: e, value: t }) => Bi(e, t))), ...c.map(Pi)];
					p || e.push(Wi(a));
					const t = co(s) || c.some(((e) => co(e))), n = ei(Xa([a], Za(e), t), s);
					return t ? Ya(n) : n;
				}
				const u = ki(c);
				return p || u.expressions.push(a), u;
			}
			if ("Identifier" !== e.left.type && "MemberExpression" !== e.left.type) throw new Error(`Unexpected assignment type ${e.left.type}`);
			return n(e.operator, e.left, e.right, t);
		}
		function AC(e, t, n, s) {
			if (s.state.analysis.runes && "MemberExpression" === t.type && "ThisExpression" === t.object.type && !t.computed) {
				const r = sl(t.property), a = r && s.state.state_fields.get(r);
				if (a && "AssignmentExpression" === a.node.type && t === a.node.left) {
					const r = xc(n, s.state.scope);
					if (r) {
						const i = "PrivateIdentifier" === t.property.type || "$state" === r || "$state.raw" === r ? t.property : a.key;
						return Qa(e, fi(Ni, i, "Literal" === i.type), s.visit(n));
					}
				} else if (a && ("$derived" === a.type || "$derived.by" === a.type) && "PrivateIdentifier" === t.property.type) {
					let a = s.visit(uo(e, t, n));
					return ei(fi(Ni, r), a);
				}
			}
			let r = t;
			for (; "MemberExpression" === r.type;) r = r.object;
			if ("Identifier" !== r.type) return null;
			if ("$" === (a = r.name)[0] && /[A-Za-z_]/.test(a[1])) {
				const a = r.name.slice(1);
				if (!s.state.scope.get(a)) return null;
				if (r === t) {
					let r = s.visit(uo(e, t, n));
					return ei("$.store_set", ui(a), r);
				}
				return ei("$.store_mutate", Qa("??=", ui("$$store_subs"), vi([])), mi(r.name), ui(a), Qa(e, s.visit(t), s.visit(n)));
			}
			var a;
			const i = s.state.scope.get(r.name);
			if ("derived" === i?.kind && r === t) {
				let r = s.visit(uo(e, t, n));
				return ei(i.node, r);
			}
			return null;
		}
		const $C = /[&"<]/g, RC = /[&<]/g;
		function IC(e, t) {
			const n = String(e ?? ""), s = t ? $C : RC;
			s.lastIndex = 0;
			let r = "", a = 0;
			for (; s.test(n);) {
				const e = s.lastIndex - 1, t = n[e];
				r += n.substring(a, e) + ("&" === t ? "&amp;" : "\"" === t ? "&quot;" : "&lt;"), a = e + 1;
			}
			return r + n.substring(a);
		}
		const MC = mi("<!--[-->"), qC = mi("<!--[!-->"), LC = mi("<!--]-->"), OC = mi("<!---->");
		function NC(e, { visit: t, state: n }) {
			let s = [];
			function r() {
				if (0 === s.length) return;
				let e = xi("", !1);
				const r = [e], a = [];
				for (let i = 0; i < s.length; i++) {
					const o = s[i];
					if ("Text" === o.type || "Comment" === o.type) e.value.cooked += "Comment" === o.type ? `\x3c!--${o.data}--\x3e` : IC(o.data);
					else {
						const l = n.scope.evaluate(o.expression);
						l.is_known ? e.value.cooked += IC((l.value ?? "") + "") : (a.push(ei("$.escape", t(o.expression))), e = xi("", i + 1 === s.length), r.push(e));
					}
				}
				for (const e of r) e.value.raw = za(e.value.cooked);
				n.template.push(Ei(r, a)), s = [];
			}
			for (const a of e) if ("ExpressionTag" === a.type && a.metadata.expression.is_async()) {
				r();
				let e = ei("$$renderer.push", Ti(ei("$.escape", t(a.expression)), a.metadata.expression.has_await));
				const s = a.metadata.expression.blockers();
				s.elements.length > 0 && (e = ei("$$renderer.async", s, Xa([ui("$$renderer")], e))), n.template.push(Pi(e));
			} else "Text" === a.type || "Comment" === a.type || "ExpressionTag" === a.type ? s.push(a) : (r(), t(a, { ...n }));
			r();
		}
		function DC(e) {
			return e.type.endsWith("Statement") || e.type.endsWith("Declaration");
		}
		function jC(e) {
			let t = [], n = [];
			const s = [], r = () => {
				s.push(Pi(ei(ui("$$renderer.push"), Ei(t.map(((e, n) => xi(e, n === t.length - 1))), n)))), t = [], n = [];
			};
			for (let a = 0; a < e.length; a++) {
				const i = e[a];
				DC(i) ? (0 !== t.length && r(), s.push(i)) : (0 === t.length && t.push(""), "Literal" === i.type ? t[t.length - 1] += i.value : "TemplateLiteral" === i.type ? (t[t.length - 1] += i.quasis[0].value.cooked, t.push(...i.quasis.slice(1).map(((e) => e.value.cooked))), n.push(...i.expressions)) : (n.push(i), t.push("")));
			}
			return 0 !== t.length && r(), s;
		}
		function BC(e, t, n, s = !1, r = !1) {
			if (!0 === e) return Mi;
			if (!Array.isArray(e) || 1 === e.length) {
				const a = Array.isArray(e) ? e[0] : e;
				if ("Text" === a.type) {
					const e = s ? a.data.replace(u, " ").trim() : a.data;
					return mi(r ? e : IC(e, !0));
				}
				return n(t.visit(a.expression), a.metadata.expression);
			}
			let a = xi("", !1);
			const i = [a], o = [];
			for (let r = 0; r < e.length; r++) {
				const l = e[r];
				"Text" === l.type ? a.value.cooked += s ? l.data.replace(u, " ") : l.data : (o.push(ei("$.stringify", n(t.visit(l.expression), l.metadata.expression))), a = xi("", r + 1 === e.length), i.push(a));
			}
			for (const e of i) e.value.raw = za(e.value.cooked);
			return Ei(i, o);
		}
		function FC(e, t) {
			const n = t.scope.get(e.name);
			if (null === n || e === n.node) return e;
			if ("store_sub" === n.kind) {
				const n = ui(e.name.slice(1));
				return ei("$.store_get", Qa("??=", ui("$$store_subs"), vi([])), mi(e.name), FC(n, t));
			}
			return "derived" === n.kind ? ("var" === n.declaration_kind ? ti : ei)(n.node) : e;
		}
		function VC(e, t, n) {
			if (0 === t.elements.length && !n) return e;
			const s = Xa([ui("$$renderer")], Za(e), n);
			return t.elements.length > 0 ? [Pi(ei("$$renderer.async_block", t, s))] : [Pi(ei("$$renderer.child_block", s))];
		}
		class HC {
			expressions = [];
			has_await = !1;
			#t = /* @__PURE__ */ new Set();
			transform = (e, t) => {
				if (this.check_blockers(t), t.has_await) {
					this.has_await = !0;
					return ui("$$" + (this.expressions.push(e) - 1));
				}
				return e;
			};
			check_blockers(e) {
				for (const t of e.dependencies) t.blocker && this.#t.add(t.blocker);
			}
			#o() {
				if (0 === this.expressions.length) return oi;
				if (1 === this.expressions.length) return ji("$$0", this.expressions[0]);
				const e = Wa(this.expressions.map(((e) => "AwaitExpression" !== e.type || ho(e.argument) ? ei(Ti(e, !0)) : e.argument)));
				return ji(Ga(this.expressions.map(((e, t) => ui(`$$${t}`)))), Ya(ei("Promise.all", e)));
			}
			blockers() {
				return Wa([...this.#t]);
			}
			is_async() {
				return this.expressions.length > 0 || this.#t.size > 0;
			}
			render(e) {
				if (!this.is_async()) return e;
				const t = Xa([ui("$$renderer")], Za([this.#o(), ...e]), this.has_await), n = this.blockers();
				return n.elements.length > 0 ? [Pi(ei("$$renderer.async", n, t))] : [Pi(ei("$$renderer.child", t))];
			}
			render_block(e) {
				return this.is_async() ? VC([this.#o(), ...e], this.blockers(), this.has_await) : e;
			}
		}
		function UC(e, n) {
			const s = [], r = /* @__PURE__ */ new Map();
			for (const a of e) if ("ConstTag" === a.type) {
				const e = a.declaration.declarations[0], s = to(e.id).map(((e) => n.scope.get(e.name))), i = /* @__PURE__ */ new Set();
				t(e.init, n, {
					_: _c,
					Identifier(e, t) {
						if (Xl(e, t.path.at(-1))) {
							const n = t.state.scope.get(e.name);
							n && i.add(n);
						}
					}
				});
				for (const e of s) r.set(e, {
					node: a,
					deps: i
				});
			} else s.push(a);
			if (0 === r.size) return e;
			const a = [];
			for (const [e, t] of r) for (const n of t.deps) r.has(n) && a.push([e, n]);
			const i = kc(a);
			if (i?.length) (function(e, t) {
				zs(e, "const_tag_cycle", `Cyclical dependency detected: ${t}\nhttps://svelte.dev/e/const_tag_cycle`);
			})(r.get(i[0]).node, i.map(((e) => e.node.name)).join(" → "));
			const o = [];
			function l(e) {
				if (!o.includes(e.node)) {
					for (const t of e.deps) {
						const e = r.get(t);
						e && l(e);
					}
					o.push(e.node);
				}
			}
			for (const e of r.values()) l(e);
			return [...o, ...s];
		}
		function zC(e, t, n, s = "html", r, a, i) {
			r.analysis.runes || (t = UC(t, r));
			const l = [], u = [];
			for (const e of t) ("Comment" !== e.type || i) && ("ConstTag" === e.type || "DebugTag" === e.type || "SvelteBody" === e.type || "SvelteWindow" === e.type || "SvelteDocument" === e.type || "SvelteHead" === e.type || "TitleElement" === e.type || "SnippetBlock" === e.type ? l.push(e) : u.push(e));
			let d = u;
			if (!a) {
				let t, r;
				for (d = []; (t = u[0]) && "Text" === t.type && !p.test(t.data);) u.shift();
				for ("Text" === t?.type && (t.raw = t.raw.replace(o, ""), t.data = t.data.replace(o, "")); (r = u.at(-1)) && "Text" === r.type && !p.test(r.data);) u.pop();
				"Text" === r?.type && (r.raw = r.raw.replace(c, ""), r.data = r.data.replace(c, ""));
				const a = "svg" === s && ("RegularElement" !== e.type || "text" !== e.name) && !n.some(((e) => "RegularElement" === e.type && "text" === e.name)) || "RegularElement" === e.type && ("select" === e.name || "tr" === e.name || "table" === e.name || "tbody" === e.name || "thead" === e.name || "tfoot" === e.name || "colgroup" === e.name || "datalist" === e.name);
				for (let e = 0; e < u.length; e++) {
					const t = u[e - 1], n = u[e], s = u[e + 1];
					if ("Text" === n.type) {
						if ("ExpressionTag" !== t?.type) {
							const e = "Text" === t?.type && c.test(t.data);
							n.data = n.data.replace(o, e ? "" : " "), n.raw = n.raw.replace(o, e ? "" : " ");
						}
						"ExpressionTag" !== s?.type && (n.data = n.data.replace(c, " "), n.raw = n.raw.replace(c, " ")), !n.data || " " === n.data && a || d.push(n);
					} else d.push(n);
				}
			}
			var h = d[0];
			return "RegularElement" === e.type && "pre" === e.name && "Text" === h?.type && ("\n" !== h.data && "\r\n" !== h.data || (d.shift(), h = d[0])), 1 === d.length && "RegularElement" === h.type && "script" === h.name && d.push({
				type: "Comment",
				data: "",
				start: -1,
				end: -1
			}), {
				hoisted: l,
				trimmed: d,
				is_standalone: 1 === d.length && ("RenderTag" === h.type && !h.metadata.dynamic || "Component" === h.type && !r.options.hmr && !h.metadata.dynamic && !h.attributes.some(((e) => "Attribute" === e.type && e.name.startsWith("--")))),
				is_text_first: ("Fragment" === e.type || "SnippetBlock" === e.type || "EachBlock" === e.type || "SvelteComponent" === e.type || "SvelteBoundary" === e.type || "Component" === e.type || "SvelteSelf" === e.type) && h && ("Text" === h?.type || "ExpressionTag" === h?.type)
			};
		}
		function WC(e, n, s) {
			if ("RegularElement" === n.type && "foreignObject" === n.name) return "html";
			if ("RegularElement" === n.type || "SvelteElement" === n.type) return n.metadata.svg ? "svg" : n.metadata.mathml ? "mathml" : "html";
			if ("Fragment" === n.type || "Root" === n.type || "Component" === n.type || "SvelteComponent" === n.type || "SvelteFragment" === n.type || "SnippetBlock" === n.type || "SlotElement" === n.type) {
				const e = function(e, n) {
					const s = (e, { stop: t }) => {
						e.metadata.svg || e.metadata.mathml ? "keep" === n && (n = e.metadata.svg ? "svg" : "mathml") : (n = "html", t());
					};
					for (const r of e) if (t(r, {}, {
						_(e, { next: t }) {
							"EachBlock" !== e.type && "IfBlock" !== e.type && "AwaitBlock" !== e.type && "Fragment" !== e.type && "KeyBlock" !== e.type && "RegularElement" !== e.type && "SvelteElement" !== e.type && "Text" !== e.type || t();
						},
						SvelteElement: s,
						RegularElement: s,
						Text(e) {
							"" !== e.data.trim() && (n = "maybe_html");
						}
					}), "html" === n) return n;
					return n;
				}(s, "keep");
				if ("keep" !== e && "maybe_html" !== e) return e;
			}
			let r = null;
			for (const e of s) if ("RegularElement" === e.type) if (e.metadata.mathml) r = null === r || "mathml" === r ? "mathml" : "html";
			else {
				if (!e.metadata.svg) return "html";
				r = null === r || "svg" === r ? "svg" : "html";
			}
			return r ?? e;
		}
		function GC(e, t) {
			return "foreignObject" === e.name ? "html" : e.metadata.svg ? "svg" : e.metadata.mathml ? "mathml" : "html";
		}
		function KC(e, t, n) {
			return {
				args: ("$inspect" === e ? t : t.callee.object).arguments.map(((e) => n(e))),
				inspector: "$inspect" === e ? "console.log" : n(t.arguments[0])
			};
		}
		function XC(e, t, n) {
			const s = [], r = [], a = [], i = { default: [] }, o = {
				...n.state,
				scope: e.metadata.scopes.default
			}, l = {}, c = e.attributes.some(((e) => "Attribute" === e.type && "slot" === e.name));
			let p = !1;
			function u(e, t = !1) {
				const n = () => {
					const t = s.at(-1), n = Array.isArray(t), r = n ? t : [];
					r.push(e), n || s.push(r);
				};
				t ? r.push(n) : n();
			}
			const d = new HC();
			for (const t of e.attributes) if ("LetDirective" === t.type) c || i.default.push(t);
			else if ("SpreadAttribute" === t.type) {
				let e = n.visit(t);
				s.push(d.transform(e, t.metadata.expression));
			} else if ("Attribute" === t.type) {
				const e = BC(t.value, n, d.transform, !1, !0);
				if (t.name.startsWith("--")) {
					a.push(hi(t.name, e));
					continue;
				}
				"children" === t.name && (p = !0), u(bi("init", Gi(t.name), e));
			} else if ("BindDirective" === t.type) {
				if (d.check_blockers(t.metadata.expression), "this" === t.name) continue;
				if ("SequenceExpression" === t.expression.type) {
					const [e, s] = n.visit(t.expression).expressions, r = ui(n.state.scope.generate("bind_get")), a = ui(n.state.scope.generate("bind_set"));
					n.state.init.push(Bi(r, e)), n.state.init.push(Bi(a, s)), u(pi(t.name, [Wi(ei(r))])), u(Ci(t.name, [Pi(ei(a, ui("$$value")))]));
				} else u(pi(t.name, [Wi(n.visit(t.expression))]), !0), u(Ci(t.name, [Pi(n.visit(Qa("=", t.expression, ui("$$value")))), Pi(Qa("=", ui("$$settled"), qi))]), !0);
			} else "AttachTag" === t.type && d.check_blockers(t.metadata.expression);
			r.forEach(((e) => e()));
			const h = [], m = [];
			for (const t of e.fragment.nodes) {
				if ("SnippetBlock" === t.type) {
					n.visit(t, {
						...n.state,
						init: h
					}), u(bi("init", t.expression, t.expression)), m.push(hi("children" === t.expression.name ? "default" : t.expression.name, Mi));
					continue;
				}
				let e = "default";
				if (Jo(t)) {
					const n = t.attributes.find(((e) => "Attribute" === e.type && "slot" === e.name));
					void 0 !== n ? (e = n.value[0].data, i[e] = t.attributes.filter(((e) => "LetDirective" === e.type))) : "SvelteFragment" === t.type && i.default.push(...t.attributes.filter(((e) => "LetDirective" === e.type)));
				}
				l[e] = l[e] || [], l[e].push(t);
			}
			for (const t of Object.keys(l)) {
				const s = n.visit({
					...e.fragment,
					nodes: l[t]
				}, "default" === t ? o : {
					...n.state,
					scope: e.metadata.scopes[t]
				});
				if (0 === s.body.length) continue;
				const r = [ui("$$renderer")];
				if (i[t].length > 0) {
					const e = gi(i[t].map(((e) => null === e.expression ? hi(e.name, ui(e.name)) : "ObjectExpression" === e.expression.type ? hi(e.name, gi(e.expression.properties)) : "ArrayExpression" === e.expression.type ? hi(e.name, Ga(e.expression.elements)) : hi(e.name, e.expression))));
					r.push(e);
				}
				const a = Xa(r, Za(s.body));
				"default" !== t || p ? m.push(hi(t, a)) : 0 === i.default.length && l.default.every(((e) => "SvelteFragment" !== e.type || !e.attributes.some(((e) => "LetDirective" === e.type)))) ? (u(bi("init", ui("children"), ge ? ei("$.prevent_snippet_stringification", a) : a)), m.push(hi(t, Mi))) : (m.push(hi(t, a)), u(hi("children", ui("$.invalid_default_snippet"))));
			}
			m.length > 0 && u(bi("init", ui("$$slots"), vi(m)));
			const f = 0 === s.length || 1 === s.length && Array.isArray(s[0]) ? vi(s[0] || []) : ei("$.spread_props", Wa(s.map(((e) => Array.isArray(e) ? vi(e) : e)))), y = "SvelteComponent" === e.type || "Component" === e.type && e.metadata.dynamic;
			let v = Pi(ei(t, ui("$$renderer"), f));
			y && (v = Hi(t, Za([
				Pi(ei("$$renderer.push", MC)),
				v,
				Pi(ei("$$renderer.push", LC))
			]), Za([Pi(ei("$$renderer.push", qC)), Pi(ei("$$renderer.push", LC))]))), h.length > 0 && (v = Za([...h, v])), a.length > 0 && (v = Pi(ei("$.css_props", ui("$$renderer"), mi("svg" !== n.state.namespace), vi(a), Ti(Za([v])), y && Mi))), "SvelteSelf" !== e.type && d.check_blockers(e.metadata.expression), n.state.template.push(...d.render_block([v])), y || d.is_async() || n.state.is_standalone || 0 !== a.length || n.state.template.push(OC);
		}
		function QC(e, t, n) {
			const s = e.sync.map(((e) => n(e)));
			if (e.declarations.length > 0 && s.push(ai("var", e.declarations.map(((e) => ii(e))))), e.async.length > 0) {
				const r = e.async.map(((e) => {
					if ("VariableDeclarator" === e.node.type) {
						const t = n(Bi(e.node.id, e.node.init)), s = "VariableDeclaration" === t.type ? t.declarations.map(((e) => "Identifier" === e.id.type && (e.id.name.startsWith("$$d") || e.id.name.startsWith("$$array")) ? Bi(e.id, e.init) : Pi(Qa("=", e.id, e.init ?? si)))) : [];
						if (1 === s.length) return Ti(s[0].expression, e.has_await);
						return Ti(Za(s), e.has_await);
					}
					if ("ClassDeclaration" === e.node.type) return Ti(Qa("=", e.node.id, {
						...e.node,
						type: "ClassExpression"
					}), e.has_await);
					if ("ExpressionStatement" === e.node.type) {
						const t = n(e.node.expression);
						return "EmptyStatement" === t.type ? null : "AwaitExpression" === t.type ? Ti(t, !0) : Ti(ni("void", t), e.has_await);
					}
					return Ti(Za([n(e.node)]), e.has_await);
				}));
				s.push(Bi("$$promises", ei(t, Wa(r))));
			}
			return s;
		}
		const YC = ["class", "style"];
		function JC(e, t, n) {
			const s = [], r = [], i = [];
			let o = null, l = !1, c = /* @__PURE__ */ new Set();
			for (const p of e.attributes) if ("Attribute" === p.type) "value" === p.name ? "textarea" === e.name ? (!0 !== p.value && Array.isArray(p.value) && "Text" === p.value[0].type && a.test(p.value[0].data) && (p.value[0].data = "\n" + p.value[0].data), o = ei("$.escape", BC(p.value, t, n))) : "select" !== e.name && s.push(p) : Zi(p) ? "onload" !== p.name && "onerror" !== p.name || !ae(e.name) || c.add(p.name) : "defaultValue" !== p.name && "defaultChecked" !== p.name && ("class" === p.name && p.metadata.needs_clsx ? s.push({
				...p,
				value: {
					...p.value,
					expression: ei("$.clsx", p.value.expression)
				}
			}) : s.push(p));
			else if ("BindDirective" === p.type) {
				if ("value" === p.name && "select" === e.name) continue;
				if ("value" === p.name && s.some(((e) => "Attribute" === e.type && "type" === e.name && Xi(e) && "file" === e.value[0].data))) continue;
				if ("this" === p.name) continue;
				if (dp[p.name]?.omit_in_ssr) continue;
				let a = t.visit(p.expression);
				if ("SequenceExpression" === a.type && (a = ei(a.expressions[0])), a = n(a, p.metadata.expression), "innerHTML" === p.name) o = a;
				else if (se(p.name) || "value" === p.name && "textarea" === e.name) o = ei("$.escape", a);
				else if ("group" === p.name && "SequenceExpression" !== p.expression.type) {
					const r = e.attributes.find(((e) => "Attribute" === e.type && "value" === e.name));
					if (!r) continue;
					const a = e.attributes.some(((e) => "Attribute" === e.type && "type" === e.name && Xi(e) && "checkbox" === e.value[0].data));
					s.push(tl("checked", null, -1, -1, [{
						type: "ExpressionTag",
						start: -1,
						end: -1,
						expression: a ? ei(fi(p.expression, "includes"), BC(r.value, t, n)) : Ja("===", p.expression, BC(r.value, t, n)),
						metadata: { expression: new nl() }
					}]));
				} else s.push(tl(p.name, null, -1, -1, [{
					type: "ExpressionTag",
					start: -1,
					end: -1,
					expression: a,
					metadata: { expression: new nl() }
				}]));
			} else "SpreadAttribute" === p.type ? (s.push(p), l = !0, ae(e.name) && (c.add("onload"), c.add("onerror"))) : "UseDirective" === p.type ? ae(e.name) && (c.add("onload"), c.add("onerror")) : "ClassDirective" === p.type ? r.push(p) : "StyleDirective" === p.type ? i.push(p) : "LetDirective" === p.type || t.visit(p);
			if (l) (function(e, t, n, s, r, a) {
				let o = ei("$.attributes", ...tS(e, t, n, s, r, a));
				r.state.template.push(o);
			})(e, s, i, r, t, n);
			else {
				const a = e.metadata.scoped ? t.state.analysis.css.hash : null;
				for (const o of s) {
					const s = ZC(e, o), l = !("class" === s && 0 !== r.length || "style" === s && 0 !== i.length);
					if (l && (!0 === o.value || Xi(o))) {
						let e = BC(o.value, t, n, YC.includes(s)).value;
						"class" === s && a && (e = (String(e) + " " + a).trim()), ("class" !== s || e) && t.state.template.push(mi(` ${s}="${!0 === e ? "" : String(e)}"`));
						continue;
					}
					const c = BC(o.value, t, n, YC.includes(s));
					l && "Literal" === c.type && "string" == typeof c.value ? ("class" === s && a && (c.value = (c.value + " " + a).trim()), t.state.template.push(mi(` ${s}="${IC(c.value, !0)}"`))) : "class" === s ? t.state.template.push(nS(r, c, t, a, n)) : "style" === s ? t.state.template.push(sS(i, c, t, n)) : t.state.template.push(ei("$.attr", mi(s), c, Q(s) && Mi));
				}
			}
			if (0 !== c.size) for (const e of c) t.state.template.push(mi(` ${e}="this.__e=event"`));
			return o;
		}
		function ZC(e, t) {
			let n = t.name;
			return e.metadata.svg || e.metadata.mathml || (n = n.toLowerCase()), n;
		}
		function eS(e, t, n) {
			const s = [], r = [], a = [];
			for (const t of e.attributes) "Attribute" === t.type || "BindDirective" === t.type || "SpreadAttribute" === t.type ? s.push(t) : "ClassDirective" === t.type ? r.push(t) : "StyleDirective" === t.type && a.push(t);
			return tS(e, s, a, r, t, n);
		}
		function tS(e, t, n, s, r, a) {
			let i, o, l = 0;
			if (s.length) i = vi(s.map(((e) => hi(e.name, "Identifier" === e.expression.type && e.expression.name === e.name ? ui(e.name) : a(r.visit(e.expression), e.metadata.expression)))));
			if (n.length > 0) o = vi(n.map(((e) => hi(e.name, !0 === e.value ? ui(e.name) : BC(e.value, r, a, !0)))));
			e.metadata.svg || e.metadata.mathml ? l |= A | $ : el(e) ? l |= $ : "RegularElement" === e.type && "input" === e.name && (l |= R);
			return [
				function(e, t, n, s) {
					return vi(t.map(((t) => {
						if ("Attribute" === t.type) {
							const r = ZC(e, t), a = BC(t.value, n, s, YC.includes(r));
							return bi("init", Gi(r), a);
						}
						if ("BindDirective" === t.type) {
							const s = ZC(e, t), r = "SequenceExpression" === t.expression.type ? ei(t.expression.expressions[0]) : n.visit(t.expression);
							return bi("init", Gi(s), r);
						}
						return Si(s(n.visit(t), t.metadata.expression));
					})));
				}(e, t, r, a),
				e.metadata.scoped && r.state.analysis.css.hash ? mi(r.state.analysis.css.hash) : void 0,
				i,
				o,
				l ? mi(l) : void 0
			];
		}
		function nS(e, t, n, s, r) {
			let a, i;
			return e.length && (a = vi(e.map(((e) => bi("init", mi(e.name), r(n.visit(e.expression, n.state), e.metadata.expression)))))), s && ("Literal" === t.type && "string" == typeof t.value ? t.value = (t.value + " " + s).trim() : i = mi(s)), ei("$.attr_class", t, i, a);
		}
		function sS(e, t, n, s) {
			let r;
			if (e.length) {
				let t = [], a = [];
				for (const r of e) {
					const e = !0 === r.value ? ui(r.name) : BC(r.value, n, s, !0);
					let i = r.name;
					"-" === i[0] && "-" === i[1] || (i = i.toLowerCase());
					const o = hi(i, e);
					r.modifiers.includes("important") ? a.push(o) : t.push(o);
				}
				r = a.length ? Wa([vi(t), vi(a)]) : vi(t);
			}
			return ei("$.attr_style", t, r);
		}
		function rS(e, t, n) {
			if ("Identifier" === e.id.type) return [ii(e.id, n)];
			const s = ui(t.generate("tmp")), { paths: r, inserts: a } = ro(e.id, s);
			return [
				ii(s, n),
				...a.map((({ id: e, value: n }) => (e.name = t.generate("$$array"), ii(e, n)))),
				...r.map(((e) => {
					const t = e.expression;
					return ii(e.node, t);
				}))
			];
		}
		function aS(e, t) {
			const n = BC(e.value, t, ((e) => e), !1, !0);
			return {
				callee: n,
				pending_block: Za(jC([
					qC,
					Pi(ei(n, ui("$$renderer"))),
					LC
				]))
			};
		}
		const iS = {
			_: _c,
			AssignmentExpression: function(e, t) {
				return TC(e, t, AC) ?? t.next();
			},
			AwaitExpression: function(e, t) {
				const n = t.visit(e.argument);
				if (t.state.analysis.pickled_awaits.has(e)) return mo(n);
				let s = t.path.length;
				for (; s--;) {
					const e = t.path[s];
					if ("ArrowFunctionExpression" === e.type || "FunctionExpression" === e.type || "FunctionDeclaration" === e.type) break;
					if (e.metadata) {
						if ("ExpressionTag" !== e.type && "Fragment" !== e.type) return mo(n);
						break;
					}
				}
				return n === e.argument ? e : {
					...e,
					argument: n
				};
			},
			CallExpression: function(e, t) {
				const n = xc(e, t.state.scope);
				if ("$host" === n || "$effect" === n || "$effect.pre" === n || "$inspect.trace" === n) return si;
				if ("$effect.tracking" === n) return qi;
				if ("$effect.root" === n) return Xa([], Za([]));
				if ("$effect.pending" === n) return mi(0);
				if ("$state" === n || "$state.raw" === n) return e.arguments[0] ? t.visit(e.arguments[0]) : si;
				if ("$derived" === n || "$derived.by" === n) {
					const s = t.visit(e.arguments[0]);
					return ei("$.derived", "$derived" === n ? Ti(s) : s);
				}
				if ("$state.eager" === n) return e.arguments[0];
				if ("$state.snapshot" === n) return ei("$.snapshot", t.visit(e.arguments[0]), Ee(e, "state_snapshot_uncloneable") && Mi);
				if ("$inspect" === n || "$inspect().with" === n) {
					if (!ge) return oi;
					const { args: s, inspector: r } = KC(n, e, t.visit);
					return "$inspect" === n ? ei(r, mi("$inspect("), ...s, mi(")")) : ei(r, mi("init"), ...s);
				}
				t.next();
			},
			ClassBody: function(e, t) {
				const n = t.state.analysis.classes.get(e);
				if (!n) return void t.next();
				const s = [], r = {
					...t.state,
					state_fields: n
				};
				for (const [e, t] of n) if ("#" !== e[0] && t && "AssignmentExpression" === t.node.type && ("$derived" === t.type || "$derived.by" === t.type)) {
					const n = fi(Ni, t.key);
					s.push(_i(t.key, null), Fi("get", Gi(e), [], [Wi(ei(n))]), Fi("set", Gi(e), [ui("$$value")], [Wi(ei(n, ui("$$value")))]));
				}
				for (const a of e.body) {
					if ("PropertyDefinition" !== a.type) {
						s.push(t.visit(a, r));
						continue;
					}
					const e = sl(a.key), i = e && n.get(e);
					if (i) {
						if ("#" === e[0] || "$state" === i.type || "$state.raw" === i.type) s.push(t.visit(a, r));
						else if (i.node === a) {
							const n = fi(Ni, i.key);
							s.push(_i(i.key, t.visit(i.value, r)), Fi("get", a.key, [], [Wi(ei(n))]), Fi("set", Gi(e), [ui("$$value")], [Wi(ei(n, ui("$$value")))]));
						}
					} else s.push(t.visit(a, r));
				}
				return {
					...e,
					body: s
				};
			},
			ExpressionStatement: function(e, t) {
				const n = xc(e.expression, t.state.scope);
				if ("$effect" === n || "$effect.pre" === n || "$effect.root" === n || "$inspect.trace" === n) return oi;
				t.next();
			},
			Identifier: function(e, t) {
				if (Xl(e, t.path.at(-1))) return "$$props" === e.name ? ui("$$sanitized_props") : e.name.startsWith("$$derived_array") ? ei(e) : FC(e, t.state);
			},
			LabeledStatement: function(e, t) {
				var n, s;
				if (!(t.state.analysis.runes || t.path.length > 1 || "$" !== e.label.name)) return t.state.legacy_reactive_statements.set(e, (n = "$", s = t.visit(e.body), {
					type: "LabeledStatement",
					label: ui(n),
					body: s
				})), oi;
			},
			MemberExpression: function(e, t) {
				if (t.state.analysis.runes && "PrivateIdentifier" === e.property.type) {
					const n = t.state.state_fields?.get(`#${e.property.name}`);
					if ("$derived" === n?.type || "$derived.by" === n?.type) return ei(e);
				}
				t.next();
			},
			Program: function(e, t) {
				if (t.state.is_instance) return {
					...e,
					body: QC(t.state.analysis.instance_body, ui("$$renderer.run"), ((e) => t.visit(e)))
				};
				t.next();
			},
			PropertyDefinition: function(e, t) {
				if (t.state.analysis.runes && null != e.value && "CallExpression" === e.value.type) {
					const n = xc(e.value, t.state.scope);
					if ("$state" === n || "$state.raw" === n) return {
						...e,
						value: 0 === e.value.arguments.length ? null : t.visit(e.value.arguments[0])
					};
					if ("$derived.by" === n || "$derived" === n) {
						const s = t.visit(e.value.arguments[0]);
						return {
							...e,
							value: 0 === e.value.arguments.length ? null : ei("$.derived", "$derived" === n ? Ti(s) : s)
						};
					}
				}
				t.next();
			},
			UpdateExpression: function(e, t) {
				const n = e.argument;
				if ("Identifier" === n.type) {
					const s = t.state.scope.get(n.name);
					if ("store_sub" === s?.kind) return ei(e.prefix ? "$.update_store_pre" : "$.update_store", Qa("??=", ui("$$store_subs"), vi([])), mi(n.name), ui(n.name.slice(1)), "--" === e.operator && mi(-1));
					if ("derived" === s?.kind) return ei(e.prefix ? "$.update_derived_pre" : "$.update_derived", s.node, "--" === e.operator && mi(-1));
				}
				return t.next();
			},
			VariableDeclaration: function(e, n) {
				const s = [];
				if (n.state.analysis.runes) for (const r of e.declarations) {
					const e = r.init, a = xc(e, n.state.scope);
					if (!a || "$effect.tracking" === a || "$inspect" === a || "$effect.root" === a) {
						s.push(n.visit(r));
						continue;
					}
					if ("$props.id" === a) continue;
					if ("$props" === a) {
						let e = !1, a = t(r.id, null, {
							RestElement(t, n) {
								n.path.at(-1) === r.id && (e = !0);
							},
							AssignmentPattern(e) {
								if ("CallExpression" === e.right.type && "$bindable" === xc(e.right, n.state.scope)) {
									const t = e.right.arguments.length ? n.visit(e.right.arguments[0]) : si;
									return Ka(e.left, t);
								}
							}
						});
						const i = n.state.analysis.uses_slots ? ui("$$slots_") : ui("$$slots");
						"ObjectPattern" === a.type && e ? a.properties.splice(a.properties.length - 1, 0, bi("init", ui("$$slots"), i), bi("init", ui("$$events"), ui("$$events"))) : "Identifier" === a.type && (a = gi([
							bi("init", ui("$$slots"), i),
							bi("init", ui("$$events"), ui("$$events")),
							wi(ui(a.name))
						])), s.push(ii(n.visit(a), ui("$$props")));
						continue;
					}
					const i = e.arguments, o = i.length > 0 ? n.visit(i[0]) : si;
					if ("$derived" !== a && "$derived.by" !== a) "Identifier" !== r.id.type ? s.push(...rS(r, n.state.scope, o)) : s.push(ii(r.id, o));
					else {
						let e = "$derived" === a && n.state.analysis.async_deriveds.has(r.init) ? Ya(ei("$.async_derived", Ti(o, !0))) : ei("$.derived", "$derived" === a ? Ti(o) : o);
						if ("Identifier" === r.id.type) s.push(ii(n.visit(r.id), e));
						else {
							const t = r.init;
							let i = o;
							if ("$derived" !== a || "Identifier" !== t.arguments[0].type) {
								const t = ui(n.state.scope.generate("$$d"));
								i = ei(t), s.push(ii(t, e));
							}
							const { inserts: l, paths: c } = ro(r.id, i);
							for (const { id: e, value: t } of l) {
								e.name = n.state.scope.generate("$$derived_array");
								const r = ei("$.derived", n.visit(Ti(t)));
								s.push(ii(e, r));
							}
							for (const e of c) {
								const t = ei("$.derived", Ti(n.visit(e.expression)));
								s.push(ii(e.node, t));
							}
						}
					}
				}
				else for (const t of e.declarations) {
					const e = n.state.scope.get_bindings(t), r = e.some(((e) => "state" === e.kind)), a = e.some(((e) => "bindable_prop" === e.kind));
					if (r || a) if (a) {
						if ("Identifier" !== t.id.type) {
							const e = ui(n.state.scope.generate("tmp")), { inserts: r, paths: a } = ro(t.id, e);
							s.push(ii(e, n.visit(t.init)));
							for (const { id: e, value: t } of r) e.name = n.state.scope.generate("$$array"), s.push(ii(e, t));
							for (const e of a) {
								const t = e.expression, r = e.node.name, a = n.state.scope.get(r), i = fi(ui("$$props"), mi(a.prop_alias ?? r), !0);
								s.push(ii(e.node, po(i, t)));
							}
							continue;
						}
						const e = n.state.scope.get(t.id.name), r = fi(ui("$$props"), mi(e.prop_alias ?? t.id.name), !0);
						let a = r;
						if (t.init) a = po(r, n.visit(t.init));
						s.push(ii(t.id, a));
					} else s.push(...rS(t, n.state.scope, t.init && n.visit(t.init)));
					else s.push(n.visit(t));
				}
				return 0 === s.length ? oi : {
					...e,
					declarations: s
				};
			}
		}, oS = {
			AwaitBlock: function(e, t) {
				let n = Pi(ei("$.await", ui("$$renderer"), t.visit(e.expression), Ti(e.pending ? t.visit(e.pending) : Za([])), Xa(e.value ? [t.visit(e.value)] : [], e.then ? t.visit(e.then) : Za([]))));
				t.state.template.push(...VC([n], e.metadata.expression.blockers(), e.metadata.expression.has_await), LC);
			},
			Component: function(e, t) {
				XC(e, t.visit(ui(e.name)), t);
			},
			ConstTag: function(e, t) {
				const n = e.declaration.declarations[0], s = t.visit(n.id), r = t.visit(n.init), a = e.metadata.expression.has_await, i = [...e.metadata.expression.dependencies].map(((e) => e.blocker)).filter(((e) => null !== e && e.object !== t.state.async_consts?.id));
				if (a || t.state.async_consts || i.length > 0) {
					const e = t.state.async_consts ??= {
						id: ui(t.state.scope.generate("promises")),
						thunks: []
					}, o = to(n.id), l = t.state.scope.get_bindings(n);
					for (const e of o) t.state.init.push(Di(e.name));
					1 === i.length ? e.thunks.push(Ti(i[0])) : i.length > 0 && e.thunks.push(Ti(ei("Promise.all", Wa(i))));
					const c = Qa("=", s, r);
					e.thunks.push(Ti(Za([Pi(c)]), a));
					const p = fi(e.id, mi(e.thunks.length - 1), !0);
					for (const e of l) e.blocker = p;
				} else t.state.init.push(ji(s, r));
			},
			DebugTag: function(e, t) {
				t.state.template.push(Pi(ei("console.log", vi(e.identifiers.map(((e) => bi("init", e, t.visit(e))))))), Oi);
			},
			EachBlock: function(e, t) {
				const n = t.state, s = e.metadata, r = t.visit(e.expression), a = s.contains_group_binding || !e.index ? s.index : ui(e.index), i = n.scope.root.unique("each_array");
				let o = [ji(i, ei("$.ensure_array_like", r))];
				const l = [];
				e.context && l.push(Di(e.context, fi(i, a, !0))), a.name !== e.index && null != e.index && l.push(Di(e.index, a));
				const c = t.visit(e.body).body;
				e.body && l.push(...c);
				const p = function(e, t, n, s) {
					return {
						type: "ForStatement",
						init: e,
						test: t,
						update: n,
						body: s
					};
				}(ai("let", [ii(a, mi(0)), ii("$$length", fi(i, "length"))]), Ja("<", a, ui("$$length")), Ri("++", a, !1), Za(l));
				if (e.fallback) {
					const n = Pi(ei(ui("$$renderer.push"), MC)), s = t.visit(e.fallback);
					s.body.unshift(Pi(ei(ui("$$renderer.push"), qC))), o.push(Hi(Ja("!==", fi(i, "length"), mi(0)), Za([n, p]), s));
				} else n.template.push(MC), o.push(p);
				n.template.push(...VC(o, e.metadata.expression.blockers(), e.metadata.expression.has_await), LC);
			},
			Fragment: function(e, t) {
				const n = t.path.at(-1) ?? e, s = WC(t.state.namespace, n, e.nodes), { hoisted: r, trimmed: a, is_standalone: i, is_text_first: o } = zC(n, e.nodes, t.path, s, t.state, t.state.preserve_whitespace, t.state.options.preserveComments), l = {
					...t.state,
					init: [],
					template: [],
					namespace: s,
					is_standalone: i,
					async_consts: void 0
				};
				for (const e of r) t.visit(e, l);
				return o && l.template.push(OC), NC(a, {
					...t,
					state: l
				}), l.async_consts && l.async_consts.thunks.length > 0 && l.init.push(Bi(l.async_consts.id, ei("$$renderer.run", Wa(l.async_consts.thunks)))), Za([...l.init, ...jC(l.template)]);
			},
			HtmlTag: function(e, t) {
				const n = ei("$.html", t.visit(e.expression));
				e.metadata.expression.is_async() ? t.state.template.push(...VC([Pi(ei("$$renderer.push", n))], e.metadata.expression.blockers(), e.metadata.expression.has_await)) : t.state.template.push(n);
			},
			IfBlock: function(e, t) {
				const n = t.visit(e.consequent);
				n.body.unshift(Pi(ei(ui("$$renderer.push"), MC)));
				let s = Hi(t.visit(e.test), n), r = 1, a = s, i = e.alternate;
				for (const n of e.metadata.flattened ?? []) {
					const e = t.visit(n.consequent);
					e.body.unshift(Pi(ei(ui("$$renderer.push"), mi(`\x3c!--[${r++}--\x3e`)))), a = a.alternate = Hi(t.visit(n.test), e), i = n.alternate;
				}
				const o = i ? t.visit(i) : Za([]);
				o.body.unshift(Pi(ei(ui("$$renderer.push"), qC))), a.alternate = o, t.state.template.push(...VC([s], e.metadata.expression.blockers(), e.metadata.expression.has_await), LC);
			},
			KeyBlock: function(e, t) {
				const n = e.metadata.expression.is_async();
				n && t.state.template.push(MC), t.state.template.push(OC, t.visit(e.fragment), OC), n && t.state.template.push(LC);
			},
			RegularElement: function(e, t) {
				const n = "html" === t.state.namespace ? e.name.toLowerCase() : e.name, s = GC(e, t.state.namespace), r = {
					...t.state,
					namespace: s,
					preserve_whitespace: t.state.preserve_whitespace || "pre" === e.name || "textarea" === e.name,
					init: [],
					template: []
				}, a = z(n), i = new HC(), o = "select" === n && e.attributes.some(((e) => ("Attribute" === e.type || "BindDirective" === e.type) && "value" === e.name || "SpreadAttribute" === e.type)), l = "option" === n;
				let c = null;
				if (o || l || (r.template.push(mi(`<${n}`)), c = JC(e, {
					...t,
					state: r
				}, i.transform), r.template.push(mi(a ? "/>" : ">"))), ("script" === n || "style" === n) && 1 === e.fragment.nodes.length) return r.template.push(mi(e.fragment.nodes[0].data), mi(`</${n}>`)), void t.state.template.push(...i.render([...r.init, ...jC(r.template)]));
				const { hoisted: p, trimmed: u } = zC(e, e.fragment.nodes, t.path, s, {
					...r,
					scope: r.scopes.get(e.fragment)
				}, r.preserve_whitespace, r.options.preserveComments);
				for (const e of p) t.visit(e, r);
				if (ge) {
					const t = be(e.start);
					r.template.push(Pi(ei("$.push_element", ui("$$renderer"), mi(n), mi(t.line), mi(t.column))));
				}
				if (o) {
					const n = {
						...r,
						template: [],
						init: []
					};
					NC(u, {
						...t,
						state: n
					});
					const s = Xa([ui("$$renderer")], Za([...r.init, ...jC(n.template)])), [a, ...o] = eS(e, t, i.transform);
					rl(e) && o.push(Mi);
					const l = Pi(ei("$$renderer.select", a, s, ...o));
					t.state.template.push(...i.render([...r.init, l]));
				} else if (l) {
					let s;
					if (e.metadata.synthetic_value_node) s = i.transform(e.metadata.synthetic_value_node.expression, e.metadata.synthetic_value_node.metadata.expression);
					else {
						const a = {
							...r,
							template: [],
							init: []
						};
						NC(u, {
							...t,
							state: a
						});
						const i = [...r.init, ...jC(a.template)];
						if (ge) {
							const t = be(e.start);
							i.unshift(Pi(ei("$.push_element", ui("$$renderer"), mi(n), mi(t.line), mi(t.column)))), i.push(Pi(ei("$.pop_element")));
						}
						s = Xa([ui("$$renderer")], Za(i));
					}
					const [a, ...o] = eS(e, t, i.transform);
					rl(e) && o.push(Mi);
					const l = Pi(ei("$$renderer.option", a, s, ...o));
					t.state.template.push(...i.render([...r.init, l]));
				} else {
					if (null !== c) {
						const e = {
							...r,
							template: [],
							init: []
						};
						NC(u, {
							...t,
							state: e
						});
						let n = c;
						"Identifier" !== c.type && (n = ui(r.scope.generate("$$body")), r.template.push(ji(n, c))), r.template.push(Hi(n, Za(jC([n])), Za([...e.init, ...jC(e.template)])));
					} else NC(u, {
						...t,
						state: r
					}), "optgroup" !== n && "select" !== n || !rl(e) || r.template.push(mi("<!>"));
					a || r.template.push(mi(`</${n}>`)), ge && r.template.push(Pi(ei("$.pop_element"))), i.is_async() ? t.state.template.push(...i.render([...r.init, ...jC(r.template)])) : (t.state.init.push(...r.init), t.state.template.push(...r.template));
				}
			},
			RenderTag: function(e, t) {
				const n = new HC(), s = lo(e.expression).callee, r = lo(e.expression).arguments, a = n.transform(t.visit(s), e.metadata.expression), i = r.map(((s, r) => n.transform(t.visit(s), e.metadata.arguments[r])));
				let o = Pi(("CallExpression" === e.expression.type ? ei : ti)(a, ui("$$renderer"), ...i));
				t.state.template.push(...n.render_block([o])), n.is_async() || t.state.is_standalone || t.state.template.push(OC);
			},
			SlotElement: function(e, t) {
				const n = [], s = [], r = new HC();
				let a = mi("default");
				for (const i of e.attributes) if ("SpreadAttribute" === i.type) {
					let e = t.visit(i);
					s.push(r.transform(e, i.metadata.expression));
				} else if ("Attribute" === i.type) {
					const e = BC(i.value, t, r.transform, !1, !0);
					"name" === i.name ? a = e : "slot" !== i.name && n.push(hi(i.name, e));
				}
				const i = 0 === s.length ? vi(n) : ei("$.spread_props", Wa([vi(n), ...s])), o = 0 === e.fragment.nodes.length ? Li : Ti(t.visit(e.fragment)), l = ei("$.slot", ui("$$renderer"), ui("$$props"), a, i, o);
				t.state.template.push(MC, ...r.render_block([Pi(l)]), LC);
			},
			SnippetBlock: function(e, t) {
				let n = ci(e.expression, [ui("$$renderer"), ...e.parameters], t.visit(e.body));
				n.___snippet = !0;
				const s = e.metadata.can_hoist ? t.state.hoisted : t.state.init;
				ge && (n.body.body.unshift(Pi(ei("$.validate_snippet_args", ui("$$renderer")))), s.push(Pi(ei("$.prevent_snippet_stringification", n.id)))), s.push(n);
			},
			SpreadAttribute: function(e, t) {
				return t.visit(e.expression);
			},
			SvelteComponent: function(e, t) {
				XC(e, t.visit(e.expression), t);
			},
			SvelteElement: function(e, t) {
				let n = t.visit(e.tag);
				if (ge) {
					if ("Identifier" !== n.type) {
						const e = t.state.scope.generate("$$tag");
						t.state.init.push(ji(e, n)), n = ui(e);
					}
					t.state.init.push(Pi(ei("$.validate_dynamic_element_tag", Ti(n)))), e.fragment.nodes.length > 0 && t.state.init.push(Pi(ei("$.validate_void_dynamic_element", Ti(n))));
				}
				const s = {
					...t.state,
					namespace: GC(e, t.state.namespace),
					template: [],
					init: []
				}, r = new HC();
				let a = [];
				if (JC(e, {
					...t,
					state: s
				}, r.transform), ge) {
					const t = be(e.start);
					a.push(Pi(ei("$.push_element", ui("$$renderer"), n, mi(t.line), mi(t.column))));
				}
				const i = Za([...s.init, ...jC(s.template)]), o = t.visit(e.fragment, s);
				a.push(...r.render([Pi(ei("$.element", ui("$$renderer"), n, i.body.length > 0 && Ti(i), o.body.length > 0 && Ti(o)))])), ge && a.push(Pi(ei("$.pop_element"))), t.state.template.push(...VC(a, e.metadata.expression.blockers(), e.metadata.expression.has_await));
			},
			SvelteFragment: function(e, t) {
				t.state.template.push(t.visit(e.fragment));
			},
			SvelteHead: function(e, t) {
				const n = t.visit(e.fragment);
				t.state.template.push(Pi(ei("$.head", mi(H(me)), ui("$$renderer"), Xa([ui("$$renderer")], n))));
			},
			SvelteSelf: function(e, t) {
				XC(e, ui(t.state.analysis.name), t);
			},
			TitleElement: function(e, t) {
				const n = [mi("<title>")];
				NC(e.fragment.nodes, {
					...t,
					state: {
						...t.state,
						template: n
					}
				}), n.push(mi("</title>")), t.state.init.push(Pi(ei("$$renderer.title", Xa([ui("$$renderer")], Za(jC(n))))));
			},
			SvelteBoundary: function(e, t) {
				const n = e.fragment.nodes.find(((e) => "SnippetBlock" === e.type && "failed" === e.expression.name)), s = e.attributes.find(((e) => "Attribute" === e.type && "failed" === e.name)), r = e.attributes.find(((e) => "Attribute" === e.type && "pending" === e.name)), a = r && "object" == typeof r.value && !Array.isArray(r.value) && !t.state.scope.evaluate(r.value.expression).is_defined, i = e.fragment.nodes.find(((e) => "SnippetBlock" === e.type && "pending" === e.expression.name)), o = e.fragment.nodes.filter(((e) => !("SnippetBlock" === e.type && ["failed", "pending"].includes(e.expression.name)))), l = {
					...e.fragment,
					nodes: o
				}, c = t.visit(l, {
					...t.state,
					scope: t.state.scopes.get(e.fragment) ?? t.state.scope
				});
				let p;
				if (r || i) if (r && a && !i) {
					const { callee: e, pending_block: n } = aS(r, t);
					p = Za([Hi(e, n, Za(jC([
						MC,
						c,
						LC
					])))]);
				} else p = r ? aS(r, t).pending_block : function(e, t) {
					return Za(jC([
						qC,
						t.visit(e.body),
						LC
					]));
				}(i, t);
				else p = Za(jC([
					MC,
					c,
					LC
				]));
				if (!n && !s) return void t.state.template.push(...p.body);
				const u = vi([]);
				if (s && !n) {
					const e = BC(s.value, t, ((e) => e), !1, !0);
					u.properties.push(hi("failed", e));
				} else n && (t.visit(n, t.state), u.properties.push(hi("failed", n.expression)));
				t.state.template.push(Pi(ei("$$renderer.boundary", u, Xa([ui("$$renderer")], p))));
			}
		};
		class lS {
			#l = [];
			#c = [];
			#t = /* @__PURE__ */ new Set();
			add(e, t, n = !1) {
				this.check_blockers(t);
				if (!(t.has_call || t.has_await || n && t.has_state)) return e;
				const s = ui("#");
				return (t.has_await ? this.#c : this.#l).push({
					id: s,
					expression: e
				}), s;
			}
			check_blockers(e) {
				for (const t of e.dependencies) t.blocker && this.#t.add(t.blocker);
			}
			apply() {
				return [...this.#l, ...this.#c].map(((e, t) => (e.id.name = `$${t}`, e.id)));
			}
			blockers() {
				return this.#t.size > 0 ? Wa([...this.#t]) : void 0;
			}
			deriveds(e = !0) {
				return this.#l.map(((t) => Di(t.id, ei(e ? "$.derived" : "$.derived_safe_equal", Ti(t.expression)))));
			}
			async_ids() {
				return this.#c.map(((e) => e.id));
			}
			async_values() {
				if (0 !== this.#c.length) return Wa(this.#c.map(((e) => Ti(e.expression, !0))));
			}
			sync_values() {
				if (0 !== this.#l.length) return Wa(this.#l.map(((e) => Ti(e.expression))));
			}
		}
		function cS(e, t, n = t.state, s = ((e, t) => n.memoizer.add(e, t))) {
			const r = [];
			let a = xi("");
			const i = [a];
			let o = !1, l = !1;
			for (let c = 0; c < e.length; c++) {
				const p = e[c];
				if ("Text" === p.type) a.value.cooked += p.data;
				else if ("Literal" === p.expression.type) null != p.expression.value && (a.value.cooked += p.expression.value + "");
				else if ("Identifier" !== p.expression.type || "undefined" !== p.expression.name || n.scope.get("undefined")) {
					let u = s(fS(t, p.expression, p.metadata.expression, n), p.metadata.expression);
					const d = n.scope.evaluate(u);
					if (l ||= p.metadata.expression.has_await || p.metadata.expression.has_blockers(), o ||= l || p.metadata.expression.has_state && !d.is_known, 1 === e.length) return d.is_known && (u = mi((d.value ?? "") + "")), {
						value: u,
						has_state: o
					};
					"LogicalExpression" !== u.type || "Literal" !== u.right.type || "??" !== u.operator && "||" !== u.operator || null === u.right.value && (u = {
						...u,
						right: mi("")
					}), d.is_known ? a.value.cooked += (d.value ?? "") + "" : (d.is_defined || (u = ri("??", u, mi(""))), r.push(u), a = xi("", c + 1 === e.length), i.push(a));
				}
			}
			for (const e of i) e.value.raw = za(e.value.cooked);
			return {
				value: r.length > 0 ? Ei(i, r) : mi(a.value.cooked),
				has_state: o
			};
		}
		function pS(e) {
			const { memoizer: t } = e;
			return Pi(ei("$.template_effect", Xa(t.apply(), 1 === e.update.length && "ExpressionStatement" === e.update[0].type ? e.update[0].expression : Za(e.update)), t.sync_values(), t.async_values(), t.blockers()));
		}
		function uS(e) {
			const t = e.split(".");
			let n = t.shift(), s = ui(n);
			for (; n = t.shift();) {
				const e = !m.test(n);
				s = fi(s, e ? mi(n) : ui(n), e);
			}
			return s;
		}
		function dS(e, n, { state: s, visit: r }) {
			const [a, i] = "SequenceExpression" === e.type ? e.expressions : [null, null], o = [], l = [], c = [], p = { ...s.transform };
			t(a ?? e, null, { Identifier(e, { path: t }) {
				if (c.includes(e.name)) return;
				c.push(e.name);
				if (!Xl(e, t.at(-1))) return;
				const n = s.scope.get(e.name);
				if (n) {
					for (const [t, a] of s.scopes) if ("EachBlock" === t.type && a === n.scope) {
						o.push(e), l.push(r(e)), p[e.name] && (p[e.name] = {
							...p[e.name],
							read: (e) => e
						});
						break;
					}
				}
			} });
			const u = {
				...s,
				transform: p
			};
			let d = r(a ?? e, u), h = r(i ?? Qa("=", e, ui("$$value")), u), m = d;
			for (; "MemberExpression" === m.type;) m.optional = !0, m = m.object;
			return d = "ArrowFunctionExpression" === d.type ? Xa([...o], d.body) : "FunctionExpression" === d.type ? Vi(null, [...o], d.body) : a ? d : Xa([...o], d), h = "ArrowFunctionExpression" === h.type ? Xa([h.params[0] ?? ui("_"), ...o], h.body) : "FunctionExpression" === h.type ? Vi(null, [h.params[0] ?? ui("_"), ...o], h.body) : i ? h : Xa([ui("$$value"), ...o], h), ei("$.bind_this", n, h, d, l.length > 0 && Ti(Wa(l)));
		}
		function hS(e, t, n) {
			if ("SequenceExpression" === t.expression.type) return;
			const s = Ki(t.expression);
			if ("store_sub" === (s && e.scope.get(s.name))?.kind) return;
			const a = be(t.start), i = n.object;
			e.init.push(Pi(ei("$.validate_binding", mi(e.analysis.source.slice(t.start, t.end)), t.metadata.expression.blockers(), Ti(e.store_to_invalidate ? ki([ei("$.mark_store_binding"), i]) : i), Ti(n.computed ? n.property : mi(n.property.name)), mi(a.line), mi(a.column))));
		}
		function mS(e, t, n) {
			let s = "AssignmentExpression" === e.type ? e.left : e.argument;
			if (!ge || "MemberExpression" !== s.type || Ee(e, "ownership_invalid_mutation")) return n;
			const r = Ki(s);
			if (!r) return n;
			const a = t.state.scope.get(r.name);
			if ("prop" !== a?.kind && "bindable_prop" !== a?.kind) return n;
			t.state.analysis.needs_mutation_validation = !0;
			const i = [];
			for (; "MemberExpression" === s.type;) {
				if ("Literal" === s.property.type) i.unshift(s.property);
				else {
					if ("Identifier" !== s.property.type) return n;
					{
						const e = Object.hasOwn(t.state.transform, s.property.name) ? t.state.transform[s.property.name] : null;
						s.computed ? i.unshift(e?.read ? e.read(s.property) : s.property) : i.unshift(mi(s.property.name));
					}
				}
				s = s.object;
			}
			i.unshift(mi(r.name));
			const o = be(s.start);
			return ei("$$ownership_validator.mutation", mi(a.prop_alias), Wa(i), n, o && mi(o.line), o && mi(o.column));
		}
		function fS(e, t, n, s = e.state) {
			const r = e.visit(t, s);
			if (e.state.analysis.runes || e.state.analysis.maybe_runes) return r;
			if (!n.has_call && !n.has_member_expression && !n.has_assignment) return r;
			const a = ki([]);
			for (const e of n.references) if ("normal" !== e.kind || "import" === e.declaration_kind) {
				var i = xp({ ...e.node }, s);
				"bindable_prop" !== e.kind && "template" !== e.kind && "import" !== e.declaration_kind && "$$props" !== e.node.name && "$$restProps" !== e.node.name || (i = ei("$.deep_read_state", i)), a.expressions.push(i);
			}
			return a.expressions.push(ei("$.untrack", Ti(r))), a;
		}
		function yS(e, t, n, s) {
			if (!ge) return Pi(e);
			const r = void 0 !== t.start && be(t.start);
			return Pi(r ? ei("$.add_svelte_meta", Xa([], e), mi(n), ui(xe), mi(r.line), mi(r.column), s && vi(Object.entries(s).map((([e, t]) => hi(e, mi(t)))))) : e);
		}
		const vS = (e, t) => {
			let n = {
				...t.state,
				in_constructor: !1,
				in_derived: !1
			};
			if ("FunctionExpression" === e.type) {
				const e = t.path.at(-1);
				n.in_constructor = "MethodDefinition" === e.type && "constructor" === e.kind;
			}
			t.next(n);
		};
		function gS(e) {
			return [
				"=",
				"||=",
				"&&=",
				"??="
			].includes(e);
		}
		const bS = {
			"=": "$.assign",
			"&&=": "$.assign_and",
			"||=": "$.assign_or",
			"??=": "$.assign_nullish"
		};
		function _S(e, t, n, s) {
			if (s.state.analysis.runes && "MemberExpression" === t.type) {
				const r = sl(t.property), a = r && s.state.state_fields.get(r);
				if (a) {
					if ("AssignmentExpression" === a.node.type && t === a.node.left) {
						const t = xc(n, s.state.scope);
						if (t) {
							const i = {
								...s.state,
								in_constructor: "$derived" !== t && "$derived.by" !== t
							};
							let o = s.visit(n, i);
							if (ge) {
								const e = s.path.findLast(((e) => "ClassDeclaration" === e.type || "ClassExpression" === e.type));
								o = ei("$.tag", o, mi(`${e?.id?.name ?? "[class]"}.${r}`));
							}
							return Qa(e, fi(Ni, a.key), o);
						}
					}
					if ("PrivateIdentifier" === t.property.type) {
						let r = s.visit(uo(e, t, n));
						return ei("$.set", t, r, "$state" === a.type && gS(e) && Cp(r, s.state.scope) && Mi);
					}
				}
			}
			let r = t;
			for (; "MemberExpression" === r.type;) r = r.object;
			if ("Identifier" !== r.type) return null;
			const a = s.state.scope.get(r.name);
			if (!a) return null;
			const i = Object.hasOwn(s.state.transform, r.name) ? s.state.transform[r.name] : null, o = s.path.map(((e) => e.type));
			if (r === t && i?.assign) {
				const l = "BindDirective" === o.at(-1) && "RegularElement" === o.at(-2);
				let c = s.visit(uo(e, t, n));
				return i.assign(r, c, !l && "prop" !== a.kind && "bindable_prop" !== a.kind && "raw_state" !== a.kind && "derived" !== a.kind && "store_sub" !== a.kind && s.state.analysis.runes && Cp(n, s.state.scope) && gS(e));
			}
			if (i?.mutate) {
				let o = i.mutate(r, Qa(e, s.visit(t), s.visit(n)));
				return a.legacy_indirect_bindings.size > 0 && (o = ki([o, ei("$.invalidate_inner_signals", Xa([], Za(Array.from(a.legacy_indirect_bindings).map(((e) => Pi(xp({ ...e.node }, s.state)))))))])), o;
			}
			let l = ge && "ExpressionStatement" !== o.at(-1) && gS(e) && !s.state.scope.evaluate(n).is_primitive;
			if ("ArrowFunctionExpression" === o.at(-1) && ("RegularElement" === o.at(-2) || "SvelteElement" === o.at(-2))) s.path.at(-2).attributes.find(((e) => {
				if ("Attribute" !== e.type || !Zi(e)) return !1;
				return Yi(e) === s.path.at(-1);
			})) && (l = !1);
			if (("BindDirective" === o.at(-1) || "Component" === o.at(-1) || "SvelteComponent" === o.at(-1) || "ArrowFunctionExpression" === o.at(-1) && ("BindDirective" === o.at(-2) || "Component" === o.at(-2) && "Fragment" === o.at(-3) || "SequenceExpression" === o.at(-2) && ("Component" === o.at(-3) || "SvelteComponent" === o.at(-3) || "BindDirective" === o.at(-3)))) && (l = !1), "MemberExpression" === t.type && l) {
				const r = bS[e];
				return s.visit(ei(r, t.object, t.computed ? t.property : mi(t.property.name), n, mi(Ce(t))));
			}
			return null;
		}
		function xS(e, t) {
			let n = !1, s = e.name.slice(2);
			var r;
			(r = s).endsWith("capture") && "gotpointercapture" !== r && "lostpointercapture" !== r && (s = s.slice(0, -7), n = !0);
			const a = Array.isArray(e.value) ? e.value[0] : e.value;
			let i = kS(a.expression, a.metadata.expression, t);
			e.metadata.delegated && t.state.events.add(s);
			const o = Pi(wS(t, s, i, n, !!function(e) {
				return te.includes(e);
			}(s) || void 0, e.metadata.delegated)), l = t.path.at(-1).type;
			"SvelteDocument" === l || "SvelteWindow" === l || "SvelteBody" === l ? t.state.init.push(o) : t.state.after_update.push(o);
		}
		function wS(e, t, n, s, r, a) {
			let i = n;
			if (ge && "ArrowFunctionExpression" === n.type) i = Vi(ui(e.state.scope.generate(t)), n.params, "BlockStatement" === n.body.type ? n.body : Za([Wi(n.body)]), n.async);
			return ei(a ? "$.delegated" : "$.event", mi(t), e.state.node, i, s && Mi, void 0 === r ? void 0 : mi(r));
		}
		function kS(e, t, n) {
			if (null === e) return Vi(null, [ui("$$arg")], Za([Pi(ei("$.bubble_event.call", Ni, ui("$$props"), ui("$$arg")))]));
			let s = n.visit(e);
			if ("ArrowFunctionExpression" === s.type || "FunctionExpression" === s.type) return s;
			if ("Identifier" === s.type) {
				const e = n.state.scope.get(s.name);
				if (e?.is_function()) return s;
				if (!ge && "import" !== e?.declaration_kind) return s;
			}
			if (t.has_call) {
				const e = ui(n.state.scope.generate("event_handler"));
				n.state.init.push(Bi(e, ei("$.derived", Ti(s)))), s = ei("$.get", e);
			}
			let r = ei(fi(s, "apply", !1, !0), Ni, ui("$$args"));
			if (ge) {
				const t = be(e.start), a = "CallExpression" === e.type && 0 === e.arguments.length && "Identifier" === e.callee.type;
				r = ei("$.apply", Ti(s), Ni, ui("$$args"), ui(n.state.analysis.name), Wa([mi(t.line), mi(t.column)]), CS(e) && Mi, a && Mi);
			}
			return Vi(null, [wi(ui("$$args"))], Za([Pi(r)]));
		}
		function CS(e) {
			return "CallExpression" === e.type || "NewExpression" === e.type || "AssignmentExpression" === e.type || "UpdateExpression" === e.type || "SequenceExpression" === e.type && e.expressions.some(CS);
		}
		function SS(e) {
			return ei("$.get", e);
		}
		function PS(e) {
			for (const [t, n] of e.state.scope.declarations) (_p(n, e.state.analysis) || "derived" === n.kind || "legacy_reactive" === n.kind) && (e.state.transform[t] = {
				read: "var" === n.declaration_kind ? (e) => ei("$.safe_get", e) : SS,
				assign: (t, n, s = !1) => {
					let r = ei("$.set", t, n, s && Mi);
					return "store_sub" === e.state.scope.get(`$${t.name}`)?.kind && (r = ei("$.store_unsub", r, mi(`$${t.name}`), ui("$$stores"))), r;
				},
				mutate: (t, n) => e.state.analysis.runes ? n : ei("$.mutate", t, n),
				update: (e) => ei(e.prefix ? "$.update_pre" : "$.update", e.argument, "--" === e.operator && mi(-1))
			});
		}
		function ES(e, t) {
			if ("Identifier" === e.type) return t.state.transform[e.name] = { read: SS }, {
				id: e,
				declarations: null
			};
			const n = t.visit(e), s = to(e), r = ui("$$source"), a = ui("$$value"), i = Za([Bi(n, ei("$.get", r)), Wi(vi(s.map(((e) => bi("init", e, e)))))]), o = [Bi(a, Sp(t.state, i))];
			for (const e of s) t.state.transform[e.name] = { read: SS }, o.push(Bi(e, Sp(t.state, fi(ei("$.get", a), e))));
			return {
				id: r,
				declarations: o
			};
		}
		function TS(e, t, n, s) {
			const r = s.state.metadata.bound_contenteditable;
			let a = t, i = 0, o = [];
			function l(e, t, n) {
				const r = function(e) {
					return 0 === i ? a(e) : ei("$.sibling", a(!1), (e || 1 !== i) && mi(i), e && Mi);
				}(e);
				let o = r;
				return "Identifier" !== o.type && (o = ui(s.state.scope.generate(t), n), s.state.init.push(Bi(o, r))), a = () => o, i = 1, o;
			}
			function c(e) {
				if (e.every(((e) => "Text" === e.type))) return i += 1, void s.state.template.push_text(e);
				s.state.template.push_text([{
					type: "Text",
					data: " ",
					raw: " ",
					start: -1,
					end: -1
				}]);
				const { has_state: t, value: n } = cS(e, s), a = l(1 === e.length, "text"), o = Pi(ei("$.set_text", a, n));
				t && !r ? s.state.update.push(o) : s.state.init.push(Pi(Qa("=", fi(a, "nodeValue"), n)));
			}
			for (const t of e) if ("Text" === t.type || "ExpressionTag" === t.type) o.push(t);
			else {
				o.length > 0 && (c(o), o = []);
				let r = s.state;
				if (AS(t)) i += 1;
				else if ("EachBlock" === t.type && 1 === e.length && n && !t.metadata.expression.is_async()) t.metadata.is_controlled = !0;
				else {
					const e = l(!1, "RegularElement" === t.type ? t.name : "node", "RegularElement" === t.type ? t.name_loc : null);
					r = {
						...s.state,
						node: e
					};
				}
				s.visit(t, r);
			}
			o.length > 0 && c(o), i > 1 && (i -= 1, s.state.init.push(Pi(ei("$.next", 1 !== i && mi(i)))));
		}
		function AS(e) {
			if ("RegularElement" !== e.type) return !1;
			if (e.fragment.metadata.dynamic) return !1;
			if (el(e)) return !1;
			for (const t of e.attributes) {
				if ("Attribute" !== t.type) return !1;
				if (Zi(t)) return !1;
				if (ee(t.name)) return !1;
				if ("dir" === t.name) return !1;
				if (["input", "textarea"].includes(e.name) && ["value", "checked"].includes(t.name)) return !1;
				if ("option" === e.name && "value" === t.name) return !1;
				if ("img" === e.name && "loading" === t.name) return !1;
				if (!0 !== t.value && !Xi(t)) return !1;
			}
			return !0;
		}
		const $S = "accent-height accumulate additive alignment-baseline allowReorder alphabetic amplitude arabic-form ascent attributeName attributeType autoReverse azimuth baseFrequency baseline-shift baseProfile bbox begin bias by calcMode cap-height class clip clipPathUnits clip-path clip-rule color color-interpolation color-interpolation-filters color-profile color-rendering contentScriptType contentStyleType cursor cx cy d decelerate descent diffuseConstant direction display divisor dominant-baseline dur dx dy edgeMode elevation enable-background end exponent externalResourcesRequired fill fill-opacity fill-rule filter filterRes filterUnits flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight format from fr fx fy g1 g2 glyph-name glyph-orientation-horizontal glyph-orientation-vertical glyphRef gradientTransform gradientUnits hanging height href horiz-adv-x horiz-origin-x id ideographic image-rendering in in2 intercept k k1 k2 k3 k4 kernelMatrix kernelUnitLength kerning keyPoints keySplines keyTimes lang lengthAdjust letter-spacing lighting-color limitingConeAngle local marker-end marker-mid marker-start markerHeight markerUnits markerWidth mask maskContentUnits maskUnits mathematical max media method min mode name numOctaves offset onabort onactivate onbegin onclick onend onerror onfocusin onfocusout onload onmousedown onmousemove onmouseout onmouseover onmouseup onrepeat onresize onscroll onunload opacity operator order orient orientation origin overflow overline-position overline-thickness panose-1 paint-order pathLength patternContentUnits patternTransform patternUnits pointer-events points pointsAtX pointsAtY pointsAtZ preserveAlpha preserveAspectRatio primitiveUnits r radius refX refY rendering-intent repeatCount repeatDur requiredExtensions requiredFeatures restart result rotate rx ry scale seed shape-rendering slope spacing specularConstant specularExponent speed spreadMethod startOffset stdDeviation stemh stemv stitchTiles stop-color stop-opacity strikethrough-position strikethrough-thickness string stroke stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width style surfaceScale systemLanguage tabindex tableValues target targetX targetY text-anchor text-decoration text-rendering textLength to transform type u1 u2 underline-position underline-thickness unicode unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical values version vert-adv-y vert-origin-x vert-origin-y viewBox viewTarget visibility width widths word-spacing writing-mode x x-height x1 x2 xChannelSelector xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type xml:base xml:lang xml:space y y1 y2 yChannelSelector z zoomAndPan".split(" "), RS = /* @__PURE__ */ new Map();
		$S.forEach(((e) => {
			RS.set(e.toLowerCase(), e);
		}));
		class IS {
			contains_script_tag = !1;
			needs_import_node = !1;
			nodes = [];
			#p = [this.nodes];
			#u;
			#d = this.nodes;
			push_element(e, t, n) {
				this.#u = {
					type: "element",
					name: e,
					attributes: {},
					children: [],
					is_html: n,
					start: t
				}, this.#d.push(this.#u), this.#d = this.#u.children, this.#p.push(this.#d);
			}
			push_comment(e) {
				this.#d.push({
					type: "comment",
					data: e
				});
			}
			push_text(e) {
				this.#d.push({
					type: "text",
					nodes: e
				});
			}
			pop_element() {
				this.#p.pop(), this.#d = this.#p.at(-1);
			}
			set_prop(e, t) {
				this.#u.attributes[e] = t;
			}
			as_html() {
				return Ei([xi(this.nodes.map(MS).join(""), !0)], []);
			}
			as_tree() {
				return "comment" === this.nodes[0].type && this.nodes.unshift({
					type: "comment",
					data: void 0
				}), Wa(this.nodes.map(qS));
			}
		}
		function MS(e) {
			if ("text" === e.type) return e.nodes.map(((e) => e.raw)).join("");
			if ("comment" === e.type) return e.data ? `\x3c!--${e.data}--\x3e` : "<!>";
			let t = `<${e.name}`;
			for (const n in e.attributes) {
				const s = e.attributes[n];
				t += ` ${e.is_html ? n.toLowerCase() : n}`, void 0 !== s && (t += `="${IC(s, !0)}"`);
			}
			return z(e.name) ? t += "/>" : (t += ">", t += e.children.map(MS).join(""), t += `</${e.name}>`), t;
		}
		function qS(e) {
			if ("text" === e.type) return mi(e.nodes.map(((e) => e.data)).join(""));
			if ("comment" === e.type) return e.data ? Wa([mi(`// ${e.data}`)]) : null;
			const t = Wa([mi(e.name)]), n = vi([]);
			for (const t in e.attributes) {
				const r = e.attributes[t];
				n.properties.push(bi("init", Gi((s = (s = t).toLowerCase(), RS.get(s) || s)), void 0 === r ? si : mi(r)));
			}
			var s;
			if ((n.properties.length > 0 || e.children.length > 0) && t.elements.push(n.properties.length > 0 ? n : Li), e.children.length > 0) {
				const n = e.children.map(qS);
				if (t.elements.push(...n), "pre" === e.name || "textarea" === e.name) {
					const e = n[0];
					"Literal" === e?.type && (e.value = e.value.replace(a, ""));
				}
			}
			return t;
		}
		function LS(e) {
			const t = Wa([]);
			for (const n of e) {
				if ("element" !== n.type) continue;
				const { line: e, column: s } = be(n.start), r = Wa([mi(e), mi(s)]), a = LS(n.children);
				a.elements.length > 0 && r.elements.push(a), t.elements.push(r);
			}
			return t;
		}
		function OS(e, t, n = 0) {
			const s = "tree" === e.options.fragments, r = s ? e.template.as_tree() : e.template.as_html();
			s && ("svg" === t && (n |= E), "mathml" === t && (n |= T));
			let a = ei(s ? "$.from_tree" : `$.from_${t}`, r, n ? mi(n) : void 0);
			return e.template.contains_script_tag && (a = ei("$.with_script", a)), ge && (a = ei("$.add_locations", a, fi(ui(e.analysis.name), "$.FILENAME", !0), LS(e.template.nodes))), a;
		}
		function NS(e, t, n = t.state.memoizer) {
			let s = [];
			const r = new nl();
			for (const n of e) {
				r.merge(n.metadata.expression);
				const e = t.visit(n.expression);
				s.push(hi(n.name, e));
			}
			const a = vi(s);
			return n.add(a, r);
		}
		function DS(e, t, n = t.state.memoizer) {
			const s = vi([]), r = vi([]), a = new nl();
			for (const n of e) {
				a.merge(n.metadata.expression);
				const e = !0 === n.value ? xp(ui(n.name), t.state) : HS(n.value, t).value;
				(n.modifiers.includes("important") ? r : s).properties.push(hi(n.name, e));
			}
			const i = r.properties.length ? Wa([s, r]) : s;
			return n.add(i, a);
		}
		function jS(e, t, n, s, r) {
			return "muted" === n ? Qa("=", fi(t, ui("muted")), s) : "value" === n ? ei("$.set_value", t, s) : "checked" === n ? ei("$.set_checked", t, s) : "selected" === n ? ei("$.set_selected", t, s) : "defaultValue" === n && (r.some(((e) => "Attribute" === e.type && "value" === e.name && Xi(e))) || "textarea" === e.name && e.fragment.nodes.length > 0) ? ei("$.set_default_value", t, s) : "defaultChecked" === n && r.some(((e) => "Attribute" === e.type && "checked" === e.name && !0 === e.value)) ? ei("$.set_default_checked", t, s) : function(e) {
				return J.includes(e);
			}(n) ? Qa("=", fi(t, n), s) : ei(n.startsWith("xlink") ? "$.set_xlink_attribute" : "$.set_attribute", t, mi(n), s, Ee(e, "hydration_attribute_changed") && Mi);
		}
		function BS(e, t, n) {
			const { value: s, has_state: r } = HS(t.value, n), a = ei("$.set_custom_element_data", e, mi(t.name), s), i = r ? ei("$.template_effect", Ti(a)) : a;
			n.state.init.push(Pi(i));
		}
		function FS(e, t, n, s, r = !1) {
			const a = s.state, i = "select" === e && !0 !== n.value && !Xi(n), { value: o, has_state: l } = HS(n.value, s, ((e, t) => a.memoizer.add(e, t))), c = s.state.scope.evaluate(o), p = Qa("=", fi(t, "__value"), o), u = Qa("=", fi(t, "value"), c.is_defined ? p : ri("??", p, mi(""))), d = Pi(i ? ki([u, ei("$.select_option", t, o)]) : r ? p : u);
			if (l) {
				const n = ui(a.scope.generate(`${t.name}_value`)), s = "option" === e ? vi([]) : void 0;
				a.init.push(Bi(n, s)), a.update.push(Hi(Ja("!==", n, Qa("=", n, o)), Za([d])));
			} else a.init.push(d);
			i && a.init.push(Pi(ei("$.init_select", t)));
		}
		function VS(e, t, n, s, r, a, i = !1) {
			const o = [], l = new lS();
			for (const t of e) if ("Attribute" === t.type) {
				const { value: e } = HS(t.value, s, ((e, t) => l.add(e, t)));
				if (!Zi(t) || "ArrowFunctionExpression" !== e.type && "FunctionExpression" !== e.type) o.push(hi(t.name, e));
				else {
					const n = s.state.scope.generate("event_handler");
					s.state.init.push(Bi(n, e)), o.push(hi(t.name, ui(n)));
				}
			} else {
				let e = s.visit(t);
				e = l.add(e, t.metadata.expression), o.push(Si(e));
			}
			t.length && o.push(bi("init", Wa([ui("$.CLASS")]), NS(t, s, l))), n.length && o.push(bi("init", Wa([ui("$.STYLE")]), DS(n, s, l)));
			const c = l.apply();
			s.state.init.push(Pi(ei("$.attribute_effect", a, Xa(c, vi(o)), l.sync_values(), l.async_values(), l.blockers(), r.metadata.scoped && "" !== s.state.analysis.css.hash && mi(s.state.analysis.css.hash), i && Mi, Ee(r, "hydration_attribute_changed") && Mi)));
		}
		function HS(e, t, n = ((e) => e)) {
			if (!0 === e) return {
				value: Mi,
				has_state: !1
			};
			if (!Array.isArray(e) || 1 === e.length) {
				const s = Array.isArray(e) ? e[0] : e;
				if ("Text" === s.type) return {
					value: mi(s.data),
					has_state: !1
				};
				return {
					value: n(fS(t, s.expression, s.metadata.expression), s.metadata.expression),
					has_state: s.metadata.expression.has_state || s.metadata.expression.is_async()
				};
			}
			return cS(e, t, t.state, n);
		}
		function US(e, t) {
			return e.metadata.svg || e.metadata.mathml ? t.name : (n = (n = t.name).toLowerCase(), Y[n] ?? n);
			var n;
		}
		function zS(e, t, n, s, r, a) {
			let i, o, l, c, { value: p, has_state: u } = HS(n.value, r, ((e, t) => (n.metadata.needs_clsx && (e = ei("$.clsx", e)), r.state.memoizer.add(e, t))));
			s.length && (l = NS(s, r), u ||= s.some(((e) => e.metadata.expression.has_state || e.metadata.expression.is_async())), u ? (i = ui(r.state.scope.generate("classes")), r.state.init.push(ai("let", [ii(i)])), o = i) : o = vi([])), e.metadata.scoped && r.state.analysis.css.hash && ("Literal" !== p.type || "" !== p.value && null !== p.value ? "Literal" === p.type && "string" == typeof p.value ? p = mi(IC(p.value, !0) + " " + r.state.analysis.css.hash) : c = mi(r.state.analysis.css.hash) : p = mi(r.state.analysis.css.hash)), !c && l && (c = Li);
			let d = ei("$.set_class", t, mi(a ? 1 : 0), p, c, o, l);
			i && (d = Qa("=", i, d)), (u ? r.state.update : r.state.init).push(Pi(d));
		}
		function WS(e, t, n, s) {
			let r, a, i, { value: o, has_state: l } = HS(t.value, s, ((e, t) => s.state.memoizer.add(e, t)));
			n.length && (i = DS(n, s), l ||= n.some(((e) => e.metadata.expression.has_state || e.metadata.expression.is_async())), l ? (r = ui(s.state.scope.generate("styles")), s.state.init.push(ai("let", [ii(r)])), a = r) : a = vi([]));
			let c = ei("$.set_style", e, o, a, i);
			r && (c = Qa("=", r, c)), (l ? s.state.update : s.state.init).push(Pi(c));
		}
		function GS(e, t, n, s) {
			const r = s.state.node, a = [], i = [], o = [], l = { default: {
				...s.state,
				scope: e.metadata.scopes.default,
				transform: { ...s.state.transform }
			} }, c = {}, p = {}, u = new lS(), d = [];
			let h = null;
			const m = [], f = "SvelteComponent" === e.type || "Component" === e.type && e.metadata.dynamic, y = "Component" === e.type && e.metadata.dynamic ? s.state.scope.generate(e.name) : "$$component";
			let v = !!Ql(e), g = !1;
			function b(e, t = !1) {
				const n = () => {
					const t = a.at(-1), n = Array.isArray(t), s = n ? t : [];
					s.push(e), n || a.push(s);
				};
				t ? i.push(n) : n();
			}
			if (v) for (const t of e.attributes) "LetDirective" === t.type && s.visit(t, {
				...s.state,
				let_directives: o
			});
			for (const n of e.attributes) if ("LetDirective" === n.type) v || s.visit(n, {
				...l.default,
				let_directives: o
			});
			else if ("OnDirective" === n.type) {
				n.expression || (s.state.analysis.needs_props = !0);
				let e = kS(n.expression, n.metadata.expression, s);
				n.modifiers.includes("once") && (e = ei("$.once", e)), (p[n.name] ||= []).push(e);
			} else if ("SpreadAttribute" === n.type) {
				const e = s.visit(n), t = u.add(e, n.metadata.expression), r = e !== t;
				r || n.metadata.expression.has_state || n.metadata.expression.has_await ? a.push(Ti(r ? ei("$.get", t) : e)) : a.push(e);
			} else if ("Attribute" === n.type) {
				if (n.name.startsWith("--")) {
					d.push(hi(n.name, HS(n.value, s, ((e, t) => {
						const n = u.add(e, t);
						return e !== n ? ei("$.get", n) : e;
					})).value));
					continue;
				}
				"slot" === n.name && (v = !0), "children" === n.name && (g = !0);
				const { value: e, has_state: t } = HS(n.value, s, ((e, t) => {
					const s = t.has_await || Ji(n.value).some(((e) => "ExpressionTag" === e.type && "Identifier" !== e.expression.type && "MemberExpression" !== e.expression.type)), r = u.add(e, t, s);
					return e !== r ? ei("$.get", r) : e;
				}));
				b(t ? pi(n.name, [Wi(e)]) : hi(n.name, e));
			} else if ("BindDirective" === n.type) {
				const r = s.visit(n.expression, {
					...s.state,
					memoizer: u
				});
				if (u.check_blockers(n.metadata.expression), ge && "this" !== n.name && !Ee(e, "ownership_invalid_binding") && "SequenceExpression" !== n.expression.type) {
					const e = Ki(n.expression), a = e && s.state.scope.get(e.name);
					"bindable_prop" !== a?.kind && "prop" !== a?.kind || (s.state.analysis.needs_mutation_validation = !0, m.push(Pi(ei("$$ownership_validator.binding", mi(a.node.name), ui(f ? y : t), Ti(r)))));
				}
				if ("SequenceExpression" === r.type) if ("this" === n.name) h = n.expression;
				else {
					const [e, t] = r.expressions, a = ui(s.state.scope.generate("bind_get")), i = ui(s.state.scope.generate("bind_set"));
					s.state.init.push(Bi(a, e)), s.state.init.push(Bi(i, t)), b(pi(n.name, [Wi(ei(a))])), b(Ci(n.name, [Pi(ei(i, ui("$$value")))]));
				}
				else if (ge && "MemberExpression" === r.type && s.state.analysis.runes && !Ee(e, "binding_property_non_reactive") && hS(s.state, n, r), "this" === n.name) h = n.expression;
				else {
					const e = "Identifier" === n.expression.type && "store_sub" === s.state.scope.get(n.expression.name)?.kind, t = pi(n.name, e ? [Pi(ei("$.mark_store_binding")), Wi(r)] : [Wi(r)]), a = Qa("=", n.expression, ui("$$value")), i = Ci(n.name, [Pi(s.visit(a))]);
					t.key.loc = n.name_loc, i.key.loc = n.name_loc, b(t, !0), b(i, !0);
				}
			} else if ("AttachTag" === n.type) {
				const e = s.state.scope.evaluate(n.expression);
				let t = s.visit(n.expression);
				n.metadata.expression.has_state && (t = Xa([ui("$$node")], ei(e.is_function ? t : ri("||", t, ui("$.noop")), ui("$$node")))), u.check_blockers(n.metadata.expression), b(bi("init", ei("$.attachment"), t, !0));
			}
			if (i.forEach(((e) => e())), v && s.state.init.push(...o), Object.keys(p).length > 0) b(hi("$$events", vi(Object.keys(p).map(((e) => hi(e, p[e].length > 1 ? Wa(p[e]) : p[e][0]))))));
			const _ = [], x = [];
			for (const t of e.fragment.nodes) {
				if ("SnippetBlock" === t.type) {
					s.visit(t, {
						...s.state,
						snippets: _
					}), b(bi("init", t.expression, t.expression)), x.push(hi("children" === t.expression.name ? "default" : t.expression.name, Mi));
					continue;
				}
				let e = Ql(t) ?? "default";
				(c[e] ||= []).push(t);
			}
			for (const t of Object.keys(c)) {
				const n = s.visit({
					...e.fragment,
					nodes: c[t]
				}, "default" === t ? v ? s.state : l.default : {
					...s.state,
					scope: e.metadata.scopes[t],
					transform: { ...s.state.transform }
				});
				if (0 === n.body.length) continue;
				const r = Xa([ui("$$anchor"), ui("$$slotProps")], Za([..."default" !== t || v ? [] : o, ...n.body]));
				"default" !== t || g ? x.push(hi(t, r)) : 0 === o.length && c.default.every(((e) => "SvelteFragment" !== e.type || !e.attributes.some(((e) => "LetDirective" === e.type)))) ? (b(hi("children", ge ? ei("$.wrap_snippet", ui(s.state.analysis.name), r) : r)), x.push(hi(t, Mi))) : (x.push(hi(t, r)), b(hi("children", ui("$.invalid_default_snippet"))));
			}
			x.length > 0 && b(hi("$$slots", vi(x))), !s.state.analysis.runes && e.attributes.some(((e) => "BindDirective" === e.type)) && b(hi("$$legacy", Mi));
			const w = 0 === a.length || 1 === a.length && Array.isArray(a[0]) ? vi(a[0] || []) : ei("$.spread_props", ...a.map(((e) => Array.isArray(e) ? vi(e) : e)));
			let k = (e) => {
				const r = f ? ui(y) : s.visit(yi(t));
				return r.loc = n, ei(r, e, w);
			};
			if (null !== h) {
				const e = k;
				k = (t) => dS(h, e(t), s);
			}
			"SvelteSelf" !== e.type && u.check_blockers(e.metadata.expression);
			let C = [..._, ...u.deriveds(s.state.analysis.runes)];
			if (f) {
				const n = k;
				k = (r) => ei("$.component", r, Ti(s.visit("Component" === e.type ? yi(t) : e.expression)), Xa([ui("$$anchor"), ui(y)], Za([...m, Pi(n(ui("$$anchor")))])));
			} else C.push(...m);
			Object.keys(d).length > 0 ? ("svg" === s.state.metadata.namespace ? s.state.template.push_element("g", e.start, !1) : (s.state.template.push_element("svelte-css-wrapper", e.start, !1), s.state.template.set_prop("style", "display: contents")), s.state.template.push_comment(), s.state.template.pop_element(), C.push(Pi(ei("$.css_props", r, Ti(vi(d)))), Pi(k(fi(r, "lastChild"))), Pi(ei("$.reset", r)))) : (s.state.template.push_comment(), C.push(yS(k(r), e, "component", { componentTag: e.name }))), u.apply();
			const S = u.async_values(), P = u.blockers();
			return (S || P) && (C = [Pi(ei("$.async", r, P, S, Xa([ui("$$anchor"), ...u.async_ids()], Za(C))))], s.state.is_standalone && C.push(Pi(ei("$.next")))), C.length > 1 ? Za(C) : C[0];
		}
		function KS(e, t, n, s, r) {
			const a = ge ? [Pi(ei("$.get", t))] : [], i = s.has_await, o = [...s.dependencies].map(((e) => e.blocker)).filter(((t) => null !== t && t.object !== e.async_consts?.id));
			if (i || e.async_consts || o.length > 0) {
				const s = e.async_consts ??= {
					id: ui(e.scope.generate("promises")),
					thunks: []
				};
				e.consts.push(Di(t));
				const l = Qa("=", t, n), c = 0 === a.length ? l : Za([Pi(l), ...a]);
				1 === o.length ? s.thunks.push(Ti(fi(o[0], "promise"))) : o.length > 0 && s.thunks.push(Ti(ei("$.wait", Wa(o)))), s.thunks.push(Ti(c, i));
				const p = fi(s.id, mi(s.thunks.length - 1), !0);
				for (const e of r) e.blocker = p;
			} else e.consts.push(ji(t, n)), e.consts.push(...a);
		}
		const XS = [
			"stopPropagation",
			"stopImmediatePropagation",
			"preventDefault",
			"self",
			"trusted",
			"once"
		];
		function QS(e, t, n) {
			const s = {
				...n.state,
				node: ui(t)
			};
			for (const t of e.attributes) "OnDirective" === t.type ? n.state.init.push(Pi(n.visit(t, s))) : n.visit(t, s);
		}
		function YS(e, t, n) {
			if ("Identifier" === e.id.type) return [ii(e.id, ei("$.mutable_source", n, t.state.analysis.immutable ? Mi : void 0))];
			const s = ui(t.state.scope.generate("tmp")), { inserts: r, paths: a } = ro(e.id, s);
			return [
				ii(s, n),
				...r.map((({ id: e, value: n }) => {
					e.name = t.state.scope.generate("$$array"), t.state.transform[e.name] = { read: SS };
					return ii(e, ei("$.derived", t.visit(Ti(n))));
				})),
				...a.map(((e) => {
					const n = t.visit(e.expression), s = t.state.scope.get(e.node.name);
					return ii(e.node, "state" === s?.kind ? ei("$.mutable_source", n, t.state.analysis.immutable ? Mi : void 0) : n);
				}))
			];
		}
		const JS = {
			_: function(e, { next: t, state: n }) {
				const s = n.scopes.get(e);
				if (s && s !== n.scope) {
					const e = { ...n.transform };
					for (const [t, r] of s.declarations) ("normal" === r.kind || "state" === r.kind && !_p(r, n.analysis)) && delete e[t];
					t({
						...n,
						transform: e,
						scope: s
					});
				} else t();
			},
			AnimateDirective: function(e, t) {
				const n = null === e.expression ? Li : Ti(t.visit(e.expression));
				let s = Pi(ei("$.animation", t.state.node, Ti(t.visit(uS(e.name))), n));
				e.metadata.expression.is_async() && (s = Pi(ei("$.run_after_blockers", e.metadata.expression.blockers(), Ti(Za([s]))))), t.state.after_update.push(s);
			},
			ArrowFunctionExpression: function(e, t) {
				return vS(e, t);
			},
			AssignmentExpression: function(e, t) {
				return mS(e, t, TC(e, t, _S) ?? t.next());
			},
			Attribute: function(e, t) {
				Zi(e) && xS(e, t);
			},
			AwaitBlock: function(e, t) {
				t.state.template.push_comment();
				const n = Ti(fS(t, e.expression, e.metadata.expression), e.metadata.expression.has_await);
				let s, r;
				if (e.then) {
					const n = {
						...t,
						state: {
							...t.state,
							transform: { ...t.state.transform }
						}
					}, r = e.value && ES(e.value, n), a = [ui("$$anchor")];
					r && a.push(r.id);
					s = Xa(a, Za([...r?.declarations ?? [], ...n.visit(e.then, n.state).body]));
				}
				if (e.catch) {
					const n = {
						...t,
						state: { ...t.state }
					}, s = e.error && ES(e.error, n), a = [ui("$$anchor")];
					s && a.push(s.id);
					r = Xa(a, Za([...s?.declarations ?? [], ...n.visit(e.catch, n.state).body]));
				}
				const a = yS(ei("$.await", t.state.node, n, e.pending ? Xa([ui("$$anchor")], t.visit(e.pending)) : Li, s, r), e, "await");
				e.metadata.expression.has_blockers() ? t.state.init.push(Pi(ei("$.async", t.state.node, e.metadata.expression.blockers(), Wa([]), Xa([t.state.node], Za([a]))))) : t.state.init.push(a);
			},
			AwaitExpression: function(e, t) {
				const n = t.visit(e.argument);
				return t.state.analysis.pickled_awaits.has(e) ? mo(n) : ge && !Ee(e, "await_reactivity_loss") ? ei(Ya(ei("$.track_reactivity_loss", n))) : n === e.argument ? e : {
					...e,
					argument: n
				};
			},
			BinaryExpression: function(e, t) {
				if (ge) {
					const n = e.operator;
					if ("===" === n || "!==" === n) return ei("$.strict_equals", t.visit(e.left), t.visit(e.right), "!==" === n && qi);
					if ("==" === n || "!=" === n) return ei("$.equals", t.visit(e.left), t.visit(e.right), "!=" === n && qi);
				}
				t.next();
			},
			BindDirective: function(e, t) {
				const n = t.visit(e.expression), s = dp[e.name], r = t.path.at(-1);
				let a, i, o;
				if ("SequenceExpression" === n.type) [a, i] = n.expressions;
				else {
					ge && t.state.analysis.runes && "MemberExpression" === n.type && ("this" !== e.name || t.path.some((({ type: e }) => "IfBlock" === e || "EachBlock" === e || "AwaitBlock" === e || "KeyBlock" === e))) && !Ee(e, "binding_property_non_reactive") && hS(t.state, e, n);
					const s = t.visit(Qa("=", e.expression, ui("$$value")));
					ge ? (a = Vi(ui("get", e.name_loc), [], Za([Wi(n)])), i = Vi(ui("set", e.name_loc), [ui("$$value")], Za([Pi(s)]))) : (a = Ti(n), i = Ai(Xa([ui("$$value")], t.visit(Qa("=", e.expression, ui("$$value"))))), a === i && (i = void 0));
				}
				if (s?.event) o = ei("$.bind_property", mi(e.name), mi(s.event), t.state.node, i ?? a, s.bidirectional && a);
				else switch (e.name) {
					case "online":
						o = ei("$.bind_online", i ?? a);
						break;
					case "scrollX":
					case "scrollY":
						o = ei("$.bind_window_scroll", mi("scrollX" === e.name ? "x" : "y"), a, i);
						break;
					case "innerWidth":
					case "innerHeight":
					case "outerWidth":
					case "outerHeight":
						o = ei("$.bind_window_size", mi(e.name), i ?? a);
						break;
					case "activeElement":
						o = ei("$.bind_active_element", i ?? a);
						break;
					case "muted":
						o = ei("$.bind_muted", t.state.node, a, i);
						break;
					case "paused":
						o = ei("$.bind_paused", t.state.node, a, i);
						break;
					case "volume":
						o = ei("$.bind_volume", t.state.node, a, i);
						break;
					case "playbackRate":
						o = ei("$.bind_playback_rate", t.state.node, a, i);
						break;
					case "currentTime":
						o = ei("$.bind_current_time", t.state.node, a, i);
						break;
					case "buffered":
						o = ei("$.bind_buffered", t.state.node, i ?? a);
						break;
					case "played":
						o = ei("$.bind_played", t.state.node, i ?? a);
						break;
					case "seekable":
						o = ei("$.bind_seekable", t.state.node, i ?? a);
						break;
					case "seeking":
						o = ei("$.bind_seeking", t.state.node, i ?? a);
						break;
					case "ended":
						o = ei("$.bind_ended", t.state.node, i ?? a);
						break;
					case "readyState":
						o = ei("$.bind_ready_state", t.state.node, i ?? a);
						break;
					case "contentRect":
					case "contentBoxSize":
					case "borderBoxSize":
					case "devicePixelContentBoxSize":
						o = ei("$.bind_resize_observer", t.state.node, mi(e.name), i ?? a);
						break;
					case "clientWidth":
					case "clientHeight":
					case "offsetWidth":
					case "offsetHeight":
						o = ei("$.bind_element_size", t.state.node, mi(e.name), i ?? a);
						break;
					case "value":
						o = "RegularElement" === r?.type && "select" === r.name ? ei("$.bind_select_value", t.state.node, a, i) : ei("$.bind_value", t.state.node, a, i);
						break;
					case "files":
						o = ei("$.bind_files", t.state.node, a, i);
						break;
					case "this":
						o = dS(e.expression, t.state.node, t);
						break;
					case "textContent":
					case "innerHTML":
					case "innerText":
						o = ei("$.bind_content_editable", mi(e.name), t.state.node, a, i);
						break;
					case "checked":
						o = ei("$.bind_checked", t.state.node, a, i);
						break;
					case "focused":
						o = ei("$.bind_focused", t.state.node, i ?? a);
						break;
					case "group": {
						const s = e.metadata.parent_each_blocks.map(((e) => e.metadata.keyed && e.index ? ei("$.get", e.metadata.index) : e.metadata.index));
						let l = a;
						if ("RegularElement" === r?.type) {
							const e = r.attributes.find(((e) => "Attribute" === e.type && "value" === e.name && !Xi(e) && !0 !== e.value))?.value;
							void 0 !== e && (l = Ti(Za([Pi(HS(e, t).value), Wi(n)])));
						}
						o = ei("$.bind_group", e.metadata.binding_group_name, Wa(s), t.state.node, l, i ?? a);
						break;
					}
					default: throw new Error("unknown binding " + e.name);
				}
				const l = "this" !== e.name && "RegularElement" === r.type && r.attributes.find(((e) => "UseDirective" === e.type));
				let c = Pi(l ? ei("$.effect", Ti(o)) : o);
				e.metadata.expression.is_async() && (c = Pi(ei("$.run_after_blockers", e.metadata.expression.blockers(), Ti(Za([c]))))), "this" === e.name || l ? t.state.init.push(c) : t.state.after_update.push(c);
			},
			BlockStatement: function(e, t) {
				PS(t);
				const n = t.state.scope.tracing;
				if (null !== n) {
					const s = t.path.at(-1).async, r = ei("$.trace", n, Ti(Za(e.body.map(((e) => t.visit(e)))), s));
					return Za([Wi(s ? Ya(r) : r)]);
				}
				t.next();
			},
			BreakStatement: function(e, t) {
				if (t.state.analysis.runes || !e.label || "$" !== e.label.name) return;
				return "LabeledStatement" === t.path[1].type && "$" === t.path[1].label.name ? Wi() : void 0;
			},
			CallExpression: function(e, t) {
				const n = xc(e, t.state.scope);
				switch (n) {
					case "$host": return ui("$$props.$$host");
					case "$effect.tracking": return ei("$.effect_tracking");
					case "$state":
					case "$state.raw": {
						let s, r = e.arguments[0];
						r && (s = t.visit(e.arguments[0]), "$state" === n && Cp(r, t.state.scope) && (s = ei("$.proxy", s)));
						return ei(ui("$.state", e.callee.loc), s);
					}
					case "$derived":
					case "$derived.by": {
						let s = t.visit(e.arguments[0]);
						return ei("$.derived", "$derived" === n ? Ti(s) : s);
					}
					case "$state.eager": return ei("$.eager", Ti(t.visit(e.arguments[0])));
					case "$state.snapshot": return ei("$.snapshot", t.visit(e.arguments[0]), Ee(e, "state_snapshot_uncloneable") && Mi);
					case "$effect":
					case "$effect.pre": {
						const s = ei("$effect" === n ? "$.user_effect" : "$.user_pre_effect", t.visit(e.arguments[0]));
						return s.callee.loc = e.callee.loc, s;
					}
					case "$effect.root": return ei("$.effect_root", ...e.arguments.map(((e) => t.visit(e))));
					case "$effect.pending": return ei("$.eager", Ti(ei("$.pending")));
					case "$inspect":
					case "$inspect().with": return function(e, t, n) {
						if (!ge) return oi;
						const { args: s, inspector: r } = KC(e, t, n.visit), a = ui("$$args"), i = Xa([wi(a)], ei(r, Si(a)));
						return ei("$.inspect", Ti(Wa(s)), i, "$inspect" === e && Mi);
					}(n, e, t);
				}
				if (ge && "MemberExpression" === e.callee.type && "Identifier" === e.callee.object.type && "console" === e.callee.object.name && null === t.state.scope.get("console") && "Identifier" === e.callee.property.type && [
					"debug",
					"dir",
					"error",
					"group",
					"groupCollapsed",
					"info",
					"log",
					"trace",
					"warn"
				].includes(e.callee.property.name) && e.arguments.some(((e) => "SpreadElement" === e.type || t.state.scope.evaluate(e).has_unknown))) return ei(e.callee, Si(ei("$.log_if_contains_state", mi(e.callee.property.name), ...e.arguments.map(((e) => t.visit(e))))));
				t.next();
			},
			ClassBody: function(e, t) {
				const n = t.state.analysis.classes.get(e);
				if (!n) return void t.next();
				const s = [], r = {
					...t.state,
					state_fields: n
				};
				for (const [e, t] of n) if ("#" !== e[0] && "AssignmentExpression" === t.node.type) {
					const n = fi(Ni, t.key), r = "$state" === t.type && !0, a = Gi(e);
					s.push(_i(t.key, null), Fi("get", a, [], [Wi(ei("$.get", n))]), Fi("set", a, [ui("value")], [Pi(ei("$.set", n, ui("value"), r && Mi))]));
				}
				const a = io(t.path, -1);
				for (const i of e.body) {
					if ("PropertyDefinition" !== i.type) {
						s.push(t.visit(i, r));
						continue;
					}
					const e = sl(i.key), o = e && n.get(e);
					if (o) {
						if ("#" === e[0]) {
							let n = i.value ? t.visit(i.value, r) : void 0;
							ge && o.node === i && (n = ei("$.tag", n, mi(`${a.id?.name ?? "[class]"}.${e}`))), s.push(_i(i.key, n));
						} else if (o.node === i) {
							let n = t.visit(o.value, r);
							ge && (n = ei("$.tag", n, mi(`${a.id?.name ?? "[class]"}.${e}`)));
							const l = fi(Ni, o.key), c = "$state" === o.type && !0;
							s.push(_i(o.key, n), Fi("get", i.key, [], [Wi(ei("$.get", l))]), Fi("set", i.key, [ui("value")], [Pi(ei("$.set", l, ui("value"), c && Mi))]));
						}
					} else s.push(t.visit(i, r));
				}
				return {
					...e,
					body: s
				};
			},
			Comment: function(e, t) {
				t.state.template.push_comment(e.data);
			},
			Component: function(e, t) {
				const n = GS(e, e.name, e.name_loc, t);
				t.state.init.push(n);
			},
			ConstTag: function(e, t) {
				const n = e.declaration.declarations[0];
				if ("Identifier" === n.id.type) {
					const s = fS(t, n.init, e.metadata.expression);
					let r = Sp(t.state, s, e.metadata.expression.has_await);
					ge && (r = ei("$.tag", r, mi(n.id.name))), t.state.transform[n.id.name] = { read: SS }, KS(t.state, n.id, r, e.metadata.expression, t.state.scope.get_bindings(n));
				} else {
					const s = to(n.id), r = ui(t.state.scope.generate("computed_const")), a = { ...t.state.transform };
					for (const e of s) delete a[e.name];
					const i = {
						...t.state,
						transform: a
					}, o = fS({
						...t,
						state: i
					}, n.init, e.metadata.expression), l = Za([ji(t.visit(n.id, i), o), Wi(vi(s.map(((e) => bi("init", e, e)))))]);
					let c = Sp(t.state, l, e.metadata.expression.has_await);
					ge && (c = ei("$.tag", c, mi("[@const]"))), KS(t.state, r, c, e.metadata.expression, t.state.scope.get_bindings(n));
					for (const e of s) t.state.transform[e.name] = { read: (e) => fi(ei("$.get", r), e) };
				}
			},
			DebugTag: function(e, t) {
				const s = ei("console.log", vi(e.identifiers.map(((e) => {
					const n = ei("$.snapshot", t.visit(e));
					return bi("init", e, t.state.analysis.runes ? n : ei("$.untrack", Ti(n)));
				}))));
				t.state.init.push(Pi(ei("$.template_effect", Ti(Za([Pi(s), Oi])))));
			},
			EachBlock: function(e, t) {
				const n = e.metadata, s = {
					...t.state,
					scope: t.state.scope.parent
				}, r = fS({
					...t,
					state: s
				}, e.expression, e.metadata.expression);
				n.is_controlled || t.state.template.push_comment();
				let a = 0;
				e.metadata.keyed && e.index && (a |= 2);
				const i = "Identifier" === e.key?.type && "Identifier" === e.context?.type && e.context?.name === e.key.name;
				let o;
				for (const t of e.metadata.expression.dependencies) if ("store_sub" === t.kind) {
					o = !0;
					break;
				}
				for (const n of e.metadata.expression.dependencies) if (!(n.scope.function_depth >= t.state.scope.function_depth) && (!t.state.analysis.runes || !i || o)) {
					a |= 1;
					break;
				}
				t.state.analysis.runes && !o && (a |= 16), e.key && e.body.nodes.some(((e) => ("RegularElement" === e.type || "SvelteElement" === e.type) && e.attributes.some(((e) => "AnimateDirective" === e.type)))) && (a |= 8), n.is_controlled && (a |= 4);
				let l = "";
				for (const t of e.metadata.expression.dependencies) if ("store_sub" === t.kind) {
					l = t.node.name;
					break;
				}
				let c = null;
				for (const [e] of t.state.scope.declarations) if (null != t.state.scope.parent?.get(e)) {
					c = t.state.scope.root.unique("$$array");
					break;
				}
				const p = {
					...t.state,
					transform: { ...t.state.transform },
					store_to_invalidate: l
				}, u = {
					...t.state,
					transform: { ...t.state.transform }
				}, d = n.contains_group_binding || !e.index ? n.index : ui(e.index), h = "Identifier" === e.context?.type ? e.context : ui("$$item");
				let m = n.contains_group_binding, f = !1;
				e.index && (p.transform[e.index] = { read: (e) => (m = !0, 0 != (2 & a) ? SS(e) : e) }, u.transform[e.index] = { read: (e) => (f = !0, e) });
				const y = [], v = l ? ei("$.invalidate_store", ui("$$stores"), mi(l)) : void 0, g = [];
				if (!t.state.analysis.runes) {
					const e = /* @__PURE__ */ new Set();
					if (c) e.add(c), p.transform[c.name] = { read: ei };
					else for (const t of n.transitive_deps) e.add(t.node);
					for (const n of function(e) {
						return e.path.filter(((e) => "EachBlock" === e.type));
					}(t)) for (const t of n.metadata.transitive_deps) e.add(t.node);
					if (e.size > 0) {
						const n = ei("$.invalidate_inner_signals", Ti(ki([...e].map(((e) => t.visit({ ...e }, p))))));
						g.push(n);
					}
				}
				if (v && g.push(v), "Identifier" === e.context?.type) {
					const n = t.state.scope.get(e.context.name);
					p.transform[e.context.name] = {
						read: (e) => n.reassigned ? fi(c ? ei(c) : r, 0 != (2 & a) ? SS(d) : d, !0) : 0 != (1 & a) ? SS(e) : e,
						assign: (e, t) => {
							m = !0;
							return ki([Qa("=", fi(c ? ei(c) : r, 0 != (2 & a) ? SS(d) : d, !0), t), ...g]);
						},
						mutate: (e, t) => (m = !0, ki([t, ...g]))
					}, delete u.transform[e.context.name];
				} else if (e.context) {
					const n = 0 != (1 & a) ? ei("$.get", h) : h, { inserts: s, paths: r } = ro(e.context, n);
					for (const { id: e, value: n } of s) {
						e.name = t.state.scope.generate("$$array"), p.transform[e.name] = { read: SS };
						const s = t.visit(Ti(n), p);
						y.push(Bi(e, ei("$.derived", s)));
					}
					for (const e of r) {
						const n = e.node.name, s = e.has_default_value, r = Ti(t.visit(e.expression, p));
						y.push(Di(e.node, s ? ei("$.derived_safe_equal", r) : r));
						const a = s ? SS : ei;
						p.transform[n] = {
							read: a,
							assign: (t, n) => ki([Qa("=", e.update_expression, n), ...g]),
							mutate: (e, t) => ki([t, ...g])
						}, ge && y.push(Pi(a(ui(n)))), delete u.transform[n];
					}
				}
				const b = t.visit(e.body, p);
				let _ = ui("$.index");
				if (e.metadata.keyed) {
					const n = e.context, s = t.visit(e.key, u);
					_ = Xa(f ? [n, d] : [n], s);
				}
				e.index && n.contains_group_binding && y.push(Di(e.index, d));
				const x = e.metadata.expression.has_await, w = Ti(r, x), k = x ? Ti(ei("$.get", ui("$$collection"))) : w, C = [ui("$$anchor"), h];
				(m || c) && C.push(d), c && C.push(c);
				const S = [
					t.state.node,
					mi(a),
					k,
					_,
					Xa(C, Za(y.concat(b.body)))
				];
				e.fallback && S.push(Xa([ui("$$anchor")], t.visit(e.fallback)));
				const P = [yS(ei("$.each", ...S), e, "each")];
				e.metadata.expression.is_async() ? t.state.init.push(Pi(ei("$.async", t.state.node, e.metadata.expression.blockers(), x ? Wa([w]) : si, Xa(x ? [t.state.node, ui("$$collection")] : [t.state.node], Za(P))))) : t.state.init.push(...P);
			},
			ExportNamedDeclaration: function(e, t) {
				return t.state.is_instance ? e.declaration ? t.visit(e.declaration) : oi : t.next();
			},
			ExpressionStatement: function(e, t) {
				if ("CallExpression" === e.expression.type) {
					if ("$inspect.trace" === xc(e.expression, t.state.scope)) return oi;
				}
				t.next();
			},
			ForOfStatement: function(e, t) {
				if (e.await && ge && !Ee(e, "await_reactivity_loss") && t.state.options.experimental.async) {
					const n = t.visit(e.left), s = t.visit(e.right), r = t.visit(e.body);
					return function(e, t, n, s = !1) {
						return {
							type: "ForOfStatement",
							left: e,
							right: t,
							body: n,
							await: s
						};
					}(n, ei("$.for_await_track_reactivity_loss", s), r, !0);
				}
				t.next();
			},
			Fragment: function(e, t) {
				const n = t.path.at(-1) ?? e, s = WC(t.state.metadata.namespace, n, e.nodes), { hoisted: r, trimmed: a, is_standalone: i, is_text_first: o } = zC(n, e.nodes, t.path, s, t.state, t.state.preserve_whitespace, t.state.options.preserveComments);
				if (0 === r.length && 0 === a.length) return Za([]);
				const l = 1 === a.length && "RegularElement" === a[0].type, c = 1 === a.length && ("SvelteFragment" === a[0].type || "TitleElement" === a[0].type || "IfBlock" === a[0].type && a[0].elseif && n.metadata.flattened?.includes(a[0])), p = t.state.scope.root.unique("root"), u = [];
				let d;
				const h = {
					...t.state,
					init: [],
					snippets: [],
					consts: [],
					let_directives: [],
					update: [],
					after_update: [],
					memoizer: new lS(),
					template: new IS(),
					transform: { ...t.state.transform },
					metadata: {
						namespace: s,
						bound_contenteditable: t.state.metadata.bound_contenteditable
					},
					async_consts: void 0
				};
				for (const e of r) t.visit(e, h);
				if (l) {
					const e = a[0], n = ui(t.state.scope.generate(e.name), e.name_loc);
					t.visit(e, {
						...h,
						node: n
					});
					const r = OS(h, s, h.template.needs_import_node ? 2 : void 0);
					h.hoisted.push(Bi(p, r)), h.init.unshift(Bi(n, ei(p))), d = Pi(ei("$.append", ui("$$anchor"), n));
				} else if (c) t.visit(a[0], h);
				else if (1 === a.length && "Text" === a[0].type) {
					const e = ui(t.state.scope.generate("text"));
					h.init.unshift(Bi(e, ei("$.text", mi(a[0].data)))), d = Pi(ei("$.append", ui("$$anchor"), e));
				} else if (a.length > 0) {
					const e = ui(t.state.scope.generate("fragment"));
					if (a.some(((e) => "ExpressionTag" === e.type)) && a.every(((e) => "Text" === e.type || "ExpressionTag" === e.type))) {
						const e = ui(t.state.scope.generate("text"));
						TS(a, (() => e), !1, {
							...t,
							state: h
						}), h.init.unshift(Bi(e, ei("$.text"))), d = Pi(ei("$.append", ui("$$anchor"), e));
					} else if (i) TS(a, (() => ui("$$anchor")), !1, {
						...t,
						state: {
							...h,
							is_standalone: i
						}
					});
					else {
						TS(a, ((t) => ei("$.first_child", e, t && Mi)), !1, {
							...t,
							state: h
						});
						let n = 1;
						if (h.template.needs_import_node && (n |= 2), 1 === h.template.nodes.length && "comment" === h.template.nodes[0].type) h.init.unshift(Bi(e, ei("$.comment")));
						else {
							const t = OS(h, s, n);
							h.hoisted.push(Bi(p, t)), h.init.unshift(Bi(e, ei(p)));
						}
						d = Pi(ei("$.append", ui("$$anchor"), e));
					}
				}
				return u.push(...h.snippets, ...h.let_directives, ...h.consts), h.async_consts && h.async_consts.thunks.length > 0 && u.push(Bi(h.async_consts.id, ei("$.run", Wa(h.async_consts.thunks)))), o && u.push(Pi(ei("$.next"))), u.push(...h.init), h.update.length > 0 && u.push(pS(h)), u.push(...h.after_update), void 0 !== d && u.push(d), Za(u);
			},
			FunctionDeclaration: function(e, t) {
				const n = {
					...t.state,
					in_constructor: !1,
					in_derived: !1
				};
				t.next(n);
			},
			FunctionExpression: function(e, t) {
				return vS(e, t);
			},
			HtmlTag: function(e, t) {
				t.state.template.push_comment();
				const n = e.metadata.expression.has_await, s = e.metadata.expression.has_blockers(), r = fS(t, e.expression, e.metadata.expression), a = n ? ei("$.get", ui("$$html")) : r, i = "svg" === t.state.metadata.namespace, o = "mathml" === t.state.metadata.namespace, l = Pi(ei("$.html", t.state.node, Ti(a), i && Mi, o && Mi, Ee(e, "hydration_html_changed") && Mi));
				n || s ? t.state.init.push(Pi(ei("$.async", t.state.node, e.metadata.expression.blockers(), n ? Wa([Ti(r, !0)]) : si, Xa(n ? [t.state.node, ui("$$html")] : [t.state.node], Za([l]))))) : t.state.init.push(l);
			},
			Identifier: function(e, t) {
				const n = t.path.at(-1);
				if (Xl(e, n)) {
					if ("$$props" === e.name) return ui("$$sanitized_props");
					const s = t.state.scope.get(e.name);
					if (t.state.analysis.runes && null !== s && e !== s.node && "rest_prop" === s.kind) {
						const e = t.path.at(-2);
						if ("MemberExpression" === n?.type && !n.computed && "AssignmentExpression" !== e?.type && "UpdateExpression" !== e?.type) {
							const e = n.property;
							if (!s.metadata?.exclude_props?.includes(e.name)) return ui("$$props");
						}
					}
					return xp(e, t.state);
				}
			},
			IfBlock: function(e, t) {
				t.state.template.push_comment();
				const n = [], s = e.metadata.expression.has_await, r = e.metadata.expression.has_blockers(), a = fS(t, e.test, e.metadata.expression);
				let i, o, l, c = 0;
				for (const s of [e, ...e.metadata.flattened ?? []]) {
					const e = t.visit(s.consequent), r = ui(t.state.scope.generate("consequent"));
					let a;
					if (n.push(Bi(r, Xa([ui("$$anchor")], e))), s.metadata.expression.has_await) a = ei("$.get", ui("$$condition"));
					else {
						const e = fS(t, s.test, s.metadata.expression);
						if (s.metadata.expression.has_call) {
							const s = ui(t.state.scope.generate("d"));
							n.push(Bi(s, ei("$.derived", Xa([], e)))), a = ei("$.get", s);
						} else a = e;
					}
					const p = Hi(a, Pi(ei("$$render", r, c > 0 && mi(c))));
					o ? o.alternate = p : i = p, l = s, o = p, c++;
				}
				if (o && l?.alternate) {
					const e = t.visit(l.alternate), s = ui(t.state.scope.generate("alternate"));
					n.push(Bi(s, Xa([ui("$$anchor")], e))), o.alternate = Pi(ei("$$render", s, mi(!1)));
				}
				const p = [t.state.node, Xa([ui("$$render")], Za(i ? [i] : []))];
				e.elseif && p.push(Mi), n.push(yS(ei("$.if", ...p), e, "if")), s || r ? t.state.init.push(Pi(ei("$.async", t.state.node, e.metadata.expression.blockers(), s ? Wa([Ti(a, !0)]) : si, Xa(s ? [t.state.node, ui("$$condition")] : [t.state.node], Za(n))))) : t.state.init.push(Za(n));
			},
			KeyBlock: function(e, t) {
				t.state.template.push_comment();
				const n = e.metadata.expression.has_await, s = e.metadata.expression.has_blockers(), r = fS(t, e.expression, e.metadata.expression), a = Ti(n ? ei("$.get", ui("$$key")) : r), i = t.visit(e.fragment), o = yS(ei("$.key", t.state.node, a, Xa([ui("$$anchor")], i)), e, "key");
				n || s ? t.state.init.push(Pi(ei("$.async", t.state.node, e.metadata.expression.blockers(), n ? Wa([Ti(r, !0)]) : si, Xa(n ? [t.state.node, ui("$$key")] : [t.state.node], Za([o]))))) : t.state.init.push(o);
			},
			LabeledStatement: function(e, t) {
				if (t.state.analysis.runes || t.path.length > 1 || "$" !== e.label.name) return void t.next();
				const n = t.state.analysis.reactive_statements.get(e);
				if (!n) return;
				let s = t.visit(e.body);
				"BlockStatement" !== s.type && (s = Za([s]));
				const r = s.body, a = [];
				for (const e of n.dependencies) {
					if ("normal" === e.kind && "import" !== e.declaration_kind) continue;
					const n = e.node.name;
					let s = xp(ui(n), t.state);
					"$$props" !== n && "$$restProps" !== n && "bindable_prop" !== e.kind || (s = ei("$.deep_read_state", s)), a.push(s);
				}
				return t.state.legacy_reactive_statements.set(e, Pi(ei("$.legacy_pre_effect", a.length > 0 ? Ti(ki(a)) : Ti(Za([])), Ti(Za(r))))), oi;
			},
			LetDirective: function(e, t) {
				if (e.expression && "Identifier" !== e.expression.type) {
					const n = t.state.scope.generate(e.name), s = t.state.scope.get_bindings(e);
					for (const e of s) t.state.transform[e.node.name] = { read: (e) => fi(ei("$.get", ui(n)), e) };
					t.state.let_directives.push(ji(n, ei("$.derived", Ti(Za([Di("ObjectExpression" === e.expression.type ? gi(e.expression.properties) : Ga(e.expression.elements), fi(ui("$$slotProps"), e.name)), Wi(vi(s.map(((e) => hi(e.node.name, e.node)))))])))));
				} else {
					const n = null === e.expression ? e.name : e.expression.name;
					t.state.transform[n] = { read: (e) => ei("$.get", e) }, t.state.let_directives.push(ji(n, Sp(t.state, fi(ui("$$slotProps"), e.name))));
				}
			},
			MemberExpression: function(e, t) {
				if ("PrivateIdentifier" === e.property.type) {
					const n = t.state.state_fields.get("#" + e.property.name);
					if (n) return !t.state.in_constructor || "$state.raw" !== n.type && "$state" !== n.type ? ei("$.get", e) : fi(e, "v");
				}
				t.next();
			},
			OnDirective: function(e, t) {
				e.expression || (t.state.analysis.needs_props = !0);
				let n = kS(e.expression, e.metadata.expression, t);
				for (const t of XS) e.modifiers.includes(t) && (n = ei("$." + t, n));
				const s = e.modifiers.includes("capture"), r = e.modifiers.includes("passive") || !e.modifiers.includes("nonpassive") && void 0;
				return wS(t, e.name, n, s, r, !1);
			},
			Program: function(e, t) {
				if (!t.state.analysis.runes) {
					t.state.transform.$$props = { read: (e) => ({
						...e,
						name: "$$sanitized_props"
					}) };
					for (const [e, n] of t.state.scope.declarations) if ("import" === n.declaration_kind && n.mutated) {
						const { start: s, end: r } = t.state.analysis.instance.ast, a = n.initial;
						if (a.start > s && a.end < r) {
							const n = ui("$$_import_" + e);
							t.state.transform[e] = {
								read: (e) => ei(n),
								mutate: (e, t) => ei(n, t)
							}, t.state.legacy_reactive_imports.push(Bi(n, ei("$.reactive_import", Ti(ui(e)))));
						}
					}
				}
				for (const [e, n] of t.state.scope.declarations) {
					if ("store_sub" === n.kind) {
						let n;
						const s = () => n ??= t.visit(ui(e.slice(1)));
						t.state.transform[e] = {
							read: ei,
							assign: (e, t) => ei("$.store_set", s(), t),
							mutate: (e, t) => {
								const n = ei("$.untrack", e);
								function r(e) {
									return "MemberExpression" === e.type ? {
										...e,
										object: r(e.object),
										property: e.property
									} : n;
								}
								return ei("$.store_mutate", s(), "AssignmentExpression" === t.type ? Qa(t.operator, r(t.left), t.right) : Ri(t.operator, r(t.argument), t.prefix), n);
							},
							update: (n) => ei(n.prefix ? "$.update_pre_store" : "$.update_store", xp(ui(e.slice(1)), t.state), ei(n.argument), "--" === n.operator && mi(-1))
						};
					}
					if ("prop" === n.kind || "bindable_prop" === n.kind) if (kp(n, t.state)) t.state.transform[e] = {
						read: ei,
						assign: (e, t) => ei(e, t),
						mutate: (e, t) => "bindable_prop" === n.kind ? ei(e, t, Mi) : t,
						update: (e) => ei(e.prefix ? "$.update_pre_prop" : "$.update_prop", e.argument, "--" === e.operator && mi(-1))
					};
					else if (n.prop_alias) {
						const s = Gi(n.prop_alias);
						t.state.transform[e] = { read: (e) => fi(ui("$$props"), s, "Literal" === s.type) };
					} else t.state.transform[e] = { read: (e) => fi(ui("$$props"), e) };
				}
				if (PS(t), t.state.is_instance) return {
					...e,
					body: QC(t.state.analysis.instance_body, ui("$.run"), ((e) => t.visit(e)))
				};
				t.next();
			},
			RegularElement: function(e, t) {
				const n = "html" === t.state.metadata.namespace && "svg" !== e.name, s = n ? e.name.toLowerCase() : e.name;
				if (t.state.template.push_element(s, e.start, n), "noscript" === s) return void t.state.template.pop_element();
				const r = el(e);
				t.state.template.needs_import_node ||= "video" === s || r, t.state.template.contains_script_tag ||= "script" === s;
				const a = [], i = [], o = [], l = [], c = [], p = /* @__PURE__ */ new Map(), u = /* @__PURE__ */ new Map();
				let d = e.metadata.has_spread, h = !1, m = !1;
				for (const n of e.attributes) switch (n.type) {
					case "AnimateDirective":
					case "OnDirective":
					case "TransitionDirective":
					case "AttachTag":
						l.push(n);
						break;
					case "Attribute":
						if ("is" === n.name && "html" === t.state.metadata.namespace) {
							const { value: e } = HS(n.value, t);
							if ("Literal" === e.type && "string" == typeof e.value) {
								t.state.template.set_prop("is", e.value);
								continue;
							}
						}
						a.push(n), p.set(n.name, n);
						break;
					case "BindDirective":
						u.set(n.name, n), l.push(n);
						break;
					case "ClassDirective":
						i.push(n);
						break;
					case "LetDirective":
						t.visit(n, {
							...t.state,
							let_directives: c
						});
						break;
					case "SpreadAttribute":
						a.push(n);
						break;
					case "StyleDirective":
						o.push(n);
						break;
					case "UseDirective": h = !0, l.push(n);
				}
				const f = {
					...t.state,
					init: [],
					after_update: []
				};
				for (const e of l) if ("OnDirective" === e.type) {
					const n = t.visit(e);
					h ? f.init.push(Pi(ei("$.effect", Ti(n)))) : f.after_update.push(Pi(n));
				} else t.visit(e, f);
				if ("input" === s) {
					const e = a.some(((e) => "Attribute" === e.type && ("value" === e.name || "checked" === e.name) && !Xi(e)));
					!a.some(((e) => "Attribute" === e.type && ("defaultValue" === e.name || "defaultChecked" === e.name))) && (d || u.has("value") || u.has("checked") || u.has("group") || !u.has("group") && e) && (d ? m = !0 : t.state.init.push(Pi(ei("$.remove_input_defaults", t.state.node))));
				}
				if ("textarea" === s) {
					const e = p.get("value") ?? p.get("checked"), n = e && !Xi(e);
					(d || u.has("value") || n) && t.state.init.push(Pi(ei("$.remove_textarea_child", t.state.node)));
				}
				t.state.init.push(...c);
				const y = t.state.node, v = "option" === s || "select" === s || u.has("group") || u.has("checked");
				if (d) VS(a, i, o, t, e, y, m);
				else for (const s of a) {
					if (Zi(s)) {
						xS(s, t);
						continue;
					}
					if (v && "value" === s.name) continue;
					const l = US(e, s);
					if (r || ee(s.name) || !0 !== s.value && !Xi(s) || "class" === l && 0 !== i.length || "style" === l && 0 !== o.length) if ("autofocus" === l) {
						let { value: e } = HS(s.value, t);
						t.state.init.push(Pi(ei("$.autofocus", y, e)));
					} else if ("class" === l) zS(e, y, s, i, t, n);
					else if ("style" === l) WS(y, s, o, t);
					else if (r) BS(y, s, t);
					else {
						const { value: n, has_state: r } = HS(s.value, t, ((e, n) => t.state.memoizer.add(e, n))), i = jS(e, y, l, n, a);
						(r ? t.state.update : t.state.init).push(Pi(i));
					}
					else {
						let n = !Xi(s) || s.value[0].data;
						"class" === l && e.metadata.scoped && t.state.analysis.css.hash && (!0 === n || "" === n ? n = t.state.analysis.css.hash : n += " " + t.state.analysis.css.hash), ("class" !== l || n) && t.state.template.set_prop(s.name, !0 === n ? "" : n);
					}
				}
				ae(s) && (d || h || p.has("onload") || p.has("onerror")) && t.state.after_update.push(Pi(ei("$.replay_events", y)));
				const g = {
					...t.state.metadata,
					namespace: GC(e, t.state.metadata.namespace)
				};
				if (u.has("innerHTML") || u.has("innerText") || u.has("textContent")) {
					const e = p.get("contenteditable");
					e && (!0 === e.value || Xi(e) && "true" === e.value[0].data) && (g.bound_contenteditable = !0);
				}
				const b = {
					...t.state,
					metadata: g,
					scope: t.state.scopes.get(e.fragment),
					preserve_whitespace: t.state.preserve_whitespace || "pre" === s || "textarea" === s
				}, { hoisted: _, trimmed: x } = zC(e, e.fragment.nodes, t.path, b.metadata.namespace, b, "script" === s || b.preserve_whitespace, b.options.preserveComments), w = {
					...b,
					init: [],
					update: [],
					after_update: [],
					snippets: []
				};
				for (const e of _) t.visit(e, w);
				if (x.every(((e) => "Text" === e.type || "ExpressionTag" === e.type)) && x.every(((e) => "Text" === e.type || !e.metadata.expression.has_state && !e.metadata.expression.has_await && !e.metadata.expression.has_blockers())) && x.some(((e) => "ExpressionTag" === e.type))) {
					const { value: e } = cS(x, t, w);
					"Literal" === e.type && "" === e.value || w.init.push(Pi(Qa("=", fi(t.state.node, "textContent"), e)));
				} else if (rl(e)) {
					const e = t.state.node;
					t.state.template.push_comment();
					const n = t.state.scope.root.unique(`${s}_content`), r = ui(t.state.scope.generate("fragment")), a = ui(t.state.scope.generate("anchor")), i = {
						...b,
						init: [],
						update: [],
						after_update: [],
						template: new IS()
					};
					TS(x, ((e) => ei("$.first_child", r, e && Mi)), !1, {
						...t,
						state: i
					});
					const o = OS(i, g.namespace, 1);
					t.state.hoisted.push(Bi(n, o));
					const l = Za([
						Bi(a, ei("$.child", e)),
						Bi(r, ei(n)),
						...i.init,
						...i.update.length > 0 ? [pS(i)] : [],
						...i.after_update,
						Pi(ei("$.append", a, r))
					]);
					w.init.push(Pi(ei("$.customizable_select", e, Xa([], l))));
				} else {
					let e = t.state.node, n = x.some(((e) => "Text" !== e.type && !AS(e)));
					"template" === s && (n = !0, w.init.push(Pi(ei("$.hydrate_template", e))), e = fi(e, "content")), TS(x, ((t) => ei("$.child", e, t && Mi)), !0, {
						...t,
						state: w
					}), n && w.init.push(Pi(ei("$.reset", t.state.node)));
				}
				if (e.fragment.nodes.some(((e) => "SnippetBlock" === e.type)) ? t.state.init.push(Za([
					...w.snippets,
					...w.init,
					...f.init,
					w.update.length > 0 ? pS(w) : oi,
					...w.after_update,
					...f.after_update
				])) : e.fragment.metadata.dynamic ? (t.state.init.push(...w.init, ...f.init), t.state.update.push(...w.update), t.state.after_update.push(...w.after_update, ...f.after_update)) : (t.state.init.push(...f.init), t.state.after_update.push(...f.after_update)), "selectedcontent" === s && t.state.init.push(Pi(ei("$.selectedcontent", t.state.node, Xa([ui("$$element")], Qa("=", t.state.node, ui("$$element")))))), p.has("dir")) {
					const e = fi(y, "dir");
					t.state.update.push(Pi(Qa("=", e, e)));
				}
				if (!d && v) {
					if (e.metadata.synthetic_value_node) {
						const n = e.metadata.synthetic_value_node;
						FS(s, y, tl("value", null, n.start, n.end, [n]), t, !0);
					} else for (const e of a) if ("value" === e.name) {
						FS(s, y, e, t);
						break;
					}
				}
				t.state.template.pop_element();
			},
			RenderTag: function(e, t) {
				t.state.template.push_comment();
				const n = lo(e.expression);
				let s = [];
				const r = new lS();
				for (let a = 0; a < n.arguments.length; a++) {
					const i = n.arguments[a], o = e.metadata.arguments[a];
					let l = fS(t, i, o);
					const c = r.add(l, o);
					l !== c && (l = ei("$.get", c)), s.push(Ti(l));
				}
				r.apply();
				const a = r.deriveds(t.state.analysis.runes);
				let i = fS(t, n.callee, e.metadata.expression);
				e.metadata.dynamic ? ("ChainExpression" === e.expression.type && (i = ri("??", i, ui("$.noop"))), a.push(yS(ei("$.snippet", t.state.node, Ti(i), ...s), e, "render"))) : a.push(yS(("CallExpression" === e.expression.type ? ei : ti)(i, t.state.node, ...s), e, "render"));
				const o = r.async_values(), l = r.blockers();
				o || l ? (t.state.init.push(Pi(ei("$.async", t.state.node, l, r.async_values(), Xa([t.state.node, ...r.async_ids()], Za(a))))), t.state.is_standalone && t.state.init.push(Pi(ei("$.next")))) : t.state.init.push(1 === a.length ? a[0] : Za(a));
			},
			SlotElement: function(e, t) {
				t.state.template.push_comment();
				const n = [], s = [], r = [], a = new lS();
				let i = mi("default");
				for (const o of e.attributes) if ("SpreadAttribute" === o.type) s.push(Ti(t.visit(o)));
				else if ("Attribute" === o.type) {
					const { value: e, has_state: s } = HS(o.value, t, ((e, t) => t.has_call || t.has_await ? ei("$.get", a.add(e, t)) : e));
					"name" === o.name ? i = e : "slot" !== o.name && (s ? n.push(pi(o.name, [Wi(e)])) : n.push(hi(o.name, e)));
				} else "LetDirective" === o.type && t.visit(o, {
					...t.state,
					let_directives: r
				});
				a.apply(), t.state.init.push(...r);
				const o = a.deriveds(t.state.analysis.runes), l = 0 === s.length ? vi(n) : ei("$.spread_props", vi(n), ...s), c = 0 === e.fragment.nodes.length ? Li : Xa([ui("$$anchor")], t.visit(e.fragment));
				o.push(Pi(ei("$.slot", t.state.node, ui("$$props"), i, l, c)));
				const p = a.async_values(), u = a.blockers();
				p || u ? t.state.init.push(Pi(ei("$.async", t.state.node, u, p, Xa([t.state.node, ...a.async_ids()], Za(o))))) : t.state.init.push(1 === o.length ? o[0] : Za(o));
			},
			SnippetBlock: function(e, t) {
				const n = [ui("$$anchor")];
				let s;
				const r = [], a = { ...t.state.transform }, i = {
					...t.state,
					transform: a
				};
				for (let s = 0; s < e.parameters.length; s++) {
					const o = e.parameters[s];
					if (!o) continue;
					if ("Identifier" === o.type) {
						n.push(Ka(o, ui("$.noop"))), a[o.name] = { read: ei };
						continue;
					}
					let l = `$$arg${s}`;
					n.push(ui(l));
					const { inserts: c, paths: p } = ro(o, ti(ui(l)));
					for (const { id: e, value: n } of c) e.name = t.state.scope.generate("$$array"), a[e.name] = { read: SS }, r.push(Bi(e, ei("$.derived", t.visit(Ti(n)))));
					for (const e of p) {
						const n = e.node.name, s = e.has_default_value, o = Ti(t.visit(e.expression, i));
						r.push(Di(e.node, s ? ei("$.derived_safe_equal", o) : o)), a[n] = { read: s ? SS : ei }, ge && r.push(Pi(a[n].read(ui(n))));
					}
				}
				const o = t.visit(e.body, i).body;
				s = Za([
					ge ? Pi(ei("$.validate_snippet_args", Si(ui("arguments")))) : oi,
					...r,
					...o
				]);
				let l = ge ? ei("$.wrap_snippet", ui(t.state.analysis.name), Vi(null, n, s)) : Xa(n, s);
				const c = ji(e.expression, l);
				1 === t.path.length && "Fragment" === t.path[0].type ? e.metadata.can_hoist ? t.state.module_level_snippets.push(c) : t.state.instance_level_snippets.push(c) : t.state.snippets.push(c);
			},
			SpreadAttribute: function(e, t) {
				return t.visit(e.expression);
			},
			SvelteBody: function(e, t) {
				QS(e, "$.document.body", t);
			},
			SvelteComponent: function(e, t) {
				const n = GS(e, "$$component", null, t);
				t.state.init.push(n);
			},
			SvelteDocument: function(e, t) {
				QS(e, "$.document", t);
			},
			SvelteElement: function(e, t) {
				t.state.template.push_comment();
				const n = [];
				let s;
				const r = [], a = [], i = [], o = ui(t.state.scope.generate("$$element")), l = {
					...t,
					state: {
						...t.state,
						node: o,
						init: [],
						update: [],
						after_update: [],
						memoizer: new lS()
					}
				};
				for (const o of e.attributes) if ("Attribute" === o.type) "xmlns" !== o.name || Xi(o) || (s = o.value), n.push(o);
				else if ("SpreadAttribute" === o.type) n.push(o);
				else if ("ClassDirective" === o.type) r.push(o);
				else if ("StyleDirective" === o.type) a.push(o);
				else if ("LetDirective" === o.type) i.push(t.visit(o));
				else if ("OnDirective" === o.type) {
					const e = t.visit(o, l.state);
					l.state.after_update.push(Pi(e));
				} else t.visit(o, l.state);
				1 === n.length && "Attribute" === n[0].type && "class" === n[0].name.toLowerCase() && Xi(n[0]) ? zS(e, o, n[0], r, l, !1) : n.length && VS(n, r, a, l, e, o);
				const c = e.metadata.expression.has_await, p = e.metadata.expression.has_blockers(), u = t.visit(e.tag), d = Ti(c ? ei("$.get", ui("$$tag")) : u), h = l.state.init;
				l.state.update.length > 0 && h.push(pS(l.state)), h.push(...l.state.after_update), h.push(...t.visit(e.fragment, {
					...t.state,
					metadata: {
						...t.state.metadata,
						namespace: GC(e, t.state.metadata.namespace)
					}
				}).body), ge && (i.push(Pi(ei("$.validate_dynamic_element_tag", d))), e.fragment.nodes.length > 0 && i.push(Pi(ei("$.validate_void_dynamic_element", d))));
				const m = ge && be(e.start);
				i.push(Pi(ei("$.element", t.state.node, d, e.metadata.svg || e.metadata.mathml ? Mi : qi, h.length > 0 && Xa([o, ui("$$anchor")], Za(h)), s && Ti(HS(s, t).value), m && Wa([mi(m.line), mi(m.column)])))), c || p ? t.state.init.push(Pi(ei("$.async", t.state.node, e.metadata.expression.blockers(), c ? Wa([Ti(u, !0)]) : si, Xa(c ? [t.state.node, ui("$$tag")] : [t.state.node], Za(i))))) : t.state.init.push(1 === i.length ? i[0] : Za(i));
			},
			SvelteFragment: function(e, t) {
				for (const n of e.attributes) "LetDirective" === n.type && t.visit(n);
				t.state.init.push(...t.visit(e.fragment).body);
			},
			SvelteBoundary: function(e, t) {
				const n = vi([]);
				for (const s of e.attributes) {
					if ("Attribute" !== s.type || !0 === s.value) continue;
					const e = Array.isArray(s.value) ? s.value[0] : s.value, r = t.visit(e.expression, t.state);
					e.metadata.expression.has_state ? n.properties.push(pi(s.name, [Wi(r)])) : n.properties.push(hi(s.name, r));
				}
				const s = [], r = [], a = [];
				let i = !1;
				for (const n of e.fragment.nodes) "ConstTag" === n.type && (i = !0, t.state.options.experimental.async || t.visit(n, {
					...t.state,
					consts: r,
					scope: t.state.scopes.get(e.fragment) ?? t.state.scope
				}));
				for (const o of e.fragment.nodes) if ("ConstTag" !== o.type) if ("SnippetBlock" !== o.type) s.push(o);
				else if (t.state.options.experimental.async && i && !["failed", "pending"].includes(o.expression.name)) s.push(o);
				else {
					const e = [];
					t.visit(o, {
						...t.state,
						snippets: e
					});
					const s = e[0], i = ge ? s.declarations[0].init.arguments[1] : s.declarations[0].init;
					t.state.options.experimental.async || i.body.body.unshift(...r.filter(((e) => "VariableDeclaration" === e.type))), ["failed", "pending"].includes(o.expression.name) && n.properties.push(bi("init", o.expression, o.expression)), a.push(s);
				}
				else t.state.options.experimental.async && s.push(o);
				const o = t.visit({
					...e.fragment,
					nodes: s
				}, {
					...t.state,
					scope: t.state.scopes.get(e.fragment) ?? t.state.scope
				});
				t.state.options.experimental.async || o.body.unshift(...r);
				const l = Pi(ei("$.boundary", t.state.node, n, Xa([ui("$$anchor")], o)));
				t.state.template.push_comment(), t.state.init.push(a.length > 0 ? Za([...a, l]) : l);
			},
			SvelteHead: function(e, t) {
				t.state.init.push(Pi(ei(ui("$.head", e.name_loc), mi(H(me)), Xa([ui("$$anchor")], t.visit(e.fragment)))));
			},
			SvelteSelf: function(e, t) {
				const n = GS(e, xe, e.name_loc, t);
				t.state.init.push(n);
			},
			SvelteWindow: function(e, t) {
				QS(e, "$.window", t);
			},
			TitleElement: function(e, t) {
				const n = new lS(), { has_state: s, value: r } = cS(e.fragment.nodes, t, t.state, ((e, t) => n.add(e, t))), a = t.state.scope.evaluate(r), i = Pi(Qa("=", fi(ui("$.document"), ui("title", e.name_loc)), a.is_known ? mi(a.value) : a.is_defined ? r : ri("??", r, mi(""))));
				s ? t.state.after_update.push(Pi(ei("$.deferred_template_effect", Xa(n.apply(), Za([i])), n.sync_values(), n.async_values(), n.blockers()))) : t.state.after_update.push(Pi(ei("$.effect", Ti(Za([i])))));
			},
			TransitionDirective: function(e, t) {
				let n = e.modifiers.includes("global") ? 4 : 0;
				e.intro && (n |= 1), e.outro && (n |= 2);
				const s = [
					mi(n),
					t.state.node,
					Ti(t.visit(uS(e.name)))
				];
				e.expression && s.push(Ti(t.visit(e.expression)));
				let r = Pi(ei("$.transition", ...s));
				e.metadata.expression.is_async() && (r = Pi(ei("$.run_after_blockers", e.metadata.expression.blockers(), Ti(Za([r]))))), t.state.after_update.push(r);
			},
			UpdateExpression: function(e, t) {
				const n = e.argument;
				if ("MemberExpression" === n.type && "ThisExpression" === n.object.type && "PrivateIdentifier" === n.property.type && t.state.state_fields.has("#" + n.property.name)) {
					let t = "$.update";
					e.prefix && (t += "_pre");
					const s = [n];
					return "--" === e.operator && s.push(mi(-1)), ei(t, ...s);
				}
				if ("Identifier" !== n.type && "MemberExpression" !== n.type) throw new Error("An impossible state was reached");
				const s = Ki(n), r = s && t.state.transform[s.name];
				if (s === n && r?.update) return r.update(e);
				let a = t.next();
				return s && r?.mutate && (a = r.mutate(s, a)), mS(e, t, a);
			},
			UseDirective: function(e, t) {
				const n = [ui("$$node")];
				e.expression && n.push(ui("$$action_arg"));
				const s = [t.state.node, Xa(n, ti(t.visit(uS(e.name)), ...n))];
				e.expression && s.push(Ti(t.visit(e.expression)));
				let r = Pi(ei("$.action", ...s));
				e.metadata.expression.is_async() && (r = Pi(ei("$.run_after_blockers", e.metadata.expression.blockers(), Ti(Za([r]))))), t.state.init.push(r), t.next();
			},
			AttachTag: function(e, t) {
				const n = fS(t, e.expression, e.metadata.expression);
				let s = Pi(ei("$.attach", t.state.node, Ti(n)));
				e.metadata.expression.is_async() && (s = Pi(ei("$.run_after_blockers", e.metadata.expression.blockers(), Ti(Za([s]))))), t.state.init.push(s), t.next();
			},
			VariableDeclaration: function(e, t) {
				const n = [];
				if (t.state.analysis.runes) for (const s of e.declarations) {
					const e = s.init, r = xc(e, t.state.scope);
					if (!r || "$effect.tracking" === r || "$effect.root" === r || "$inspect" === r || "$inspect.trace" === r || "$state.snapshot" === r || "$host" === r) {
						n.push(t.visit(s));
						continue;
					}
					if ("$props.id" === r) continue;
					if ("$props" === r) {
						const e = [
							"$$slots",
							"$$events",
							"$$legacy"
						];
						if (t.state.analysis.custom_element && e.push("$$host"), "Identifier" === s.id.type) {
							const t = [ui("$$props"), Wa(e.map(((e) => mi(e))))];
							ge && t.push(mi(s.id.name)), n.push(ii(s.id, ei("$.rest_props", ...t)));
						} else {
							yw(s.id.type, "ObjectPattern");
							for (const r of s.id.properties) if ("Property" === r.type) {
								const s = r.key, a = "Identifier" === s.type ? s.name : s.value;
								e.push(a);
								let i = "AssignmentPattern" === r.value.type ? r.value.left : r.value;
								yw(i.type, "Identifier");
								const o = t.state.scope.get(i.name);
								let l = o.initial && t.visit(o.initial);
								l && "bindable_prop" === o.kind && Cp(l, t.state.scope) && (l = ei("$.proxy", l), ge && (l = ei("$.tag_proxy", l, mi(i.name)))), kp(o, t.state) && n.push(ii(i, wp(o, t.state, a, l)));
							} else {
								const t = [ui("$$props"), Wa(e.map(((e) => mi(e))))];
								ge && t.push(mi(r.argument.name)), n.push(ii(r.argument, ei("$.rest_props", ...t)));
							}
						}
						continue;
					}
					const a = e.arguments[0] ?? si;
					if ("$state" !== r && "$state.raw" !== r) if ("$derived" !== r && "$derived.by" !== r);
					else {
						const i = t.state.analysis.async_deriveds.has(e), o = t.state.is_instance && t.state.scope.function_depth > 1;
						if ("Identifier" === s.id.type) {
							let l = t.visit(a);
							if (i) {
								const t = ge && !Ee(e, "await_waterfall") && Ce(e);
								let r = ei("$.async_derived", Ti(l, !0), ge && mi(s.id.name), t ? mi(t) : void 0);
								r = o ? mo(r) : Ya(r), n.push(ii(s.id, r));
							} else {
								"$derived" === r && (l = Ti(l));
								let e = ei("$.derived", l);
								ge && (e = ei("$.tag", e, mi(s.id.name))), n.push(ii(s.id, e));
							}
						} else {
							const e = s.init;
							let l = t.visit(a), c = a;
							if ("$derived" !== r || "Identifier" !== e.arguments[0].type) {
								const a = ui(t.state.scope.generate("$$d"));
								let p = ei("$.derived", "$derived" === r ? Ti(l) : l);
								if (c = ei("$.get", a), i) {
									const t = ge && !Ee(e, "await_waterfall") && Ce(e);
									p = ei("$.async_derived", Ti(l, !0), ge && mi(`[$derived ${"ArrayPattern" === s.id.type ? "iterable" : "object"}]`), t ? mi(t) : void 0), p = o ? mo(p) : Ya(p);
								}
								n.push(ii(a, p));
							}
							const { inserts: p, paths: u } = ro(s.id, c);
							for (const { id: e, value: r } of p) {
								e.name = t.state.scope.generate("$$array"), t.state.transform[e.name] = { read: SS };
								let a = ei("$.derived", t.visit(Ti(r)));
								if (ge) a = ei("$.tag", a, mi(`[$derived ${"ArrayPattern" === s.id.type ? "iterable" : "object"}]`));
								n.push(ii(e, a));
							}
							for (const e of u) {
								const s = ei("$.derived", Ti(t.visit(e.expression)));
								n.push(ii(e.node, ge ? ei("$.tag", s, mi(e.node.name)) : s));
							}
						}
					}
					else {
						const i = (n, s) => {
							const a = _p(t.state.scope.get(n.name), t.state.analysis), i = Cp(s, t.state.scope);
							if ("$state" === r && i && (s = ei("$.proxy", s), ge && !a && (s = ei("$.tag_proxy", s, mi(n.name)))), a) s = ei(ui("$.state", e.callee.loc), s), ge && (s = ei("$.tag", s, mi(n.name)));
							return s;
						};
						if ("Identifier" === s.id.type) {
							const e = t.visit(a);
							n.push(ii(s.id, i(s.id, e)));
						} else {
							const e = ui(t.state.scope.generate("tmp")), { inserts: r, paths: o } = ro(s.id, e);
							n.push(ii(e, t.visit(a)), ...r.map((({ id: e, value: n }) => {
								e.name = t.state.scope.generate("$$array"), t.state.transform[e.name] = { read: SS };
								let r = ei("$.derived", t.visit(Ti(n)));
								if (ge) r = ei("$.tag", r, mi(`[$state ${"ArrayPattern" === s.id.type ? "iterable" : "object"}]`));
								return ii(e, r);
							})), ...o.map(((e) => {
								const n = t.visit(e.expression), s = t.state.scope.get(e.node.name);
								return ii(e.node, "state" === s?.kind || "raw_state" === s?.kind ? i(s.node, n) : n);
							})));
						}
					}
				}
				else for (const s of e.declarations) {
					const e = t.state.scope.get_bindings(s), r = e.some(((e) => "state" === e.kind)), a = e.some(((e) => "bindable_prop" === e.kind));
					if (r || a) if (a) {
						if ("Identifier" !== s.id.type) {
							const e = ui(t.state.scope.generate("tmp")), { inserts: r, paths: a } = ro(s.id, e);
							n.push(ii(e, t.visit(s.init)));
							for (const { id: e, value: s } of r) {
								e.name = t.state.scope.generate("$$array"), t.state.transform[e.name] = { read: SS };
								const r = t.visit(Ti(s));
								n.push(ii(e, ei("$.derived", r)));
							}
							for (const e of a) {
								const s = e.node.name, r = t.state.scope.get(s), a = t.visit(e.expression);
								n.push(ii(e.node, "bindable_prop" === r.kind ? wp(r, t.state, r.prop_alias ?? s, a) : a));
							}
							continue;
						}
						const e = t.state.scope.get(s.id.name);
						n.push(ii(s.id, wp(e, t.state, e.prop_alias ?? s.id.name, s.init && t.visit(s.init))));
					} else n.push(...YS(s, t, s.init && t.visit(s.init)));
					else n.push(t.visit(s));
				}
				return 0 === n.length ? oi : {
					...e,
					declarations: n
				};
			}
		};
		function ZS(e, n, s) {
			if (!1 === s.generate) return {
				js: null,
				css: null,
				warnings: fe,
				metadata: { runes: e.runes },
				ast: null
			};
			const r = "server" === s.generate ? function(e, n) {
				const s = {
					analysis: e,
					options: n,
					scope: e.module.scope,
					scopes: e.module.scopes,
					hoisted: [Ui("$", "svelte/internal/server"), ...e.instance_body.hoisted],
					legacy_reactive_statements: /* @__PURE__ */ new Map(),
					init: null,
					template: null,
					namespace: n.namespace,
					preserve_whitespace: n.preserveWhitespace,
					state_fields: /* @__PURE__ */ new Map(),
					is_standalone: !1,
					is_instance: !1
				}, r = t(e.module.ast, s, iS), a = t(e.instance.ast, {
					...s,
					scopes: e.instance.scopes,
					is_instance: !0
				}, {
					...iS,
					ImportDeclaration: (e) => (s.hoisted.push(e), oi),
					ExportNamedDeclaration: (e, t) => e.declaration ? t.visit(e.declaration) : oi
				}), i = t(e.template.ast, {
					...s,
					scopes: e.template.scopes
				}, {
					...iS,
					...oS
				}), o = [];
				for (const [t] of e.reactive_statements) {
					const n = [...s.legacy_reactive_statements].find((([e]) => e === t));
					if (void 0 === n) throw new Error("Could not find reactive statement");
					if ("ExpressionStatement" === t.body.type && "AssignmentExpression" === t.body.expression.type) for (const n of to(t.body.expression.left)) "legacy_reactive" === e.instance.scope.get(n.name)?.kind && o.push(ii(n));
					a.body.push(n[1]);
				}
				if (o.length > 0 && a.body.unshift({
					type: "VariableDeclaration",
					kind: "let",
					declarations: o
				}), e.uses_component_bindings) {
					const e = i.body.filter(((e) => "FunctionDeclaration" === e.type && e.___snippet)), t = i.body.filter(((e) => "FunctionDeclaration" !== e.type || !e.___snippet));
					i.body = [
						...e,
						Di("$$settled", Mi),
						Di("$$inner_renderer"),
						ci(ui("$$render_inner"), [ui("$$renderer")], Za(t)),
						Ii(ni("!", ui("$$settled")), Za([
							Pi(Qa("=", ui("$$settled"), Mi)),
							Pi(Qa("=", ui("$$inner_renderer"), ei("$$renderer.copy"))),
							Pi(ei("$$render_inner", ui("$$inner_renderer")))
						])),
						Pi(ei("$$renderer.subsume", ui("$$inner_renderer")))
					];
				}
				[...e.instance.scope.declarations.values()].some(((e) => "store_sub" === e.kind)) && (a.body.unshift(Bi("$$store_subs")), i.body.push(Hi(ui("$$store_subs"), Pi(ei("$.unsubscribe_stores", ui("$$store_subs"))))));
				const l = [];
				for (const [t, n] of e.instance.scope.declarations) "bindable_prop" !== n.kind || t.startsWith("$$") || l.push(hi(n.prop_alias ?? t, ui(t)));
				for (const { name: t, alias: n } of e.exports) l.push(hi(n ?? t, ui(t)));
				l.length > 0 && i.body.push(Pi(ei("$.bind_props", ui("$$props"), vi(l))));
				let c = Za([...a.body, ...i.body]);
				c.loc = a.loc, e.props_id && c.body.unshift(ji(e.props_id, ei("$.props_id", ui("$$renderer"))));
				let p = ge || e.needs_context;
				if (p && (c = Za([Pi(ei("$$renderer.component", Xa([ui("$$renderer")], c, !1), ge && ui(xe)))])), e.uses_rest_props) {
					const t = e.exports.map((({ name: e, alias: t }) => t ?? e));
					for (const [n, s] of e.instance.scope.declarations) "bindable_prop" === s.kind && t.push(s.prop_alias ?? n);
					c.body.unshift(ji("$$restProps", ei("$.rest_props", ui("$$sanitized_props"), Wa(t.map(((e) => mi(e)))))));
				}
				(e.uses_props || e.uses_rest_props) && c.body.unshift(ji("$$sanitized_props", ei("$.sanitize_props", ui("$$props")))), e.uses_slots && c.body.unshift(ji("$$slots", ei("$.sanitize_slots", ui("$$props"))));
				const u = [...s.hoisted, ...r.body];
				if (null !== e.css.ast && "injected" === n.css && !n.customElement) {
					const t = mi(e.css.hash), s = mi(_C(e.source, e, n).code);
					u.push(ji("$$css", vi([hi("hash", t), hi("code", s)]))), c.body.unshift(Pi(ei("$$renderer.global.css.add", ui("$$css"))));
				}
				let d = p || l.length > 0 || e.needs_props || e.uses_props || e.uses_rest_props || e.uses_slots || e.slot_names.size > 0;
				const h = ci(ui(e.name), d ? [ui("$$renderer"), ui("$$props")] : [ui("$$renderer")], c);
				var m;
				return 4 === n.compatibility.componentApi ? (u.unshift(zi([["render", "$$_render"]], "svelte/server")), u.push(h, Pi(Qa("=", yi(`${e.name}.render`), Vi(null, [ui("$$props"), ui("$$opts")], Za([Wi(ei("$$_render", ui(e.name), vi([hi("props", ui("$$props")), hi("context", fi(ui("$$opts"), "context", !1, !0))])))])))), li(ui(e.name)))) : ge ? u.push(h, Pi(Qa("=", yi(`${e.name}.render`), Vi(null, [], Za([(m = "Component.render(...) is no longer valid in Svelte 5. See https://svelte.dev/docs/svelte/v5-migration-guide#Components-are-no-longer-classes for more information", {
					type: "ThrowStatement",
					argument: $i("Error", mi(m))
				})])))), li(ui(e.name))) : u.push(li(h)), ge && u.unshift(Pi(Qa("=", fi(ui(e.name), "$.FILENAME", !0), mi(me)))), n.experimental.async && u.unshift(zi([], "svelte/internal/flags/async")), {
					type: "Program",
					sourceType: "module",
					body: u
				};
			}(e, s) : function(e, n) {
				const s = {
					analysis: e,
					options: n,
					scope: e.module.scope,
					scopes: e.module.scopes,
					is_instance: !1,
					hoisted: [Ui("$", "svelte/internal/client"), ...e.instance_body.hoisted],
					node: null,
					legacy_reactive_imports: [],
					legacy_reactive_statements: /* @__PURE__ */ new Map(),
					metadata: {
						namespace: n.namespace,
						bound_contenteditable: !1
					},
					events: /* @__PURE__ */ new Set(),
					preserve_whitespace: n.preserveWhitespace,
					state_fields: /* @__PURE__ */ new Map(),
					transform: {},
					in_constructor: !1,
					instance_level_snippets: [],
					module_level_snippets: [],
					is_standalone: !1,
					init: null,
					consts: null,
					snippets: null,
					let_directives: null,
					update: null,
					after_update: null,
					template: null,
					memoizer: null
				}, r = t(e.module.ast, s, JS), a = {
					...s,
					transform: { ...s.transform },
					scope: e.instance.scope,
					scopes: e.instance.scopes,
					is_instance: !0
				}, i = t(e.instance.ast, a, JS), o = t(e.template.ast, {
					...s,
					transform: a.transform,
					scope: e.instance.scope,
					scopes: e.template.scopes
				}, JS);
				r.body.unshift(...s.legacy_reactive_imports);
				const l = [];
				let c = oi;
				const p = [];
				let u = !1;
				for (const [t, n] of e.instance.scope.declarations) if ("legacy_reactive" === n.kind && p.push(ji(t, ei("$.mutable_source", void 0, e.immutable ? Mi : void 0))), "store_sub" === n.kind) {
					0 === l.length && (u = !0, c = ji(Ga([ui("$$stores"), ui("$$cleanup")]), ei("$.setup_stores")));
					const e = xp(ui(t.slice(1)), a), s = ei("$.store_get", e, mi(t), ui("$$stores"));
					l.push(ji(n.node, Ti(ge ? ki([ei("$.validate_store", e, mi(t.slice(1))), s]) : s)));
				}
				for (const [t] of e.reactive_statements) {
					const e = [...s.legacy_reactive_statements].find((([e]) => e === t));
					if (void 0 === e) throw new Error("Could not find reactive statement");
					i.body.push(e[1]);
				}
				e.reactive_statements.size > 0 && i.body.push(Pi(ei("$.legacy_pre_effect_reset")));
				const d = [];
				for (const t of e.binding_groups.values()) d.push(ji(t.name, Wa([])));
				const h = e.exports.flatMap((({ name: e, alias: t }) => {
					const n = a.scope.get(e), s = xp(ui(e), a), r = pi(t ?? e, [Wi(s)]);
					if ("Identifier" === s.type) {
						if ("let" === n?.declaration_kind || "var" === n?.declaration_kind) return [r, Ci(t ?? e, [Pi(Qa("=", s, ui("$$value")))])];
						if (!ge) return hi(t ?? e, s);
					}
					if ("prop" === n?.kind || "bindable_prop" === n?.kind) return [r, Ci(t ?? e, [Pi(ei(e, ui("$$value")))])];
					if ("state" === n?.kind || "raw_state" === n?.kind) {
						const s = "state" === n.kind ? ei("$.proxy", ui("$$value")) : ui("$$value");
						return [r, Ci(t ?? e, [Pi(ei("$.set", ui(e), s))])];
					}
					return r;
				})), m = [...e.instance.scope.declarations].filter((([e, t]) => ("prop" === t.kind || "bindable_prop" === t.kind) && !e.startsWith("$$")));
				if (e.accessors) for (const [t, n] of m) {
					const s = n.prop_alias ?? t, r = pi(s, [Wi(ei(ui(t)))]), a = Ci(s, [Pi(ei(ui(t), ui("$$value"))), Pi(ei("$.flush"))]);
					e.runes && n.initial && (a.value.params[0] = {
						type: "AssignmentPattern",
						left: ui("$$value"),
						right: n.initial
					}), h.push(r, a);
				}
				4 === n.compatibility.componentApi ? h.push(hi("$set", ui("$.update_legacy_props")), hi("$on", Xa([ui("$$event_name"), ui("$$event_cb")], ei("$.add_legacy_event_listener", ui("$$props"), ui("$$event_name"), ui("$$event_cb"))))) : ge && h.push(Si(ei(ui("$.legacy_api"))));
				const f = [ui("$$props"), mi(e.runes)];
				ge && f.push(ui(e.name));
				let y = Za([
					c,
					...p,
					...d
				]);
				const v = ge || e.needs_context || e.reactive_statements.size > 0 || h.length > 0;
				y.body.push(...s.instance_level_snippets, ...i.body), v && h.length > 0 && y.body.push(Bi("$$exports", vi(h))), y.body.unshift(...l), !e.runes && e.needs_context && y.body.push(Pi(ei("$.init", e.immutable ? Mi : void 0))), y.body.push(...o.body), e.needs_mutation_validation && y.body.unshift(Bi("$$ownership_validator", ei("$.create_ownership_validator", ui("$$props"))));
				let g = v || e.needs_props || e.uses_props || e.uses_rest_props || e.uses_slots || e.slot_names.size > 0;
				if (y.loc = i.loc, !e.runes) for (const { name: t, alias: n } of e.exports) y.body.push(Pi(ei("$.bind_prop", ui("$$props"), mi(n ?? t), xp(ui(t), a))));
				if (null !== e.css.ast && e.inject_styles) {
					const t = mi(e.css.hash), r = mi(_C(e.source, e, n).code);
					s.hoisted.push(ji("$$css", vi([hi("hash", t), hi("code", r)]))), y.body.unshift(Pi(ei("$.append_styles", ui("$$anchor"), ui("$$css"))));
				}
				if (v) {
					let e;
					if (y.body.unshift(Pi(ei("$.push", ...f))), h.length > 0) {
						let t = ei("$.pop", ui("$$exports"));
						e = u ? Bi("$$pop", t) : Wi(t);
					} else e = Pi(ei("$.pop"));
					y.body.push(e);
				}
				if (u && (y.body.push(Pi(ei("$$cleanup"))), h.length > 0 && y.body.push(Wi(ui("$$pop")))), e.uses_rest_props) {
					const t = e.exports.map((({ name: e, alias: t }) => t ?? e));
					for (const [n, s] of e.instance.scope.declarations) "bindable_prop" === s.kind && t.push(s.prop_alias ?? n);
					y.body.unshift(ji("$$restProps", ei("$.legacy_rest_props", ui("$$sanitized_props"), Wa(t.map(((e) => mi(e)))))));
				}
				if (e.uses_props || e.uses_rest_props) {
					const t = [
						mi("children"),
						mi("$$slots"),
						mi("$$events"),
						mi("$$legacy")
					];
					e.custom_element && t.push(mi("$$host")), y.body.unshift(ji("$$sanitized_props", ei("$.legacy_rest_props", ui("$$props"), Wa(t))));
				}
				e.uses_slots && y.body.unshift(ji("$$slots", ei("$.sanitize_slots", ui("$$props"))));
				const b = [];
				let _ = [];
				for (const e of [...r.body, ...s.hoisted]) "ImportDeclaration" === e.type ? b.push(e) : _.push(e);
				_ = [
					...b,
					...s.module_level_snippets,
					..._
				];
				const x = ci(ui(e.name), g ? [ui("$$anchor"), ui("$$props")] : [ui("$$anchor")], y);
				if (n.hmr) {
					const t = ui(e.name), n = [Pi(ei(fi(fi(t, ui("$.HMR"), !0), "update"), ui("module.default")))];
					e.css.hash && n.unshift(Pi(ei("$.cleanup_styles", mi(e.css.hash))));
					const s = Za([Pi(Qa("=", t, ei("$.hmr", t))), Pi(ei("import.meta.hot.accept", Xa([ui("module")], Za(n))))]);
					_.push(x, Hi(ui("import.meta.hot"), s), li(ui(e.name)));
				} else _.push(li(x));
				ge && _.unshift(Pi(Qa("=", fi(ui(e.name), "$.FILENAME", !0), mi(me)))), n.experimental.async && _.unshift(zi([], "svelte/internal/flags/async")), e.runes || _.unshift(zi([], "svelte/internal/flags/legacy")), e.tracing && _.unshift(zi([], "svelte/internal/flags/tracing")), n.discloseVersion && _.unshift(zi([], "svelte/internal/disclose-version")), 4 === n.compatibility.componentApi ? (_.unshift(zi([["createClassComponent", "$$_createClassComponent"]], "svelte/legacy")), y.body.unshift(Hi(ui("new.target"), Wi(ei("$$_createClassComponent", vi([hi("component", ui(e.name)), Si(ui("$$anchor"))])))))) : ge && y.body.unshift(Pi(ei("$.check_target", ui("new.target")))), e.props_id && y.body.unshift(ji(e.props_id, ei("$.props_id"))), s.events.size > 0 && _.push(Pi(ei("$.delegate", Wa(Array.from(s.events).map(((e) => mi(e)))))));
				const w = n.customElementOptions ?? n.customElement;
				if (w) {
					const t = "boolean" == typeof w ? {} : w.props || {}, s = [];
					for (const [n, r] of Object.entries(t)) {
						const t = e.instance.scope.get(n), a = t?.prop_alias ?? n;
						r.type || "Literal" !== t?.initial?.type || "boolean" != typeof t?.initial.value || (r.type = "Boolean");
						const i = vi([
							r.attribute ? hi("attribute", mi(r.attribute)) : void 0,
							r.reflect ? hi("reflect", Mi) : void 0,
							r.type ? hi("type", mi(r.type)) : void 0
						].filter(Boolean));
						s.push(hi(a, i));
					}
					for (const [e, n] of m) {
						const r = n.prop_alias ?? e;
						t[r] || s.push(hi(r, vi([])));
					}
					const r = Wa([...e.slot_names.keys()].map(((e) => mi(e)))), a = Wa(e.exports.map((({ name: e, alias: t }) => mi(t ?? e))));
					let i;
					i = "boolean" == typeof w || "open" === w.shadow || void 0 === w.shadow ? vi([hi("mode", mi("open"))]) : "none" === w.shadow ? void 0 : w.shadow;
					const o = ei("$.create_custom_element", ui(e.name), vi(s), r, a, i, "boolean" != typeof w ? w.extend : void 0);
					if ("boolean" != typeof w && "string" == typeof w.tag) {
						const e = Pi(ei("customElements.define", mi(w.tag), o));
						n.hmr ? _.push(Hi(Ja("==", ei("customElements.get", mi(w.tag)), Li), e)) : _.push(e);
					} else _.push(Pi(o));
				}
				return {
					type: "Program",
					sourceType: "module",
					body: _
				};
			}(e, s), a = bC(s.filename, s.outputFilename), i = Ww(r, Qw({ comments: e.comments }), {
				sourceMapContent: n,
				sourceMapSource: a
			});
			yC(i, s, a);
			return {
				js: i,
				css: e.css.ast && !e.inject_styles ? _C(n, e, s) : null,
				warnings: fe,
				metadata: { runes: e.runes },
				ast: null
			};
		}
		function eP(e, n, s) {
			if (!1 === s.generate) return {
				js: null,
				css: null,
				warnings: fe,
				metadata: { runes: !0 },
				ast: null
			};
			const r = "server" === s.generate ? function(e, n) {
				const s = {
					analysis: e,
					options: n,
					scope: e.module.scope,
					scopes: e.module.scopes,
					legacy_reactive_statements: /* @__PURE__ */ new Map(),
					state_fields: /* @__PURE__ */ new Map(),
					is_instance: !1
				}, r = t(e.module.ast, s, iS);
				return {
					type: "Program",
					sourceType: "module",
					body: [Ui("$", "svelte/internal/server"), ...r.body]
				};
			}(e, s) : function(e, n) {
				const s = {
					analysis: e,
					options: n,
					scope: e.module.scope,
					scopes: e.module.scopes,
					state_fields: /* @__PURE__ */ new Map(),
					transform: {},
					in_constructor: !1,
					is_instance: !1
				}, r = t(e.module.ast, s, JS), a = [Ui("$", "svelte/internal/client")];
				return e.tracing && a.push(zi([], "svelte/internal/flags/tracing")), {
					type: "Program",
					sourceType: "module",
					body: [...a, ...r.body]
				};
			}(e, s), a = s.filename.split(/[/\\]/).at(-1);
			r.body.length > 0 && (r.body[0].leadingComments = [{
				type: "Block",
				value: ` ${a} generated by Svelte v${ek} `
			}]);
			const i = Ww(r, Qw({ comments: e.comments }), {
				sourceMapContent: n,
				sourceMapSource: bC(s.filename, void 0)
			});
			return i.code = `/* ${a} generated by Svelte v${ek} */\n${i.code}`, i.map.mappings = ";" + i.map.mappings, {
				js: i,
				css: null,
				metadata: { runes: !0 },
				warnings: fe,
				ast: null
			};
		}
		const tP = {
			filename: dP("(unknown)"),
			rootDir: dP("undefined" != typeof process ? process.cwd?.() : "undefined" != typeof Deno ? Deno.cwd() : void 0),
			dev: hP(!1),
			generate: uP("client", ((e, t) => "dom" === e || "ssr" === e ? (oP(ot), "dom" === e ? "client" : "server") : ("client" !== e && "server" !== e && !1 !== e && yP(`${t} must be "client", "server" or false`), e))),
			warningFilter: fP((() => !0)),
			experimental: pP({ async: hP(!1) })
		}, nP = {
			accessors: cP(rt, hP(!1)),
			css: uP("external", ((e) => (!0 !== e && !1 !== e || yP("The boolean options have been removed from the css option. Use \"external\" instead of false and \"injected\" instead of true"), "none" === e && yP("css: \"none\" is no longer a valid option. If this was crucial for you, please open an issue on GitHub with your use case."), "external" !== e && "injected" !== e && yP("css should be either \"external\" (default, recommended) or \"injected\""), e))),
			cssHash: fP((({ css: e, filename: t, hash: n }) => `svelte-${n("(unknown)" === t ? e : t ?? e)}`)),
			cssOutputFilename: dP(void 0),
			customElement: hP(!1),
			discloseVersion: hP(!0),
			immutable: cP(at, hP(!1)),
			legacy: aP("The legacy option has been removed. If you are using this because of legacy.componentApi, use compatibility.componentApi instead"),
			compatibility: pP({ componentApi: mP([4, 5], 5) }),
			loopGuardTimeout: lP((function(e) {
				qe(e, "options_removed_loop_guard_timeout", "The `loopGuardTimeout` option has been removed\nhttps://svelte.dev/e/options_removed_loop_guard_timeout");
			})),
			name: dP(void 0),
			namespace: mP([
				"html",
				"mathml",
				"svg"
			]),
			modernAst: hP(!1),
			outputFilename: dP(void 0),
			preserveComments: hP(!1),
			fragments: mP(["html", "tree"]),
			preserveWhitespace: hP(!1),
			runes: hP(void 0),
			hmr: hP(!1),
			sourcemap: uP(void 0, ((e) => e)),
			enableSourcemap: lP((function(e) {
				qe(e, "options_removed_enable_sourcemap", "The `enableSourcemap` option has been removed. Source maps are always generated now, and tooling can choose to ignore them\nhttps://svelte.dev/e/options_removed_enable_sourcemap");
			})),
			hydratable: lP((function(e) {
				qe(e, "options_removed_hydratable", "The `hydratable` option has been removed. Svelte components are always hydratable now\nhttps://svelte.dev/e/options_removed_hydratable");
			})),
			format: aP("The format option has been removed in Svelte 4, the compiler only outputs ESM now. Remove \"format\" from your compiler options. If you did not set this yourself, bump the version of your bundler plugin (vite-plugin-svelte/rollup-plugin-svelte/svelte-loader)"),
			tag: aP("The tag option has been removed in Svelte 5. Use `<svelte:options customElement=\"tag-name\" />` inside the component instead. If that does not solve your use case, please open an issue on GitHub with details."),
			sveltePath: aP("The sveltePath option has been removed in Svelte 5. If this option was crucial for you, please open an issue on GitHub with your use case."),
			errorMode: aP("The errorMode option has been removed. If you are using this through svelte-preprocess with TypeScript, use the https://www.typescriptlang.org/tsconfig#verbatimModuleSyntax setting instead"),
			varsReport: aP("The vars option has been removed. If you are using this through svelte-preprocess with TypeScript, use the https://www.typescriptlang.org/tsconfig#verbatimModuleSyntax setting instead")
		}, sP = pP({
			...tP,
			...Object.fromEntries(Object.keys(nP).map(((e) => [e, () => {}])))
		}), rP = pP({
			...tP,
			...nP
		});
		function aP(e) {
			return (t) => {
				void 0 !== t && zs(null, "options_removed", `Invalid compiler option: ${e}\nhttps://svelte.dev/e/options_removed`);
			};
		}
		const iP = /* @__PURE__ */ new Set();
		function oP(e) {
			iP.has(e) || (iP.add(e), e(null));
		}
		function lP(e) {
			return (t) => {
				void 0 !== t && oP(e);
			};
		}
		function cP(e, t) {
			return (n, s) => (void 0 !== n && oP(e), t(n, s));
		}
		function pP(e, t = !1) {
			return (n, s) => {
				const r = {};
				(n && "object" != typeof n || Array.isArray(n)) && yP(`${s} should be an object`);
				for (const a in n) a in e || (t ? r[a] = n[a] : Ws(null, `${s ? `${s}.${a}` : a}`));
				for (const t in e) {
					const a = e[t];
					r[t] = a(n && n[t], s ? `${s}.${t}` : t);
				}
				return r;
			};
		}
		function uP(e, t) {
			return (n, s) => void 0 === n ? e : t(n, s);
		}
		function dP(e, t = !0) {
			return uP(e, ((e, n) => ("string" != typeof e && yP(`${n} should be a string, if specified`), t || "" !== e || yP(`${n} cannot be empty`), e)));
		}
		function hP(e) {
			return uP(e, ((e, t) => ("boolean" != typeof e && yP(`${t} should be true or false, if specified`), e)));
		}
		function mP(e, t = e[0]) {
			return uP(t, ((t, n) => {
				if (!e.includes(t)) yP(e.length > 2 ? `${n} should be one of ${e.slice(0, -1).map(((e) => `"${e}"`)).join(", ")} or "${e[e.length - 1]}"` : `${n} should be either "${e[0]}" or "${e[1]}"`);
				return t;
			}));
		}
		function fP(e) {
			return uP(e, ((e, t) => ("function" != typeof e && yP(`${t} should be a function, if specified`), e)));
		}
		function yP(e) {
			zs(null, "options_invalid_value", `Invalid compiler option: ${e}\nhttps://svelte.dev/e/options_invalid_value`);
		}
		function vP(e, t, { file_basename: n, filename: s, get_location: r }) {
			return {
				source: e,
				get_location: (e) => r(e + t),
				file_basename: n,
				filename: s
			};
		}
		async function gP(e, t, n) {
			return function(e, t) {
				const n = new uC();
				let s = 0;
				for (const { offset: r, length: a, replacement: i } of e) {
					const e = uC.from_source(vP(t.source.slice(s, r), s, t));
					n.concat(e).concat(i), s = r + a;
				}
				const r = uC.from_source(vP(t.source.slice(s), s, t));
				return n.concat(r);
			}(await function(e, t, n) {
				const s = [];
				return n.replace(e, ((...e) => (s.push(t(...e).then(((t) => {
					const n = e[0];
					return {
						offset: e[e.length - 2],
						length: n.length,
						replacement: t
					};
				}))), ""))), Promise.all(s);
			}(e, t, n.source), n);
		}
		class bP {
			source;
			filename;
			sourcemap_list = [];
			dependencies = [];
			file_basename = void 0;
			get_location = void 0;
			constructor(e, t) {
				this.source = e, this.filename = t, this.update_source({ string: e }), this.file_basename = null == t ? null : gC(t);
			}
			update_source({ string: e, map: t, dependencies: n }) {
				null != e && (this.source = e, this.get_location = F(e)), t && this.sourcemap_list.unshift(t), n && this.dependencies.push(...n);
			}
			to_processed() {
				const e = mC(this.file_basename, this.sourcemap_list);
				return {
					code: this.source,
					dependencies: [...new Set(this.dependencies)],
					map: e,
					toString: () => this.source
				};
			}
		}
		function _P(e, t, n) {
			let s;
			if (e.map && (s = function(e) {
				let t = "string" == typeof e.map ? JSON.parse(e.map) : e.map;
				return "string" == typeof t.mappings && (t.mappings = Iw(t.mappings)), t._mappings && "SourceMapGenerator" === t.constructor.name && (t = function(e) {
					let t = 1;
					const n = [[]];
					let s, r, a = n[0];
					const i = e._sources.toArray().reduce(((e, t, n) => (e[t] = n, e)), {}), o = e._names.toArray().reduce(((e, t, n) => (e[t] = n, e)), {}), l = e._mappings.toArray();
					for (let e = 0, c = l.length; e < c; e++) {
						if (r = l[e], r.generatedLine > t) {
							for (; r.generatedLine > t;) n.push([]), t++;
							a = n[r.generatedLine - 1];
						} else if (e > 0) {
							const t = l[e - 1];
							if (r.generatedColumn === t.generatedColumn && r.originalColumn === t.originalColumn && r.name === t.name && r.generatedLine === t.generatedLine && r.originalLine === t.originalLine && r.source === t.source) continue;
						}
						a.push([r.generatedColumn]), s = a[a.length - 1], null != r.source && (s.push(i[r.source], r.originalLine - 1, r.originalColumn), null != r.name && s.push(o[r.name]));
					}
					const c = {
						version: e._version,
						sources: e._sources.toArray(),
						names: e._names.toArray(),
						mappings: n
					};
					return null != e._file && (c.file = e._file), c;
				}(t)), t;
			}(e), s?.sources)) {
				const e = s.sources.indexOf(n);
				-1 !== e && lC(s, t, e);
			}
			return uC.from_processed(e.code, s);
		}
		function xP(e, t, n, s, r) {
			const { file_basename: a, get_location: i } = r, o = (e, t) => uC.from_source(vP(e, t, r)), l = `<${t}${n}>`, c = `<${t}${s}>`;
			let p;
			if (l.length !== c.length) {
				const e = [[[
					0,
					0,
					0,
					0
				], [
					`<${t}`.length,
					0,
					0,
					`<${t}`.length
				]]], n = c.split("\n").length - 1, s = c.length - (0 === n ? 0 : c.lastIndexOf("\n")) - 1;
				for (; e.length <= n;) e.push([[
					0,
					0,
					0,
					`<${t}`.length
				]]);
				e[n].push([
					s,
					0,
					l.split("\n").length - 1,
					l.length - l.lastIndexOf("\n") - 1
				]);
				const r = {
					version: 3,
					names: [],
					sources: [a],
					mappings: e
				};
				lC(r, i(0), 0), p = uC.from_processed(c, r);
			} else p = o(c, 0);
			const u = o(`</${t}>`, l.length + r.source.length);
			(function(e, t) {
				const n = "[#@]\\s*sourceMappingURL\\s*=\\s*(\\S*)", s = "script" == t ? new RegExp("(?://" + n + ")|(?:/\\*[#@]\\s*sourceMappingURL\\s*=\\s*(\\S*)\\s*\\*/)$") : new RegExp("/\\*" + n + "\\s*\\*/$");
				function r(t) {
					const n = e.code.length < 100 ? e.code : e.code.slice(0, 100) + " [...]";
					console.warn(`warning: ${t}. processed.code = ${JSON.stringify(n)}`);
				}
				e.code = e.code.replace(s, ((n, s, a) => {
					const i = "script" == t ? s || a : s, o = (i.match(fC) || [])[1];
					return o ? e.map ? (r("Not implemented. Found sourcemap in both processed.code and processed.map. Please update your preprocessor to return only one sourcemap."), "") : (e.map = hC(o), "") : (e.map || r(`Found sourcemap path ${JSON.stringify(i)} in processed.code, but no sourcemap data. Please update your preprocessor to return sourcemap data directly.`), "");
				}));
			})(e, t);
			const d = _P(e, i(l.length), a);
			return p.concat(d).concat(u);
		}
		const wP = /([\w-$]+\b)(?:=(?:"([^"]*)"|'([^']*)'|(\S+)))?/g;
		function kP(e) {
			const t = {};
			let n;
			for (; null !== (n = wP.exec(e));) {
				const e = n[1], s = n[2] || n[3] || n[4];
				t[e] = !s || s;
			}
			return t;
		}
		const CP = /<!--[^]*?-->|<style((?:\s+[^=>'"/\s]+=(?:"[^"]*"|'[^']*'|[^>\s]+)|\s+[^=>'"/\s]+)*\s*)(?:\/>|>([\S\s]*?)<\/style>)/g, SP = /<!--[^]*?-->|<script((?:\s+[^=>'"/\s]+=(?:"[^"]*"|'[^']*'|[^>\s]+)|\s+[^=>'"/\s]+)*\s*)(?:\/>|>([\S\s]*?)<\/script>)/g;
		async function PP(e, t, n) {
			const { filename: s, source: r } = n, a = "style" === e ? CP : SP, i = [];
			const { string: o, map: l } = await gP(a, (async function(a, o = "", l = "", c) {
				const p = () => uC.from_source(vP(a, c, n));
				if (!o && !l) return p();
				const u = await t({
					content: l || "",
					attributes: kP(o || ""),
					markup: r,
					filename: s
				});
				return u ? (u.dependencies && i.push(...u.dependencies), u.map || u.code !== l ? xP(u, e, o, function(e) {
					if (!e) return;
					let t = Object.entries(e).map((([e, t]) => !0 === t ? e : `${e}="${t}"`)).join(" ");
					return t && (t = " " + t), t;
				}(u.attributes) ?? o, vP(l, c, n)) : p()) : p();
			}), n);
			return {
				string: o,
				map: l,
				dependencies: i
			};
		}
		async function EP(e, t) {
			const n = await e({
				content: t.source,
				filename: t.filename
			});
			return n ? {
				string: n.code,
				map: n.map ? "string" == typeof n.map ? JSON.parse(n.map) : n.map : void 0,
				dependencies: n.dependencies
			} : {};
		}
		const TP = 50;
		function AP(e, t, n = !1) {
			const s = e.new();
			s.visit(t), s.empty() || (n && !s.multiline ? e.append(s) : (e.indent(), e.newline(), e.append(s), e.dedent(), e.newline()));
		}
		function $P(e, t, n, s) {
			if (0 === t.length) return !1;
			let r = -1, a = s.findIndex(((t) => t.start > e.start));
			-1 === a && (a = s.length);
			const i = n.new(), o = t.map(((e) => {
				const t = n.new();
				for (; a < s.length;) {
					const n = s[a];
					if (!(n.start < e.start)) break;
					"Line" === n.type ? (t.write("//" + n.value), t.newline()) : (t.write("/*" + n.value + "*/"), t.append(i)), a += 1;
				}
				return t.visit(e), r += t.measure() + 1, t;
			}));
			let l = n.multiline || r > TP;
			if (l) {
				i.newline(), n.indent();
				for (const e of o) n.newline(), n.append(e);
				n.dedent(), n.newline();
			} else {
				i.write(" ");
				for (const e of o) n.write(" "), n.append(e);
			}
			return l;
		}
		function RP(e, t, n) {
			const s = t.new();
			s.write("<" + e.name), "SvelteComponent" === e.type ? (s.write(" this={"), s.visit(e.expression), s.write("}")) : "SvelteElement" === e.type && (s.write(" this={"), s.visit(e.tag), s.write("}"));
			const r = $P(e, e.attributes, s, n), a = "!doctype" === e.name.toLowerCase(), i = z(e.name) || "Component" === e.type && 0 === e.fragment.nodes.length;
			a ? s.write(">") : i ? s.write((r ? "" : " ") + "/>") : (s.write(">"), AP(s, e.fragment, !0), s.write(`</${e.name}>`)), t.append(s);
		}
		const IP = {
			Atrule(e, t) {
				t.write(`@${e.name}`), e.prelude && t.write(` ${e.prelude}`), e.block ? (t.write(" "), t.visit(e.block)) : t.write(";");
			},
			AttributeSelector(e, t) {
				t.write(`[${e.name}`), e.matcher && (t.write(e.matcher), t.write(`"${e.value}"`), e.flags && t.write(` ${e.flags}`)), t.write("]");
			},
			Block(e, t) {
				if (t.write("{"), e.children.length > 0) {
					t.indent(), t.newline();
					let n = !1;
					for (const s of e.children) n && t.newline(), t.visit(s), n = !0;
					t.dedent(), t.newline();
				}
				t.write("}");
			},
			ClassSelector(e, t) {
				t.write(`.${e.name}`);
			},
			ComplexSelector(e, t) {
				for (const n of e.children) t.visit(n);
			},
			Declaration(e, t) {
				t.write(`${e.property}: ${e.value};`);
			},
			IdSelector(e, t) {
				t.write(`#${e.name}`);
			},
			NestingSelector(e, t) {
				t.write("&");
			},
			Nth(e, t) {
				t.write(e.value);
			},
			Percentage(e, t) {
				t.write(`${e.value}%`);
			},
			PseudoClassSelector(e, t) {
				if (t.write(`:${e.name}`), e.args) {
					t.write("(");
					let n = !1;
					for (const s of e.args.children) n && t.write(", "), t.visit(s), n = !0;
					t.write(")");
				}
			},
			PseudoElementSelector(e, t) {
				t.write(`::${e.name}`);
			},
			RelativeSelector(e, t) {
				e.combinator && (" " === e.combinator.name ? t.write(" ") : t.write(` ${e.combinator.name} `));
				for (const n of e.selectors) t.visit(n);
			},
			Rule(e, t) {
				let n = !1;
				for (const s of e.prelude.children) n && (t.write(","), t.newline()), t.visit(s), n = !0;
				t.write(" "), t.visit(e.block);
			},
			SelectorList(e, t) {
				let n = !1;
				for (const s of e.children) n && t.write(", "), t.visit(s), n = !0;
			},
			TypeSelector(e, t) {
				t.write(e.name);
			}
		}, MP = (e) => ({
			Root(e, t) {
				if (e.options) {
					t.write("<svelte:options");
					for (const n of e.options.attributes) t.write(" "), t.visit(n);
					t.write(" />");
				}
				let n = !1;
				for (const s of [
					e.module,
					e.instance,
					e.fragment,
					e.css
				]) s && (n && (t.margin(), t.newline()), t.visit(s), n = !0);
			},
			Script(t, n) {
				n.write("<script"), $P(t, t.attributes, n, e), n.write(">"), AP(n, t.content), n.write("<\/script>");
			},
			Fragment(e, t) {
				const n = [];
				let s = [];
				const r = () => {
					n.push(s), s = [];
				};
				for (let t = 0; t < e.nodes.length; t += 1) {
					let n = e.nodes[t];
					const a = e.nodes[t - 1], i = e.nodes[t + 1];
					if ("Text" === n.type) {
						if (n = { ...n }, n.data = n.data.replace(/[^\S]+/g, " "), 0 === t && (n.data = n.data.trimStart()), t === e.nodes.length - 1 && (n.data = n.data.trimEnd()), "" === n.data) continue;
						n.data.startsWith(" ") && a && "ExpressionTag" !== a.type && (r(), n.data = n.data.trimStart()), "" !== n.data && (s.push({
							...n,
							data: n.data
						}), n.data.endsWith(" ") && i && "ExpressionTag" !== i.type && (r(), n.data = n.data.trimStart()));
					} else {
						const e = "RegularElement" === n.type || "Component" === n.type || "SvelteHead" === n.type || "SvelteFragment" === n.type || "SvelteBoundary" === n.type || "SvelteDocument" === n.type || "SvelteSelf" === n.type || "SvelteWindow" === n.type || "SvelteComponent" === n.type || "SvelteElement" === n.type || "SlotElement" === n.type || "TitleElement" === n.type;
						e && s.length > 0 && r(), s.push(n), e && r();
					}
				}
				r();
				let a = !1, i = 0;
				const o = n.filter(((e) => e.length > 0)).map(((e) => {
					const n = t.new();
					for (const t of e) n.visit(t), a ||= n.multiline;
					return i += n.measure(), n;
				}));
				a ||= i > TP;
				for (let e = 0; e < o.length; e += 1) {
					const n = o[e], s = o[e + 1];
					t.append(n), s && (n.multiline || s.multiline ? (t.margin(), t.newline()) : a && t.newline());
				}
			},
			AnimateDirective(e, t) {
				t.write(`animate:${e.name}`), null === e.expression || "Identifier" === e.expression.type && e.expression.name === e.name || (t.write("={"), t.visit(e.expression), t.write("}"));
			},
			AttachTag(e, t) {
				t.write("{@attach "), t.visit(e.expression), t.write("}");
			},
			Attribute(e, t) {
				if (t.write(e.name), !0 !== e.value) if (t.write("="), Array.isArray(e.value)) {
					(e.value.length > 1 || "Text" === e.value[0].type) && t.write("\"");
					for (const n of e.value) t.visit(n);
					(e.value.length > 1 || "Text" === e.value[0].type) && t.write("\"");
				} else t.visit(e.value);
			},
			AwaitBlock(e, t) {
				t.write("{#await "), t.visit(e.expression), e.pending ? (t.write("}"), AP(t, e.pending), t.write("{:")) : t.write(" "), e.then && (t.write(e.value ? "then " : "then"), e.value && t.visit(e.value), t.write("}"), AP(t, e.then), e.catch && t.write("{:")), e.catch && (t.write(e.value ? "catch " : "catch"), e.error && t.visit(e.error), t.write("}"), AP(t, e.catch)), t.write("{/await}");
			},
			BindDirective(e, t) {
				t.write(`bind:${e.name}`), "Identifier" === e.expression.type && e.expression.name === e.name || (t.write("={"), "SequenceExpression" === e.expression.type ? (t.visit(e.expression.expressions[0]), t.write(", "), t.visit(e.expression.expressions[1])) : t.visit(e.expression), t.write("}"));
			},
			ClassDirective(e, t) {
				t.write(`class:${e.name}`), null === e.expression || "Identifier" === e.expression.type && e.expression.name === e.name || (t.write("={"), t.visit(e.expression), t.write("}"));
			},
			Comment(e, t) {
				t.write("<!--" + e.data + "-->");
			},
			Component(t, n) {
				RP(t, n, e);
			},
			ConstTag(e, t) {
				t.write("{@"), t.visit(e.declaration), t.write("}");
			},
			DebugTag(e, t) {
				t.write("{@debug ");
				let n = !1;
				for (const s of e.identifiers) n && t.write(", "), t.visit(s), n = !0;
				t.write("}");
			},
			EachBlock(e, t) {
				t.write("{#each "), t.visit(e.expression), e.context && (t.write(" as "), t.visit(e.context)), e.index && t.write(`, ${e.index}`), e.key && (t.write(" ("), t.visit(e.key), t.write(")")), t.write("}"), AP(t, e.body), e.fallback && (t.write("{:else}"), AP(t, e.fallback)), t.write("{/each}");
			},
			ExpressionTag(e, t) {
				t.write("{"), t.visit(e.expression), t.write("}");
			},
			HtmlTag(e, t) {
				t.write("{@html "), t.visit(e.expression), t.write("}");
			},
			IfBlock(e, t) {
				e.elseif ? (t.write("{:else if "), t.visit(e.test), t.write("}"), AP(t, e.consequent)) : (t.write("{#if "), t.visit(e.test), t.write("}"), AP(t, e.consequent)), null !== e.alternate && (1 === e.alternate.nodes.length && "IfBlock" === e.alternate.nodes[0].type && e.alternate.nodes[0].elseif ? t.visit(e.alternate) : (t.write("{:else}"), AP(t, e.alternate))), e.elseif || t.write("{/if}");
			},
			KeyBlock(e, t) {
				t.write("{#key "), t.visit(e.expression), t.write("}"), AP(t, e.fragment), t.write("{/key}");
			},
			LetDirective(e, t) {
				t.write(`let:${e.name}`), null === e.expression || "Identifier" === e.expression.type && e.expression.name === e.name || (t.write("={"), t.visit(e.expression), t.write("}"));
			},
			OnDirective(e, t) {
				t.write(`on:${e.name}`);
				for (const n of e.modifiers) t.write(`|${n}`);
				null === e.expression || "Identifier" === e.expression.type && e.expression.name === e.name || (t.write("={"), t.visit(e.expression), t.write("}"));
			},
			RegularElement(t, n) {
				RP(t, n, e);
			},
			RenderTag(e, t) {
				t.write("{@render "), t.visit(e.expression), t.write("}");
			},
			SlotElement(t, n) {
				RP(t, n, e);
			},
			SnippetBlock(e, t) {
				t.write("{#snippet "), t.visit(e.expression), e.typeParams && t.write(`<${e.typeParams}>`), t.write("(");
				for (let n = 0; n < e.parameters.length; n += 1) n > 0 && t.write(", "), t.visit(e.parameters[n]);
				t.write(")}"), AP(t, e.body), t.write("{/snippet}");
			},
			SpreadAttribute(e, t) {
				t.write("{..."), t.visit(e.expression), t.write("}");
			},
			StyleDirective(e, t) {
				t.write(`style:${e.name}`);
				for (const n of e.modifiers) t.write(`|${n}`);
				if (!0 !== e.value) if (t.write("="), Array.isArray(e.value)) {
					t.write("\"");
					for (const n of e.value) t.visit(n);
					t.write("\"");
				} else t.visit(e.value);
			},
			StyleSheet(t, n) {
				if (n.write("<style"), $P(t, t.attributes, n, e), n.write(">"), t.children.length > 0) {
					n.indent(), n.newline();
					let e = !1;
					for (const s of t.children) e && (n.margin(), n.newline()), n.visit(s), e = !0;
					n.dedent(), n.newline();
				}
				n.write("</style>");
			},
			SvelteBoundary(t, n) {
				RP(t, n, e);
			},
			SvelteComponent(t, n) {
				n.write("<svelte:component"), n.write(" this={"), n.visit(t.expression), n.write("}"), $P(t, t.attributes, n, e), t.fragment && t.fragment.nodes.length > 0 ? (n.write(">"), AP(n, t.fragment, !0), n.write("</svelte:component>")) : n.write(" />");
			},
			SvelteDocument(t, n) {
				RP(t, n, e);
			},
			SvelteElement(t, n) {
				n.write("<svelte:element "), n.write("this={"), n.visit(t.tag), n.write("}"), $P(t, t.attributes, n, e), t.fragment && t.fragment.nodes.length > 0 ? (n.write(">"), AP(n, t.fragment), n.write("</svelte:element>")) : n.write(" />");
			},
			SvelteFragment(t, n) {
				RP(t, n, e);
			},
			SvelteHead(t, n) {
				RP(t, n, e);
			},
			SvelteSelf(t, n) {
				RP(t, n, e);
			},
			SvelteWindow(t, n) {
				RP(t, n, e);
			},
			Text(e, t) {
				t.write(e.data);
			},
			TitleElement(t, n) {
				RP(t, n, e);
			},
			TransitionDirective(e, t) {
				const n = e.intro && e.outro ? "transition" : e.intro ? "in" : "out";
				t.write(`${n}:${e.name}`);
				for (const n of e.modifiers) t.write(`|${n}`);
				null === e.expression || "Identifier" === e.expression.type && e.expression.name === e.name || (t.write("={"), t.visit(e.expression), t.write("}"));
			},
			UseDirective(e, t) {
				t.write(`use:${e.name}`), null === e.expression || "Identifier" === e.expression.type && e.expression.name === e.name || (t.write("={"), t.visit(e.expression), t.write("}"));
			}
		}), qP = /(<style[^>]+>)([\S\s]*?)(<\/style>)/g, LP = "/*$$__STYLE_CONTENT__$$*/";
		let OP = !1;
		class NP extends Error {
			constructor(e) {
				super(e);
			}
		}
		function DP(e, t) {
			let n = 1, s = e, r = t[s];
			for (; 0 !== n && r;) "(" === r && n++, ")" === r && n--, s++, r = t[s];
			return s;
		}
		const jP = {
			_(e, { state: t, next: n }) {
				const s = e.leadingComments;
				if (s) {
					for (const e of s) if ("Line" === e.type) {
						const n = xt(e.value);
						n !== e.value && t.str.overwrite(e.start + 2, e.end, n);
					}
				}
				n();
			},
			Identifier(e, { state: t, path: n }) {
				GP(e, t, n);
			},
			ImportDeclaration(e, { state: t }) {
				if (t.props_insertion_point = e.end ?? t.props_insertion_point, "svelte" === e.source.value) {
					let n = [], s = 0;
					for (let r of e.specifiers) if ("ImportSpecifier" === r.type && "Identifier" === r.imported.type && ["beforeUpdate", "afterUpdate"].includes(r.imported.name)) {
						if (!t.scope.references.get(r.local.name)) {
							let e = -1 !== t.str.original.indexOf(",", r.end) && t.str.original.indexOf(",", r.end) < t.str.original.indexOf("}", r.end) ? t.str.original.indexOf(",", r.end) + 1 : r.end;
							for (; "" === t.str.original[e].trim();) e++;
							t.str.remove(r.start, e), s++;
							continue;
						}
						n.push(r.imported.name);
					}
					if (s === e.specifiers.length && t.str.remove(e.start, e.end), n.length > 0) throw new NP(`Can't migrate code with ${n.join(" and ")}. Please migrate by hand.`);
				}
			},
			ExportNamedDeclaration(e, { state: t, next: n }) {
				if (e.declaration) return void n();
				let s = 0;
				for (const n of e.specifiers) {
					if ("Identifier" !== n.local.type) continue;
					"bindable_prop" === t.scope.get(n.local.name)?.kind && (t.str.remove(n.start, n.end), s++);
				}
				s === e.specifiers.length && t.str.remove(e.start, e.end);
			},
			VariableDeclaration(e, { state: t, path: n, visit: s, next: r }) {
				if (t.scope !== t.analysis.instance.scope) return;
				let a = 0;
				for (let i = 0; i < e.declarations.length; i++) {
					const o = e.declarations[i];
					if (t.analysis.runes) {
						"$props" === xc(o.init, t.scope) && (t.props_insertion_point = o.id.start + 1, t.has_props_rune = !0);
						continue;
					}
					let l;
					try {
						l = t.scope.get_bindings(o);
					} catch (d) {
						r();
						continue;
					}
					const c = l.some(((e) => "state" === e.kind)), p = l.some(((e) => "bindable_prop" === e.kind));
					if (c || p) if (p) {
						if (a++, "Identifier" !== o.id.type) throw new NP("Encountered an export declaration pattern that is not supported for automigration.");
						const h = o.id.name, m = t.scope.get(h);
						if (t.analysis.uses_props && (o.init || m.updated)) throw new NP("$$props is used together with named props in a way that cannot be automatically migrated.");
						const f = t.props.find(((e) => e.exported === (m.prop_alias || h)));
						f ? (r(), f.init = o.init ? t.str.snip(o.init.start, o.init.end).toString() : "", f.bindable = m.updated, f.exported = m.prop_alias || h, f.type_only = !1) : (r(), t.props.push({
							local: h,
							exported: m.prop_alias ? m.prop_alias : h,
							init: o.init ? t.str.snip(o.init.start, o.init.end).toString() : "",
							optional: !!o.init,
							bindable: m.updated,
							...HP(o, t, n)
						}));
						let y = o.start, v = o.end;
						e.declarations.length > 1 ? (t.props_insertion_point = e.end, 0 !== i && (y = t.str.original.indexOf(",", e.declarations[i - 1].end)), i !== e.declarations.length - 1 && (v = 0 === i ? e.declarations[i + 1].start : t.str.original.lastIndexOf(",", e.declarations[i + 1].start))) : t.props_insertion_point = o.end, t.str.update(y, v, "");
					} else if (o.init) {
						let { start: g, end: b } = o.init;
						if ("SequenceExpression" === o.init.type) {
							for (; "(" !== t.str.original[g];) g -= 1;
							for (; ")" !== t.str.original[b - 1];) b += 1;
						}
						u("state"), t.str.prependLeft(g, "$state("), t.str.appendRight(b, ")");
					} else {
						let _, x;
						const w = l.every(((e) => e.references.every(((t) => {
							const n = t.path.find(((e) => "VariableDeclaration" === e.type)), s = t.path.find(((e) => "AssignmentExpression" === e.type)), r = t.path.find(((e) => "UpdateExpression" === e.type)), a = t.path.find(((e) => "LabeledStatement" === e.type && "$" === e.label.name));
							if (s && a && ("ExpressionStatement" !== a.body.type || a.body.expression !== s || "Identifier" === s.left.type && s.left.name === e.node.name)) {
								if (_) return !1;
								_ = s, x = a;
							}
							return !r && (n && e.initial || a && s || !a && !s);
						})))), k = "BlockStatement" === x?.body.type && 1 === x.body.body.length && "ExpressionStatement" === x.body.body[0].type, C = "ExpressionStatement" === x?.body.type && "AssignmentExpression" === x.body.expression.type;
						let S = !1;
						if (C) {
							const E = (x?.body).expression, [, T] = no(E.right);
							0 === T.length && (S = !0, t.derived_labeled_statements.add(x));
						}
						if (!S && w && _ && x && (k || C)) {
							const A = t.str.original.substring(t.str.original.lastIndexOf("\n", e.start) + 1, e.start);
							if ("BlockStatement" === x.body.type && x.body.body[0].leadingComments) for (let $ of x.body.body[0].leadingComments) t.str.prependLeft(e.start, "Block" === $.type ? `/*${$.value}*/\n${A}` : `// ${$.value}\n${A}`);
							if (u("derived"), t.str.appendRight(o.id.typeAnnotation?.end ?? o.id.end, " = $derived("), s(_.right), t.str.appendRight(o.id.typeAnnotation?.end ?? o.id.end, t.str.snip(_.right.start, _.right.end).toString()), t.str.remove(x.start, x.end), t.str.appendRight(o.id.typeAnnotation?.end ?? o.id.end, ")"), t.derived_labeled_statements.add(x), "BlockStatement" === x.body.type && x.body.body[0].trailingComments) for (let R of x.body.body[0].trailingComments) t.str.appendRight(o.id.typeAnnotation?.end ?? o.id.end, "Block" === R.type ? `\n${A}/*${R.value}*/` : `\n${A}// ${R.value}`);
						} else u("state"), t.str.prependLeft(o.id.typeAnnotation?.end ?? o.id.end, " = $state("), S && (t.str.appendRight(o.id.typeAnnotation?.end ?? o.id.end, t.str.snip(_.right.start, _.right.end).toString()), t.str.remove(x.start, x.end)), t.str.appendRight(o.id.typeAnnotation?.end ?? o.id.end, ")");
					}
					else r();
					function u(n) {
						if (!!t.scope.get(n)) throw new NP(`can't migrate \`${t.str.original.substring(e.start, e.end)}\` to \`$${n}\` because there's a variable named ${n}.\n     Rename the variable and try again or migrate by hand.`);
					}
				}
				if (a === e.declarations.length) {
					let I = e.start, M = e.end;
					const q = n.at(-1);
					for ("ExportNamedDeclaration" === q?.type && (I = q.start, M = q.end); "\n" !== t.str.original[I];) I--;
					for (; "\n" !== t.str.original[M];) M++;
					t.str.update(I, M, "");
				}
			},
			BreakStatement(e, { state: t, path: n }) {
				"LabeledStatement" === n[1].type && "$" === e.label?.name && t.str.update(e.start, e.end, "return;");
			},
			LabeledStatement(e, { path: t, state: n, next: s }) {
				if (n.analysis.runes) return;
				if (t.length > 1) return;
				if ("$" !== e.label.name) return;
				if (n.derived_labeled_statements.has(e)) return;
				function r(t) {
					if (n.scope.get(t)) throw new NP(`can't migrate \`$: ${n.str.original.substring(e.body.start, e.body.end)}\` to \`$${t}\` because there's a variable named ${t}.\n     Rename the variable and try again or migrate by hand.`);
				}
				if (s(), "ExpressionStatement" === e.body.type && "AssignmentExpression" === e.body.expression.type) {
					const { left: t, right: s } = e.body.expression, a = to(t), [, i] = no(s), o = a.map(((e) => n.scope.get(e.name)));
					if (o.every(((e) => "legacy_reactive" === e.kind))) {
						if ("Literal" !== s.type && o.every(((e) => "store_sub" !== e.kind)) && "MemberExpression" !== t.type) {
							let { start: t, end: a } = s;
							if (r("derived"), n.str.update(e.start, e.body.expression.start, "let "), "SequenceExpression" === s.type) {
								for (; "(" !== n.str.original[t];) t -= 1;
								for (; ")" !== n.str.original[a - 1];) a += 1;
							}
							n.str.prependRight(t, "$derived("), "(" !== n.str.original[e.body.start] && n.str.appendLeft(a, ")");
							return;
						}
						for (const t of o) if (t.reassigned && (a.includes(t.node) || 0 === i.length)) {
							r("state");
							const a = "state" === t.kind ? " = $state()" : 0 === i.length ? ` = $state(${n.str.original.substring(s.start, s.end)})` : "";
							n.str.prependLeft(e.start, `let ${t.node.name}${a};\n${n.indent}`);
						}
						if (0 === i.length && o.every(((e) => "store_sub" !== e.kind))) return void n.str.remove(e.start, e.end);
					}
				}
				n.legacy_imports.add("run");
				const a = "BlockStatement" === e.body.type, i = e.body.start;
				if (a) {
					n.str.update(e.start, i + 1, `${n.names.run}(() => {`);
					const t = e.body.end;
					n.str.update(t - 1, t, "});");
				} else n.str.update(e.start, i, `${n.names.run}(() => {\n${n.indent}`), n.str.indent(n.indent, { exclude: [[0, e.body.start], [e.body.end, n.end]] }), n.str.appendLeft(e.end, `\n${n.indent}});`);
			}
		};
		function BP(e, t, n) {
			const s = e.str.snip(t, n).toString(), r = s.substring(1, s.length - 1);
			r.trim().length !== r.length && e.str.update(t + 1, n - 1, r.trim());
		}
		const FP = {
			Identifier(e, { state: t, path: n }) {
				GP(e, t, n);
			},
			RegularElement(e, { state: t, path: n, next: s }) {
				const r = e.name.replace(/[a-zA-Z-]*:/g, "");
				if ("/" === t.analysis.source[e.end - 2] && !z(r) && !oe(r)) {
					let n = e.end - 2;
					for (; " " === t.str.original.charAt(n - 1);) n--;
					t.str.remove(n, e.end - 1), t.str.appendLeft(e.end, `</${e.name}>`);
				}
				VP(e, n, t), zP(e, t), s();
			},
			SvelteSelf(e, { state: t, next: n }) {
				const s = t.str.original.substring(e.start, e.end);
				if (!t.filename) {
					const r = KP(s);
					OP = !0, t.str.prependRight(e.start, `\x3c!-- @migration-task: svelte:self is deprecated, import this Svelte file into itself instead --\x3e\n${r}`), n();
					return;
				}
				t.str.overwrite(e.start + 1, e.start + 1 + 11, `${t.analysis.name}`), e.fragment.nodes.length > 0 ? t.str.overwrite(t.str.original.lastIndexOf("<", e.end) + 2, e.end - 1, `${t.analysis.name}`) : s.endsWith("/>") || t.str.overwrite(e.start + s.lastIndexOf("</", e.end) + 2, e.end - 1, `${t.analysis.name}`), t.has_svelte_self = !0, n();
			},
			SvelteElement(e, { state: t, path: n, next: s }) {
				if (VP(e, n, t), "Literal" === e.tag.type) {
					let n = !0, s = e.tag.start, r = e.tag.end, a = t.str.original[s - 1];
					for (; "=" !== t.str.original[--s];) if ("{" === t.str.original[s]) {
						n = !1;
						break;
					}
					n && t.str.original[r] === a && (t.str.prependLeft(s + 1, "{"), t.str.appendRight(e.tag.end + 1, "}"));
				}
				zP(e, t), s();
			},
			Component(e, { state: t, path: n, next: s }) {
				s(), VP(e, n, t);
			},
			SvelteComponent(e, { state: t, next: n, path: s }) {
				n(), VP(e, s, t);
				let r = t.str.snip(e.expression.start, e.expression.end).toString();
				if ("Identifier" !== e.expression.type && "MemberExpression" !== e.expression.type || !gl.test(r)) {
					let n = r;
					r = t.scope.generate("SvelteComponent");
					let a = !0;
					for (let i = s.length - 1; i >= 0; i--) {
						const o = s[i];
						if ("EachBlock" === o.type || "AwaitBlock" === o.type || "IfBlock" === o.type || "SnippetBlock" === o.type || "Component" === o.type || "SvelteComponent" === o.type) {
							let o = e.start;
							if (i !== s.length - 1) for (let e = 1; e < s.length - i; e++) {
								const t = s[i + e];
								if ("start" in t) {
									o = t.start;
									break;
								}
							}
							const l = t.str.original.substring(t.str.original.lastIndexOf("\n", o) + 1, o);
							t.str.appendRight(o, `{@const ${r} = ${n}}\n${l}`), a = !1;
							break;
						}
					}
					a && (t.derived_components.has(n) ? r = t.derived_components.get(n) : t.derived_components.set(n, r));
				}
				t.str.overwrite(e.start + 1, e.start + e.name.length + 1, r), t.str.original.substring(e.end - e.name.length - 1, e.end - 1) === e.name && t.str.overwrite(e.end - e.name.length - 1, e.end - 1, r);
				let a = t.str.original.lastIndexOf("this", e.expression.start);
				for (; !t.str.original.charAt(a - 1).trim();) a--;
				const i = t.str.original.indexOf("}", e.expression.end) + 1;
				t.str.remove(a, i);
			},
			SvelteFragment(e, { state: t, path: n, next: s }) {
				VP(e, n, t), s();
			},
			SvelteWindow(e, { state: t, next: n }) {
				zP(e, t), n();
			},
			SvelteBody(e, { state: t, next: n }) {
				zP(e, t), n();
			},
			SvelteDocument(e, { state: t, next: n }) {
				zP(e, t), n();
			},
			SlotElement(e, { state: t, path: n, next: s, visit: r }) {
				if (VP(e, n, t), t.analysis.custom_element) return;
				let a, i = "children", o = "default", l = "{ ";
				for (const s of e.attributes) if ("SpreadAttribute" === s.type) l += `...${t.str.original.substring(s.expression.start, s.expression.end)}, `;
				else if ("Attribute" === s.type) {
					if ("slot" === s.name) continue;
					if ("name" === s.name) o = s.value[0].data, (n.some(((e) => ("RegularElement" === e.type || "SvelteElement" === e.type || "Component" === e.type || "SvelteComponent" === e.type || "SvelteFragment" === e.type) && e.attributes.some(((e) => "Attribute" === e.type && "slot" === e.name && Xi(e) && e.value[0].data === o)))) || e.attributes.some(((e) => "Attribute" === e.type && "slot" === e.name && Xi(e) && e.value[0].data === o))) && (a = `${o}_render`, t.derived_conflicting_slots.set(a, o));
					else {
						const e = !0 === s.value || Array.isArray(s.value) ? s.value : [s.value];
						let n = "true";
						if (!0 !== e) {
							const s = e[0], a = e[e.length - 1];
							for (const t of e) r(t);
							n = t.str.snip("Text" === s.type ? s.start - 1 : s.expression.start, "Text" === a.type ? a.end + 1 : a.expression.end).toString();
						}
						l += n === s.name ? `${n}, ` : `${s.name}: ${n}, `;
					}
				}
				l += "}", "{ }" === l && (l = "");
				const c = t.props.find(((e) => e.slot_name === o));
				if (c) i = c.local;
				else if ("default" !== o && (i = t.scope.generate(o), i !== o)) throw new NP(`This migration would change the name of a slot (${o} to ${i}) making the component unusable`);
				c ? c.needs_refine_type && (c.type = "import('svelte')." + (l ? "Snippet<[any]>" : "Snippet"), c.needs_refine_type = !1) : t.props.push({
					local: i,
					exported: i,
					init: "",
					bindable: !1,
					optional: !0,
					slot_name: o,
					type: "import('svelte')." + (l ? "Snippet<[any]>" : "Snippet")
				}), "default" === o && n.some(((e) => ("SvelteComponent" === e.type || "Component" === e.type || "RegularElement" === e.type || "SvelteElement" === e.type || "SvelteFragment" === e.type) && e.attributes.some(((e) => "LetDirective" === e.type)))) && (a = `${i}_render`, t.derived_conflicting_slots.set(a, i)), i = a ?? i, e.fragment.nodes.length > 0 ? (s(), t.str.update(e.start, e.fragment.nodes[0].start, `{#if ${i}}{@render ${t.analysis.uses_props ? `${t.names.props}.` : ""}${i}(${l})}{:else}`), t.str.update(e.fragment.nodes[e.fragment.nodes.length - 1].end, e.end, "{/if}")) : t.str.update(e.start, e.end, `{@render ${t.analysis.uses_props ? `${t.names.props}.` : ""}${i}?.(${l})}`);
			},
			Comment(e, { state: t }) {
				const n = xt(e.data);
				n !== e.data && t.str.overwrite(e.start + 4, e.end - 3, n);
			},
			HtmlTag(e, { state: t, next: n }) {
				BP(t, e.start, e.end), n();
			},
			ConstTag(e, { state: t, next: n }) {
				BP(t, e.start, e.end), n();
			},
			IfBlock(e, { state: t, next: n }) {
				const s = e.start;
				BP(t, s, t.str.original.indexOf("}", e.test.end) + 1), n();
			},
			AwaitBlock(e, { state: t, next: n }) {
				const s = e.start;
				if (BP(t, s, t.str.original.indexOf("}", null !== e.pending ? e.expression.end : e.value?.end) + 1), null !== e.pending) BP(t, t.str.original.lastIndexOf("{", e.value?.start), t.str.original.indexOf("}", e.value?.end) + 1);
				if (null !== e.catch) BP(t, t.str.original.lastIndexOf("{", e.error?.start), t.str.original.indexOf("}", e.error?.end) + 1);
				n();
			},
			KeyBlock(e, { state: t, next: n }) {
				const s = e.start;
				BP(t, s, t.str.original.indexOf("}", e.expression.end) + 1), n();
			}
		};
		function VP(e, t, n) {
			const s = t.at(-2);
			if ("Component" !== s?.type && "SvelteComponent" !== s?.type && "Component" !== e.type && "SvelteComponent" !== e.type) return;
			let r = "children", a = [], i = [];
			for (let t of e.attributes) {
				if ("Attribute" === t.type && "slot" === t.name && Xi(t)) {
					if (r = t.value[0].data, "default" === r && (r = "children"), !m.test(r) || G(r)) return OP = !0, void n.str.appendLeft(e.start, `\x3c!-- @migration-task: migrate this slot by hand, \`${r}\` is an invalid identifier --\x3e\n${n.indent}`);
					if ("Component" === s?.type || "SvelteComponent" === s?.type) {
						for (let t of s.attributes) if (("Attribute" === t.type || "BindDirective" === t.type) && t.name === r) return void n.str.appendLeft(e.start, `\x3c!-- @migration-task: migrate this slot by hand, \`${r}\` would shadow a prop on the parent component --\x3e\n${n.indent}`);
					}
					for (let e of i) e();
					n.str.remove(t.start, t.end);
				}
				"LetDirective" === t.type && (a.push(t.name + (t.expression ? `: ${n.str.original.substring(t.expression.start, t.expression.end)}` : "")), i.push((() => n.str.remove(t.start, t.end))));
			}
			if (i.length > 0) for (let e of i) e();
			"SvelteFragment" === e.type && e.fragment.nodes.length > 0 && (n.str.remove(e.start, e.fragment.nodes[0].start), n.str.remove(e.fragment.nodes[e.fragment.nodes.length - 1].end, e.end));
			const o = a.length > 0 ? `{ ${a.join(", ")} }` : "";
			if ("children" === r && "SvelteFragment" !== e.type) {
				if (0 === a.length) return;
				let s = 0, i = 0;
				for (let t = 0; t < e.fragment.nodes.length; t++) {
					const r = e.fragment.nodes[t], a = "Text" === r.type && !r.data.trim();
					"RegularElement" !== r.type && "SvelteElement" !== r.type && "Component" !== r.type && "SvelteComponent" !== r.type && "SlotElement" !== r.type && "SvelteFragment" !== r.type || !r.attributes.some(((e) => "Attribute" === e.type && "slot" === e.name)) ? s || a ? i && !a && (n.str.update(i - 1, i, ""), n.str.prependLeft(i - 1, n.str.original[i - 1]), n.str.move(r.start, r.end, i - 1)) : s = r.start : s && !i && (i = r.start);
				}
				i || (i = e.fragment.nodes[e.fragment.nodes.length - 1].end), n.str.appendLeft(s, `{#snippet ${r}(${o})}\n${n.indent.repeat(t.length)}`), n.str.indent(n.indent, { exclude: [[0, s], [i, n.str.original.length]] }), i < e.fragment.nodes[e.fragment.nodes.length - 1].end ? n.str.prependLeft(i, `{/snippet}\n${n.indent.repeat(t.length)}`) : n.str.prependLeft(i, `${n.indent.repeat(t.length)}{/snippet}\n${n.indent.repeat(t.length - 1)}`);
			} else {
				n.str.prependLeft(e.start, `{#snippet ${r}(${o})}\n${n.indent.repeat(t.length - 2)}`), n.str.indent(n.indent, { exclude: [[0, e.start], [e.end, n.str.original.length]] });
				const s = `\n${n.indent.repeat(t.length - 2)}{/snippet}`;
				"SlotElement" === e.type ? n.str.appendRight(e.end, s) : n.str.appendLeft(e.end, s);
			}
		}
		function HP(e, t, n) {
			const s = t.str, r = n.at(-1);
			let a = r?.leadingComments?.at(-1);
			const i = a?.start, o = a?.end;
			let l = a && s.original.substring(i, o);
			a && s.update(i, o, "");
			const c = r?.trailingComments?.at(0), p = c?.start, u = c?.end;
			let d = c && s.original.substring(p, u);
			if (c && s.update(p, u, ""), e.id.typeAnnotation) {
				t.has_type_or_fallback = !0;
				let n = e.id.typeAnnotation.start + 1;
				for (; " " === s.original[n];) n++;
				return {
					type: s.original.substring(n, e.id.typeAnnotation.end),
					comment: l,
					trailing_comment: d
				};
			}
			let h = l?.split("\n").map(((e) => e.trim().replace(/^\/\/\s*/g, "").replace(/^\/\*\*?\s*/g, "").replace(/\s*\*\/$/g, "").replace(/^\*\s*/g, ""))).filter(Boolean);
			const m = h?.findIndex(((e) => e.startsWith("@")));
			let f = h?.slice(0, -1 !== m ? m : h.length).join("\n"), y = d?.split("\n").map(((e) => e.trim().replace(/^\/\/\s*/g, "").replace(/^\/\*\*?\s*/g, "").replace(/\s*\*\/$/g, "").replace(/^\*\s*/g, ""))).filter(Boolean);
			const v = y?.findIndex(((e) => e.startsWith("@")));
			let g = y?.slice(0, -1 !== v ? v : y.length).join("\n");
			if ("ExportNamedDeclaration" === r?.type && a) {
				t.has_type_or_fallback = !0;
				const e = /@type {(.+)}/.exec(a.value);
				if (e) {
					const t = /@type {.+} (?:\w+|\[.*?\]) - (.+)/.exec(a.value);
					return t && (f += t[1]?.trim()), {
						type: e[1],
						comment: f,
						trailing_comment: g
					};
				}
			}
			if ("Literal" === e.init?.type) {
				t.has_type_or_fallback = !0;
				const n = typeof e.init.value;
				if ("string" === n || "number" === n || "boolean" === n) return {
					type: n,
					comment: t.uses_ts ? l : f,
					trailing_comment: t.uses_ts ? d : g
				};
			}
			return {
				type: "any",
				comment: t.uses_ts ? l : f,
				trailing_comment: t.uses_ts ? d : g
			};
		}
		const UP = [
			"preventDefault",
			"stopPropagation",
			"stopImmediatePropagation",
			"self",
			"trusted",
			"once"
		];
		function zP(e, t) {
			const n = /* @__PURE__ */ new Map();
			for (const t of e.attributes) {
				if ("OnDirective" !== t.type) continue;
				let e = `on${t.name}`;
				t.modifiers.includes("capture") && (e += "capture");
				const s = n.get(e) || [];
				s.push(t), n.set(e, s);
			}
			for (const [e, s] of n) {
				const n = [];
				let r = null;
				for (const e of s) {
					let s;
					e.expression ? s = t.str.original.substring(e.expression.start, e.expression.end) : (s = `${t.names.bubble}('${e.name}')`, t.legacy_imports.add("createBubbler"), t.script_insertions.add(`const ${t.names.bubble} = ${t.names.createBubbler}();`));
					const a = e.modifiers.includes("passive"), i = e.modifiers.includes("nonpassive"), o = UP.filter(((t) => e.modifiers.includes(t)));
					for (const e of o) t.legacy_imports.add(e), s = `${t.names[e]}(${s})`;
					if (a || i) {
						const n = a ? "passive" : "nonpassive";
						t.legacy_imports.add(n), t.str.overwrite(e.start, e.end, `use:${t.names[n]}={['${e.name}', () => ${s}]}`);
					} else {
						if (r) {
							let n = e.start, s = e.end;
							for (; /[\s\n]/.test(t.str.original[n - 1]);) n -= 1;
							t.str.remove(n, s);
						} else r = e;
						n.push(s);
					}
				}
				if (r) {
					let s;
					if (n.length > 1) t.legacy_imports.add("handlers"), s = `${e}={${t.names.handlers}(${n.join(", ")})}`;
					else {
						const t = n[0];
						s = t === e ? `{${t}}` : `${e}={${t}}`;
					}
					t.str.overwrite(r.start, r.end, s);
				}
			}
		}
		function WP(e, t) {
			const n = t.leadingComments?.[0], s = t.trailingComments?.[t.trailingComments.length - 1];
			let r = n?.start ?? t.start, a = s?.end ?? t.end, i = r;
			for (; "\n" !== e[i - 1] && "\r" !== e[i - 1];) if (i--, " " !== e[i] && "	" !== e[i]) {
				i = r;
				break;
			}
			return r = i, {
				start: r,
				end: a
			};
		}
		function GP(e, t, n) {
			const s = n.at(-1);
			if ("MemberExpression" !== s?.type || s.property !== e) {
				if (t.analysis.uses_props && "$$slots" !== e.name) if ("$$props" === e.name || "$$restProps" === e.name) t.str.update(e.start, e.end, t.names.props);
				else {
					const n = t.scope.get(e.name);
					"bindable_prop" === n?.kind && n.node !== e && t.str.prependLeft(e.start, `${t.names.props}.`);
				}
				else if ("$$restProps" === e.name && t.analysis.uses_rest_props) t.str.update(e.start, e.end, t.names.rest);
				else if ("$$slots" === e.name && t.analysis.uses_slots) {
					if ("MemberExpression" === s?.type) {
						if (t.analysis.custom_element) return;
						let n = "Literal" === s.property.type ? s.property.value : s.property.name, r = n;
						const a = t.props.find(((e) => e.slot_name === n));
						if (a) n = a.local;
						else if ("default" !== n) {
							let e = t.scope.generate(n);
							if (e !== n) throw new NP(`This migration would change the name of a slot (${n} to ${e}) making the component unusable`);
						}
						n = "default" === n ? "children" : n, a || t.props.push({
							local: n,
							exported: n,
							init: "",
							bindable: !1,
							optional: !0,
							slot_name: r,
							type: "import('svelte').Snippet<[any]>",
							needs_refine_type: !0
						}), t.str.update(e.start, s.property.start, t.analysis.uses_props ? `${t.names.props}.` : ""), t.str.update(s.property.start, s.end, n);
					}
				} else if ("TSInterfaceDeclaration" === s?.type || "TSTypeAliasDeclaration" === s?.type) {
					const n = "TSInterfaceDeclaration" === s.type ? s.body.body : s.typeAnnotation?.members;
					if (Array.isArray(n) && "$$Props" === e.name) {
						t.has_type_or_fallback = !0;
						for (const e of n) {
							const n = t.props.find(((t) => t.exported === e.key.name)), s = t.str.original.substring(e.typeAnnotation.typeAnnotation.start, e.typeAnnotation.typeAnnotation.end);
							let r;
							const a = e.leadingComments?.at(-1);
							"Block" === a?.type && (r = t.str.original.substring(a.start, a.end));
							const i = e.trailingComments?.at(0)?.value;
							n ? (n.type = s, n.optional = e.optional, n.comment = r ?? n.comment, n.trailing_comment = i ?? n.trailing_comment) : t.props.push({
								local: e.key.name,
								exported: e.key.name,
								init: "",
								bindable: !1,
								optional: e.optional,
								type: s,
								comment: r,
								trailing_comment: i,
								type_only: !0
							});
						}
						t.str.remove(s.start, s.end);
					}
				}
			}
		}
		function KP(e) {
			const t = e.split("\n"), n = t.filter(((e) => /^\t+/.test(e))), s = t.filter(((e) => /^ {2,}/.test(e)));
			if (0 === n.length && 0 === s.length) return "	";
			if (n.length >= s.length) return "	";
			const r = s.reduce(((e, t) => {
				const n = /^ +/.exec(t)?.[0].length ?? 0;
				return Math.min(n, e);
			}), Infinity);
			return " ".repeat(r);
		}
		function XP(e, n, s) {
			if (s) {
				const e = (e) => {
					delete e.metadata;
				};
				return n.options?.attributes.forEach(((t) => {
					e(t), e(t.value), Array.isArray(t.value) && t.value.forEach(e);
				})), t(n, null, { _(t, { next: n }) {
					e(t), n();
				} });
			}
			return function(e, n) {
				return t(n, null, {
					_(e, { next: t }) {
						delete e.metadata, t();
					},
					Root(t, { visit: s }) {
						const { instance: r, module: a, options: i } = t;
						if (i?.__raw__) {
							let e = t.fragment.nodes.findIndex(((e) => i.end <= e.start));
							-1 === e && (e = t.fragment.nodes.length), t.fragment.nodes.splice(e, 0, i.__raw__);
						}
						let o = null, l = null;
						if (t.fragment.nodes.length > 0) {
							const n = t.fragment.nodes.at(0), s = t.fragment.nodes.at(-1);
							for (o = n.start, l = s.end; /\s/.test(e[o]);) o += 1;
							for (; /\s/.test(e[l - 1]);) l -= 1;
						}
						return r && delete r.attributes, a && delete a.attributes, {
							html: {
								type: "Fragment",
								start: o,
								end: l,
								children: t.fragment.nodes.map(((e) => s(e)))
							},
							instance: r,
							module: a,
							css: n.css ? s(n.css) : void 0,
							_comments: n.comments?.length > 0 ? n.comments : void 0
						};
					},
					AnimateDirective: (e) => ({
						...e,
						type: "Animation"
					}),
					AwaitBlock(t, { visit: n }) {
						let s = {
							type: "PendingBlock",
							start: null,
							end: null,
							children: t.pending?.nodes.map(((e) => n(e))) ?? [],
							skip: !0
						}, r = {
							type: "ThenBlock",
							start: null,
							end: null,
							children: t.then?.nodes.map(((e) => n(e))) ?? [],
							skip: !0
						}, a = {
							type: "CatchBlock",
							start: null,
							end: null,
							children: t.catch?.nodes.map(((e) => n(e))) ?? [],
							skip: !0
						};
						if (t.pending) {
							const n = t.pending.nodes.at(0), r = t.pending.nodes.at(-1);
							s.start = n?.start ?? e.indexOf("}", t.expression.end) + 1, s.end = r?.end ?? s.start, s.skip = !1;
						}
						if (t.then) {
							const n = t.then.nodes.at(0), a = t.then.nodes.at(-1);
							r.start = s.end ?? n?.start ?? e.indexOf("}", t.expression.end) + 1, r.end = a?.end ?? e.lastIndexOf("}", s.end ?? t.expression.end) + 1, r.skip = !1;
						}
						if (t.catch) {
							const n = t.catch.nodes.at(0), i = t.catch.nodes.at(-1);
							a.start = r.end ?? s.end ?? n?.start ?? e.indexOf("}", t.expression.end) + 1, a.end = i?.end ?? e.lastIndexOf("}", r.end ?? s.end ?? t.expression.end) + 1, a.skip = !1;
						}
						return {
							type: "AwaitBlock",
							start: t.start,
							end: t.end,
							expression: t.expression,
							value: t.value,
							error: t.error,
							pending: s,
							then: r,
							catch: a
						};
					},
					BindDirective: (e) => ({
						...e,
						type: "Binding"
					}),
					ClassDirective: (e) => ({
						...e,
						type: "Class"
					}),
					Comment: (e) => ({
						...e,
						ignores: _t(e.start, e.data, !1)
					}),
					ComplexSelector(e, { next: t }) {
						t();
						const n = [];
						for (const t of e.children) t.combinator && n.push(t.combinator), n.push(...t.selectors);
						return {
							type: "Selector",
							start: e.start,
							end: e.end,
							children: n
						};
					},
					Component: (e, { visit: t }) => ({
						type: "InlineComponent",
						start: e.start,
						end: e.end,
						name: e.name,
						attributes: e.attributes.map(((e) => t(e))),
						children: e.fragment.nodes.map(((e) => t(e)))
					}),
					ConstTag(e) {
						if (void 0 !== e.expression) return e;
						const t = e, { id: n } = { ...t.declaration.declarations[0] };
						return delete n.typeAnnotation, {
							type: "ConstTag",
							start: t.start,
							end: e.end,
							expression: {
								type: "AssignmentExpression",
								start: (t.declaration.start ?? 0) + 6,
								end: t.declaration.end ?? 0,
								operator: "=",
								left: n,
								right: t.declaration.declarations[0].init
							}
						};
					},
					KeyBlock: (e, { visit: t }) => (wt(e.fragment.nodes), {
						type: "KeyBlock",
						start: e.start,
						end: e.end,
						expression: e.expression,
						children: e.fragment.nodes.map(((e) => t(e)))
					}),
					EachBlock(t, { visit: n }) {
						let s;
						if (t.fallback) {
							const r = t.fallback.nodes.at(0), a = e.lastIndexOf("{", t.end - 1), i = r?.start ?? a;
							wt(t.fallback.nodes), s = {
								type: "ElseBlock",
								start: i,
								end: a,
								children: t.fallback.nodes.map(((e) => n(e)))
							};
						}
						return wt(t.body.nodes), {
							type: "EachBlock",
							start: t.start,
							end: t.end,
							children: t.body.nodes.map(((e) => n(e))),
							context: t.context,
							expression: t.expression,
							index: t.index,
							key: t.key,
							else: s
						};
					},
					ExpressionTag(t, { path: n }) {
						const s = n.at(-1);
						return "Attribute" === s?.type && "{" === e[s.start] ? {
							type: "AttributeShorthand",
							start: t.start,
							end: t.end,
							expression: t.expression
						} : {
							type: "MustacheTag",
							start: t.start,
							end: t.end,
							expression: t.expression
						};
					},
					HtmlTag: (e) => ({
						...e,
						type: "RawMustacheTag"
					}),
					IfBlock(t, { visit: n }) {
						let s;
						if (t.alternate) {
							let r = t.alternate.nodes;
							1 === r.length && "IfBlock" === r[0].type && r[0].elseif && (r = r[0].consequent.nodes);
							const a = e.lastIndexOf("{", t.end - 1), i = r.at(0)?.start ?? a;
							wt(t.alternate.nodes), s = {
								type: "ElseBlock",
								start: i,
								end: a,
								children: t.alternate.nodes.map(((e) => n(e)))
							};
						}
						const r = t.elseif ? t.consequent.nodes[0]?.start ?? e.lastIndexOf("{", t.end - 1) : t.start;
						return wt(t.consequent.nodes), {
							type: "IfBlock",
							start: r,
							end: t.end,
							expression: t.test,
							children: t.consequent.nodes.map(((e) => n(e))),
							else: s,
							elseif: !!t.elseif || void 0
						};
					},
					OnDirective: (e) => ({
						...e,
						type: "EventHandler"
					}),
					SnippetBlock: (e, { visit: t }) => (wt(e.body.nodes), {
						type: "SnippetBlock",
						start: e.start,
						end: e.end,
						expression: e.expression,
						parameters: e.parameters,
						children: e.body.nodes.map(((e) => t(e))),
						typeParams: e.typeParams
					}),
					SvelteBoundary: (e, { visit: t }) => (wt(e.fragment.nodes), {
						type: "SvelteBoundary",
						name: "svelte:boundary",
						start: e.start,
						end: e.end,
						attributes: e.attributes.map(((e) => t(e))),
						children: e.fragment.nodes.map(((e) => t(e)))
					}),
					RegularElement: (e, { visit: t }) => ({
						type: "Element",
						start: e.start,
						end: e.end,
						name: e.name,
						attributes: e.attributes.map(((e) => t(e))),
						children: e.fragment.nodes.map(((e) => t(e)))
					}),
					SlotElement: (e, { visit: t }) => ({
						type: "Slot",
						start: e.start,
						end: e.end,
						name: e.name,
						attributes: e.attributes.map(((e) => t(e))),
						children: e.fragment.nodes.map(((e) => t(e)))
					}),
					Attribute(e, { visit: t, next: n, path: s }) {
						if (!0 === e.value || Array.isArray(e.value)) return n();
						{
							s.push(e);
							const n = [t(e.value)];
							return s.pop(), {
								...e,
								value: n
							};
						}
					},
					StyleDirective(e, { visit: t, next: n, path: s }) {
						if (!0 === e.value || Array.isArray(e.value)) return n();
						{
							s.push(e);
							const n = [t(e.value)];
							return s.pop(), {
								...e,
								value: n
							};
						}
					},
					SpreadAttribute: (e) => ({
						...e,
						type: "Spread"
					}),
					StyleSheet: (e, t) => ({
						...e,
						...t.next(),
						type: "Style"
					}),
					SvelteBody: (e, { visit: t }) => ({
						type: "Body",
						name: "svelte:body",
						start: e.start,
						end: e.end,
						attributes: e.attributes.map(((e) => t(e))),
						children: e.fragment.nodes.map(((e) => t(e)))
					}),
					SvelteComponent: (e, { visit: t }) => ({
						type: "InlineComponent",
						name: "svelte:component",
						start: e.start,
						end: e.end,
						expression: e.expression,
						attributes: e.attributes.map(((e) => t(e))),
						children: e.fragment.nodes.map(((e) => t(e)))
					}),
					SvelteDocument: (e, { visit: t }) => ({
						type: "Document",
						name: "svelte:document",
						start: e.start,
						end: e.end,
						attributes: e.attributes.map(((e) => t(e))),
						children: e.fragment.nodes.map(((e) => t(e)))
					}),
					SvelteElement(t, { visit: n }) {
						let s = t.tag;
						return "Literal" === s.type && "string" == typeof s.value && "{" !== e[t.tag.start - 1] && (s = s.value), {
							type: "Element",
							name: "svelte:element",
							start: t.start,
							end: t.end,
							tag: s,
							attributes: t.attributes.map(((e) => n(e))),
							children: t.fragment.nodes.map(((e) => n(e)))
						};
					},
					SvelteFragment: (e, { visit: t }) => ({
						type: "SlotTemplate",
						name: "svelte:fragment",
						start: e.start,
						end: e.end,
						attributes: e.attributes.map(((e) => t(e))),
						children: e.fragment.nodes.map(((e) => t(e)))
					}),
					SvelteHead: (e, { visit: t }) => ({
						type: "Head",
						name: "svelte:head",
						start: e.start,
						end: e.end,
						attributes: e.attributes.map(((e) => t(e))),
						children: e.fragment.nodes.map(((e) => t(e)))
					}),
					SvelteOptions: (e, { visit: t }) => ({
						type: "Options",
						name: "svelte:options",
						start: e.start,
						end: e.end,
						attributes: e.attributes.map(((e) => t(e)))
					}),
					SvelteSelf: (e, { visit: t }) => ({
						type: "InlineComponent",
						name: "svelte:self",
						start: e.start,
						end: e.end,
						attributes: e.attributes.map(((e) => t(e))),
						children: e.fragment.nodes.map(((e) => t(e)))
					}),
					SvelteWindow: (e, { visit: t }) => ({
						type: "Window",
						name: "svelte:window",
						start: e.start,
						end: e.end,
						attributes: e.attributes.map(((e) => t(e))),
						children: e.fragment.nodes.map(((e) => t(e)))
					}),
					Text(e, { path: t }) {
						const n = t.at(-1);
						if ("RegularElement" === n?.type && "style" === n.name) return {
							type: "Text",
							start: e.start,
							end: e.end,
							data: e.data
						};
					},
					TitleElement: (e, { visit: t }) => ({
						type: "Title",
						name: "title",
						start: e.start,
						end: e.end,
						attributes: e.attributes.map(((e) => t(e))),
						children: e.fragment.nodes.map(((e) => t(e)))
					}),
					TransitionDirective: (e) => ({
						...e,
						type: "Transition"
					}),
					UseDirective: (e) => ({
						...e,
						type: "Action"
					}),
					LetDirective: (e) => ({
						...e,
						type: "Let"
					})
				});
			}(e, n);
		}
		function QP(e) {
			return 65279 === e.charCodeAt(0) ? e.slice(1) : e;
		}
		e.VERSION = ek, e.compile = function(e, t) {
			e = QP(e), Te({
				warning: t.warningFilter,
				filename: t.filename
			});
			const n = rP(t, "");
			let s = zl(e);
			const { customElement: r, ...a } = s.options || {}, i = {
				...n,
				...a,
				customElementOptions: r
			};
			s.metadata.ts && (s = {
				...s,
				fragment: s.fragment && Kl(s.fragment),
				instance: s.instance && Kl(s.instance),
				module: s.module && Kl(s.module)
			}, i.customElementOptions?.extend && (i.customElementOptions.extend = Kl(i.customElementOptions?.extend)));
			const o = ZS(_w(s, e, i), e, i);
			return o.ast = XP(e, s, t.modernAst), o;
		}, e.compileModule = function(e, n) {
			e = QP(e), Te({
				warning: n.warningFilter,
				filename: n.filename
			});
			const s = sP(n, "");
			return eP(function(e, n) {
				const s = [];
				ke(e);
				const r = Fs(e, s, !1, !1), { scope: a, scopes: i, has_await: o } = bc(r, new gc(), !1, null);
				for (const [e, t] of a.references) "$" !== e[0] || bw.includes(e) || ("$" !== e && "$" !== e[1] || Js(t[0].node, e), null === a.get(e.slice(1)) || de(e) || zs(t[0].node, "store_invalid_subscription_module", "Cannot reference store value outside a `.svelte` file\nhttps://svelte.dev/e/store_invalid_subscription_module"));
				const l = {
					module: {
						ast: r,
						scope: a,
						scopes: i,
						has_await: o
					},
					name: n.filename,
					accessors: !1,
					runes: !0,
					immutable: !0,
					tracing: !1,
					async_deriveds: /* @__PURE__ */ new Set(),
					comments: s,
					classes: /* @__PURE__ */ new Map(),
					pickled_awaits: /* @__PURE__ */ new Set()
				};
				return Ae({
					dev: n.dev,
					rootDir: n.rootDir,
					runes: !0
				}), t(r, {
					scope: a,
					scopes: i,
					analysis: l,
					state_fields: /* @__PURE__ */ new Map(),
					ast_type: null,
					component_slots: /* @__PURE__ */ new Set(),
					expression: null,
					function_depth: 0,
					has_props_rune: !1,
					options: n,
					fragment: null,
					parent_element: null,
					reactive_statement: null,
					derived_function_depth: -1
				}, vw), l;
			}(e, s), e, s);
		}, e.migrate = function(e, { filename: n, use_ts: s } = {}) {
			let r = e;
			try {
				OP = !1;
				const a = [];
				e = e.replace(qP, ((e, t, n, s, r) => (a.push([r + t.length, n]), t + LP + s))), Te({
					warning: () => !1,
					filename: n
				});
				let i = zl(e);
				const { customElement: o, ...l } = i.options || {}, c = {
					...rP({}, ""),
					...l,
					customElementOptions: o,
					filename: n ?? ye,
					experimental: { async: !0 }
				}, p = new hk(e), u = _w(i, e, c), d = KP(e);
				p.replaceAll(/(<svelte:options\s.*?\s?)accessors\s?/g, ((e, t) => t));
				for (const _ of a) p.overwrite(_[0], _[0] + 25, _[1]);
				let h = {
					scope: u.instance.scope,
					analysis: u,
					filename: n,
					str: p,
					indent: d,
					props: [],
					props_insertion_point: i.instance?.content.start ?? 0,
					has_props_rune: !1,
					has_type_or_fallback: !1,
					end: e.length,
					names: {
						props: u.root.unique("props").name,
						rest: u.root.unique("rest").name,
						run: u.root.unique("run").name,
						handlers: u.root.unique("handlers").name,
						stopImmediatePropagation: u.root.unique("stopImmediatePropagation").name,
						preventDefault: u.root.unique("preventDefault").name,
						stopPropagation: u.root.unique("stopPropagation").name,
						once: u.root.unique("once").name,
						self: u.root.unique("self").name,
						trusted: u.root.unique("trusted").name,
						createBubbler: u.root.unique("createBubbler").name,
						bubble: u.root.unique("bubble").name,
						passive: u.root.unique("passive").name,
						nonpassive: u.root.unique("nonpassive").name
					},
					legacy_imports: /* @__PURE__ */ new Set(),
					script_insertions: /* @__PURE__ */ new Set(),
					derived_components: /* @__PURE__ */ new Map(),
					derived_conflicting_slots: /* @__PURE__ */ new Map(),
					derived_labeled_statements: /* @__PURE__ */ new Set(),
					has_svelte_self: !1,
					uses_ts: s && !e.includes("@type {") || !!i.instance?.attributes.some(((e) => "lang" === e.name && "ts" === e.value[0].data))
				};
				if (i.module) {
					const x = i.module.attributes.find(((e) => "context" === e.name));
					x && h.str.update(x.start, x.end, "module");
				}
				i.instance && t(i.instance.content, h, jP), h = {
					...h,
					scope: u.template.scope
				}, t(i.fragment, h, FP);
				let m = i.instance ? i.instance.content.start : 0;
				const f = h.legacy_imports.size > 0 || h.derived_components.size > 0 || h.derived_conflicting_slots.size > 0 || h.script_insertions.size > 0 || h.props.length > 0 || u.uses_rest_props || u.uses_props || h.has_svelte_self, y = h.uses_ts && (!i.instance || !i.instance.attributes.some(((e) => "lang" === e.name)));
				if (!i.instance && f && p.appendRight(0, y ? "<script lang=\"ts\">" : "<script>"), h.has_svelte_self && n) {
					const w = n.split("/").pop();
					p.appendRight(m, `\n${d}import ${h.analysis.name} from './${w}';`);
				}
				const v = `import { ${[...h.legacy_imports].map(((e) => {
					const t = h.names[e];
					return e === t ? e : `${e} as ${t}`;
				})).join(", ")} } from 'svelte/legacy';\n`;
				function g(e) {
					if (!!h.scope.get(e)) throw new NP(`migrating this component would require adding a \`$${e}\` rune but there's already a variable named ${e}.\n     Rename the variable and try again or migrate by hand.`);
				}
				if (h.legacy_imports.size > 0 && p.appendRight(m, `\n${d}${v}`), h.script_insertions.size > 0 && p.appendRight(m, `\n${d}${[...h.script_insertions].join(`\n${d}`)}`), m = h.props_insertion_point, h.props.length > 0 || u.uses_rest_props || u.uses_props) {
					const k = h.props.length > 3, C = `\n${d}${d}`, S = k ? C : " ";
					let P = "";
					if (u.uses_props ? P = `...${h.names.props}` : (P = h.props.filter(((e) => !e.type_only)).map(((e) => {
						let t = e.local === e.exported ? e.local : `${e.exported}: ${e.local}`;
						return e.bindable ? (g("bindable"), t += ` = $bindable(${e.init})`) : e.init && (t += ` = ${e.init}`), t;
					})).join(`,${S}`), u.uses_rest_props && (P += `${h.props.length > 0 ? `,${S}` : ""}...${h.names.rest}`)), h.has_props_rune) p.appendRight(m, ` ${P},`);
					else {
						const E = h.scope.root.unique("Props").name;
						let T = "";
						(h.has_type_or_fallback || h.props.every(((e) => e.slot_name))) && (h.uses_ts ? (T = `interface ${E} {${C}${h.props.map(((e) => `${e.comment ? `${e.comment}${C}` : ""}${e.exported}${e.optional ? "?" : ""}: ${e.type};${e.trailing_comment ? " " + e.trailing_comment : ""}`)).join(C)}`, (u.uses_props || u.uses_rest_props) && (T += `${h.props.length > 0 ? C : ""}[key: string]: any`), T += `\n${d}}`) : T = `/**\n${d} * @typedef {Object} ${E}${h.props.map(((e) => `\n${d} * @property {${e.type}} ${e.optional ? `[${e.exported}]` : e.exported}${e.comment ? ` - ${e.comment}` : ""}${e.trailing_comment ? ` - ${e.trailing_comment.trim()}` : ""}`)).join("")}\n${d} */`);
						let A = `let {${S}${P}${k ? `\n${d}` : " "}}`;
						h.uses_ts ? (T && (A = `${T}\n\n${d}${A}`), g("props"), A = `${A}${T ? `: ${E}` : ""} = $props();`) : (T && (A = `${h.props.length > 0 ? `${T}\n\n${d}` : ""}/** @type {${h.props.length > 0 ? E : ""}${u.uses_props || u.uses_rest_props ? (h.props.length > 0 ? " & " : "") + "{ [key: string]: any }" : ""}} */\n${d}${A}`), g("props"), A = `${A} = $props();`), A = `\n${d}${A}`, p.appendRight(m, A);
					}
					i.instance && y && p.appendRight(i.instance.start + 7, " lang=\"ts\"");
				}
				let b = !1;
				for (const [$, { dependencies: R }] of h.analysis.reactive_statements) {
					let I = [];
					if ("ExpressionStatement" === $.body.type && "AssignmentExpression" === $.body.expression.type && (I = to($.body.expression.left).map(((e) => h.scope.get(e.name))).filter(((e) => !!e))), R.some(((e) => !I.includes(e) && ("prop" === e.kind || "bindable_prop" === e.kind ? h.props_insertion_point : e.node.start) > $.start))) {
						b = !0;
						break;
					}
				}
				if (b) {
					const M = Array.from(h.analysis.reactive_statements.keys());
					for (const q of M) {
						const { start: L, end: O } = WP(e, q);
						p.appendLeft(O, "\n"), p.move(L, O, i.instance?.content.end), p.update(L - ("\r" === e[L - 2] ? 2 : 1), L, "");
					}
				}
				return m = i.instance ? i.instance.content.end : m, h.derived_components.size > 0 && (g("derived"), p.appendRight(m, `\n${d}${[...h.derived_components.entries()].map((([e, t]) => `const ${t} = $derived(${e});`)).join(`\n${d}`)}\n`)), h.derived_conflicting_slots.size > 0 && (g("derived"), p.appendRight(m, `\n${d}${[...h.derived_conflicting_slots.entries()].map((([e, t]) => `const ${e} = $derived(${t});`)).join(`\n${d}`)}\n`)), h.props.length > 0 && h.analysis.accessors && p.appendRight(m, `\n${d}export {${h.props.reduce(((e, t) => t.slot_name || t.type_only ? e : `${e}\n${d}\t${t.local},`), "")}\n${d}}\n`), !i.instance && f && p.appendRight(m, "\n<\/script>\n\n"), function(e) {
					if (!e.analysis.css.ast?.start) return;
					const t = e.str.snip(e.analysis.css.ast.start, e.analysis.css.ast?.end).toString();
					let n = t, s = 0;
					const r = new hk(n);
					for (; n;) {
						if (n.startsWith(":has") || n.startsWith(":is") || n.startsWith(":where") || n.startsWith(":not")) {
							let e = n.indexOf("(") + 1, a = !1;
							const i = ":global", o = n.indexOf(i);
							if (n.substring(e, o).trim()) {
								const r = t.lastIndexOf(i, s);
								if (r > -1) {
									const a = DP(t.indexOf("(", r) + 1, t) - s;
									if (a > e) {
										s += a, n = n.substring(a);
										continue;
									}
								}
							} else a = !0, e += 7;
							const l = DP(e, n);
							if (e && l) {
								a || n.startsWith(":not") || (r.prependLeft(s + e, ":global("), r.appendRight(s + l - 1, ")")), s += l - 1, n = n.substring(l - 1);
								continue;
							}
						}
						s++, n = n.substring(1);
					}
					e.str.update(e.analysis.css.ast?.start, e.analysis.css.ast?.end, r.toString());
				}(h), { code: p.toString() };
			} catch (N) {
				return N instanceof NP || console.error("Error while migrating Svelte code", N), OP = !0, { code: `\x3c!-- @migration-task Error while migrating Svelte code: ${N.message} --\x3e\n${r}` };
			} finally {
				OP && console.log(`One or more \`@migration-task\` comments were added to ${n ? `\`${n}\`` : "a file (unfortunately we don't know the name)"}, please check them and complete the migration manually.`);
			}
		}, e.parse = function(e, { modern: t, loose: n } = {}) {
			return e = QP(e), Te({
				warning: () => !1,
				filename: void 0
			}), XP(e, zl(e, n), t);
		}, e.parseCss = function(e) {
			e = QP(e), Te({
				warning: () => !1,
				filename: void 0
			}), ke(e);
			const t = function(e) {
				return Ro(e, ((e) => e.index >= e.template.length));
			}(Ul.forCss(e));
			return {
				type: "StyleSheetFile",
				start: 0,
				end: e.length,
				children: t
			};
		}, e.preprocess = async function(e, t, n) {
			const s = n && n.filename || t.filename, r = t ? Array.isArray(t) ? t : [t] : [], a = new bP(e, s);
			for (const e of r) e.markup && a.update_source(await EP(e.markup, a)), e.script && a.update_source(await PP("script", e.script, a)), e.style && a.update_source(await PP("style", e.style, a));
			return a.to_processed();
		}, e.print = function(e, t = void 0) {
			const n = "Root" === e.type && e.comments || [];
			return Ww(e, {
				...Qw({
					comments: n,
					getLeadingComments: t?.getLeadingComments,
					getTrailingComments: t?.getTrailingComments
				}),
				...MP(n),
				...IP
			});
		}, e.walk = function() {
			throw new Error("'svelte/compiler' no longer exports a `walk` utility — please import it directly from 'estree-walker' instead");
		};
	}));
}));

//#endregion
//#region node_modules/prettier-plugin-svelte/plugin.js
var require_plugin = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var prettierPluginBabel = require_babel();
	var prettier = require_prettier();
	var compiler = require_compiler();
	function _interopNamespace(e) {
		if (e && e.__esModule) return e;
		var n = Object.create(null);
		if (e) Object.keys(e).forEach(function(k) {
			if (k !== "default") {
				var d = Object.getOwnPropertyDescriptor(e, k);
				Object.defineProperty(n, k, d.get ? d : {
					enumerable: true,
					get: function() {
						return e[k];
					}
				});
			}
		});
		n["default"] = e;
		return Object.freeze(n);
	}
	/******************************************************************************
	Copyright (c) Microsoft Corporation.
	
	Permission to use, copy, modify, and/or distribute this software for any
	purpose with or without fee is hereby granted.
	
	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
	REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
	AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
	INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
	LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
	OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
	PERFORMANCE OF THIS SOFTWARE.
	***************************************************************************** */
	function __awaiter(thisArg, _arguments, P, generator) {
		function adopt(value) {
			return value instanceof P ? value : new P(function(resolve) {
				resolve(value);
			});
		}
		return new (P || (P = Promise))(function(resolve, reject) {
			function fulfilled(value) {
				try {
					step(generator.next(value));
				} catch (e) {
					reject(e);
				}
			}
			function rejected(value) {
				try {
					step(generator["throw"](value));
				} catch (e) {
					reject(e);
				}
			}
			function step(result) {
				result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	}
	const selfClosingTags = [
		"area",
		"base",
		"br",
		"col",
		"embed",
		"hr",
		"img",
		"input",
		"link",
		"meta",
		"param",
		"source",
		"track",
		"wbr"
	];
	const blockElements = [
		"address",
		"article",
		"aside",
		"blockquote",
		"details",
		"dialog",
		"dd",
		"div",
		"dl",
		"dt",
		"fieldset",
		"figcaption",
		"figure",
		"footer",
		"form",
		"h1",
		"h2",
		"h3",
		"h4",
		"h5",
		"h6",
		"header",
		"hgroup",
		"hr",
		"li",
		"main",
		"nav",
		"ol",
		"p",
		"pre",
		"section",
		"table",
		"ul"
	];
	/**
	* HTML attributes that we may safely reformat (trim whitespace, add or remove newlines)
	*/
	const formattableAttributes = [];
	const stringToBase64 = typeof Buffer !== "undefined" ? (str) => Buffer.from(str).toString("base64") : (str) => btoa(new TextEncoder().encode(str).reduce((acc, byte) => acc + String.fromCharCode(byte), ""));
	const base64ToString = typeof Buffer !== "undefined" ? (str) => Buffer.from(str, "base64").toString() : (str) => new TextDecoder().decode(Uint8Array.from(atob(str), (c) => c.charCodeAt(0)));
	const snippedTagContentAttribute = "✂prettier:content✂";
	const scriptRegex = /<!--[^]*?-->|<script((?:\s+[^=>'"\/\s]+=(?:"[^"]*"|'[^']*'|[^>\s]+)|\s+[^=>'"\/\s]+)*\s*)>([^]*?)<\/script>/g;
	const styleRegex = /<!--[^]*?-->|<style((?:\s+[^=>'"\/\s]+=(?:"[^"]*"|'[^']*'|[^>\s]+)|\s+[^=>'"\/\s]+)*\s*)>([^]*?)<\/style>/g;
	const langTsRegex = /\slang=["']?ts["']?/;
	function snipScriptAndStyleTagContent(source) {
		let scriptMatchSpans = getMatchIndexes("script");
		let styleMatchSpans = getMatchIndexes("style");
		let isTypescript = false;
		return {
			text: snipTagContent(snipTagContent(source, "script", "{}", styleMatchSpans), "style", "", scriptMatchSpans),
			isTypescript
		};
		function getMatchIndexes(tagName) {
			const regex = getRegexp(tagName);
			const indexes = [];
			let match = null;
			while ((match = regex.exec(source)) != null) if (source.slice(match.index, match.index + 4) !== "<!--") indexes.push([match.index, regex.lastIndex]);
			return indexes;
		}
		function snipTagContent(_source, tagName, placeholder, otherSpans) {
			const regex = getRegexp(tagName);
			let newScriptMatchSpans = scriptMatchSpans;
			let newStyleMatchSpans = styleMatchSpans;
			const newSource = _source.replace(regex, (match, attributes, content, index) => {
				if (match.startsWith("<!--") || withinOtherSpan(index)) return match;
				if (langTsRegex.test(attributes)) isTypescript = true;
				const newContent = `<${tagName}${attributes} ${snippedTagContentAttribute}="${stringToBase64(content)}">${placeholder}</${tagName}>`;
				const lengthDiff = match.length - newContent.length;
				newScriptMatchSpans = adjustSpans(scriptMatchSpans, newScriptMatchSpans);
				newStyleMatchSpans = adjustSpans(styleMatchSpans, newStyleMatchSpans);
				function adjustSpans(oldSpans, newSpans) {
					return oldSpans.map((oldSpan, idx) => {
						const newSpan = newSpans[idx];
						if (oldSpan[0] > index) return [newSpan[0] - lengthDiff, newSpan[1] - lengthDiff];
						else if (oldSpan[0] === index) return [newSpan[0], newSpan[1] - lengthDiff];
						else return newSpan;
					});
				}
				return newContent;
			});
			scriptMatchSpans = newScriptMatchSpans;
			styleMatchSpans = newStyleMatchSpans;
			return newSource;
			function withinOtherSpan(idx) {
				return otherSpans.some((otherSpan) => idx > otherSpan[0] && idx < otherSpan[1]);
			}
		}
		function getRegexp(tagName) {
			return tagName === "script" ? scriptRegex : styleRegex;
		}
	}
	function hasSnippedContent(text) {
		return text.includes(snippedTagContentAttribute);
	}
	const regex = /(<\w+.*?)\s*✂prettier:content✂="(.*?)">.*?(?=<\/)/gi;
	function unsnipContent(text) {
		return text.replace(regex, (_, start, encodedContent) => {
			return `${start}>${base64ToString(encodedContent)}`;
		});
	}
	function makeChoice(choice) {
		return {
			value: choice,
			description: choice
		};
	}
	const options = {
		svelte5CompilerPath: {
			category: "Svelte",
			type: "string",
			default: "",
			description: "Only set this when using Svelte 5! Path to the Svelte 5 compiler"
		},
		svelteSortOrder: {
			category: "Svelte",
			type: "choice",
			default: "options-scripts-markup-styles",
			description: "Sort order for scripts, markup, and styles",
			choices: [
				makeChoice("options-scripts-markup-styles"),
				makeChoice("options-scripts-styles-markup"),
				makeChoice("options-markup-styles-scripts"),
				makeChoice("options-markup-scripts-styles"),
				makeChoice("options-styles-markup-scripts"),
				makeChoice("options-styles-scripts-markup"),
				makeChoice("scripts-options-markup-styles"),
				makeChoice("scripts-options-styles-markup"),
				makeChoice("markup-options-styles-scripts"),
				makeChoice("markup-options-scripts-styles"),
				makeChoice("styles-options-markup-scripts"),
				makeChoice("styles-options-scripts-markup"),
				makeChoice("scripts-markup-options-styles"),
				makeChoice("scripts-styles-options-markup"),
				makeChoice("markup-styles-options-scripts"),
				makeChoice("markup-scripts-options-styles"),
				makeChoice("styles-markup-options-scripts"),
				makeChoice("styles-scripts-options-markup"),
				makeChoice("scripts-markup-styles-options"),
				makeChoice("scripts-styles-markup-options"),
				makeChoice("markup-styles-scripts-options"),
				makeChoice("markup-scripts-styles-options"),
				makeChoice("styles-markup-scripts-options"),
				makeChoice("styles-scripts-markup-options"),
				makeChoice("none")
			]
		},
		svelteStrictMode: {
			category: "Svelte",
			type: "boolean",
			default: false,
			description: "More strict HTML syntax: Quotes in attributes, no self-closing DOM tags"
		},
		svelteBracketNewLine: {
			category: "Svelte",
			type: "boolean",
			description: "Put the `>` of a multiline element on a new line",
			deprecated: "2.5.0"
		},
		svelteAllowShorthand: {
			category: "Svelte",
			type: "boolean",
			default: true,
			description: "Option to enable/disable component attribute shorthand if attribute name and expressions are same"
		},
		svelteIndentScriptAndStyle: {
			category: "Svelte",
			type: "boolean",
			default: true,
			description: "Whether or not to indent the code inside <script> and <style> tags in Svelte files"
		}
	};
	const sortOrderSeparator = "-";
	function parseSortOrder(sortOrder = "options-scripts-markup-styles") {
		if (sortOrder === "none") return [];
		const order = sortOrder.split(sortOrderSeparator);
		if (!order.includes("options")) throw new Error("svelteSortOrder is missing option `options`");
		return order;
	}
	function isBracketSameLine(options) {
		return options.svelteBracketNewLine != null ? !options.svelteBracketNewLine : options.bracketSameLine != null ? options.bracketSameLine : false;
	}
	/**
	* Determines whether or not given node
	* is the root of the Svelte AST.
	*/
	function isASTNode(n) {
		return n && n.__isRoot;
	}
	function isPreTagContent(path) {
		return path.stack.some((node) => node.type === "Element" && node.name.toLowerCase() === "pre" || node.type === "Attribute" && !formattableAttributes.includes(node.name));
	}
	function flatten(arrays) {
		return [].concat.apply([], arrays);
	}
	function findLastIndex(isMatch, items) {
		for (let i = items.length - 1; i >= 0; i--) if (isMatch(items[i], i)) return i;
		return -1;
	}
	function replaceEndOfLineWith(text, replacement) {
		const parts = [];
		for (const part of text.split("\n")) {
			if (parts.length > 0) parts.push(replacement);
			if (part.endsWith("\r")) parts.push(part.slice(0, -1));
			else parts.push(part);
		}
		return parts;
	}
	function getAttributeLine(node, options) {
		const { hardline, line } = prettier.doc.builders;
		const hasThisBinding = node.type === "InlineComponent" && !!node.expression || node.type === "Element" && !!node.tag;
		const attributes = node.attributes.filter((attribute) => attribute.name !== snippedTagContentAttribute);
		return options.singleAttributePerLine && (attributes.length > 1 || attributes.length && hasThisBinding) ? hardline : line;
	}
	function printWithPrependedAttributeLine(node, options, print) {
		return (path) => path.getNode().name !== snippedTagContentAttribute ? [getAttributeLine(node, options), path.call(print)] : "";
	}
	/**
	* Check if doc is a hardline.
	* We can't just rely on a simple equality check because the doc could be created with another
	* runtime version of prettier than what we import, making a reference check fail.
	*/
	function isHardline(docToCheck) {
		return docToCheck === prettier.doc.builders.hardline || deepEqual(docToCheck, prettier.doc.builders.hardline);
	}
	/**
	* Simple deep equal function which suits our needs. Only works properly on POJOs without cyclic deps.
	*/
	function deepEqual(x, y) {
		if (x === y) return true;
		else if (typeof x == "object" && x != null && typeof y == "object" && y != null) {
			if (Object.keys(x).length != Object.keys(y).length) return false;
			for (var prop in x) if (y.hasOwnProperty(prop)) {
				if (!deepEqual(x[prop], y[prop])) return false;
			} else return false;
			return true;
		} else return false;
	}
	function isDocCommand(doc) {
		return typeof doc === "object" && doc !== null;
	}
	function isLine(docToCheck) {
		return isHardline(docToCheck) || isDocCommand(docToCheck) && docToCheck.type === "line" || Array.isArray(docToCheck) && docToCheck.every(isLine);
	}
	/**
	* Check if the doc is empty, i.e. consists of nothing more than empty strings (possibly nested).
	*/
	function isEmptyDoc(doc) {
		if (typeof doc === "string") return doc.length === 0;
		if (isDocCommand(doc) && doc.type === "line") return !doc.keepIfLonely;
		if (Array.isArray(doc)) return doc.length === 0;
		const { contents } = doc;
		if (contents) return isEmptyDoc(contents);
		const { parts } = doc;
		if (parts) return isEmptyGroup(parts);
		return false;
	}
	function isEmptyGroup(group) {
		return !group.find((doc) => !isEmptyDoc(doc));
	}
	/**
	* Trims both leading and trailing nodes matching `isWhitespace` independent of nesting level
	* (though all trimmed adjacent nodes need to be a the same level). Modifies the `docs` array.
	*/
	function trim(docs, isWhitespace) {
		trimLeft(docs, isWhitespace);
		trimRight(docs, isWhitespace);
		return docs;
	}
	/**
	* Trims the leading nodes matching `isWhitespace` independent of nesting level (though all nodes need to be a the same level).
	* If there are empty docs before the first whitespace, they are removed, too.
	*/
	function trimLeft(group, isWhitespace) {
		let firstNonWhitespace = group.findIndex((doc) => !isEmptyDoc(doc) && !isWhitespace(doc));
		if (firstNonWhitespace < 0 && group.length) firstNonWhitespace = group.length;
		if (firstNonWhitespace > 0) {
			if (group.splice(0, firstNonWhitespace).every(isEmptyDoc)) return trimLeft(group, isWhitespace);
		} else {
			const parts = getParts(group[0]);
			if (parts) return trimLeft(parts, isWhitespace);
		}
	}
	/**
	* Trims the trailing nodes matching `isWhitespace` independent of nesting level (though all nodes need to be a the same level).
	* If there are empty docs after the last whitespace, they are removed, too.
	*/
	function trimRight(group, isWhitespace) {
		let lastNonWhitespace = group.length ? findLastIndex((doc) => !isEmptyDoc(doc) && !isWhitespace(doc), group) : 0;
		if (lastNonWhitespace < group.length - 1) {
			if (group.splice(lastNonWhitespace + 1).every(isEmptyDoc)) return trimRight(group, isWhitespace);
		} else {
			const parts = getParts(group[group.length - 1]);
			if (parts) return trimRight(parts, isWhitespace);
		}
	}
	function getParts(doc) {
		if (typeof doc === "object") {
			if (Array.isArray(doc)) return doc;
			if (doc.type === "fill") return doc.parts;
			if (doc.type === "group") return getParts(doc.contents);
		}
	}
	/**
	* `(foo = bar)` => `foo = bar`
	*/
	function removeParentheses(doc) {
		return trim([doc], (_doc) => _doc === "(" || _doc === ")")[0];
	}
	const unsupportedLanguages = [
		"coffee",
		"coffeescript",
		"styl",
		"stylus",
		"sass"
	];
	function isInlineElement(path, options, node) {
		return node && node.type === "Element" && !isBlockElement(node, options) && !isPreTagContent(path);
	}
	function isBlockElement(node, options) {
		return node && node.type === "Element" && options.htmlWhitespaceSensitivity !== "strict" && (options.htmlWhitespaceSensitivity === "ignore" || blockElements.includes(node.name));
	}
	function isSvelteBlock(node) {
		return [
			"IfBlock",
			"SnippetBlock",
			"AwaitBlock",
			"CatchBlock",
			"EachBlock",
			"ElseBlock",
			"KeyBlock",
			"PendingBlock",
			"ThenBlock"
		].includes(node.type);
	}
	function isNodeWithChildren(node) {
		return node.children;
	}
	function getChildren(node) {
		return isNodeWithChildren(node) ? node.children : [];
	}
	/**
	* Returns siblings, that is, the children of the parent.
	*/
	function getSiblings(path) {
		let parent = path.getParentNode();
		if (isASTNode(parent)) parent = parent.html;
		return getChildren(parent);
	}
	/**
	* Returns the next sibling node.
	*/
	function getNextNode(path, node = path.getNode()) {
		return getSiblings(path).find((child) => child.start === node.end);
	}
	/**
	* Returns the comment that is above the current node.
	*/
	function getLeadingComment(path) {
		const siblings = getSiblings(path);
		let node = path.getNode();
		let prev = siblings.find((child) => child.end === node.start);
		while (prev) if (prev.type === "Comment" && !isIgnoreStartDirective(prev) && !isIgnoreEndDirective(prev)) return prev;
		else if (isEmptyTextNode(prev)) {
			node = prev;
			prev = siblings.find((child) => child.end === node.start);
		} else return;
	}
	/**
	* Did there use to be any embedded object (that has been snipped out of the AST to be moved)
	* at the specified position?
	*/
	function doesEmbedStartAfterNode(node, path, siblings = getSiblings(path)) {
		if (!isNodeTopLevelHTML(node, path)) return false;
		const position = node.end;
		const root = path.stack[0];
		const embeds = [
			root.css,
			root.html,
			root.instance,
			root.js,
			root.module
		];
		const nextNode = siblings[siblings.indexOf(node) + 1];
		return embeds.find((n) => n && n.start >= position && (!nextNode || n.end <= nextNode.start));
	}
	function isNodeTopLevelHTML(node, path) {
		const root = path.stack[0];
		return !!root.html && !!root.html.children && root.html.children.includes(node);
	}
	function isEmptyTextNode(node) {
		return !!node && node.type === "Text" && getUnencodedText(node).trim() === "";
	}
	function isIgnoreDirective(node) {
		return !!node && node.type === "Comment" && node.data.trim() === "prettier-ignore";
	}
	function isIgnoreStartDirective(node) {
		return !!node && node.type === "Comment" && node.data.trim() === "prettier-ignore-start";
	}
	function isIgnoreEndDirective(node) {
		return !!node && node.type === "Comment" && node.data.trim() === "prettier-ignore-end";
	}
	function printRaw(node, originalText, stripLeadingAndTrailingNewline = false) {
		if (node.children.length === 0) return "";
		const firstChild = node.children[0];
		const lastChild = node.children[node.children.length - 1];
		let raw = originalText.substring(firstChild.start, lastChild.end);
		if (!stripLeadingAndTrailingNewline) return raw;
		if (startsWithLinebreak(raw)) raw = raw.substring(raw.indexOf("\n") + 1);
		if (endsWithLinebreak(raw)) {
			raw = raw.substring(0, raw.lastIndexOf("\n"));
			if (raw.charAt(raw.length - 1) === "\r") raw = raw.substring(0, raw.length - 1);
		}
		return raw;
	}
	function isTextNode(node) {
		return node.type === "Text";
	}
	function getAttributeValue(attributeName, node) {
		var _a;
		const langAttribute = ((_a = node.attributes) !== null && _a !== void 0 ? _a : []).find((attribute) => attribute.name === attributeName);
		return langAttribute && langAttribute.value;
	}
	function getAttributeTextValue(attributeName, node) {
		const value = getAttributeValue(attributeName, node);
		if (value != null && typeof value === "object") {
			const textValue = value.find(isTextNode);
			if (textValue) return textValue.data;
		}
		return null;
	}
	function getLangAttribute(node) {
		const value = getAttributeTextValue("lang", node) || getAttributeTextValue("type", node);
		if (value != null) return value.replace(/^text\//, "");
		else return null;
	}
	/**
	* Checks whether the node contains a `lang` or `type` attribute with a value corresponding to
	* a language we cannot format. This might for example be `<template lang="pug">`.
	* If the node does not contain a `lang` attribute, the result is true.
	*/
	function isNodeSupportedLanguage(node) {
		const lang = getLangAttribute(node);
		return !(lang && unsupportedLanguages.includes(lang));
	}
	/**
	* Checks whether the node contains a `lang` or `type` attribute which indicates that
	* the script contents are written in TypeScript. Note that the absence of the tag
	* does not mean it's not TypeScript, because the user could have set the default
	* to TypeScript in his settings.
	*/
	function isTypeScript(node) {
		const lang = getLangAttribute(node) || "";
		return ["typescript", "ts"].includes(lang);
	}
	function isJSON(node) {
		const lang = getLangAttribute(node) || "";
		return lang.endsWith("json") || lang.endsWith("importmap");
	}
	function isLess(node) {
		const lang = getLangAttribute(node) || "";
		return ["less"].includes(lang);
	}
	function isScss(node) {
		const lang = getLangAttribute(node) || "";
		return ["sass", "scss"].includes(lang);
	}
	function isPugTemplate(node) {
		return node.type === "Element" && node.name === "template" && getLangAttribute(node) === "pug";
	}
	function isLoneMustacheTag(node) {
		return node !== true && node.length === 1 && node[0].type === "MustacheTag";
	}
	function isAttributeShorthand(node) {
		return node !== true && node.length === 1 && node[0].type === "AttributeShorthand";
	}
	/**
	* True if node is of type `{a}` or `a={a}`
	*/
	function isOrCanBeConvertedToShorthand(node) {
		if (isAttributeShorthand(node.value)) return true;
		if (isLoneMustacheTag(node.value)) {
			const expression = node.value[0].expression;
			return expression.type === "Identifier" && expression.name === node.name;
		}
		return false;
	}
	function getUnencodedText(node) {
		return node.raw || node.data;
	}
	function isTextNodeStartingWithLinebreak(node, nrLines = 1) {
		return node.type === "Text" && startsWithLinebreak(getUnencodedText(node), nrLines);
	}
	function startsWithLinebreak(text, nrLines = 1) {
		return new RegExp(`^([\\t\\f\\r ]*\\n){${nrLines}}`).test(text);
	}
	function isTextNodeEndingWithLinebreak(node, nrLines = 1) {
		return node.type === "Text" && endsWithLinebreak(getUnencodedText(node), nrLines);
	}
	function endsWithLinebreak(text, nrLines = 1) {
		return new RegExp(`(\\n[\\t\\f\\r ]*){${nrLines}}$`).test(text);
	}
	function isTextNodeStartingWithWhitespace(node) {
		return node.type === "Text" && /^\s/.test(getUnencodedText(node));
	}
	function isTextNodeEndingWithWhitespace(node) {
		return node.type === "Text" && /\s$/.test(getUnencodedText(node));
	}
	function trimTextNodeRight(node) {
		node.raw = node.raw && node.raw.trimRight();
		node.data = node.data && node.data.trimRight();
	}
	function trimTextNodeLeft(node) {
		node.raw = node.raw && node.raw.trimLeft();
		node.data = node.data && node.data.trimLeft();
	}
	/**
	* Remove all leading whitespace up until the first non-empty text node,
	* and all trailing whitespace from the last non-empty text node onwards.
	*/
	function trimChildren(children, path) {
		let firstNonEmptyNode = children.findIndex((n) => !isEmptyTextNode(n) && !doesEmbedStartAfterNode(n, path));
		firstNonEmptyNode = firstNonEmptyNode === -1 ? children.length - 1 : firstNonEmptyNode;
		let lastNonEmptyNode = findLastIndex((n, idx) => {
			return !isEmptyTextNode(n) && (idx === children.length - 1 && n.type !== "Comment" || !doesEmbedStartAfterNode(n, path));
		}, children);
		lastNonEmptyNode = lastNonEmptyNode === -1 ? 0 : lastNonEmptyNode;
		for (let i = 0; i <= firstNonEmptyNode; i++) {
			const n = children[i];
			if (n.type === "Text") trimTextNodeLeft(n);
		}
		for (let i = children.length - 1; i >= lastNonEmptyNode; i--) {
			const n = children[i];
			if (n.type === "Text") trimTextNodeRight(n);
		}
	}
	/**
	* Check if given node's start tag should hug its first child. This is the case for inline elements when there's
	* no whitespace between the `>` and the first child.
	*/
	function shouldHugStart(node, isSupportedLanguage, options) {
		if (!isSupportedLanguage) return true;
		if (node.type === "SvelteBoundary") return false;
		if (isBlockElement(node, options)) return false;
		if (!isNodeWithChildren(node)) return false;
		const children = node.children;
		if (children.length === 0) return true;
		if (options.htmlWhitespaceSensitivity === "ignore") return false;
		const firstChild = children[0];
		return !isTextNodeStartingWithWhitespace(firstChild);
	}
	/**
	* Check if given node's end tag should hug its last child. This is the case for inline elements when there's
	* no whitespace between the last child and the `</`.
	*/
	function shouldHugEnd(node, isSupportedLanguage, options) {
		if (!isSupportedLanguage) return true;
		if (node.type === "SvelteBoundary") return false;
		if (isBlockElement(node, options)) return false;
		if (!isNodeWithChildren(node)) return false;
		const children = node.children;
		if (children.length === 0) return true;
		if (options.htmlWhitespaceSensitivity === "ignore") return false;
		const lastChild = children[children.length - 1];
		return !isTextNodeEndingWithWhitespace(lastChild);
	}
	/**
	* Check for a svelte block if there's whitespace at the start and if it's a space or a line.
	*/
	function checkWhitespaceAtStartOfSvelteBlock(node, options) {
		if (!isSvelteBlock(node) || !isNodeWithChildren(node)) return "none";
		const children = node.children;
		if (children.length === 0) return "none";
		const firstChild = children[0];
		if (isTextNodeStartingWithLinebreak(firstChild)) return "line";
		else if (isTextNodeStartingWithWhitespace(firstChild)) return "space";
		const parentOpeningEnd = options.originalText.lastIndexOf("}", firstChild.start);
		if (parentOpeningEnd > 0 && firstChild.start > parentOpeningEnd + 1) {
			const textBetween = options.originalText.substring(parentOpeningEnd + 1, firstChild.start);
			if (textBetween.trim() === "") return startsWithLinebreak(textBetween) ? "line" : "space";
		}
		return "none";
	}
	/**
	* Check for a svelte block if there's whitespace at the end and if it's a space or a line.
	*/
	function checkWhitespaceAtEndOfSvelteBlock(node, options) {
		if (!isSvelteBlock(node) || !isNodeWithChildren(node)) return "none";
		const children = node.children;
		if (children.length === 0) return "none";
		const lastChild = children[children.length - 1];
		if (isTextNodeEndingWithLinebreak(lastChild)) return "line";
		else if (isTextNodeEndingWithWhitespace(lastChild)) return "space";
		const parentClosingStart = options.originalText.indexOf("{", lastChild.end);
		if (parentClosingStart > 0 && lastChild.end < parentClosingStart) {
			const textBetween = options.originalText.substring(lastChild.end, parentClosingStart);
			if (textBetween.trim() === "") return endsWithLinebreak(textBetween) ? "line" : "space";
		}
		return "none";
	}
	function isInsideQuotedAttribute(path, options) {
		return path.stack.some((node) => (node.type === "Attribute" || node.type === "StyleDirective") && (!isLoneMustacheTag(node.value) || options.svelteStrictMode && !options._svelte_is5Plus));
	}
	/**
	* Returns true if the softline between `</tagName` and `>` can be omitted.
	*/
	function canOmitSoftlineBeforeClosingTag(node, path, options) {
		return isBracketSameLine(options) && (!hugsStartOfNextNode(node, options) || isLastChildWithinParentBlockElement(path, options));
	}
	/**
	* Return true if given node does not hug the next node, meaning there's whitespace
	* or the end of the doc afterwards.
	*/
	function hugsStartOfNextNode(node, options) {
		if (node.end === options.originalText.length) return false;
		return !options.originalText.substring(node.end).match(/^\s/);
	}
	function isLastChildWithinParentBlockElement(path, options) {
		const parent = path.getParentNode();
		if (!parent || !isBlockElement(parent, options)) return false;
		const children = getChildren(parent);
		return children[children.length - 1] === path.getNode();
	}
	function assignCommentsToNodes(ast) {
		if (ast.module) ast.module.comments = removeAndGetLeadingComments(ast, ast.module);
		if (ast.instance) ast.instance.comments = removeAndGetLeadingComments(ast, ast.instance);
		if (ast.css) ast.css.comments = removeAndGetLeadingComments(ast, ast.css);
	}
	/**
	* Returns the comments that are above the current node and deletes them from the html ast.
	*/
	function removeAndGetLeadingComments(ast, current) {
		const siblings = getChildren(ast.html);
		const comments = [];
		const newlines = [];
		if (!siblings.length) return [];
		let node = current;
		let prev = siblings.find((child) => child.end === node.start);
		while (prev) {
			if (prev.type === "Comment" && !isIgnoreStartDirective(prev) && !isIgnoreEndDirective(prev)) {
				comments.push(prev);
				if (comments.length !== newlines.length) newlines.push({
					type: "Text",
					data: "",
					raw: "",
					start: -1,
					end: -1
				});
			} else if (isEmptyTextNode(prev)) newlines.push(prev);
			else break;
			node = prev;
			prev = siblings.find((child) => child.end === node.start);
		}
		newlines.length = comments.length;
		for (const comment of comments) siblings.splice(siblings.indexOf(comment), 1);
		for (const text of newlines) siblings.splice(siblings.indexOf(text), 1);
		return comments.map((comment, i) => ({
			comment,
			emptyLineAfter: getUnencodedText(newlines[i]).split("\n").length > 2
		})).reverse();
	}
	const { join, line, group, indent, dedent, softline, hardline, fill, breakParent, literalline } = prettier.doc.builders;
	function hasPragma(text) {
		return /^\s*<!--\s*@(format|prettier)\W/.test(text);
	}
	let ignoreNext = false;
	let ignoreRange = false;
	let svelteOptionsDoc;
	function print(path, options, print) {
		var _a, _b;
		const bracketSameLine = isBracketSameLine(options);
		const n = path.getValue();
		if (!n) return "";
		if (isASTNode(n)) return printTopLevelParts(n, options, path, print);
		const [open, close] = options.svelteStrictMode && !options._svelte_is5Plus ? ["\"{", "}\""] : ["{", "}"];
		const printJsExpression = () => [
			open,
			printJS(path, print, "expression"),
			close
		];
		const node = n;
		if ((ignoreNext || ignoreRange && !isIgnoreEndDirective(node)) && (node.type !== "Text" || !isEmptyTextNode(node))) {
			if (ignoreNext) ignoreNext = false;
			return flatten(options.originalText.slice(options.locStart(node), options.locEnd(node)).split("\n").map((o, i) => i == 0 ? [o] : [literalline, o]));
		}
		switch (node.type) {
			case "Fragment":
				const children = node.children;
				if (children.length === 0 || children.every(isEmptyTextNode)) return "";
				if (!isPreTagContent(path)) {
					trimChildren(node.children, path);
					const output = trim([printChildren(path, print, options)], (n) => isLine(n) || typeof n === "string" && n.trim() === "" || n === breakParent);
					if (output.every((doc) => isEmptyDoc(doc))) return "";
					return group([...output, hardline]);
				} else return group(path.map(print, "children"));
			case "Text": if (!isPreTagContent(path)) {
				if (isEmptyTextNode(node)) {
					const hasWhiteSpace = getUnencodedText(node).trim().length < getUnencodedText(node).length;
					const hasOneOrMoreNewlines = /\n/.test(getUnencodedText(node));
					if (/\n\r?\s*\n\r?/.test(getUnencodedText(node))) return [hardline, hardline];
					if (hasOneOrMoreNewlines) return hardline;
					if (hasWhiteSpace) return line;
					return "";
				}
				/**
				* For non-empty text nodes each sequence of non-whitespace characters (effectively,
				* each "word") is joined by a single `line`, which will be rendered as a single space
				* until this node's current line is out of room, at which `fill` will break at the
				* most convenient instance of `line`.
				*/
				return fill(splitTextToDocs(node));
			} else {
				let rawText = getUnencodedText(node);
				const parent = path.getParentNode();
				if (parent.type === "Attribute") {
					if (parent.name === "class" && path.getParentNode(1).type === "Element") {
						rawText = rawText.replace(/([^ \t\n])(([ \t]+$)|([ \t]+(\r?\n))|[ \t]+)/g, (match, characterBeforeWhitespace, _, isEndOfString, isEndOfLine, endOfLine) => isEndOfString ? match : characterBeforeWhitespace + (isEndOfLine ? endOfLine : " "));
						rawText = rawText.replace(/([^ \t\n])[ \t]+$/, parent.value.indexOf(node) === parent.value.length - 1 ? "$1" : "$1 ");
					}
					return replaceEndOfLineWith(rawText, literalline);
				}
				return rawText;
			}
			case "Element":
			case "InlineComponent":
			case "Slot":
			case "SlotTemplate":
			case "Window":
			case "Head":
			case "SvelteBoundary":
			case "Title": {
				const isSupportedLanguage = !(node.name === "template" && !isNodeSupportedLanguage(node));
				const isEmpty = node.children.every((child) => isEmptyTextNode(child));
				const isDoctypeTag = node.name.toUpperCase() === "!DOCTYPE";
				const didSelfClose = options.originalText[node.end - 2] === "/";
				const isSelfClosingTag = isEmpty && ((node.type === "Element" && !options.svelteStrictMode || node.type === "Head" || node.type === "InlineComponent" || node.type === "Slot" || node.type === "SlotTemplate" || node.type === "SvelteBoundary" || node.type === "Title") && didSelfClose || node.type === "Window" || selfClosingTags.indexOf(node.name) !== -1 || isDoctypeTag);
				const attributes = path.map(printWithPrependedAttributeLine(node, options, print), "attributes");
				const attributeLine = getAttributeLine(node, options);
				const possibleThisBinding = node.type === "InlineComponent" && node.expression ? [
					attributeLine,
					"this=",
					...printJsExpression()
				] : node.type === "Element" && node.tag ? [
					attributeLine,
					"this=",
					...typeof node.tag === "string" ? [`"${node.tag}"`] : [
						open,
						printJS(path, print, "tag"),
						close
					]
				] : "";
				if (isSelfClosingTag) return group([
					"<",
					node.name,
					indent(group([
						possibleThisBinding,
						...attributes,
						bracketSameLine || isDoctypeTag ? "" : dedent(line)
					])),
					...[bracketSameLine && !isDoctypeTag ? " " : "", `${isDoctypeTag ? "" : "/"}>`]
				]);
				const children = node.children;
				const firstChild = children[0];
				const lastChild = children[children.length - 1];
				let body;
				const hugStart = shouldHugStart(node, isSupportedLanguage, options);
				const hugEnd = shouldHugEnd(node, isSupportedLanguage, options);
				if (isEmpty) body = isInlineElement(path, options, node) && node.children.length && isTextNodeStartingWithWhitespace(node.children[0]) && !isPreTagContent(path) ? () => line : () => bracketSameLine ? softline : "";
				else if (isPreTagContent(path)) body = () => printPre(node, options.originalText, path, print);
				else if (!isSupportedLanguage) body = () => printRaw(node, options.originalText, true);
				else if (isInlineElement(path, options, node) && !isPreTagContent(path)) body = () => printChildren(path, print, options);
				else body = () => printChildren(path, print, options);
				const openingTag = [
					"<",
					node.name,
					indent(group([
						possibleThisBinding,
						...attributes,
						hugStart && !isEmpty ? "" : !bracketSameLine && !isPreTagContent(path) ? dedent(softline) : ""
					]))
				];
				if (!isSupportedLanguage && !isEmpty) return group([
					...openingTag,
					">",
					group([
						hardline,
						body(),
						hardline
					]),
					`</${node.name}>`
				]);
				if (hugStart && hugEnd) {
					const huggedContent = [softline, group([
						">",
						body(),
						`</${node.name}`
					])];
					const omitSoftlineBeforeClosingTag = isEmpty && !bracketSameLine || canOmitSoftlineBeforeClosingTag(node, path, options);
					return group([
						...openingTag,
						isEmpty ? group(huggedContent) : group(indent(huggedContent)),
						omitSoftlineBeforeClosingTag ? "" : softline,
						">"
					]);
				}
				let noHugSeparatorStart = softline;
				let noHugSeparatorEnd = softline;
				if (isPreTagContent(path)) {
					noHugSeparatorStart = "";
					noHugSeparatorEnd = "";
				} else {
					let didSetEndSeparator = false;
					if (!hugStart && firstChild && firstChild.type === "Text") {
						if (isTextNodeStartingWithLinebreak(firstChild) && firstChild !== lastChild && (!isInlineElement(path, options, node) || isTextNodeEndingWithWhitespace(lastChild))) {
							noHugSeparatorStart = hardline;
							noHugSeparatorEnd = hardline;
							didSetEndSeparator = true;
						} else if (isInlineElement(path, options, node)) noHugSeparatorStart = line;
						trimTextNodeLeft(firstChild);
					}
					if (!hugEnd && lastChild && lastChild.type === "Text") {
						if (isInlineElement(path, options, node) && !didSetEndSeparator) noHugSeparatorEnd = line;
						trimTextNodeRight(lastChild);
					}
				}
				if (hugStart) return group([
					...openingTag,
					indent([softline, group([">", body()])]),
					noHugSeparatorEnd,
					`</${node.name}>`
				]);
				if (hugEnd) return group([
					...openingTag,
					">",
					indent([noHugSeparatorStart, group([body(), `</${node.name}`])]),
					canOmitSoftlineBeforeClosingTag(node, path, options) ? "" : softline,
					">"
				]);
				if (isEmpty) return group([
					...openingTag,
					">",
					body(),
					`</${node.name}>`
				]);
				return group([
					...openingTag,
					">",
					indent([noHugSeparatorStart, body()]),
					noHugSeparatorEnd,
					`</${node.name}>`
				]);
			}
			case "Options": if (options.svelteSortOrder !== "none") throw new Error("Options tags should have been handled by prepareChildren");
			case "Body":
			case "Document":
			case "SvelteHTML": return group([
				"<",
				node.name,
				indent(group([...path.map(printWithPrependedAttributeLine(node, options, print), "attributes"), bracketSameLine ? "" : dedent(line)])),
				...[bracketSameLine ? " " : "", "/>"]
			]);
			case "Identifier": return node.name;
			case "AttributeShorthand": return node.expression.name;
			case "Attribute": if (isOrCanBeConvertedToShorthand(node)) if (options.svelteAllowShorthand) return [
				"{",
				node.name,
				"}"
			];
			else return [
				node.name,
				`=${open}`,
				node.name,
				close
			];
			else {
				if (node.value === true) return [node.name];
				const quotes = !isLoneMustacheTag(node.value) || ((_a = options.svelteStrictMode && !options._svelte_is5Plus) !== null && _a !== void 0 ? _a : false);
				const attrNodeValue = printAttributeNodeValue(path, print, quotes, node);
				if (quotes) return [
					node.name,
					"=",
					"\"",
					attrNodeValue,
					"\""
				];
				else return [
					node.name,
					"=",
					attrNodeValue
				];
			}
			case "MustacheTag": return [
				"{",
				printJS(path, print, "expression"),
				"}"
			];
			case "IfBlock": {
				const def = [
					"{#if ",
					printJS(path, print, "expression"),
					"}",
					printSvelteBlockChildren(path, print, options)
				];
				if (node.else) def.push(path.call(print, "else"));
				def.push("{/if}");
				return group([def, breakParent]);
			}
			case "ElseBlock": {
				const parent = path.getParentNode();
				if (node.children.length === 1 && node.children[0].type === "IfBlock" && parent.type !== "EachBlock") {
					const ifNode = node.children[0];
					const def = [
						"{:else if ",
						path.map((ifPath) => printJS(ifPath, print, "expression"), "children")[0],
						"}",
						path.map((ifPath) => printSvelteBlockChildren(ifPath, print, options), "children")[0]
					];
					if (ifNode.else) def.push(path.map((ifPath) => ifPath.call(print, "else"), "children")[0]);
					return def;
				}
				return ["{:else}", printSvelteBlockChildren(path, print, options)];
			}
			case "EachBlock": {
				const def = ["{#each ", printJS(path, print, "expression")];
				if (node.context) def.push(" as", expandNode(node.context, options.originalText));
				if (node.index) def.push(", ", node.index);
				if (node.key) def.push(" (", printJS(path, print, "key"), ")");
				def.push("}", printSvelteBlockChildren(path, print, options));
				if (node.else) def.push(path.call(print, "else"));
				def.push("{/each}");
				return group([def, breakParent]);
			}
			case "AwaitBlock": {
				const hasPendingBlock = node.pending.children.some((n) => !isEmptyTextNode(n));
				const hasThenBlock = node.then.children.some((n) => !isEmptyTextNode(n));
				const hasCatchBlock = node.catch.children.some((n) => !isEmptyTextNode(n));
				let block = [];
				if (!hasPendingBlock && hasThenBlock) block.push(group([
					"{#await ",
					printJS(path, print, "expression"),
					" then",
					expandNode(node.value, options.originalText),
					"}"
				]), path.call(print, "then"));
				else if (!hasPendingBlock && hasCatchBlock) block.push(group([
					"{#await ",
					printJS(path, print, "expression"),
					" catch",
					expandNode(node.error, options.originalText),
					"}"
				]), path.call(print, "catch"));
				else {
					block.push(group([
						"{#await ",
						printJS(path, print, "expression"),
						"}"
					]));
					if (hasPendingBlock) block.push(path.call(print, "pending"));
					if (hasThenBlock) block.push(group([
						"{:then",
						expandNode(node.value, options.originalText),
						"}"
					]), path.call(print, "then"));
				}
				if ((hasPendingBlock || hasThenBlock) && hasCatchBlock) block.push(group([
					"{:catch",
					expandNode(node.error, options.originalText),
					"}"
				]), path.call(print, "catch"));
				block.push("{/await}");
				return group(block);
			}
			case "KeyBlock": {
				const def = [
					"{#key ",
					printJS(path, print, "expression"),
					"}",
					printSvelteBlockChildren(path, print, options)
				];
				def.push("{/key}");
				return group([def, breakParent]);
			}
			case "ThenBlock":
			case "PendingBlock":
			case "CatchBlock": return printSvelteBlockChildren(path, print, options);
			case "SnippetBlock": {
				const snippet = ["{#snippet ", printJS(path, print, "expression")];
				snippet.push("}", printSvelteBlockChildren(path, print, options), "{/snippet}");
				return snippet;
			}
			case "EventHandler": return [
				"on:",
				node.name,
				node.modifiers && node.modifiers.length ? ["|", join("|", node.modifiers)] : "",
				node.expression ? ["=", ...printJsExpression()] : ""
			];
			case "Binding": return [
				"bind:",
				node.name,
				node.expression.type === "Identifier" && node.expression.name === node.name && options.svelteAllowShorthand ? "" : ["=", ...printJsExpression()]
			];
			case "Class": return [
				"class:",
				node.name,
				node.expression.type === "Identifier" && node.expression.name === node.name && options.svelteAllowShorthand ? "" : ["=", ...printJsExpression()]
			];
			case "StyleDirective":
				const prefix = [
					"style:",
					node.name,
					node.modifiers && node.modifiers.length ? ["|", join("|", node.modifiers)] : ""
				];
				if (isOrCanBeConvertedToShorthand(node) || node.value === true) if (options.svelteAllowShorthand) return [...prefix];
				else return [
					...prefix,
					`=${open}`,
					node.name,
					close
				];
				else {
					const quotes = !isLoneMustacheTag(node.value) || ((_b = options.svelteStrictMode && !options._svelte_is5Plus) !== null && _b !== void 0 ? _b : false);
					const attrNodeValue = printAttributeNodeValue(path, print, quotes, node);
					if (quotes) return [
						...prefix,
						"=",
						"\"",
						attrNodeValue,
						"\""
					];
					else return [
						...prefix,
						"=",
						attrNodeValue
					];
				}
			case "Let": return [
				"let:",
				node.name,
				!node.expression || node.expression.type === "Identifier" && node.expression.name === node.name ? "" : ["=", ...printJsExpression()]
			];
			case "DebugTag": return [
				"{@debug",
				node.identifiers.length > 0 ? [" ", join(", ", path.map(print, "identifiers"))] : "",
				"}"
			];
			case "Ref": return ["ref:", node.name];
			case "Comment": {
				const nodeAfterComment = getNextNode(path);
				if (isIgnoreStartDirective(node) && isNodeTopLevelHTML(node, path)) ignoreRange = true;
				else if (isIgnoreEndDirective(node) && isNodeTopLevelHTML(node, path)) ignoreRange = false;
				else if (doesEmbedStartAfterNode(node, path) || isEmptyTextNode(nodeAfterComment) && doesEmbedStartAfterNode(nodeAfterComment, path)) return "";
				else if (isIgnoreDirective(node)) ignoreNext = true;
				return printComment(node);
			}
			case "Transition": return [
				node.intro && node.outro ? "transition" : node.intro ? "in" : "out",
				":",
				node.name,
				node.modifiers && node.modifiers.length ? ["|", join("|", node.modifiers)] : "",
				node.expression ? ["=", ...printJsExpression()] : ""
			];
			case "Action": return [
				"use:",
				node.name,
				node.expression ? ["=", ...printJsExpression()] : ""
			];
			case "Animation": return [
				"animate:",
				node.name,
				node.expression ? ["=", ...printJsExpression()] : ""
			];
			case "RawMustacheTag": return [
				"{@html ",
				printJS(path, print, "expression"),
				"}"
			];
			case "RenderTag": return [
				"{@render ",
				printJS(path, print, "expression"),
				"}"
			];
			case "AttachTag": return [
				"{@attach ",
				printJS(path, print, "expression"),
				"}"
			];
			case "Spread": return [
				"{...",
				printJS(path, print, "expression"),
				"}"
			];
			case "ConstTag": return [
				"{@const ",
				printJS(path, print, "expression"),
				"}"
			];
		}
		console.error(JSON.stringify(node, null, 4));
		throw new Error("unknown node type: " + node.type);
	}
	function printTopLevelParts(n, options, path, print) {
		if (options.svelteSortOrder === "none") {
			const topLevelPartsByEnd = {};
			const topLevelPartsByStart = {};
			if (n.module) {
				topLevelPartsByEnd[n.module.end] = n.module;
				topLevelPartsByStart[n.module.start] = n.module;
			}
			if (n.instance) {
				topLevelPartsByEnd[n.instance.end] = n.instance;
				topLevelPartsByStart[n.instance.start] = n.instance;
			}
			if (n.css) {
				topLevelPartsByEnd[n.css.end] = n.css;
				topLevelPartsByStart[n.css.start] = n.css;
			}
			const children = getChildren(n.html);
			for (let i = 0; i < children.length; i++) {
				const node = children[i];
				if (topLevelPartsByEnd[node.start]) {
					children.splice(i, 0, topLevelPartsByEnd[node.start]);
					delete topLevelPartsByEnd[node.start];
				} else if (i === children.length - 1 && topLevelPartsByStart[node.end]) children.push(topLevelPartsByStart[node.end]);
			}
			const result = path.call(print, "html");
			if (options.insertPragma && !hasPragma(options.originalText)) return [
				`<!-- @format -->`,
				hardline,
				result
			];
			else return result;
		}
		const parts = {
			options: [],
			scripts: [],
			markup: [],
			styles: []
		};
		if (n.module) parts.scripts.push(path.call(print, "module"));
		if (n.instance) parts.scripts.push(path.call(print, "instance"));
		if (n.css) parts.styles.push(path.call(print, "css"));
		const htmlDoc = path.call(print, "html");
		if (htmlDoc) parts.markup.push(htmlDoc);
		if (svelteOptionsDoc) parts.options.push(svelteOptionsDoc);
		const docs = flatten(parseSortOrder(options.svelteSortOrder).map((p) => parts[p]));
		ignoreNext = false;
		ignoreRange = false;
		svelteOptionsDoc = void 0;
		if (options.parentParser === "markdown") {
			const lastDoc = docs[docs.length - 1];
			trimRight([lastDoc], isLine);
		}
		if (options.insertPragma && !hasPragma(options.originalText)) return [
			`<!-- @format -->`,
			hardline,
			group(docs)
		];
		else return group([join(hardline, docs)]);
	}
	function printAttributeNodeValue(path, print, quotes, node) {
		const valueDocs = path.map((childPath) => childPath.call(print), "value");
		if (!quotes || !formattableAttributes.includes(node.name)) return valueDocs;
		else return indent(group(trim(valueDocs, isLine)));
	}
	function printSvelteBlockChildren(path, print, options) {
		const node = path.getValue();
		const children = node.children;
		if (!children || children.length === 0) return "";
		const whitespaceAtStartOfBlock = checkWhitespaceAtStartOfSvelteBlock(node, options);
		const whitespaceAtEndOfBlock = checkWhitespaceAtEndOfSvelteBlock(node, options);
		const startline = whitespaceAtStartOfBlock === "none" ? "" : whitespaceAtEndOfBlock === "line" || whitespaceAtStartOfBlock === "line" ? hardline : line;
		const endline = whitespaceAtEndOfBlock === "none" ? "" : whitespaceAtEndOfBlock === "line" || whitespaceAtStartOfBlock === "line" ? hardline : line;
		const firstChild = children[0];
		const lastChild = children[children.length - 1];
		if (isTextNodeStartingWithWhitespace(firstChild)) trimTextNodeLeft(firstChild);
		if (isTextNodeEndingWithWhitespace(lastChild)) trimTextNodeRight(lastChild);
		return [indent([startline, group(printChildren(path, print, options))]), endline];
	}
	function printPre(node, originalText, path, print) {
		const result = [];
		const length = node.children.length;
		for (let i = 0; i < length; i++) {
			const child = node.children[i];
			if (child.type === "Text") originalText.substring(child.start, child.end).split(/\r?\n/).forEach((line, j) => {
				if (j > 0) result.push(literalline);
				result.push(line);
			});
			else result.push(path.call(print, "children", i));
		}
		return result;
	}
	function printChildren(path, print, options) {
		if (isPreTagContent(path)) return path.map(print, "children");
		const childNodes = prepareChildren(path.getValue().children, path, print, options);
		path.getValue().children = childNodes;
		if (childNodes.length === 0) return "";
		const childDocs = [];
		let handleWhitespaceOfPrevTextNode = false;
		for (let i = 0; i < childNodes.length; i++) {
			const childNode = childNodes[i];
			if (childNode.type === "Text") handleTextChild(i, childNode);
			else if (isBlockElement(childNode, options)) handleBlockChild(i);
			else if (isInlineElement(path, options, childNode)) handleInlineChild(i);
			else {
				childDocs.push(printChild(i));
				handleWhitespaceOfPrevTextNode = false;
			}
		}
		if (childNodes.length > 1 && childNodes.some((child) => isBlockElement(child, options))) childDocs.push(breakParent);
		return childDocs;
		function printChild(idx) {
			return path.call(print, "children", idx);
		}
		/**
		* Print inline child. Hug whitespace of previous text child if there was one.
		*/
		function handleInlineChild(idx) {
			if (handleWhitespaceOfPrevTextNode) childDocs.push(group([line, printChild(idx)]));
			else childDocs.push(printChild(idx));
			handleWhitespaceOfPrevTextNode = false;
		}
		/**
		* Print block element. Add softlines around it if needed
		* so it breaks into a separate line if children are broken up.
		* Don't add lines at the start/end if it's the first/last child because this
		* kind of whitespace handling is done in the parent already.
		*/
		function handleBlockChild(idx) {
			const prevChild = childNodes[idx - 1];
			if (prevChild && !isBlockElement(prevChild, options) && (prevChild.type !== "Text" || handleWhitespaceOfPrevTextNode || !isTextNodeEndingWithWhitespace(prevChild))) childDocs.push(softline);
			childDocs.push(printChild(idx));
			const nextChild = childNodes[idx + 1];
			if (nextChild && (nextChild.type !== "Text" || (!isEmptyTextNode(nextChild) || childNodes[idx + 2] && isInlineElement(path, options, childNodes[idx + 2])) && !isTextNodeStartingWithLinebreak(nextChild))) childDocs.push(softline);
			handleWhitespaceOfPrevTextNode = false;
		}
		/**
		* Print text child. First/last child white space handling
		* is done in parent already. By definition of the Svelte AST,
		* a text node always is inbetween other tags. Add hardlines
		* if the users wants to have them inbetween.
		* If the text is trimmed right, toggle flag telling
		* subsequent (inline)block element to alter its printing logic
		* to check if they need to hug or print lines themselves.
		*/
		function handleTextChild(idx, childNode) {
			handleWhitespaceOfPrevTextNode = false;
			if (idx === 0 || idx === childNodes.length - 1) {
				childDocs.push(printChild(idx));
				return;
			}
			const prevNode = childNodes[idx - 1];
			const nextNode = childNodes[idx + 1];
			if (isTextNodeStartingWithWhitespace(childNode) && !isEmptyTextNode(childNode)) {
				if (isInlineElement(path, options, prevNode) && !isTextNodeStartingWithLinebreak(childNode)) {
					trimTextNodeLeft(childNode);
					const lastChildDoc = childDocs.pop();
					childDocs.push(group([lastChildDoc, line]));
				}
				if (isBlockElement(prevNode, options) && !isTextNodeStartingWithLinebreak(childNode)) trimTextNodeLeft(childNode);
			}
			if (isTextNodeEndingWithWhitespace(childNode)) {
				if (isInlineElement(path, options, nextNode) && !isTextNodeEndingWithLinebreak(childNode)) {
					handleWhitespaceOfPrevTextNode = !prevNode || !isBlockElement(prevNode, options);
					trimTextNodeRight(childNode);
				}
				if (isBlockElement(nextNode, options) && !isTextNodeEndingWithLinebreak(childNode, 2)) {
					handleWhitespaceOfPrevTextNode = !prevNode || !isBlockElement(prevNode, options);
					trimTextNodeRight(childNode);
				}
			}
			childDocs.push(printChild(idx));
		}
	}
	/**
	* `svelte:options` is part of the html part but needs to be snipped out and handled
	* separately to reorder it as configured. The comment above it should be moved with it.
	* Do that here.
	*/
	function prepareChildren(children, path, print, options) {
		let svelteOptionsComment;
		const childrenWithoutOptions = [];
		const bracketSameLine = isBracketSameLine(options);
		for (let idx = 0; idx < children.length; idx++) {
			const currentChild = children[idx];
			if (currentChild.type === "Text" && getUnencodedText(currentChild) === "") continue;
			if (isEmptyTextNode(currentChild) && doesEmbedStartAfterNode(currentChild, path)) continue;
			if (options.svelteSortOrder !== "none") {
				if (isCommentFollowedByOptions(currentChild, idx)) {
					svelteOptionsComment = printComment(currentChild);
					const nextChild = children[idx + 1];
					idx += nextChild && isEmptyTextNode(nextChild) ? 1 : 0;
					continue;
				}
				if (currentChild.type === "Options") {
					printSvelteOptions(currentChild, idx, path, print);
					continue;
				}
			}
			childrenWithoutOptions.push(currentChild);
		}
		const mergedChildrenWithoutOptions = [];
		for (let idx = 0; idx < childrenWithoutOptions.length; idx++) {
			const currentChild = childrenWithoutOptions[idx];
			const nextChild = childrenWithoutOptions[idx + 1];
			if (currentChild.type === "Text" && nextChild && nextChild.type === "Text") {
				currentChild.raw += nextChild.raw;
				currentChild.data += nextChild.data;
				idx++;
			}
			mergedChildrenWithoutOptions.push(currentChild);
		}
		return mergedChildrenWithoutOptions;
		function printSvelteOptions(node, idx, path, print) {
			svelteOptionsDoc = group([[
				"<",
				node.name,
				indent(group([...path.map(printWithPrependedAttributeLine(node, options, print), "children", idx, "attributes"), bracketSameLine ? "" : dedent(line)])),
				...[bracketSameLine ? " " : "", "/>"]
			], hardline]);
			if (svelteOptionsComment) svelteOptionsDoc = group([
				svelteOptionsComment,
				hardline,
				svelteOptionsDoc
			]);
		}
		function isCommentFollowedByOptions(node, idx) {
			if (node.type !== "Comment" || isIgnoreEndDirective(node) || isIgnoreStartDirective(node)) return false;
			const nextChild = children[idx + 1];
			if (nextChild) {
				if (isEmptyTextNode(nextChild)) {
					const afterNext = children[idx + 2];
					return afterNext && afterNext.type === "Options";
				}
				return nextChild.type === "Options";
			}
			return false;
		}
	}
	/**
	* Split the text into words separated by whitespace. Replace the whitespaces by lines,
	* collapsing multiple whitespaces into a single line.
	*
	* If the text starts or ends with multiple newlines, two of those should be kept.
	*/
	function splitTextToDocs(node) {
		const text = getUnencodedText(node);
		let docs = join(line, text.split(/[\t\n\f\r ]+/)).filter((doc) => doc !== "");
		if (startsWithLinebreak(text)) docs[0] = hardline;
		if (startsWithLinebreak(text, 2)) docs = [hardline, ...docs];
		if (endsWithLinebreak(text)) docs[docs.length - 1] = hardline;
		if (endsWithLinebreak(text, 2)) docs = [...docs, hardline];
		return docs;
	}
	function printJS(path, print, name) {
		return path.call(print, name);
	}
	function expandNode(node, original) {
		let str = _expandNode(node);
		if (node === null || node === void 0 ? void 0 : node.typeAnnotation) str += ": " + original.slice(node.typeAnnotation.typeAnnotation.start, node.typeAnnotation.typeAnnotation.end);
		return str;
	}
	function _expandNode(node, parent) {
		if (node === null) return "";
		if (typeof node === "string") return " " + node;
		switch (node.type) {
			case "ArrayExpression":
			case "ArrayPattern": return " [" + node.elements.map((el) => el === null ? " " : _expandNode(el)).join(",").slice(1) + "]";
			case "AssignmentPattern": return _expandNode(node.left) + " =" + _expandNode(node.right);
			case "Identifier": return " " + node.name;
			case "Literal": return " " + node.raw;
			case "ObjectExpression": return " {" + node.properties.map((p) => _expandNode(p, node)).join(",") + " }";
			case "ObjectPattern": return " {" + node.properties.map(_expandNode).join(",") + " }";
			case "Property": if (node.value.type === "ObjectPattern" || node.value.type === "ArrayPattern") return " " + node.key.name + ":" + _expandNode(node.value);
			else if (node.value.type === "Identifier" && node.key.name !== node.value.name || parent && parent.type === "ObjectExpression") return _expandNode(node.key) + ":" + _expandNode(node.value);
			else return _expandNode(node.value);
			case "RestElement": return " ..." + node.argument.name;
		}
		console.error(JSON.stringify(node, null, 4));
		throw new Error("unknown node type: " + node.type);
	}
	function printComment(node) {
		let text = node.data;
		if (hasSnippedContent(text)) text = unsnipContent(text);
		return group([
			"<!--",
			text,
			"-->"
		]);
	}
	function getText(node, options, unsnip = false) {
		const leadingComments = node.leadingComments;
		const text = options.originalText.slice(options.locStart(leadingComments && leadingComments[0] || node), options.locEnd(node));
		if (!unsnip || !hasSnippedContent(text)) return text;
		return unsnipContent(text);
	}
	const extractAttributesRegex = /<[a-z]+((?:\s+[^=>'"\/]+=(?:"[^"]*"|'[^']*'|[^>\s]+)|\s+[^=>'"\/]+)*\s*)>/im;
	const attributeRegex = /([^\s=]+)(?:=(?:(?:("|')([\s\S]*?)\2)|(?:([^>\s]+?)(?:\s|>|$))))?/gim;
	function extractAttributes(html) {
		const [, attributesString] = html.match(extractAttributesRegex);
		const attrs = [];
		let match;
		while (match = attributeRegex.exec(attributesString)) {
			const [all, name, quotes, valueQuoted, valueUnquoted] = match;
			const value = valueQuoted || valueUnquoted;
			const attrStart = match.index;
			let valueNode;
			if (!value) valueNode = true;
			else {
				let valueStart = attrStart + name.length;
				if (quotes) valueStart += 2;
				valueNode = [{
					type: "Text",
					data: value,
					start: valueStart,
					end: valueStart + value.length
				}];
			}
			attrs.push({
				type: "Attribute",
				name,
				value: valueNode,
				start: attrStart,
				end: attrStart + all.length
			});
		}
		return attrs;
	}
	const { builders: { group: group$1, hardline: hardline$1, softline: softline$1, indent: indent$1, dedent: dedent$1, literalline: literalline$1 }, utils: { removeLines } } = prettier.doc;
	const leaveAlone = new Set([
		"Script",
		"Style",
		"Identifier",
		"MemberExpression",
		"CallExpression",
		"ArrowFunctionExpression"
	]);
	const dontTraverse = new Set([
		"start",
		"end",
		"type"
	]);
	function getVisitorKeys(node, nonTraversableKeys) {
		return Object.keys(node).filter((key) => {
			return !nonTraversableKeys.has(key) && !leaveAlone.has(node.type) && !dontTraverse.has(key);
		});
	}
	function embed(path, _options) {
		var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
		const node = path.getNode();
		const options = _options;
		if (!options.locStart || !options.locEnd || !options.originalText) throw new Error("Missing required options");
		if (isASTNode(node)) {
			assignCommentsToNodes(node);
			attachAttributeComments(node);
			if (node.module) {
				node.module.type = "Script";
				node.module.attributes = extractAttributes(getText(node.module, options));
			}
			if (node.instance) {
				node.instance.type = "Script";
				node.instance.attributes = extractAttributes(getText(node.instance, options));
			}
			if (node.css) {
				node.css.type = "Style";
				node.css.content.type = "StyleProgram";
			}
			return null;
		}
		const parent = path.getParentNode();
		const printJsExpression = () => {
			var _a;
			return parent.expression ? printJS$1(parent, "expression", { forceSingleQuote: (_a = options.svelteStrictMode && !options._svelte_is5Plus) !== null && _a !== void 0 ? _a : false }) : void 0;
		};
		const printSvelteBlockJS = (name) => printJS$1(parent, name, { forceSingleLine: true });
		switch (parent.type) {
			case "IfBlock":
			case "ElseBlock":
			case "AwaitBlock":
			case "KeyBlock":
				printSvelteBlockJS("expression");
				break;
			case "EachBlock":
				printSvelteBlockJS("expression");
				printSvelteBlockJS("key");
				break;
			case "SnippetBlock":
				if (node === parent.expression) {
					parent.expression.end = options.originalText.indexOf(")", (_g = (_d = (_c = (_b = (_a = parent.parameters) === null || _a === void 0 ? void 0 : _a[parent.parameters.length - 1]) === null || _b === void 0 ? void 0 : _b.typeAnnotation) === null || _c === void 0 ? void 0 : _c.end) !== null && _d !== void 0 ? _d : (_f = (_e = parent.parameters) === null || _e === void 0 ? void 0 : _e[parent.parameters.length - 1]) === null || _f === void 0 ? void 0 : _f.end) !== null && _g !== void 0 ? _g : parent.expression.end) + 1;
					parent.parameters = null;
					node.isJS = true;
					node.asFunction = true;
				}
				break;
			case "Element":
				printJS$1(parent, "tag", { forceSingleQuote: (_h = options.svelteStrictMode && !options._svelte_is5Plus) !== null && _h !== void 0 ? _h : false });
				break;
			case "MustacheTag":
				printJS$1(parent, "expression", { forceSingleQuote: isInsideQuotedAttribute(path, options) });
				break;
			case "RawMustacheTag":
				printJS$1(parent, "expression", {});
				break;
			case "Spread":
				printJS$1(parent, "expression", {});
				break;
			case "AttachTag":
				printJS$1(parent, "expression", {});
				break;
			case "ConstTag":
				printJS$1(parent, "expression", { removeParentheses: true });
				break;
			case "Binding":
				printJS$1(parent, "expression", {
					removeParentheses: parent.expression.type === "SequenceExpression",
					surroundWithSoftline: true
				});
				break;
			case "RenderTag":
				if (node === parent.expression) {
					if ("argument" in parent || "arguments" in parent) {
						parent.expression.end = options.originalText.indexOf(")", (_o = (_k = (_j = parent.argument) === null || _j === void 0 ? void 0 : _j.end) !== null && _k !== void 0 ? _k : (_m = (_l = parent.arguments) === null || _l === void 0 ? void 0 : _l[parent.arguments.length - 1]) === null || _m === void 0 ? void 0 : _m.end) !== null && _o !== void 0 ? _o : parent.expression.end) + 1;
						parent.argument = null;
						parent.arguments = null;
					}
					printJS$1(parent, "expression", {});
				}
				break;
			case "EventHandler":
			case "Binding":
			case "Class":
			case "Let":
			case "Transition":
			case "Action":
			case "Animation":
			case "InlineComponent":
				printJsExpression();
				break;
		}
		if (node.isJS) return (textToDoc) => __awaiter(this, void 0, void 0, function* () {
			try {
				const embeddedOptions = {
					parser: options._svelte_ts ? "svelteTSExpressionParser" : "svelteExpressionParser",
					singleQuote: node.forceSingleQuote ? true : options.singleQuote,
					_svelte_asFunction: node.asFunction
				};
				const text = getText(node, options, true);
				let docs = yield textToDoc(node.asFunction ? forceIntoFunction(text) : forceIntoExpression(text), embeddedOptions);
				if (node.forceSingleLine) docs = removeLines(docs);
				if (node.removeParentheses) docs = removeParentheses(docs);
				if (node.asFunction) if (Array.isArray(docs) && typeof docs[0] === "string") {
					docs[0] = docs[0].replace("function ", "");
					docs.splice(-1, 1);
				} else throw new Error("Prettier AST changed, asFunction logic needs to change");
				if (node.surroundWithSoftline) docs = group$1(indent$1([
					softline$1,
					group$1(docs),
					dedent$1(softline$1)
				]));
				return docs;
			} catch (e) {
				return getText(node, options, true);
			}
		});
		const embedType = (tag, parser, isTopLevel) => {
			return (textToDoc, print) => __awaiter(this, void 0, void 0, function* () {
				return embedTag(tag, options.originalText, path, (content) => formatBodyContent(content, parser, textToDoc, options), print, isTopLevel, options);
			});
		};
		const embedScript = (isTopLevel) => embedType("script", isTypeScript(node) ? "typescript" : isJSON(node) ? "json" : "babel-ts", isTopLevel);
		const embedStyle = (isTopLevel) => embedType("style", isLess(node) ? "less" : isScss(node) ? "scss" : "css", isTopLevel);
		const embedPug = () => embedType("template", "pug", false);
		switch (node.type) {
			case "Script": return embedScript(true);
			case "Style": return embedStyle(true);
			case "Element": if (node.name === "script") return embedScript(false);
			else if (node.name === "style") return embedStyle(false);
			else if (isPugTemplate(node)) return embedPug();
		}
		return null;
	}
	function forceIntoExpression(statement) {
		return `(${statement}\n)`;
	}
	function forceIntoFunction(statement) {
		return `function ${statement} {}`;
	}
	function preformattedBody(str) {
		if (!str) return "";
		return [
			literalline$1,
			str.replace(/^[\t\f\r ]*\n/, "").replace(/\n[\t\f\r ]*$/, ""),
			hardline$1
		];
	}
	function getSnippedContent(node) {
		const encodedContent = getAttributeTextValue(snippedTagContentAttribute, node);
		if (encodedContent) return base64ToString(encodedContent);
		else return "";
	}
	function formatBodyContent(content, parser, textToDoc, options) {
		return __awaiter(this, void 0, void 0, function* () {
			try {
				const body = yield textToDoc(content, { parser });
				if (parser === "pug" && typeof body === "string") {
					const whitespace = options.useTabs ? "	" : " ".repeat(options.pugTabWidth && options.pugTabWidth > 0 ? options.pugTabWidth : options.tabWidth);
					return [hardline$1, body.split("\n").map((line) => line ? whitespace + line : line).join("\n")];
				}
				const indentIfDesired = (doc) => options.svelteIndentScriptAndStyle ? indent$1(doc) : doc;
				trimRight([body], isLine);
				return [indentIfDesired([hardline$1, body]), hardline$1];
			} catch (error) {
				if (process.env.PRETTIER_DEBUG) throw error;
				console.error(error);
				return preformattedBody(content);
			}
		});
	}
	function embedTag(tag, text, path, formatBodyContent, print, isTopLevel, options) {
		var _a;
		return __awaiter(this, void 0, void 0, function* () {
			const node = path.getNode();
			const content = tag === "template" ? printRaw(node, text) : getSnippedContent(node);
			const previousComments = node.type === "Script" || node.type === "Style" ? node.comments : [getLeadingComment(path)].filter(Boolean).map((comment) => ({
				comment,
				emptyLineAfter: false
			}));
			const body = isNodeSupportedLanguage(node) && !isIgnoreDirective((_a = previousComments[previousComments.length - 1]) === null || _a === void 0 ? void 0 : _a.comment) && (tag !== "template" || options.plugins.some((plugin) => typeof plugin !== "string" && plugin.parsers && plugin.parsers.pug)) ? content.trim() !== "" ? yield formatBodyContent(content) : content === "" ? "" : hardline$1 : preformattedBody(content);
			let result = group$1([
				group$1([
					"<",
					tag,
					indent$1(group$1([...path.map(printWithPrependedAttributeLine(node, options, print), "attributes"), isBracketSameLine(options) ? "" : dedent$1(softline$1)])),
					">"
				]),
				body,
				"</",
				tag,
				">"
			]);
			const comments = [];
			for (const comment of previousComments) {
				comments.push("<!--", comment.comment.data, "-->");
				comments.push(hardline$1);
				if (comment.emptyLineAfter) comments.push(hardline$1);
			}
			if (isTopLevel && options.svelteSortOrder !== "none") return [
				...comments,
				result,
				hardline$1
			];
			else return isTopLevel && comments.length ? [...comments, result] : result;
		});
	}
	function printJS$1(node, name, options) {
		const part = node[name];
		if (!part || typeof part !== "object") return;
		part.isJS = true;
		part.forceSingleQuote = options.forceSingleQuote;
		part.forceSingleLine = options.forceSingleLine;
		part.removeParentheses = options.removeParentheses;
		part.surroundWithSoftline = options.surroundWithSoftline;
	}
	/**
	* Walk the AST and use `_comments` (stashed by the parser) to attach
	* attribute-level comments to their neighbouring attribute nodes via
	* Prettier's `util.addLeadingComment` / `util.addTrailingComment`.
	*/
	function attachAttributeComments(ast) {
		const comments = ast._comments;
		if (!comments || comments.length === 0) return;
		const commentsByStart = /* @__PURE__ */ new Map();
		for (const c of comments) commentsByStart.set(c.start, c);
		walkAndAttach(ast.html, commentsByStart);
	}
	function walkAndAttach(node, commentsByStart) {
		if (!node || typeof node !== "object") return;
		if ("attributes" in node && Array.isArray(node.attributes) && node.attributes.length > 0) {
			const attrs = node.attributes;
			attachCommentsInRange(node.start + 2, attrs[0].start, null, attrs[0], commentsByStart);
			for (let i = 0; i < attrs.length - 1; i++) attachCommentsInRange(attrs[i].end, attrs[i + 1].start, attrs[i], attrs[i + 1], commentsByStart);
		}
		for (const child of getChildren(node)) walkAndAttach(child, commentsByStart);
		if ((node.type === "IfBlock" || node.type === "EachBlock") && node.else) walkAndAttach(node.else, commentsByStart);
		if (node.type === "AwaitBlock") {
			if (node.pending) walkAndAttach(node.pending, commentsByStart);
			if (node.then) walkAndAttach(node.then, commentsByStart);
			if (node.catch) walkAndAttach(node.catch, commentsByStart);
		}
	}
	function attachCommentsInRange(rangeStart, rangeEnd, precedingAttr, followingAttr, commentsByStart) {
		for (const [start, comment] of commentsByStart) if (start >= rangeStart && comment.end <= rangeEnd) {
			if (followingAttr) prettier.util.addLeadingComment(followingAttr, comment);
			else if (precedingAttr) prettier.util.addTrailingComment(precedingAttr, comment);
			commentsByStart.delete(start);
		}
	}
	const babelParser = prettierPluginBabel.parsers.babel;
	const typescriptParser = prettierPluginBabel.parsers["babel-ts"];
	const isSvelte5Plus = Number(compiler.VERSION.split(".")[0]) >= 5;
	function locStart(node) {
		return node.start;
	}
	function locEnd(node) {
		return node.end;
	}
	const languages = [{
		name: "svelte",
		parsers: ["svelte"],
		extensions: [".svelte"],
		vscodeLanguageIds: ["svelte"]
	}];
	const parsers = {
		svelte: {
			hasPragma,
			parse: (text, options) => __awaiter(void 0, void 0, void 0, function* () {
				try {
					let _parse = compiler.parse;
					if (options.svelte5CompilerPath) try {
						_parse = (yield Promise.resolve().then(function() {
							return /* @__PURE__ */ _interopNamespace(__require(options.svelte5CompilerPath));
						})).parse;
					} catch (e) {
						console.warn(`Failed to load Svelte 5 compiler from ${options.svelte5CompilerPath}`);
						console.warn(e);
						options.svelte5CompilerPath = void 0;
					}
					const root = _parse(text);
					root.__isRoot = true;
					return root;
				} catch (err) {
					if (err.start != null && err.end != null) err.loc = {
						start: err.start,
						end: err.end
					};
					throw err;
				}
			}),
			preprocess: (text, options) => {
				const result = snipScriptAndStyleTagContent(text);
				text = result.text.trim();
				options.originalText = text;
				const is = !!options.svelte5CompilerPath || isSvelte5Plus;
				options._svelte_ts = is && result.isTypescript;
				options._svelte_is5Plus = is;
				return text;
			},
			locStart,
			locEnd,
			astFormat: "svelte-ast"
		},
		svelteExpressionParser: Object.assign(Object.assign({}, babelParser), { parse: (text, options) => {
			const ast = babelParser.parse(text, options);
			let program = ast.program.body[0];
			if (!options._svelte_asFunction) program = program.expression;
			return Object.assign(Object.assign({}, ast), { program });
		} }),
		svelteTSExpressionParser: Object.assign(Object.assign({}, typescriptParser), { parse: (text, options) => {
			const ast = typescriptParser.parse(text, options);
			let program = ast.program.body[0];
			if (!options._svelte_asFunction) program = program.expression;
			return Object.assign(Object.assign({}, ast), { program });
		} })
	};
	const printers = { "svelte-ast": {
		print,
		embed,
		getVisitorKeys,
		isBlockComment(comment) {
			return comment.type === "Block";
		},
		printComment(commentPath) {
			const comment = commentPath.getValue();
			if (comment.type === "Line") return "//" + comment.value.replace(/\r$/, "");
			return "/*" + comment.value + "*/";
		}
	} };
	exports.languages = languages;
	exports.options = options;
	exports.parsers = parsers;
	exports.printers = printers;
}));

//#endregion
//#region src/entry-combined.js
init_prettier();
var import_plugin = /* @__PURE__ */ __toESM(require_plugin(), 1);
const js = await format2("const   x=1", { parser: "babel" });
console.log("[js]", js.trim());
const svelte = await format2("<script>const   x=1<\/script><p>hello</p>", {
	parser: "svelte",
	plugins: [import_plugin]
});
console.log("[svelte]", svelte.trim());

//#endregion
export {  };